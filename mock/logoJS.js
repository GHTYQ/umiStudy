export default {
  // 支持值为 Object 和 Array
  //获取JavaScript核心原理目录 这里面sectionid 都是从1开始 id也是从1开始只不过前面加上sectionid
  'GET /api/lago/courseList/js': {
    data: [
      {
        sectionName: '开篇词',
        sectionId: 1,
        courseList: [
          {
            theme: '开篇词 | 打好 JS 基石，走稳前端进阶之路',
            id: 11, //id 第一位表示一个教程 后面数字表示文章
            content:
              '<p data-nodeid="4012" class="">你好，我是若离，从事 Web 前端开发工作将近 9 年，前美团前端技术专家。</p>\n<p data-nodeid="4013">我在美团工作期间，负责和参与过“到家”“团购”及“电影”等业务的前端研发，以及团队搭建。其间，我还致力于前端性能优化、质量保证、效率提升、跨端融合等方向的研究，并且都有一定的技术落地，得到了超出预期的结果。</p>\n<p data-nodeid="4014">我也持续为公司进行前端岗位的社招、校招面试近 6 年多，面试候选人近千人，深谙大厂面试套路及定级之道，因此也总结了很多前端面试经验、技术提升心得，希望通过这个专栏分享给你。</p>\n<h3 data-nodeid="4015">为什么要学习这门课</h3>\n<p data-nodeid="4016">随着前端技术的日新月异，前端应用的复杂度日益提升。与此同时，市场上对于前端人才的要求也愈加严格。</p>\n<p data-nodeid="4017">通过招聘网站可以看出，大厂普遍要求前端人才精通 JavaScript，其他各种高薪岗位也不乏“理解并掌握 JavaScript”等字眼。</p>\n<p data-nodeid="4018"><img src="https://s0.lgstatic.com/i/image/M00/8D/02/CgqCHl_21uaAP_fKAAC8vf9tZcI919.png" alt="Drawing 0.png" data-nodeid="4062"><br>\n<img src="https://s0.lgstatic.com/i/image/M00/8C/F7/Ciqc1F_21uyAMBp6AADTPxja5LU637.png" alt="Drawing 1.png" data-nodeid="4066"></p>\n<p data-nodeid="4019">作为前端人，我们必须认识到这样一个现状：<strong data-nodeid="4072">想要在这一领域走得长远，就必须具备扎实的 JavaScript 编码能力，它既是前端人的自检清单，更是进阶的必修课</strong>。</p>\n<p data-nodeid="4020">而经过多年的面试招聘，我发现了<strong data-nodeid="4078">一个“通病”</strong>：很大一部分候选人的技术水平，只停留在前端框架（如 Vue、React）API 的使用层面，对于框架的源码逻辑一知半解，甚至对源码的思路也只是依靠死记硬背，很少愿意花时间去深入研究原生 JavaScript 的底层逻辑，因此造成了一系列的问题：</p>\n<ol data-nodeid="4021">\n<li data-nodeid="4022">\n<p data-nodeid="4023">对框架的源码理解起来比较困难，导致在编码过程中只会写业务逻辑，却又不注重代码性能；</p>\n</li>\n<li data-nodeid="4024">\n<p data-nodeid="4025">只会简单地调用 JS 框架的 API，而对于复杂的、非常依赖原生 JavaScript 实现的组件，实现的过程很吃力，甚至难以完成开发需求；</p>\n</li>\n<li data-nodeid="4026">\n<p data-nodeid="4027">工作中往往需要通过阅读别人的代码去了解当前项目状况，而对于公司内其他人自研的前端组件的实现方式和原理，理解起来又较为困难，更别说在这个基础上进行维护了。</p>\n</li>\n</ol>\n<p data-nodeid="4028">也正是这些问题，往往让初级开发者在业务场景里面无法呈现优秀的工作表现，做出更多的创新，更何况开发出更高效的前端工具。</p>\n<p data-nodeid="4029">很显然，<strong data-nodeid="4088">正是自身的技术差异，导致了这些人职业发展停滞不前——职级晋升、面试大厂无果</strong>。</p>\n<p data-nodeid="4030">尤其是想进大厂的前端同学，如果能力仅仅停留在使用层面，是很难通过大厂层层考核的，因为面试官将会通过深挖技术背后的实现原理，来判断你对技术的掌握程度，以及是否对技术有钻研精神。如果你只是以熟练使用 Vue 或者 React 框架作为靠山，而 JavaScript 技术基础能力不过关，那么将在行业中举步维艰。</p>\n<p data-nodeid="4031">至此，以我多年的从业经验和招聘经验来看，未来互联网行业对候选人的能力要求只会越来越高，总结下来就是：<strong data-nodeid="4095">扎实掌握并加强原生 JavaScript 的核心原理及编码功底、深入理解前端框架源代码，对于提升自己的前端技术能力、提高职业生涯天花板是非常有必要的</strong>。</p>\n<h3 data-nodeid="4032">我要带你怎么学</h3>\n<p data-nodeid="4033">那么，怎样才能有效地提升原生 JS 能力，从而摆脱上面所说的那些困境呢？</p>\n<p data-nodeid="4034">这个专栏就是为帮你夯实前端 JavaScript 核心基础知识而写就。我将围绕基础原理、数组、异步编程、V8 引擎几个核心知识点展开，通过 4 个模块、22 讲内容，带你深挖 JavaScript 底层原理。</p>\n<p data-nodeid="4035"><strong data-nodeid="4107">模块一</strong>，我会深入讲解 JavaScript 数据类型、继承、闭包等核心基础知识，分析它们的底层原理。<strong data-nodeid="4108">这是构建前端工具的基础，只有掌握好这部分内容，你才能为以后的编码能力打下基础</strong>。</p>\n<p data-nodeid="4036">并且这其中的一些知识点，比如深浅拷贝和自己手工实现 JSON.Stringfy 这样的题目，是大厂面试官经常会问到的内容，所以这部分我将以进阶练习的形式帮你轻松掌握。</p>\n<p data-nodeid="4037"><strong data-nodeid="4114">模块二</strong>，我会介绍 JavaScript 的数组相关知识。要知道，在日常开发中，数组是经常会用到的数据类型，使用和出现频率非常之高。所以我会从数组原理、数组排序两大方向带你了解它，比如梳理数组 API、实现数组扁平化，以及数组 sort 方法。</p>\n<p data-nodeid="4038"><strong data-nodeid="4119">掌握这部分知识，你可以在每次写前端业务逻辑、处理一些数组数据的时候，不用再去翻看相关的数组 API 文档，从而提升你的开发效率</strong>。</p>\n<p data-nodeid="4039">此外，由于 Javascript 语言的执行环境是“单线程”，如果有多个任务，就必须排队，前面一个任务完成，再执行后面的任务，因此在浏览器端比较耗时的操作都应该进行异步操作来减少等待时间。由此可见，异步编程在浏览器端是非常重要的，如果不采用异步编程模式，大量的同步代码会造成浏览器的性能急剧下降。</p>\n<p data-nodeid="4040">因此，<strong data-nodeid="4130">模块三</strong>会从 JavaScript 最基础的异步编程方式讲起，比如 Promise、Async/await、Co 等。当<strong data-nodeid="4131">掌握了 JavaScript 异步编程源码精髓，你就可以摆脱前端代码的“回调地狱”，更优雅地实现并解决业务场景的复杂问题、提升页面性能</strong>。</p>\n<p data-nodeid="4041"><strong data-nodeid="4136">模块四</strong>是浏览器核心 V8 引擎相关的内容，它是执行 JavaScript 代码的程序或解释器，可以使得 JS 的执行性能大幅提升，这也是目前大多数浏览器普遍使用的引擎。</p>\n<p data-nodeid="4042">这一模块我会通过讲解浏览器垃圾回收机制、浏览器核心引擎的工作逻辑等内容，帮助你理解 JavaScript 代码是如何被 V8 引擎编译和执行的。<strong data-nodeid="4142">这对于写出高性能的 JavaScript 代码帮助甚大</strong>。</p>\n<p data-nodeid="4043">在最后的<strong data-nodeid="4156">彩蛋</strong>部分，我也会带你剖析一些互联网大厂的面试题目，让你真正了解互联网<strong data-nodeid="4157">大厂的职级体系</strong>和<strong data-nodeid="4158">面试定级标准</strong>，梳理面试思路和前端知识的学习方法，实现自身的突破和提升。</p>\n<p data-nodeid="4520">除此之外，<strong data-nodeid="4529">每一个模块的最后我都会专门拿出 1~2 讲来带你实操，手把手帮助你实践</strong>，比如实现一个 JSON.Stringfy 方法、手写 JS 数组多个 API 的底层实现、实现一个 EventEmitter 等。这种更贴合实践的学习方式，会比你天天抱着编程的书啃，学习效率要高很多。</p>\n<p data-nodeid="4521" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/91/6B/Ciqc1GAOd5WAIGqFAAPSocLEgeg539.png" alt="JS大纲.png" data-nodeid="4532"></p>\n\n\n<h3 data-nodeid="4046">讲师寄语</h3>\n<p data-nodeid="4047">前端技术的快速发展和充满希望的前景，也吸引了更多人加入前端工程师的行列，各种前端新技术、新框架的出现，也在考验前端工程师的能力。那么如何提升技术能力、建立自己的“核心竞争力”，是每一位优秀的前端工程师应该思考的问题。</p>\n<p data-nodeid="4048">希望你不仅跟着我的思路去理解内容本身，还能在学习过程中在 IDE 里面亲自动手实现一遍，从而深刻体会程序实现逻辑的一些细节，进而加深对每一部分知识点的理解，做到融会贯通。</p>\n<p data-nodeid="4049">你也不妨给自己养成一个好习惯，每看完一篇文章就对知识点进行总结，形成自己的学习思维脑图，等到学完全部课程以后再来回顾，以便加深知识理解。</p>\n<p data-nodeid="4050">希望这个专栏，能够带你了解原生 JS 的底层原理，更好地掌握 JS 框架源码的代码实现逻辑，在写业务代码时可以做到游刃有余，提升工作效率，加强自身技术储备，拿高薪，进大厂！</p>\n<hr data-nodeid="4051">\n<p data-nodeid="4052"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="4179"><img src="https://s0.lgstatic.com/i/image2/M01/00/66/CgpVE1_W_x2AaW0rAAdqMM6w3z0145.png" alt="大前端引流.png" data-nodeid="4178"></a></p>\n<p data-nodeid="4053" class="">对标阿里P7技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="4183">点此链接，快来领取！</a></p>',
          },
        ],
      },
      {
        sectionName: '模块一：基石篇',
        sectionId: 2,
        courseList: [
          {
            theme: '01 | 代码基本功测试（上）：JS 的数据类型你了解多少？',
            id: 12,
            content:
              '<p data-nodeid="7562" class="">在第一讲我要为你介绍的是 JS 数据类型的相关知识。</p>\n<p data-nodeid="7563">作为 JavaScript 的入门级知识点，JS 数据类型在整个 JavaScript 的学习过程中其实尤为重要。因为在 JavaScript 编程中，我们经常会遇到边界数据类型条件判断问题，很多代码只有在某种特定的数据类型下，才能可靠地执行。</p>\n<p data-nodeid="7564">尤其在大厂面试中，经常需要你现场手写代码，因此你很有必要提前考虑好数据类型的边界判断问题，并在你的 JavaScript 逻辑编写前进行前置判断，这样才能让面试官看到你严谨的编程逻辑和深入思考的能力，面试才可以加分。</p>\n<p data-nodeid="7565">因此，这一讲我将从数据类型的<strong data-nodeid="7730">概念</strong>、<strong data-nodeid="7731">检测方法</strong>、<strong data-nodeid="7732">转换方法</strong>几个方面，帮你梳理和深入学习 JavaScript 的数据类型的知识点。</p>\n<p data-nodeid="7566">我希望通过本讲的学习，你能够熟练掌握数据类型的判断以及转换等相关知识点，并且在遇到数据类型判断以及数据类型的隐式转换等问题时可以轻松应对。</p>\n<h3 data-nodeid="7567">数据类型概念</h3>\n<p data-nodeid="7568">JavaScript 的数据类型有下图所示的 8 种：</p>\n<p data-nodeid="7569"><img src="https://s0.lgstatic.com/i/image2/M01/04/F0/CgpVE1_4DdGAJ_EXAAE38RQC0js096.png" alt="Lark20210108-154509.png" data-nodeid="7738"></p>\n<p data-nodeid="7570">其中，前 7 种类型为基础类型，最后 1 种（Object）为引用类型，也是你需要重点关注的，因为它在日常工作中是使用得最频繁，也是需要关注最多技术细节的数据类型。</p>\n<p data-nodeid="7571">而引用数据类型（Object）又分为图上这几种常见的类型：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象。</p>\n<p data-nodeid="7572">在这里，我想先请你重点了解下面两点，因为各种 JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分成两类来进行存储：</p>\n<ol data-nodeid="7573">\n<li data-nodeid="7574">\n<p data-nodeid="7575">基础类型存储在<strong data-nodeid="7747">栈内存</strong>，被引用或拷贝时，会创建一个完全相等的变量；</p>\n</li>\n<li data-nodeid="7576">\n<p data-nodeid="7577">引用类型存储在<strong data-nodeid="7757">堆内存</strong>，存储的是地址，多个引用指向同一个地址，这里会涉及一个“<strong data-nodeid="7758">共享</strong>”的概念。</p>\n</li>\n</ol>\n<p data-nodeid="7578">关于引用类型下面直接通过两段代码来讲解，让你深入理解一下核心“共享”的概念。</p>\n<h4 data-nodeid="7579">题目一：初出茅庐</h4>\n<pre class="lang-javascript" data-nodeid="7580"><code data-language="javascript"><span class="hljs-keyword">let</span> a = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'lee\'</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>\n}\n<span class="hljs-keyword">let</span> b = a;\n<span class="hljs-built_in">console</span>.log(a.name);  <span class="hljs-comment">//第一个console</span>\nb.name = <span class="hljs-string">\'son\'</span>;\n<span class="hljs-built_in">console</span>.log(a.name);  <span class="hljs-comment">//第二个console</span>\n<span class="hljs-built_in">console</span>.log(b.name);  <span class="hljs-comment">//第三个console</span>\n</code></pre>\n<p data-nodeid="7581">这道题比较简单，我们可以看到第一个 console 打出来 name 是 \'lee\'，这应该没什么疑问；但是在执行了 b.name=\'son\' 之后，结果你会发现 a 和 b 的属性 name 都是 \'son\'，第二个和第三个打印结果是一样的，这里就体现了引用类型的“共享”的特性，即这两个值都存在同一块内存中共享，一个发生了改变，另外一个也随之跟着变化。</p>\n<p data-nodeid="7582">你可以直接在 Chrome 控制台敲一遍，深入理解一下这部分概念。下面我们再看一段代码，它是比题目一稍复杂一些的对象属性变化问题。</p>\n<h4 data-nodeid="7583">题目二：渐入佳境</h4>\n<pre class="lang-javascript" data-nodeid="7584"><code data-language="javascript"><span class="hljs-keyword">let</span> a = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'Julia\'</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">change</span>(<span class="hljs-params">o</span>) </span>{\n  o.age = <span class="hljs-number">24</span>;\n  o = {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">\'Kath\'</span>,\n    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>\n  }\n  <span class="hljs-keyword">return</span> o;\n}\n\n<span class="hljs-keyword">let</span> b = change(a);     <span class="hljs-comment">// 注意这里没有new，后面new相关会有专门文章讲解</span>\n<span class="hljs-built_in">console</span>.log(b.age);    <span class="hljs-comment">// 第一个console</span>\n<span class="hljs-built_in">console</span>.log(a.age);    <span class="hljs-comment">// 第二个console</span>\n</code></pre>\n<p data-nodeid="7585">这道题涉及了 function，你通过上述代码可以看到第一个 console 的结果是 30，b 最后打印结果是 {name: "Kath", age: 30}；第二个 console 的返回结果是 24，而 a 最后的打印结果是 {name: "Julia", age: 24}。</p>\n<p data-nodeid="7586">是不是和你预想的有些区别？你要注意的是，<strong data-nodeid="7790">这里的 function 和 return 带来了不一样的东西</strong>。</p>\n<p data-nodeid="8000" class="te-preview-highlight">原因在于：函数传参进来的 o，传递的是对象在堆中的内存地址值，通过调用 o.age = 24（第 7 行代码）确实改变了 a 对象的 age 属性；12 行把参数 o 的地址重新返回了，将 {name: "Kath", age: 30} 存入其中，最后返回 b 的值就变成了 {name: "Kath", age: 30}。而如果把第 12 行去掉，那么 b 就会返回 undefined。这里你可以再仔细琢磨一下。</p>\n\n<p data-nodeid="7588">讲完数据类型的基本概念，我们继续看下一部分，如何对数据类型进行检测，这也是比较重要的问题。</p>\n<h3 data-nodeid="7589">数据类型检测</h3>\n<p data-nodeid="7590">数据类型检测也是面试过程中经常会遇到的问题，比如：如何判断是否为数组？让你写一段代码把 JavaScript 的各种数据类型判断出来，等等。类似的题目会很多，而且在平常写代码过程中我们也会经常用到。</p>\n<p data-nodeid="7591">我也经常在面试一些候选人的时候，有些回答比如“用 typeof 来判断”，然后就没有其他答案了，但这样的回答是不能令面试官满意的，因为他要考察你对 JS 的数据类型理解的深度，所以我们先要做到的是对各种数据类型的判断方法了然于胸，然后再进行归纳总结，给面试官一个满意的答案。</p>\n<p data-nodeid="7592">数据类型的判断方法其实有很多种，比如 typeof 和 instanceof，下面我来重点介绍三种在工作中经常会遇到的数据类型检测方法。</p>\n<h4 data-nodeid="7593">第一种判断方法：typeof</h4>\n<p data-nodeid="7594">这是比较常用的一种，那么我们通过一段代码来快速回顾一下这个方法。</p>\n<pre class="lang-javascript" data-nodeid="7595"><code data-language="javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span> <span class="hljs-comment">// \'number\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-string">\'1\'</span> <span class="hljs-comment">// \'string\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// \'undefined\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// \'boolean\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>() <span class="hljs-comment">// \'symbol\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-keyword">typeof</span> {} <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span>.log <span class="hljs-comment">// \'function\'</span>\n</code></pre>\n<p data-nodeid="7596">你可以看到，前 6 个都是基础数据类型，而为什么第 6 个 null 的 typeof 是 \'object\' 呢？这里要和你强调一下，虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。</p>\n<p data-nodeid="7597">此外还要注意，引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 \'object\'，是无法判断出来的。</p>\n<h4 data-nodeid="7598">第二种判断方法：instanceof</h4>\n<p data-nodeid="7599">想必 instanceof 的方法你也听说过，我们 new 一个对象，那么这个新对象就是它原型链继承上面的对象了，通过 instanceof 我们能判断这个对象是否是之前那个构造函数生成的对象，这样就基本可以判断出这个新对象的数据类型。下面通过代码来了解一下。</p>\n<pre class="lang-javascript" data-nodeid="7600"><code data-language="javascript"><span class="hljs-keyword">let</span> Car = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}\n<span class="hljs-keyword">let</span> benz = <span class="hljs-keyword">new</span> Car()\nbenz <span class="hljs-keyword">instanceof</span> Car <span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">\'Mercedes Benz\'</span>)\ncar <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span> <span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> str = <span class="hljs-string">\'Covid-19\'</span>\nstr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span> <span class="hljs-comment">// false</span>\n</code></pre>\n<p data-nodeid="7601">上面就是用 instanceof 方法判断数据类型的大致流程，那么如果让你自己实现一个 instanceof 的底层实现，应该怎么写呢？请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="7602"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>{\n  <span class="hljs-comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span>\n  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">\'object\'</span> || left === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n  <span class="hljs-comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span>\n  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);\n  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {                  <span class="hljs-comment">//循环往下寻找，直到找到相同的原型对象</span>\n    <span class="hljs-keyword">if</span>(proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    <span class="hljs-keyword">if</span>(proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//找到相同原型对象，返回true</span>\n    proto = <span class="hljs-built_in">Object</span>.getPrototypeof(proto);\n    }\n}\n<span class="hljs-comment">// 验证一下自己实现的myInstanceof是否OK</span>\n<span class="hljs-built_in">console</span>.log(myInstanceof(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>), <span class="hljs-built_in">Number</span>));    <span class="hljs-comment">// true</span>\n<span class="hljs-built_in">console</span>.log(myInstanceof(<span class="hljs-number">123</span>, <span class="hljs-built_in">Number</span>));                <span class="hljs-comment">// false</span>\n</code></pre>\n<p data-nodeid="7603">现在你知道了两种判断数据类型的方法，那么它们之间有什么差异呢？我总结了下面两点：</p>\n<ol data-nodeid="7604">\n<li data-nodeid="7605">\n<p data-nodeid="7606">instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</p>\n</li>\n<li data-nodeid="7607">\n<p data-nodeid="7608">而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</p>\n</li>\n</ol>\n<p data-nodeid="7609">总之，不管单独用 typeof 还是 instanceof，都不能满足所有场景的需求，而只能通过二者混写的方式来判断。但是这种方式判断出来的其实也只是大多数情况，并且写起来也比较难受，你也可以试着写一下。</p>\n<p data-nodeid="7610">其实我个人还是比较推荐下面的第三种方法，相比上述两个而言，能更好地解决数据类型检测问题。</p>\n<h4 data-nodeid="7611">第三种判断方法：Object.prototype.toString</h4>\n<p data-nodeid="7612">toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。</p>\n<pre class="lang-javascript" data-nodeid="7613"><code data-language="javascript"><span class="hljs-built_in">Object</span>.prototype.toString({})       <span class="hljs-comment">// "[object Object]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call({})  <span class="hljs-comment">// 同上结果，加上call也ok</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>)    <span class="hljs-comment">// "[object Number]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">\'1\'</span>)  <span class="hljs-comment">// "[object String]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// "[object Boolean]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{})  <span class="hljs-comment">// "[object Function]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>)   <span class="hljs-comment">//"[object Null]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">//"[object Undefined]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-regexp">/123/g</span>)    <span class="hljs-comment">//"[object RegExp]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()) <span class="hljs-comment">//"[object Date]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call([])       <span class="hljs-comment">//"[object Array]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">document</span>)  <span class="hljs-comment">//"[object HTMLDocument]"</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">window</span>)   <span class="hljs-comment">//"[object Window]"</span>\n</code></pre>\n<p data-nodeid="7614">从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</p>\n<p data-nodeid="7615">但是在写判断条件的时候一定要注意，使用这个方法最后返回统一字符串格式为 "[object Xxx]" ，而这里字符串里面的 "Xxx" ，<strong data-nodeid="7851">第一个首字母要大写</strong>（注意：使用 typeof 返回的是小写），这里需要多加留意。</p>\n<p data-nodeid="7616">那么下面来实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="7617"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">obj</span>)</span>{\n  <span class="hljs-keyword">let</span> type  = <span class="hljs-keyword">typeof</span> obj;\n  <span class="hljs-keyword">if</span> (type !== <span class="hljs-string">"object"</span>) {    <span class="hljs-comment">// 先进行typeof判断，如果是基础数据类型，直接返回</span>\n    <span class="hljs-keyword">return</span> type;\n  }\n  <span class="hljs-comment">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj).replace(<span class="hljs-regexp">/^\\[object (\\S+)\\]$/</span>, <span class="hljs-string">\'$1\'</span>);  <span class="hljs-comment">// 注意正则中间有个空格</span>\n}\n<span class="hljs-comment">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span>\ngetType([])     <span class="hljs-comment">// "Array" typeof []是object，因此toString返回</span>\ngetType(<span class="hljs-string">\'123\'</span>)  <span class="hljs-comment">// "string" typeof 直接返回</span>\ngetType(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// "Window" toString返回</span>\ngetType(<span class="hljs-literal">null</span>)   <span class="hljs-comment">// "Null"首字母大写，typeof null是object，需toString来判断</span>\ngetType(<span class="hljs-literal">undefined</span>)   <span class="hljs-comment">// "undefined" typeof 直接返回</span>\ngetType()            <span class="hljs-comment">// "undefined" typeof 直接返回</span>\ngetType(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}) <span class="hljs-comment">// "function" typeof能判断，因此首字母小写</span>\ngetType(<span class="hljs-regexp">/123/g</span>)      <span class="hljs-comment">//"RegExp" toString返回</span>\n</code></pre>\n<p data-nodeid="7618">到这里，数据类型检测的三种方法就介绍完了，最后也给出来了示例代码，希望你可以对比着来学习、使用，并且不断加深记忆，以便遇到问题时不会手忙脚乱。你如果一遍记不住可以多次来回看巩固，直到把上面的代码都能全部理解，并且把几个特殊的问题都强化记忆，这样未来你去做类似题目才不会有问题。</p>\n<p data-nodeid="7619">下面我们来看本讲的最后一部分：数据类型的转换。</p>\n<h3 data-nodeid="7620">数据类型转换</h3>\n<p data-nodeid="7621">在日常的业务开发中，经常会遇到 JavaScript 数据类型转换问题，有的时候需要我们主动进行强制转换，而有的时候 JavaScript 会进行隐式转换，隐式转换的时候就需要我们多加留心。</p>\n<p data-nodeid="7622">那么这部分都会涉及哪些内容呢？我们先看一段代码，了解下大致的情况。</p>\n<pre class="lang-javascript" data-nodeid="7623"><code data-language="javascript"><span class="hljs-string">\'123\'</span> == <span class="hljs-number">123</span>   <span class="hljs-comment">// false or true?</span>\n<span class="hljs-string">\'\'</span> == <span class="hljs-literal">null</span>    <span class="hljs-comment">// false or true?</span>\n<span class="hljs-string">\'\'</span> == <span class="hljs-number">0</span>        <span class="hljs-comment">// false or true?</span>\n[] == <span class="hljs-number">0</span>        <span class="hljs-comment">// false or true?</span>\n[] == <span class="hljs-string">\'\'</span>       <span class="hljs-comment">// false or true?</span>\n[] == ![]      <span class="hljs-comment">// false or true?</span>\n<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &nbsp;false or true?</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)     <span class="hljs-comment">// 返回什么？</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-string">\'\'</span>)      <span class="hljs-comment">//&nbsp;返回什么？</span>\n<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">\'\'</span>);    <span class="hljs-comment">// 返回什么？</span>\n{}+<span class="hljs-number">10</span>           <span class="hljs-comment">//&nbsp;返回什么？</span>\n<span class="hljs-keyword">let</span> obj = {\n    [<span class="hljs-built_in">Symbol</span>.toPrimitive]() {\n        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;\n    },\n    valueOf() {\n        <span class="hljs-keyword">return</span> <span class="hljs-number">300</span>;\n    },\n    toString() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">\'Hello\'</span>;\n    }\n}\n<span class="hljs-built_in">console</span>.log(obj + <span class="hljs-number">200</span>); <span class="hljs-comment">// 这里打印出来是多少？</span>\n</code></pre>\n<p data-nodeid="7624">上面这 12 个问题相信你并不陌生，基本涵盖了我们平常容易疏漏的一些情况，这就是在做数据类型转换时经常会遇到的强制转换和隐式转换的方式，那么下面我就围绕数据类型的两种转换方式详细讲解一下，希望可以为你提供一些借鉴。</p>\n<h4 data-nodeid="7625">强制类型转换</h4>\n<p data-nodeid="7626">强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()，这几种方法都比较类似，通过字面意思可以很容易理解，都是通过自身的方法来进行数据类型的强制转换。下面我列举一些来详细说明。</p>\n<p data-nodeid="7627">上面代码中，第 8 行的结果是 0，第 9 行的结果同样是 0，第 10 行的结果是 NaN。这些都是很明显的强制类型转换，因为用到了 Number() 和 parseInt()。</p>\n<p data-nodeid="7628">其实上述几个强制类型转换的原理大致相同，下面我挑两个比较有代表性的方法进行讲解。</p>\n<p data-nodeid="7629"><strong data-nodeid="7866">Number() 方法的强制转换规则</strong></p>\n<ul data-nodeid="7630">\n<li data-nodeid="7631">\n<p data-nodeid="7632">如果是布尔值，true 和 false 分别被转换为 1 和 0；</p>\n</li>\n<li data-nodeid="7633">\n<p data-nodeid="7634">如果是数字，返回自身；</p>\n</li>\n<li data-nodeid="7635">\n<p data-nodeid="7636">如果是 null，返回 0；</p>\n</li>\n<li data-nodeid="7637">\n<p data-nodeid="7638">如果是 undefined，返回&nbsp;NaN；</p>\n</li>\n<li data-nodeid="7639">\n<p data-nodeid="7640">如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是&nbsp;0X&nbsp;/&nbsp;0x&nbsp;开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回&nbsp;NaN；</p>\n</li>\n<li data-nodeid="7641">\n<p data-nodeid="7642">如果是 Symbol，抛出错误；</p>\n</li>\n<li data-nodeid="7643">\n<p data-nodeid="7644">如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的&nbsp;valueOf()&nbsp;方法，然后依据前面的规则转换返回的值；如果转换的结果是&nbsp;NaN&nbsp;，则调用对象的&nbsp;toString()&nbsp;方法，再次依照前面的顺序转换返回对应的值（Object 转换规则会在下面细讲）。</p>\n</li>\n</ul>\n<p data-nodeid="7645">下面通过一段代码来说明上述规则。</p>\n<pre class="lang-javascript" data-nodeid="7646"><code data-language="javascript"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>);        <span class="hljs-comment">// 1</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>);       <span class="hljs-comment">// 0</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-string">\'0111\'</span>);      <span class="hljs-comment">//111</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>);        <span class="hljs-comment">//0</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-string">\'\'</span>);          <span class="hljs-comment">//0</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-string">\'1a\'</span>);        <span class="hljs-comment">//NaN</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-number">-0X11</span>);       <span class="hljs-comment">//-17</span>\n<span class="hljs-built_in">Number</span>(<span class="hljs-string">\'0X11\'</span>)       <span class="hljs-comment">//17</span>\n</code></pre>\n<p data-nodeid="7647">其中，我分别列举了比较常见的 Number 转换的例子，它们都会把对应的非数字类型转换成数字类型，而有一些实在无法转换成数字的，最后只能输出 NaN 的结果。<br>\n<strong data-nodeid="7884">Boolean() 方法的强制转换规则</strong></p>\n<p data-nodeid="7648">这个方法的规则是：除了 undefined、 null、 false、 \'\'、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。</p>\n<p data-nodeid="7649">这个规则应该很好理解，没有那么多条条框框，我们还是通过代码来形成认知，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="7650"><code data-language="javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>)          <span class="hljs-comment">//false</span>\n<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)       <span class="hljs-comment">//false</span>\n<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)  <span class="hljs-comment">//false</span>\n<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>)        <span class="hljs-comment">//false</span>\n<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>)          <span class="hljs-comment">//true</span>\n<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">13</span>)         <span class="hljs-comment">//true</span>\n<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">\'12\'</span>)       <span class="hljs-comment">//true</span>\n</code></pre>\n<p data-nodeid="7651">其余的 parseInt()、parseFloat()、toString()、String() 这几个方法，你可以按照我的方式去整理一下规则，在这里不占过多篇幅了。</p>\n<h4 data-nodeid="7652">隐式类型转换</h4>\n<p data-nodeid="7653">凡是通过逻辑运算符 (&amp;&amp;、 ||、 !)、运算符 (+、-、*、/)、关系操作符 (&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符 (==) 或者 if/while 条件的操作，如果遇到两个数据类型不一样的情况，都会出现隐式类型转换。这里你需要重点关注一下，因为比较隐蔽，特别容易让人忽视。</p>\n<p data-nodeid="7654">下面着重讲解一下日常用得比较多的“==”和“+”这两个符号的隐式转换规则。</p>\n<p data-nodeid="7655"><strong data-nodeid="7934">\'==\' 的隐式类型转换规则</strong></p>\n<ul data-nodeid="7656">\n<li data-nodeid="7657">\n<p data-nodeid="7658">如果类型相同，无须进行类型转换；</p>\n</li>\n<li data-nodeid="7659">\n<p data-nodeid="7660">如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</p>\n</li>\n<li data-nodeid="7661">\n<p data-nodeid="7662">如果其中一个是 Symbol 类型，那么返回 false；</p>\n</li>\n<li data-nodeid="7663">\n<p data-nodeid="7664">两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</p>\n</li>\n<li data-nodeid="7665">\n<p data-nodeid="7666">如果一个操作值是 boolean，那么转换成 number；</p>\n</li>\n<li data-nodeid="7667">\n<p data-nodeid="7668">如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。</p>\n</li>\n</ul>\n<p data-nodeid="7669">如果直接死记这些理论会有点懵，我们还是直接看代码，这样更容易理解一些，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="7670"><code data-language="javascript"><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>       <span class="hljs-comment">// true  规则2</span>\n<span class="hljs-literal">null</span> == <span class="hljs-number">0</span>               <span class="hljs-comment">// false 规则2</span>\n<span class="hljs-string">\'\'</span> == <span class="hljs-literal">null</span>              <span class="hljs-comment">// false 规则2</span>\n<span class="hljs-string">\'\'</span> == <span class="hljs-number">0</span>                 <span class="hljs-comment">// true  规则4 字符串转隐式转换成Number之后再对比</span>\n<span class="hljs-string">\'123\'</span> == <span class="hljs-number">123</span>            <span class="hljs-comment">// true  规则4 字符串转隐式转换成Number之后再对比</span>\n<span class="hljs-number">0</span> == <span class="hljs-literal">false</span>              <span class="hljs-comment">// true  e规则 布尔型隐式转换成Number之后再对比</span>\n<span class="hljs-number">1</span> == <span class="hljs-literal">true</span>               <span class="hljs-comment">// true  e规则 布尔型隐式转换成Number之后再对比</span>\n<span class="hljs-keyword">var</span> a = {\n&nbsp; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>,\n&nbsp; <span class="hljs-attr">valueOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">this</span>.value++;\n&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;\n&nbsp; }\n};\n<span class="hljs-comment">// 注意这里a又可以等于1、2、3</span>\n<span class="hljs-built_in">console</span>.log(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a ==<span class="hljs-number">3</span>);  <span class="hljs-comment">//true f规则 Object隐式转换</span>\n<span class="hljs-comment">// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下</span>\n</code></pre>\n<p data-nodeid="7671">对照着这个规则看完上面的代码和注解之后，你可以再回过头做一下我在讲解“数据类型转换”之前的那 12 道题目，是不是就很容易解决了？</p>\n<p data-nodeid="7672"><strong data-nodeid="7949">\'+\' 的隐式类型转换规则</strong></p>\n<p data-nodeid="7673">\'+\' 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 \'+\' 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。</p>\n<p data-nodeid="7674">除了上述比较常规的情况外，还有一些特殊的规则，如下所示。</p>\n<ul data-nodeid="7675">\n<li data-nodeid="7676">\n<p data-nodeid="7677">如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级（下一讲会专门介绍），然后再进行拼接。</p>\n</li>\n<li data-nodeid="7678">\n<p data-nodeid="7679">如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</p>\n</li>\n<li data-nodeid="7680">\n<p data-nodeid="7681">如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。</p>\n</li>\n</ul>\n<p data-nodeid="7682">下面还是结合代码来理解上述规则，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="7683"><code data-language="javascript"><span class="hljs-number">1</span> + <span class="hljs-number">2</span>        <span class="hljs-comment">// 3  常规情况</span>\n<span class="hljs-string">\'1\'</span> + <span class="hljs-string">\'2\'</span>    <span class="hljs-comment">// \'12\' 常规情况</span>\n<span class="hljs-comment">// 下面看一下特殊情况</span>\n<span class="hljs-string">\'1\'</span> + <span class="hljs-literal">undefined</span>   <span class="hljs-comment">// "1undefined" 规则1，undefined转换字符串</span>\n<span class="hljs-string">\'1\'</span> + <span class="hljs-literal">null</span>        <span class="hljs-comment">// "1null" 规则1，null转换字符串</span>\n<span class="hljs-string">\'1\'</span> + <span class="hljs-literal">true</span>        <span class="hljs-comment">// "1true" 规则1，true转换字符串</span>\n<span class="hljs-string">\'1\'</span> + <span class="hljs-number">1n</span>          <span class="hljs-comment">// \'11\' 比较特殊字符串和BigInt相加，BigInt转换为字符串</span>\n<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>     <span class="hljs-comment">// NaN  规则2，undefined转换数字相加NaN</span>\n<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>          <span class="hljs-comment">// 1    规则2，null转换为0</span>\n<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>          <span class="hljs-comment">// 2    规则2，true转换为1，二者相加为2</span>\n<span class="hljs-number">1</span> + <span class="hljs-number">1n</span>            <span class="hljs-comment">// 错误  不能把BigInt和Number类型直接混合相加</span>\n<span class="hljs-string">\'1\'</span> + <span class="hljs-number">3</span>           <span class="hljs-comment">// \'13\' 规则3，字符串拼接</span>\n</code></pre>\n<p data-nodeid="7684">整体来看，如果数据中有字符串，JavaScript 类型转换还是更倾向于转换成字符串，因为第三条规则中可以看到，在字符串和数字相加的过程中最后返回的还是字符串，这里需要关注一下。</p>\n<p data-nodeid="7685">了解了 \'+\' 的转换规则后，我们最后再看一下 Object 的转换规则。</p>\n<p data-nodeid="7686"><strong data-nodeid="7972">Object 的转换规则</strong></p>\n<p data-nodeid="7687">对象转换的规则，会先调用内置的 [ToPrimitive] 函数，其规则逻辑如下：</p>\n<ul data-nodeid="7688">\n<li data-nodeid="7689">\n<p data-nodeid="7690">如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</p>\n</li>\n<li data-nodeid="7691">\n<p data-nodeid="7692">调用 valueOf()，如果转换为基础类型，则返回；</p>\n</li>\n<li data-nodeid="7693">\n<p data-nodeid="7694">调用 toString()，如果转换为基础类型，则返回；</p>\n</li>\n<li data-nodeid="7695">\n<p data-nodeid="7696">如果都没有返回基础类型，会报错。</p>\n</li>\n</ul>\n<p data-nodeid="7697">直接理解有些晦涩，还是直接来看代码，你也可以在控制台自己敲一遍来加深印象。</p>\n<pre class="lang-javascript" data-nodeid="7698"><code data-language="javascript"><span class="hljs-keyword">var</span> obj = {\n  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,\n  valueOf() {\n    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;\n  },\n  toString() {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'3\'</span>\n  },\n  [<span class="hljs-built_in">Symbol</span>.toPrimitive]() {\n    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>\n  }\n}\n<span class="hljs-built_in">console</span>.log(obj + <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出5</span>\n<span class="hljs-comment">// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回\'31\'(字符串拼接)</span>\n<span class="hljs-comment">// 再看两个特殊的case：</span>\n<span class="hljs-number">10</span> + {}\n<span class="hljs-comment">// "10[object Object]"，注意：{}会默认调用valueOf是{}，不是基础类型继续转换，调用toString，返回结果"[object Object]"，于是和10进行\'+\'运算，按照字符串拼接规则来，参考\'+\'的规则C</span>\n[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] + <span class="hljs-number">10</span>\n<span class="hljs-comment">// "1,2,,4,510"，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回"1,2,,4,5"，然后再和10进行运算，还是按照字符串拼接规则，参考\'+\'的第3条规则</span>\n</code></pre>\n<p data-nodeid="7699">关于 Object 的转化，就讲解到这里，希望你可以深刻体会一下上面讲的原理和内容。</p>\n<h3 data-nodeid="7700">总结</h3>\n<p data-nodeid="7701">以上就是本讲的内容了，在这一讲中，我们从三个方面学习了数据类型相关内容，下面整体回顾一下。</p>\n<ol data-nodeid="7702">\n<li data-nodeid="7703">\n<p data-nodeid="7704">数据类型的基本概念：这是必须掌握的知识点，作为深入理解 JavaScript 的基础。</p>\n</li>\n<li data-nodeid="7705">\n<p data-nodeid="7706">数据类型的判断方法：typeof 和 instanceof，以及 Object.prototype.toString 的判断数据类型、手写 instanceof 代码片段，这些是日常开发中经常会遇到的，因此你需要好好掌握。</p>\n</li>\n<li data-nodeid="7707">\n<p data-nodeid="7708">数据类型的转换方式：两种数据类型的转换方式，日常写代码过程中隐式转换需要多留意，如果理解不到位，很容易引起在编码过程中的 bug，得到一些意想不到的结果。</p>\n</li>\n</ol>\n<p data-nodeid="7709">对于本讲内容，如果你有不清楚的地方，欢迎在评论区留言，我们一起探讨、进步。</p>\n<p data-nodeid="7710">下一讲我会在本讲内容的基础上，为你详细介绍手写一个深浅拷贝代码的完整思路以及代码的实现。我们下一讲见。</p>\n<hr data-nodeid="7711">\n<p data-nodeid="7712"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="7995"><img src="https://s0.lgstatic.com/i/image2/M01/00/66/CgpVE1_W_x2AaW0rAAdqMM6w3z0145.png" alt="大前端引流.png" data-nodeid="7994"></a></p>\n<p data-nodeid="7713" class="">对标阿里P7技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="7999">点此链接，快来领取！</a></p>',
          },
          {
            theme: '02 | 代码基本功测试（下）：如何实现一个深浅拷贝？',
            id: 13,
            content:
              '<p data-nodeid="1041" class="">上一讲我们介绍了 JS 的两种数据类型，分别是基础数据类型和引用数据类型，你可以回忆一下我提到的重点内容。那么这一讲要聊的浅拷贝和深拷贝，其实就是围绕着这两种数据类型展开的。</p>\n<p data-nodeid="1042">我把深浅拷贝单独作为一讲来专门讲解，是因为在 JavaScript 的编程中经常需要对数据进行复制，什么时候用深拷贝、什么时候用浅拷贝，是开发过程中需要思考的；同时深浅拷贝也是前端面试中比较高频的题目。</p>\n<p data-nodeid="1043">但是我在面试候选人的过程中，发现有很多同学都没有搞懂深拷贝和浅拷贝的区别和定义。最近我也在一些关于 JavaScript 的技术文章中发现，里面很多关于深浅拷贝的代码写得比较简陋，从面试官的角度来讲，简陋的答案是不太能让人满意的。</p>\n<p data-nodeid="1044">因此，深入学习这部分知识有助于提高你手写 JS 的能力，以及对一些边界特殊情况的深入思考能力，这一讲我会结合最基础但是又容易写不好的的题目来帮助你提升。</p>\n<p data-nodeid="1045">在开始之前，我先抛出来两个问题，你可以思考一下。</p>\n<ol data-nodeid="1046">\n<li data-nodeid="1047">\n<p data-nodeid="1048">拷贝一个很多嵌套的对象怎么实现？</p>\n</li>\n<li data-nodeid="1049">\n<p data-nodeid="1050">在面试官眼中，写成什么样的深拷贝代码才能算合格？</p>\n</li>\n</ol>\n<p data-nodeid="1051">带着这两个问题，我们先来看下浅拷贝的相关内容。</p>\n<h3 data-nodeid="1052">浅拷贝的原理和实现</h3>\n<p data-nodeid="1053">对于浅拷贝的定义我们可以初步理解为：</p>\n<blockquote data-nodeid="1054">\n<p data-nodeid="1055">自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象。</p>\n</blockquote>\n<p data-nodeid="1056">下面我总结了一些 JavaScript 提供的浅拷贝方法，一起来看看哪些方法能实现上述定义所描述的过程。</p>\n<h4 data-nodeid="1057">方法一：object.assign</h4>\n<p data-nodeid="1058">object.assign 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。</p>\n<blockquote data-nodeid="1059">\n<p data-nodeid="1060">object.assign 的语法为：Object.assign(target, ...sources)</p>\n</blockquote>\n<p data-nodeid="1061">object.assign 的示例代码如下：</p>\n<pre class="lang-javascript" data-nodeid="1062"><code data-language="javascript"><span class="hljs-keyword">let</span> target = {};\n<span class="hljs-keyword">let</span> source = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> } };\n<span class="hljs-built_in">Object</span>.assign(target, source);\n<span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">// { a: { b: 1 } };</span>\n</code></pre>\n<p data-nodeid="1063">从上面的代码中可以看到，通过 object.assign 我们的确简单实现了一个浅拷贝，“target”就是我们新拷贝的对象，下面再看一个和上面不太一样的例子。</p>\n<pre class="lang-javascript" data-nodeid="1064"><code data-language="javascript"><span class="hljs-keyword">let</span> target = {};\n<span class="hljs-keyword">let</span> source = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> } };\n<span class="hljs-built_in">Object</span>.assign(target, source);\n<span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">// { a: { b: 10 } }; </span>\nsource.a.b = <span class="hljs-number">10</span>; \n<span class="hljs-built_in">console</span>.log(source); <span class="hljs-comment">// { a: { b: 10 } }; </span>\n<span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">// { a: { b: 10 } };</span>\n</code></pre>\n<p data-nodeid="1065">从上面代码中我们可以看到，首先通过 Object.assign 将 source 拷贝到 target 对象中，然后我们尝试将 source 对象中的 b 属性由 2 修改为 10。通过控制台可以发现，打印结果中，三个 target 里的 b 属性都变为 10 了，证明 Object.assign 暂时实现了我们想要的拷贝效果。</p>\n<p data-nodeid="1066">但是使用 object.assign 方法有几点需要注意：</p>\n<ul data-nodeid="1067">\n<li data-nodeid="1068">\n<p data-nodeid="1069">它不会拷贝对象的继承属性；</p>\n</li>\n<li data-nodeid="1070">\n<p data-nodeid="1071">它不会拷贝对象的不可枚举的属性；</p>\n</li>\n<li data-nodeid="1072">\n<p data-nodeid="1073">可以拷贝 Symbol 类型的属性。</p>\n</li>\n</ul>\n<p data-nodeid="1074">可以简单理解为：Object.assign 循环遍历原对象的属性，通过复制的方式将其赋值给目标对象的相应属性，来看一下这段代码，以验证它可以拷贝 Symbol 类型的对象。</p>\n<pre class="lang-javascript" data-nodeid="1075"><code data-language="javascript"><span class="hljs-keyword">let</span> obj1 = { <span class="hljs-attr">a</span>:{ <span class="hljs-attr">b</span>:<span class="hljs-number">1</span> }, <span class="hljs-attr">sym</span>:<span class="hljs-built_in">Symbol</span>(<span class="hljs-number">1</span>)}; \n<span class="hljs-built_in">Object</span>.defineProperty(obj1, <span class="hljs-string">\'innumerable\'</span> ,{\n    <span class="hljs-attr">value</span>:<span class="hljs-string">\'不可枚举属性\'</span>,\n    <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>\n});\n<span class="hljs-keyword">let</span> obj2 = {};\n<span class="hljs-built_in">Object</span>.assign(obj2,obj1)\nobj1.a.b = <span class="hljs-number">2</span>;\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'obj1\'</span>,obj1);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'obj2\'</span>,obj2);\n</code></pre>\n<p data-nodeid="1076">我们来看一下控制台打印的结果，如下图所示。</p>\n<p data-nodeid="1077"><img src="https://s0.lgstatic.com/i/image2/M01/04/DD/CgpVE1_23KWABxpDAAC0XN0mEv4915.png" alt="Drawing 0.png" data-nodeid="1207"></p>\n<p data-nodeid="1078">从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 Symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能。</p>\n<h4 data-nodeid="1079">方法二：扩展运算符方式</h4>\n<p data-nodeid="1080">我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。</p>\n<blockquote data-nodeid="1081">\n<p data-nodeid="1082">扩展运算符的语法为：let cloneObj = { ...obj };</p>\n</blockquote>\n<p data-nodeid="1083">代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1084"><code data-language="javascript"><span class="hljs-comment">/* 对象的拷贝 */</span>\n<span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:{<span class="hljs-attr">c</span>:<span class="hljs-number">1</span>}}\n<span class="hljs-keyword">let</span> obj2 = {...obj}\nobj.a = <span class="hljs-number">2</span>\n<span class="hljs-built_in">console</span>.log(obj)  <span class="hljs-comment">//{a:2,b:{c:1}} console.log(obj2); //{a:1,b:{c:1}}</span>\nobj.b.c = <span class="hljs-number">2</span>\n<span class="hljs-built_in">console</span>.log(obj)  <span class="hljs-comment">//{a:2,b:{c:2}} console.log(obj2); //{a:1,b:{c:2}}</span>\n<span class="hljs-comment">/* 数组的拷贝 */</span>\n<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-keyword">let</span> newArr = [...arr]; <span class="hljs-comment">//跟arr.slice()是一样的效果</span>\n</code></pre>\n<p data-nodeid="1085">扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</p>\n<h4 data-nodeid="1086">方法三：concat 拷贝数组</h4>\n<p data-nodeid="1087">数组的 concat 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 concat 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1088"><code data-language="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-keyword">let</span> newArr = arr.concat();\nnewArr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;\n<span class="hljs-built_in">console</span>.log(arr);  <span class="hljs-comment">// [ 1, 2, 3 ]</span>\n<span class="hljs-built_in">console</span>.log(newArr); <span class="hljs-comment">// [ 1, 100, 3 ]</span>\n</code></pre>\n<h4 data-nodeid="1089">方法四：slice 拷贝数组</h4>\n<p data-nodeid="1090">slice 方法也比较有局限性，因为它仅仅针对数组类型。slice 方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。</p>\n<blockquote data-nodeid="1091">\n<p data-nodeid="1092">slice 的语法为：arr.slice(begin, end);</p>\n</blockquote>\n<p data-nodeid="1093">我们来看一下 slice 怎么使用，代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1094"><code data-language="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, {<span class="hljs-attr">val</span>: <span class="hljs-number">4</span>}];\n<span class="hljs-keyword">let</span> newArr = arr.slice();\nnewArr[<span class="hljs-number">2</span>].val = <span class="hljs-number">1000</span>;\n<span class="hljs-built_in">console</span>.log(arr);  <span class="hljs-comment">//[ 1, 2, { val: 1000 } ]</span>\n</code></pre>\n<p data-nodeid="1095">从上面的代码中可以看出，这就是浅拷贝的限制所在了——它只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。这一讲的后面我会介绍深拷贝相关的内容。</p>\n<h3 data-nodeid="1096">手工实现一个浅拷贝</h3>\n<p data-nodeid="1097">根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：</p>\n<ol data-nodeid="1098">\n<li data-nodeid="1099">\n<p data-nodeid="1100">对基础类型做一个最基本的一个拷贝；</p>\n</li>\n<li data-nodeid="1101">\n<p data-nodeid="1102">对引用类型开辟一个新的存储，并且拷贝一层对象属性。</p>\n</li>\n</ol>\n<p data-nodeid="1103">那么，围绕着这两个思路，请你跟着我的操作，自己来实现一个浅拷贝吧，代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1104"><code data-language="javascript"><span class="hljs-keyword">const</span> shallowClone = <span class="hljs-function">(<span class="hljs-params">target</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">\'object\'</span> &amp;&amp; target !== <span class="hljs-literal">null</span>) {\n    <span class="hljs-keyword">const</span> cloneTarget = <span class="hljs-built_in">Array</span>.isArray(target) ? []: {};\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> target) {\n      <span class="hljs-keyword">if</span> (target.hasOwnProperty(prop)) {\n          cloneTarget[prop] = target[prop];\n      }\n    }\n    <span class="hljs-keyword">return</span> cloneTarget;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> target;\n  }\n}\n</code></pre>\n<p data-nodeid="1105">从上面这段代码可以看出，利用类型判断，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性，基本就可以手工实现一个浅拷贝的代码了。</p>\n<p data-nodeid="1106">那么了解了实现浅拷贝代码的思路，接下来我们再看看深拷贝是怎么实现的。</p>\n<h3 data-nodeid="1107">深拷贝的原理和实现</h3>\n<p data-nodeid="1108">浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p>\n<p data-nodeid="1109">这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，深拷贝的原理可以总结如下：</p>\n<blockquote data-nodeid="1110">\n<p data-nodeid="1111">将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p>\n</blockquote>\n<p data-nodeid="1112">现在原理你知道了，那么怎么去实现深拷贝呢？我也总结了几种方法分享给你。</p>\n<h4 data-nodeid="1301" class="">方法一：乞丐版（JSON.stringify）</h4>\n\n<p data-nodeid="1823" class="">JSON.stringify() 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 JSON 的字符串，并将对象里面的内容转换成字符串，最后再用 JSON.parse() 的方法将JSON 字符串生成一个新的对象。示例代码如下所示。</p>\n\n<pre class="lang-javascript" data-nodeid="1115"><code data-language="javascript"><span class="hljs-keyword">let</span> obj1 = { <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] }\n<span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(obj1)；\n<span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(str)；\n<span class="hljs-built_in">console</span>.log(obj2);   <span class="hljs-comment">//{a:1,b:[1,2,3]} </span>\nobj1.a = <span class="hljs-number">2</span>；\nobj1.b.push(<span class="hljs-number">4</span>);\n<span class="hljs-built_in">console</span>.log(obj1);   <span class="hljs-comment">//{a:2,b:[1,2,3,4]}</span>\n<span class="hljs-built_in">console</span>.log(obj2);   <span class="hljs-comment">//{a:1,b:[1,2,3]}</span>\n</code></pre>\n<p data-nodeid="2345" class="">从上面的代码可以看到，通过 JSON.stringify 可以初步实现一个对象的深拷贝，通过改变 obj1 的 b 属性，其实可以看出 obj2 这个对象也不受影响。</p>\n\n<p data-nodeid="2867" class="">但是使用 JSON.stringify 实现深拷贝还是有一些地方值得注意，我总结下来主要有这几点：</p>\n\n<ol data-nodeid="1118">\n<li data-nodeid="1119">\n<p data-nodeid="1120">拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</p>\n</li>\n<li data-nodeid="1121">\n<p data-nodeid="1122">拷贝 Date 引用类型会变成字符串；</p>\n</li>\n<li data-nodeid="1123">\n<p data-nodeid="1124">无法拷贝不可枚举的属性；</p>\n</li>\n<li data-nodeid="1125">\n<p data-nodeid="1126">无法拷贝对象的原型链；</p>\n</li>\n<li data-nodeid="1127">\n<p data-nodeid="1128">拷贝 RegExp 引用类型会变成空对象；</p>\n</li>\n<li data-nodeid="1129">\n<p data-nodeid="1130">对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</p>\n</li>\n<li data-nodeid="1131">\n<p data-nodeid="1132">无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</p>\n</li>\n</ol>\n<p data-nodeid="3389" class="">针对这些存在的问题，你可以尝试着用下面的这段代码亲自执行一遍，来看看如此复杂的对象，如果用 JSON.stringify 实现深拷贝会出现什么情况。</p>\n\n<pre class="lang-javascript" data-nodeid="1134"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Obj</span>(<span class="hljs-params"></span>) </span>{ \n  <span class="hljs-keyword">this</span>.func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-number">1</span>) }; \n  <span class="hljs-keyword">this</span>.obj = {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>};\n  <span class="hljs-keyword">this</span>.arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];\n  <span class="hljs-keyword">this</span>.und = <span class="hljs-literal">undefined</span>; \n  <span class="hljs-keyword">this</span>.reg = <span class="hljs-regexp">/123/</span>; \n  <span class="hljs-keyword">this</span>.date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>); \n  <span class="hljs-keyword">this</span>.NaN = <span class="hljs-literal">NaN</span>;\n  <span class="hljs-keyword">this</span>.infinity = <span class="hljs-literal">Infinity</span>;\n  <span class="hljs-keyword">this</span>.sym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-number">1</span>);\n} \n<span class="hljs-keyword">let</span> obj1 = <span class="hljs-keyword">new</span> Obj();\n<span class="hljs-built_in">Object</span>.defineProperty(obj1,<span class="hljs-string">\'innumerable\'</span>,{ \n  <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>,\n  <span class="hljs-attr">value</span>:<span class="hljs-string">\'innumerable\'</span>\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'obj1\'</span>,obj1);\n<span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(obj1);\n<span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(str);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'obj2\'</span>,obj2);\n</code></pre>\n<p data-nodeid="1135">通过上面这段代码可以看到执行结果如下图所示。</p>\n<p data-nodeid="1136"><img src="https://s0.lgstatic.com/i/image/M00/8D/03/CgqCHl_23LaAXa7jAAFYsb1e_kA876.png" alt="Drawing 1.png" data-nodeid="1252"></p>\n<p data-nodeid="1137">使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，JSON.stringify 暂时还是无法满足的，那么就需要下面的几种方法了。</p>\n<h4 data-nodeid="1138" class="">方法二：基础版（手写递归实现）</h4>\n<p data-nodeid="1139" class="">下面是一个实现 deepClone 函数封装的例子，通过 for in 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制，代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1140"><code data-language="javascript"><span class="hljs-keyword">let</span> obj1 = {\n  <span class="hljs-attr">a</span>:{\n    <span class="hljs-attr">b</span>:<span class="hljs-number">1</span>\n  }\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>{ \n  <span class="hljs-keyword">let</span> cloneObj = {}\n  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {                 <span class="hljs-comment">//遍历</span>\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] ===<span class="hljs-string">\'object\'</span>) { \n      cloneObj[key] = deepClone(obj[key])  <span class="hljs-comment">//是对象就再次调用该函数递归</span>\n    } <span class="hljs-keyword">else</span> {\n      cloneObj[key] = obj[key]  <span class="hljs-comment">//基本类型的话直接复制值</span>\n    }\n  }\n  <span class="hljs-keyword">return</span> cloneObj\n}\n<span class="hljs-keyword">let</span> obj2 = deepClone(obj1);\nobj1.a.b = <span class="hljs-number">2</span>;\n<span class="hljs-built_in">console</span>.log(obj2);   <span class="hljs-comment">//  {a:{b:1}}</span>\n</code></pre>\n<p data-nodeid="3911" class="te-preview-highlight">虽然利用递归能实现一个深拷贝，但是同上面的 JSON.stringify 一样，还是有一些问题没有完全解决，例如：</p>\n\n<ol data-nodeid="1142">\n<li data-nodeid="1143">\n<p data-nodeid="1144">这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</p>\n</li>\n<li data-nodeid="1145">\n<p data-nodeid="1146">这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</p>\n</li>\n<li data-nodeid="1147">\n<p data-nodeid="1148">对象的属性里面成环，即循环引用没有解决。</p>\n</li>\n</ol>\n<p data-nodeid="1149">这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。</p>\n<p data-nodeid="1150">所以为了“拯救”这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。</p>\n<h4 data-nodeid="1151">方法三：改进版（改进后递归实现）</h4>\n<p data-nodeid="1152">针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。</p>\n<ol data-nodeid="1153">\n<li data-nodeid="1154">\n<p data-nodeid="1155">针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</p>\n</li>\n<li data-nodeid="1156">\n<p data-nodeid="1157">当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</p>\n</li>\n<li data-nodeid="1158">\n<p data-nodeid="1159">利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</p>\n</li>\n<li data-nodeid="1160">\n<p data-nodeid="1161">利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。</p>\n</li>\n</ol>\n<p data-nodeid="1162">关于第 4 点的 WeakMap，这里我不进行过多的科普讲解了，你如果不清楚可以自己再通过相关资料了解一下。我也经常在给人面试中看到有人使用 WeakMap 来解决循环引用问题，但是很多解释都是不够清晰的。</p>\n<p data-nodeid="1163">当你不太了解 WeakMap 的真正作用时，我建议你不要在面试中写出这样的代码，如果只是死记硬背，会给自己挖坑的。<strong data-nodeid="1274">因为你写的每一行代码都是需要经过深思熟虑并且非常清晰明白的，这样你才能经得住面试官的推敲</strong>。</p>\n<p data-nodeid="1164">当然，如果你在考虑到循环引用的问题之后，还能用 WeakMap 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了。</p>\n<p data-nodeid="1165">那么针对上面这几个问题，我们来看下改进后的递归实现的深拷贝代码应该是什么样子的，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1166"><code data-language="javascript"><span class="hljs-keyword">const</span> isComplexDataType = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">\'object\'</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">\'function\'</span>) &amp;&amp; (obj !== <span class="hljs-literal">null</span>)\n<span class="hljs-keyword">const</span> deepClone = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, hash = new WeakMap(</span>)) </span>{\n  <span class="hljs-keyword">if</span> (obj.constructor === <span class="hljs-built_in">Date</span>) \n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj)       <span class="hljs-comment">// 日期对象直接返回一个新的日期对象</span>\n  <span class="hljs-keyword">if</span> (obj.constructor === <span class="hljs-built_in">RegExp</span>)\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj)     <span class="hljs-comment">//正则对象直接返回一个新的正则对象</span>\n  <span class="hljs-comment">//如果循环引用了就用 weakMap 来解决</span>\n  <span class="hljs-keyword">if</span> (hash.has(obj)) <span class="hljs-keyword">return</span> hash.get(obj)\n  <span class="hljs-keyword">let</span> allDesc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)\n  <span class="hljs-comment">//遍历传入参数所有键的特性</span>\n  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj), allDesc)\n  <span class="hljs-comment">//继承原型链</span>\n  hash.set(obj, cloneObj)\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj)) { \n    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] !== <span class="hljs-string">\'function\'</span>) ? deepClone(obj[key], hash) : obj[key]\n  }\n  <span class="hljs-keyword">return</span> cloneObj\n}\n<span class="hljs-comment">// 下面是验证代码</span>\n<span class="hljs-keyword">let</span> obj = {\n  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">str</span>: <span class="hljs-string">\'\'</span>,\n  <span class="hljs-attr">boolean</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">unf</span>: <span class="hljs-literal">undefined</span>,\n  <span class="hljs-attr">nul</span>: <span class="hljs-literal">null</span>,\n  <span class="hljs-attr">obj</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">\'我是一个对象\'</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> },\n  <span class="hljs-attr">arr</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],\n  <span class="hljs-attr">func</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'我是一个函数\'</span>) },\n  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>),\n  <span class="hljs-attr">reg</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">\'/我是一个正则/ig\'</span>),\n  [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">\'1\'</span>)]: <span class="hljs-number">1</span>,\n};\n<span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">\'innumerable\'</span>, {\n  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">\'不可枚举属性\'</span> }\n);\nobj = <span class="hljs-built_in">Object</span>.create(obj, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj))\nobj.loop = obj    <span class="hljs-comment">// 设置loop成循环引用的属性</span>\n<span class="hljs-keyword">let</span> cloneObj = deepClone(obj)\ncloneObj.arr.push(<span class="hljs-number">4</span>)\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'obj\'</span>, obj)\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'cloneObj\'</span>, cloneObj)\n</code></pre>\n<p data-nodeid="1167">我们看一下结果，cloneObj 在 obj 的基础上进行了一次深拷贝，cloneObj 里的 arr 数组进行了修改，并未影响到 obj.arr 的变化，如下图所示。</p>\n<p data-nodeid="1168"><img src="https://s0.lgstatic.com/i/image/M00/8D/03/CgqCHl_23NqAajeeAAIH4UWV0LE467.png" alt="Drawing 2.png" data-nodeid="1280"></p>\n<p data-nodeid="1169">从这张截图的结果可以看出，改进版的 deepClone 函数已经对基础版的那几个问题进行了改进，也验证了我上面提到的那四点理论。</p>\n<p data-nodeid="1170">那么到这里，深拷贝的相关内容就介绍得差不多了。</p>\n<h3 data-nodeid="1171">总结</h3>\n<p data-nodeid="1172">这一讲，我们探讨了如何实现一个深浅拷贝。在日常的开发中，由于开发者可以使用一些现成的库来实现深拷贝，所以很多人对如何实现深拷贝的细节问题并不清楚。但是如果仔细研究你就会发现，这部分内容对于你深入了解 JS 底层的原理有很大帮助。如果未来你需要自己实现一个前端相关的工具或者库，对 JS 理解的深度会决定你能把这个东西做得有多好。</p>\n<p data-nodeid="1173">其实到最后我们可以看到，自己完整实现一个深拷贝，还是考察了不少的知识点和编程能力，总结下来大致分为这几点，请看下图。</p>\n<p data-nodeid="1174"><img src="https://s0.lgstatic.com/i/image2/M01/05/11/Cip5yF_7s86AOlltAAEet-x_UAc883.png" alt="图片4.png" data-nodeid="1288"></p>\n<p data-nodeid="1175">可以看到通过这一个问题能考察的能力有很多，因此千万不要用最低的标准来要求自己，应该用类似的方法去分析每个问题深入考察的究竟是什么，这样才能更好地去全面提升自己的基本功。</p>\n<p data-nodeid="1176">关于深浅拷贝如果你有不清楚的地方，欢迎在评论区留言，最好的建议还是要多动手，不清楚的地方自己敲一遍代码，这样才能加深印象，然后更容易地去消化这部分内容。</p>\n<p data-nodeid="1177">下一讲，我们将迎来继承方式的学习，这部分知识也是非常重要的，你需要熟练掌握并理解其原理。也欢迎你提前预习相关知识，这样才能在不同的角度有所收获。下一讲再见。</p>\n<hr data-nodeid="1178">\n<p data-nodeid="1179"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1296"><img src="https://s0.lgstatic.com/i/image2/M01/00/66/CgpVE1_W_x2AaW0rAAdqMM6w3z0145.png" alt="大前端引流.png" data-nodeid="1295"></a></p>\n<p data-nodeid="1180" class="">对标阿里P7技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1300">点此链接，快来领取！</a></p>',
          },
          {
            theme: '03 | 继承实现：探究 JS 常见的 6 种继承方式',
            id: 14,
            content:
              '<p data-nodeid="725" class="">这一讲我要带你一起探究 JavaScript 的继承方式。</p>\n<p data-nodeid="726">我先来简单介绍一下继承的概念。继承是面向对象的，使用这种方式我们可以更好地复用以前的开发代码，缩短开发的周期、提升开发效率。</p>\n<p data-nodeid="727">继承在各种编程语言中都充当着至关重要的角色，特别是在 JavaScript 中，它天生的灵活性，使应用场景更加丰富。JavaScript 的继承也经常会在用在前端工程基础库的底层搭建上面，在整个 JavaScript 的学习中尤为重要。</p>\n<p data-nodeid="728">因此，我希望这一讲，能让你对 JavaScript 的继承有更深一步的理解，更加得心应手地运用在业务代码中，并可以轻松掌握和 JavaScript 继承相关的面试题目。</p>\n<p data-nodeid="729">那么，为了方便你更好地理解本讲的内容，在课程开始前请你先思考几个问题：</p>\n<ol data-nodeid="730">\n<li data-nodeid="731">\n<p data-nodeid="732">JS 的继承到底有多少种实现方式呢？</p>\n</li>\n<li data-nodeid="733">\n<p data-nodeid="734">ES6 的 extends 关键字是用哪种继承方式实现的呢？</p>\n</li>\n</ol>\n<p data-nodeid="735">是不是这几个问题并不是那么容易地回答出来？那么我们带着思考，开始学习。</p>\n<h3 data-nodeid="736">继承概念的探究</h3>\n<p data-nodeid="737">说到继承的概念，首先要说一个经典的例子。</p>\n<p data-nodeid="738">先定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等，由汽车这个类可以派生出“轿车”和“货车”两个类，那么可以在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱。这样轿车和货车就是不一样的，但是二者都属于汽车这个类，这样从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系。</p>\n<p data-nodeid="739">继承可以使得子类别具有父类的各种方法和属性，比如上面的例子中“轿车” 和 “货车” 分别继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性。在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法。</p>\n<p data-nodeid="740">继承的基本概念就初步介绍这些，下面我们就来看看 JavaScript 中都有哪些实现继承的方法。</p>\n<h3 data-nodeid="741">JS 实现继承的几种方式</h3>\n<h4 data-nodeid="742">第一种：原型链继承</h4>\n<p data-nodeid="743">原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。</p>\n<p data-nodeid="744">下面我们结合代码来了解一下。</p>\n<pre class="lang-javascript" data-nodeid="745"><code data-language="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent1</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'parent1\'</span>;\n    <span class="hljs-keyword">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child1</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.type = <span class="hljs-string">\'child2\'</span>;\n  }\n  Child1.prototype = <span class="hljs-keyword">new</span> Parent1();\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Child1());\n</code></pre>\n<p data-nodeid="746">上面的代码看似没有问题，虽然父类的方法和属性都能够访问，但其实有一个潜在的问题，我再举个例子来说明这个问题。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="906"><code data-language="javascript">  <span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> Child1();\n  <span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> Child2();\n  s1.play.push(<span class="hljs-number">4</span>);\n  <span class="hljs-built_in">console</span>.log(s1.play, s2.play);\n</code></pre>\n\n<p data-nodeid="748">这段代码在控制台执行之后，可以看到结果如下：</p>\n<p data-nodeid="749"><img src="https://s0.lgstatic.com/i/image2/M01/05/2A/CgpVE1_9B-GAE-pIAAAYEv_K_84787.png" alt="Drawing 0.png" data-nodeid="834"></p>\n<p data-nodeid="750">明明我只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？原因很简单，因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>\n<p data-nodeid="751">那么要解决这个问题的话，我们就得再看看其他的继承方式，下面我们看看能解决原型属性共享问题的第二种方法。</p>\n<h4 data-nodeid="752">第二种：构造函数继承（借助 call）</h4>\n<p data-nodeid="753">直接通过代码来了解，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="754"><code data-language="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent1</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'parent1\'</span>;\n  }\n\n  Parent1.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;\n  }\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child1</span>(<span class="hljs-params"></span>)</span>{\n    Parent1.call(<span class="hljs-keyword">this</span>);\n    <span class="hljs-keyword">this</span>.type = <span class="hljs-string">\'child1\'</span>\n  }\n\n  <span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> Child1();\n  <span class="hljs-built_in">console</span>.log(child);  <span class="hljs-comment">// 没问题</span>\n  <span class="hljs-built_in">console</span>.log(child.getName());  <span class="hljs-comment">// 会报错</span>\n</code></pre>\n<p data-nodeid="755">执行上面的这段代码，可以得到这样的结果。</p>\n<p data-nodeid="756"><img src="https://s0.lgstatic.com/i/image2/M01/05/2A/CgpVE1_9B-qAHGGjAABBe0l-7oE835.png" alt="Drawing 1.png" data-nodeid="842"></p>\n<p data-nodeid="757">可以看到最后打印的 child 在控制台显示，除了 Child1 的属性 type 之外，也继承了 Parent1 的属性 name。这样写的时候子类虽然能够拿到父类的属性值，解决了第一种继承方式的弊端，但问题是，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法。这种情况的控制台执行结果如下图所示。</p>\n<p data-nodeid="758"><img src="https://s0.lgstatic.com/i/image/M00/8D/42/Ciqc1F_9B_KACrgnAABDSFXfnx0666.png" alt="Drawing 2.png" data-nodeid="846"></p>\n<p data-nodeid="759">因此，从上面的结果就可以看到构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>\n<p data-nodeid="760">上面的两种继承方式各有优缺点，那么结合二者的优点，于是就产生了下面这种组合的继承方式。</p>\n<h4 data-nodeid="761">第三种：组合继承（前两种组合）</h4>\n<p data-nodeid="762">这种方式结合了前两种继承方式的优缺点，结合起来的继承，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="763"><code data-language="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent3</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'parent3\'</span>;\n    <span class="hljs-keyword">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n  }\n\n  Parent3.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child3</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-comment">// 第二次调用 Parent3()</span>\n    Parent3.call(<span class="hljs-keyword">this</span>);\n    <span class="hljs-keyword">this</span>.type = <span class="hljs-string">\'child3\'</span>;\n  }\n\n  <span class="hljs-comment">// 第一次调用 Parent3()</span>\n  Child3.prototype = <span class="hljs-keyword">new</span> Parent3();\n  <span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span>\n  Child3.prototype.constructor = Child3;\n  <span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> Child3();\n  <span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> Child3();\n  s3.play.push(<span class="hljs-number">4</span>);\n  <span class="hljs-built_in">console</span>.log(s3.play, s4.play);  <span class="hljs-comment">// 不互相影响</span>\n  <span class="hljs-built_in">console</span>.log(s3.getName()); <span class="hljs-comment">// 正常输出\'parent3\'</span>\n  <span class="hljs-built_in">console</span>.log(s4.getName()); <span class="hljs-comment">// 正常输出\'parent3\'</span>\n</code></pre>\n<p data-nodeid="764">执行上面的代码，可以看到控制台的输出结果，之前方法一和方法二的问题都得以解决。</p>\n<p data-nodeid="765"><img src="https://s0.lgstatic.com/i/image/M00/8D/42/Ciqc1F_9B_uAHQtBAAAgMta5Vz8933.png" alt="Drawing 3.png" data-nodeid="854"></p>\n<p data-nodeid="766">但是这里又增加了一个新问题：通过注释我们可以看到 Parent3 执行了两次，第一次是改变Child3 的 prototype 的时候，第二次是通过 call 方法调用 Parent3 的时候，那么 Parent3 多构造一次就多进行了一次性能开销，这是我们不愿看到的。</p>\n<p data-nodeid="767">那么是否有更好的办法解决这个问题呢？请你再往下学习，下面的第六种继承方式可以更好地解决这里的问题。</p>\n<p data-nodeid="768">上面介绍的更多是围绕着构造函数的方式，那么对于 JavaScript 的普通对象，怎么实现继承呢？</p>\n<h4 data-nodeid="769">第四种：原型式继承</h4>\n<p data-nodeid="770">这里不得不提到的就是 ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）。</p>\n<p data-nodeid="771">我们通过一段代码，看看普通对象是怎么实现的继承。</p>\n<pre class="lang-javascript" data-nodeid="772"><code data-language="javascript">  <span class="hljs-keyword">let</span> parent4 = {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">"parent4"</span>,\n    <span class="hljs-attr">friends</span>: [<span class="hljs-string">"p1"</span>, <span class="hljs-string">"p2"</span>, <span class="hljs-string">"p3"</span>],\n    <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;\n    }\n  };\n\n  <span class="hljs-keyword">let</span> person4 = <span class="hljs-built_in">Object</span>.create(parent4);\n  person4.name = <span class="hljs-string">"tom"</span>;\n  person4.friends.push(<span class="hljs-string">"jerry"</span>);\n\n  <span class="hljs-keyword">let</span> person5 = <span class="hljs-built_in">Object</span>.create(parent4);\n  person5.friends.push(<span class="hljs-string">"lucy"</span>);\n\n  <span class="hljs-built_in">console</span>.log(person4.name);\n  <span class="hljs-built_in">console</span>.log(person4.name === person4.getName());\n  <span class="hljs-built_in">console</span>.log(person5.name);\n  <span class="hljs-built_in">console</span>.log(person4.friends);\n  <span class="hljs-built_in">console</span>.log(person5.friends);\n</code></pre>\n<p data-nodeid="773">从上面的代码中可以看到，通过 Object.create 这个方法可以实现普通对象的继承，不仅仅能继承属性，同样也可以继承 getName 的方法，请看这段代码的执行结果。</p>\n<p data-nodeid="774"><img src="https://s0.lgstatic.com/i/image/M00/8D/4E/CgqCHl_9CASAJMvwAAA_d30-jH8783.png" alt="Drawing 4.png" data-nodeid="864"></p>\n<p data-nodeid="775">第一个结果“tom”，比较容易理解，person4 继承了 parent4 的 name 属性，但是在这个基础上又进行了自定义。</p>\n<p data-nodeid="776">第二个是继承过来的 getName 方法检查自己的 name 是否和属性里面的值一样，答案是 true。</p>\n<p data-nodeid="777">第三个结果“parent4”也比较容易理解，person5 继承了 parent4 的 name 属性，没有进行覆盖，因此输出父对象的属性。</p>\n<p data-nodeid="778">最后两个输出结果是一样的，讲到这里你应该可以联想到 02 讲中浅拷贝的知识点，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。</p>\n<p data-nodeid="779">那么关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能，接下来我们看一下在这个继承基础上进行优化之后的另一种继承方式——寄生式继承。</p>\n<h4 data-nodeid="780">第五种：寄生式继承</h4>\n<p data-nodeid="781">使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>\n<p data-nodeid="782">虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。那么我们看一下代码是怎么实现。</p>\n<pre class="lang-javascript" data-nodeid="783"><code data-language="javascript">   <span class="hljs-keyword">let</span> parent5 = {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">"parent5"</span>,\n    <span class="hljs-attr">friends</span>: [<span class="hljs-string">"p1"</span>, <span class="hljs-string">"p2"</span>, <span class="hljs-string">"p3"</span>],\n    <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;\n    }\n  };\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">original</span>) </span>{\n    <span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(original);\n    clone.getFriends = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.friends;\n    };\n    <span class="hljs-keyword">return</span> clone;\n  }\n\n  <span class="hljs-keyword">let</span> person5 = clone(parent5);\n\n  <span class="hljs-built_in">console</span>.log(person5.getName());\n  <span class="hljs-built_in">console</span>.log(person5.getFriends());\n</code></pre>\n<p data-nodeid="784">通过上面这段代码，我们可以看到 person5 是通过寄生式继承生成的实例，它不仅仅有 getName 的方法，而且可以看到它最后也拥有了 getFriends 的方法，结果如下图所示。</p>\n<p data-nodeid="785"><img src="https://s0.lgstatic.com/i/image/M00/8D/4E/CgqCHl_9CA2AT-ozAAAWLoCKBTA043.png" alt="Drawing 5.png" data-nodeid="876"></p>\n<p data-nodeid="786">从最后的输出结果中可以看到，person5 通过 clone 的方法，增加了 getFriends 的方法，从而使 person5 这个普通对象在继承过程中又增加了一个方法，这样的继承方式就是寄生式继承。</p>\n<p data-nodeid="787">我在上面第三种组合继承方式中提到了一些弊端，即两次调用父类的构造函数造成浪费，下面要介绍的寄生组合继承就可以解决这个问题。</p>\n<h4 data-nodeid="788">第六种：寄生组合式继承</h4>\n<p data-nodeid="789">结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="790"><code data-language="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span> (<span class="hljs-params">parent, child</span>) </span>{\n    <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span>\n    child.prototype = <span class="hljs-built_in">Object</span>.create(parent.prototype);\n    child.prototype.constructor = child;\n  }\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent6</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'parent6\'</span>;\n    <span class="hljs-keyword">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n  }\n   Parent6.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child6</span>(<span class="hljs-params"></span>) </span>{\n    Parent6.call(<span class="hljs-keyword">this</span>);\n    <span class="hljs-keyword">this</span>.friends = <span class="hljs-string">\'child5\'</span>;\n  }\n\n  clone(Parent6, Child6);\n\n  Child6.prototype.getFriends = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.friends;\n  }\n\n  <span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> Child6();\n  <span class="hljs-built_in">console</span>.log(person6);\n  <span class="hljs-built_in">console</span>.log(person6.getName());\n  <span class="hljs-built_in">console</span>.log(person6.getFriends());\n</code></pre>\n<p data-nodeid="791">通过这段代码可以看出来，这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销，我们来看一下上面这一段代码的执行结果。</p>\n<p data-nodeid="792"><img src="https://s0.lgstatic.com/i/image/M00/8D/4E/CgqCHl_9CBWATQbEAABszTJIdBQ249.png" alt="Drawing 6.png" data-nodeid="884"></p>\n<p data-nodeid="793">可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题，可以输出预期的结果。</p>\n<p data-nodeid="794">整体看下来，这六种继承方式中，寄生组合式继承是这六种里面最优的继承方式。另外，ES6 还提供了继承的关键字 extends，我们再看下 extends 的底层实现继承的逻辑。</p>\n<h3 data-nodeid="795">ES6 的 extends 关键字实现逻辑</h3>\n<p data-nodeid="796">我们可以利用 ES6 里的 extends 的语法糖，使用关键词很容易直接实现 JavaScript 的继承，但是如果想深入了解 extends 语法糖是怎么实现的，就得深入研究 extends 的底层逻辑。</p>\n<p data-nodeid="797">我们先看下用利用 extends 如何直接实现继承，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="798"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{\n  <span class="hljs-keyword">constructor</span>(name) {\n    <span class="hljs-keyword">this</span>.name = name\n  }\n  <span class="hljs-comment">// 原型方法</span>\n  <span class="hljs-comment">// 即 Person.prototype.getName = function() { }</span>\n  <span class="hljs-comment">// 下面可以简写为 getName() {...}</span>\n  getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Person:\'</span>, <span class="hljs-keyword">this</span>.name)\n  }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gamer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{\n  <span class="hljs-keyword">constructor</span>(name, age) {\n    <span class="hljs-comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span>\n    <span class="hljs-keyword">super</span>(name)\n    <span class="hljs-keyword">this</span>.age = age\n  }\n}\n<span class="hljs-keyword">const</span> asuna = <span class="hljs-keyword">new</span> Gamer(<span class="hljs-string">\'Asuna\'</span>, <span class="hljs-number">20</span>)\nasuna.getName() <span class="hljs-comment">// 成功访问到父类的方法</span>\n</code></pre>\n<p data-nodeid="799">因为浏览器的兼容性问题，如果遇到不支持 ES6 的浏览器，那么就得利用 babel 这个编译工具，将 ES6 的代码编译成 ES5，让一些不支持新语法的浏览器也能运行。</p>\n<p data-nodeid="800">那么最后 extends 编译成了什么样子呢？我们看一下转译之后的代码片段。</p>\n<pre class="lang-javascript" data-nodeid="801"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_possibleConstructorReturn</span> (<span class="hljs-params">self, call</span>) </span>{ \n\t\t<span class="hljs-comment">// ...</span>\n\t\t<span class="hljs-keyword">return</span> call &amp;&amp; (<span class="hljs-keyword">typeof</span> call === <span class="hljs-string">\'object\'</span> || <span class="hljs-keyword">typeof</span> call === <span class="hljs-string">\'function\'</span>) ? call : self; \n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherits</span> (<span class="hljs-params">subClass, superClass</span>) </span>{ \n    <span class="hljs-comment">// 这里可以看到</span>\n\tsubClass.prototype = <span class="hljs-built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, { \n\t\t<span class="hljs-attr">constructor</span>: { \n\t\t\t<span class="hljs-attr">value</span>: subClass, \n\t\t\t<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, \n\t\t\t<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, \n\t\t\t<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span> \n\t\t} \n\t}); \n\t<span class="hljs-keyword">if</span> (superClass) <span class="hljs-built_in">Object</span>.setPrototypeOf ? <span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; \n}\n\n<span class="hljs-keyword">var</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-comment">// 验证是否是 Parent 构造出来的 this</span>\n\t_classCallCheck(<span class="hljs-keyword">this</span>, Parent);\n};\n<span class="hljs-keyword">var</span> Child = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Parent</span>) </span>{\n\t_inherits(Child, _Parent);\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params"></span>) </span>{\n\t\t_classCallCheck(<span class="hljs-keyword">this</span>, Child);\n\t\t<span class="hljs-keyword">return</span> _possibleConstructorReturn(<span class="hljs-keyword">this</span>, (Child.__proto__ || <span class="hljs-built_in">Object</span>.getPrototypeOf(Child)).apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));\n}\n\t<span class="hljs-keyword">return</span> Child;\n}(Parent));\n</code></pre>\n<p data-nodeid="802">从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>\n<p data-nodeid="803">到这里，JavaScript 中实现继承的方式也基本讲解差不多了，本课时也将告一段落。</p>\n<h3 data-nodeid="804">总结</h3>\n<p data-nodeid="805">下面我将 JavaScript 的继承方式做了个总结的脑图，方便你更清晰地回顾本课时所讲的内容。</p>\n<p data-nodeid="806"><img src="https://s0.lgstatic.com/i/image/M00/8D/4A/Ciqc1F_9SVuAfHXWAAEfwyAfiC0647.png" alt="图片7.png" data-nodeid="898"></p>\n<p data-nodeid="807">通过 Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似。</p>\n<p data-nodeid="808">综上，我们可以看到不同的继承方式有不同的优缺点，我们需要深入了解各种方式的优缺点，这样才能在日常开发中，选择最适合当前场景的继承方式。</p>\n<p data-nodeid="809">在日常的前端开发工作中，开发者往往会忽视对继承相关的系统性学习，但因为继承的方法比较多，每个实现的方法细节也比较零散，很多开发者很难有一个系统的、整体的认识，造成效率低下，以及代码能力难以进一步提升等问题。</p>\n<p data-nodeid="810">因此我希望通过这一讲的学习，你能很好地掌握 JavaScript 的继承方式，以便在开发中规避我所说的这些问题。</p>\n<p data-nodeid="811">在后续的课时中，我将继续带领你尝试一些和继承相关的 API 方法的实现，比如 call、apply 等。同时希望你多动手练习以熟练上面的代码，也欢迎你在下方留言讨论自己在学习过程中遇到的困惑，以及学习感悟等，让我们共同进步。</p>\n<p data-nodeid="812" class="">我们下一讲再见~</p>',
          },
          {
            theme:
              '04 | 继承进阶：如何实现 new、apply、call、bind 的底层逻辑？',
            id: 15,
            content:
              '<p data-nodeid="4941" class="">我在上一讲介绍了继承的概念，同时你也可以看到，其中综合使用了 new、apply 以及 call 的方法，那么这一讲我们就围绕这几个方法进行更深入的讲解，以便于你清楚这几个核心方法的实现思路，更好地去理解继承的原理。</p>\n<p data-nodeid="4942">JavaScript 中的 apply、call 和 bind 方法是前端代码开发中相当重要的概念，并且与 this 的指向密切相关。很多人对它们的理解还比较浅显，如果你想拥有扎实的 JavaScript 编程基础，那么必须要了解这些基础常用的方法。希望通过这一讲的学习，你可以彻底掌握它们。</p>\n<p data-nodeid="4943">为了方便你更好地理解本讲的内容，在课程开始前请你先思考几个问题：</p>\n<ol data-nodeid="4944">\n<li data-nodeid="4945">\n<p data-nodeid="4946">用什么样的思路可以 new 关键词？</p>\n</li>\n<li data-nodeid="4947">\n<p data-nodeid="4948">apply、call、bind 这三个方法之间有什么区别?</p>\n</li>\n<li data-nodeid="4949">\n<p data-nodeid="4950">怎样实现一个 apply 或者 call 的方法？</p>\n</li>\n</ol>\n<p data-nodeid="4951">带着这几个思考，我们开始本课时的学习吧。</p>\n<h3 data-nodeid="4952">方法的基本介绍</h3>\n<h4 data-nodeid="4953">new 原理介绍</h4>\n<p data-nodeid="4954">new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。下面我们通过一段代码来看一个简单的 new 的例子。</p>\n<pre class="lang-javascript" data-nodeid="4955"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>{\n   <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'Jack\'</span>;\n}\n<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(); \n<span class="hljs-built_in">console</span>.log(p.name)  <span class="hljs-comment">// Jack</span>\n</code></pre>\n<p data-nodeid="4956">这段代码比较容易理解，从输出结果可以看出，p 是一个通过 person 这个构造函数生成的一个实例对象，这个应该很容易理解。那么 new 在这个生成实例的过程中到底进行了哪些步骤来实现呢？总结下来大致分为以下几个步骤。</p>\n<ol data-nodeid="4957">\n<li data-nodeid="4958">\n<p data-nodeid="4959">创建一个新对象；</p>\n</li>\n<li data-nodeid="4960">\n<p data-nodeid="4961">将构造函数的作用域赋给新对象（this 指向新对象）；</p>\n</li>\n<li data-nodeid="4962">\n<p data-nodeid="4963">执行构造函数中的代码（为这个新对象添加属性）；</p>\n</li>\n<li data-nodeid="4964">\n<p data-nodeid="4965">返回新对象。</p>\n</li>\n</ol>\n<p data-nodeid="4966">那么问题来了，如果不用 new 这个关键词，结合上面的代码改造一下，去掉 new，会发生什么样的变化呢？我们再来看下面这段代码。</p>\n<pre class="lang-javascript" data-nodeid="4967"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'Jack\'</span>;\n}\n<span class="hljs-keyword">var</span> p = Person();\n<span class="hljs-built_in">console</span>.log(p) <span class="hljs-comment">// undefined</span>\n<span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// Jack</span>\n<span class="hljs-built_in">console</span>.log(p.name) <span class="hljs-comment">// \'name\' of undefined</span>\n</code></pre>\n<p data-nodeid="4968">从上面的代码中可以看到，我们没有使用 new 这个关键词，返回的结果就是 undefined。其中由于 JavaScript 代码在默认情况下 this 的指向是 window，那么 name 的输出结果就为 Jack，这是一种不存在 new 关键词的情况。</p>\n<p data-nodeid="4969">那么当构造函数中有 return 一个对象的操作，结果又会是什么样子呢？我们再来看一段在上面的基础上改造过的代码。</p>\n<pre class="lang-javascript" data-nodeid="4970"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>{\n   <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'Jack\'</span>; \n   <span class="hljs-keyword">return</span> {<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>}\n}\n<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(); \n<span class="hljs-built_in">console</span>.log(p)  <span class="hljs-comment">// {age: 18}</span>\n<span class="hljs-built_in">console</span>.log(p.name) <span class="hljs-comment">// undefined</span>\n<span class="hljs-built_in">console</span>.log(p.age) <span class="hljs-comment">// 18</span>\n</code></pre>\n<p data-nodeid="4971">通过这段代码又可以看出，当构造函数最后 return 出来的是一个和 this 无关的对象时，new 命令会直接返回这个新对象，而不是通过 new 执行步骤生成的 this 对象。</p>\n<p data-nodeid="4972">但是这里要求构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。接下来还是在上面这段代码的基础之上稍微改动一下。</p>\n<pre class="lang-javascript" data-nodeid="4973"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>{\n   <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'Jack\'</span>; \n   <span class="hljs-keyword">return</span> <span class="hljs-string">\'tom\'</span>;\n}\n<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(); \n<span class="hljs-built_in">console</span>.log(p)  <span class="hljs-comment">// {name: \'Jack\'}</span>\n<span class="hljs-built_in">console</span>.log(p.name) <span class="hljs-comment">// Jack</span>\n</code></pre>\n<p data-nodeid="4974">可以看出，当构造函数中 return 的不是一个对象时，那么它还是会根据 new 关键词的执行逻辑，生成一个新的对象（绑定了最新 this），最后返回出来。</p>\n<p data-nodeid="4975">因此我们总结一下：new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>\n<p data-nodeid="4976"><img src="https://s0.lgstatic.com/i/image/M00/8E/0F/CgqCHmABa_qAP_2zAAVBMulvP2U718.png" alt="刘烨的js.png" data-nodeid="5069"></p>\n<p data-nodeid="4977">好了，new 这个关键词内容基本就讲到这里了，我们再看一下 apply 和 call 的基本原理。</p>\n<h4 data-nodeid="4978">apply &amp; call &amp; bind 原理介绍</h4>\n<p data-nodeid="4979">先来了解一下这三个方法的基本情况，call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>\n<p data-nodeid="4980">请看这三个函数的基本语法。</p>\n<pre class="lang-javascript" data-nodeid="4981"><code data-language="javascript">func.call(thisArg, param1, param2, ...)\nfunc.apply(thisArg, [param1,param2,...])\nfunc.bind(thisArg, param1, param2, ...)\n</code></pre>\n<p data-nodeid="4982">其中 func 是要调用的函数，thisArg 一般为 this 所指向的对象，后面的 param1、2 为函数 func 的多个参数，如果 func 不需要参数，则后面的 param1、2 可以不写。</p>\n<p data-nodeid="4983">这三个方法共有的、比较明显的作用就是，都可以改变函数 func 的 this 指向。call 和 apply 的区别在于，传参的写法不同：apply 的第 2 个参数为数组； call 则是从第 2 个至第 N 个都是给 func 的传参；而 bind 和这两个（call、apply）又不同，bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>\n<p data-nodeid="4984">这几个方法的区别和原理基本讲清楚了，但是理解起来是不是很抽象呢？那么我举个形象的例子再配合着代码一起看下。</p>\n<p data-nodeid="4985">例如，生活中我不经常做饭，家里没有锅，周末突然想给自己做个饭尝尝。但是家里没有锅，而我又不想出去买，所以就问隔壁邻居借了一个锅来用，这样做了饭，又节省了开销，一举两得。</p>\n<p data-nodeid="4986">对应在程序中：A 对象有个 getName 的方法，B 对象也需要临时使用同样的方法，那么这时候我们是单独为 B 对象扩展一个方法，还是借用一下 A 对象的方法呢？当然是可以借用 A 对象的 getName 方法，既达到了目的，又节省重复定义，节约内存空间。</p>\n<p data-nodeid="4987">为了更好地掌握这部分概念，我们结合一段代码再深入理解一下这几个方法。</p>\n<pre class="lang-javascript" data-nodeid="4988"><code data-language="javascript"><span class="hljs-keyword">let</span> a = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'jack\'</span>,\n  <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>{\n    <span class="hljs-keyword">return</span> msg + <span class="hljs-keyword">this</span>.name;\n  } \n}\n<span class="hljs-keyword">let</span> b = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'lily\'</span>\n}\n<span class="hljs-built_in">console</span>.log(a.getName(<span class="hljs-string">\'hello~\'</span>));  <span class="hljs-comment">// hello~jack</span>\n<span class="hljs-built_in">console</span>.log(a.getName.call(b, <span class="hljs-string">\'hi~\'</span>));  <span class="hljs-comment">// hi~lily</span>\n<span class="hljs-built_in">console</span>.log(a.getName.apply(b, [<span class="hljs-string">\'hi~\'</span>]))  <span class="hljs-comment">// hi~lily</span>\n<span class="hljs-keyword">let</span> name = a.getName.bind(b, <span class="hljs-string">\'hello~\'</span>);\n<span class="hljs-built_in">console</span>.log(name());  <span class="hljs-comment">// hello~lily</span>\n</code></pre>\n<p data-nodeid="4989">从上面的代码执行的结果中可以发现，使用这三种方式都可以达成我们想要的目标，即通过改变 this 的指向，让 b 对象可以直接使用 a 对象中的 getName 方法。从结果中可以看到，最后三个方法输出的都是和 lily 相关的打印结果，满足了我们的预期。</p>\n<p data-nodeid="4990">关于这三个方法的原理相关先介绍到这里，我们再看看这几个方法的使用场景。</p>\n<h3 data-nodeid="4991">方法的应用场景</h3>\n<p data-nodeid="4992">下面几种应用场景，你多加体会就可以发现它们的理念都是“借用”方法的思路。我们来看看都有哪些。</p>\n<h4 data-nodeid="4993">判断数据类型</h4>\n<p data-nodeid="4994">用 Object.prototype.toString 来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据，我在 <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6174" data-nodeid="5092">01 讲数据类型的判断</a>中有介绍过，我将当时总结的用来判断数据类型的那部分代码粘贴在下面了，你可以回忆一下。</p>\n<pre class="lang-javascript" data-nodeid="4995"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">obj</span>)</span>{\n  <span class="hljs-keyword">let</span> type  = <span class="hljs-keyword">typeof</span> obj;\n  <span class="hljs-keyword">if</span> (type !== <span class="hljs-string">"object"</span>) {\n    <span class="hljs-keyword">return</span> type;\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj).replace(<span class="hljs-regexp">/^$/</span>, <span class="hljs-string">\'$1\'</span>);\n}\n</code></pre>\n<p data-nodeid="4996">结合上面这段代码，以及在前面讲的 call 的方法的 “借用” 思路，那么判断数据类型就是借用了 Object 的原型链上的 toString 方法，最后返回用来判断传入的 obj 的字符串，来确定最后的数据类型，这里就不再多做讲解了。</p>\n<h4 data-nodeid="4997">类数组借用方法</h4>\n<p data-nodeid="4998">类数组相关知识我会在第二个模块“深入数组”中详细介绍，这里先简单说一下，类数组因为不是真正的数组，所有没有数组类型上自带的种种方法，所以我们就可以利用一些方法去借用数组的方法，比如借用数组的 push 方法，看下面的一段代码。</p>\n<pre class="lang-javascript" data-nodeid="4999"><code data-language="javascript"><span class="hljs-keyword">var</span> arrayLike = { \n  <span class="hljs-number">0</span>: <span class="hljs-string">\'java\'</span>,\n  <span class="hljs-number">1</span>: <span class="hljs-string">\'script\'</span>,\n  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>\n} \n<span class="hljs-built_in">Array</span>.prototype.push.call(arrayLike, <span class="hljs-string">\'jack\'</span>, <span class="hljs-string">\'lily\'</span>); \n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> arrayLike); <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-built_in">console</span>.log(arrayLike);\n<span class="hljs-comment">// {0: "java", 1: "script", 2: "jack", 3: "lily", length: 4}</span>\n</code></pre>\n<p data-nodeid="5000">从上面的代码可以看到，arrayLike 是一个对象，模拟数组的一个类数组。从数据类型上看，它是一个对象。从上面的代码中可以看出，用 typeof 来判断输出的是 \'object\'，它自身是不会有数组的 push 方法的，这里我们就用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 arrayLike 添加新的元素。</p>\n<p data-nodeid="5001">从上面的控制台可以看出，push 满足了我们想要实现添加元素的诉求。</p>\n<h4 data-nodeid="5002">获取数组的最大 / 最小值</h4>\n<p data-nodeid="5003">我们可以用 apply 来实现数组中判断最大 / 最小值，apply 直接传递数组作为调用方法的参数，也可以减少一步展开数组，可以直接使用 Math.max、Math.min 来获取数组的最大值 / 最小值，请看下面这段代码。</p>\n<pre class="lang-javascript" data-nodeid="5004"><code data-language="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">13</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">16</span>];\n<span class="hljs-keyword">const</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, arr); \n<span class="hljs-keyword">const</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, arr);\n \n<span class="hljs-built_in">console</span>.log(max);  <span class="hljs-comment">// 16</span>\n<span class="hljs-built_in">console</span>.log(min);  <span class="hljs-comment">// 6</span>\n</code></pre>\n<h4 data-nodeid="5005">继承</h4>\n<p data-nodeid="5006">我们在上一讲中说到了继承，它与 new、call 共同实现了各种各样的继承方式。那么下面我们结合着这一讲的内容再来回顾一下组合继承方式，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="5007"><code data-language="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent3</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'parent3\'</span>;\n    <span class="hljs-keyword">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n  }\n\n  Parent3.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child3</span>(<span class="hljs-params"></span>) </span>{\n    Parent3.call(<span class="hljs-keyword">this</span>);\n    <span class="hljs-keyword">this</span>.type = <span class="hljs-string">\'child3\'</span>;\n  }\n\n  Child3.prototype = <span class="hljs-keyword">new</span> Parent3();\n  Child3.prototype.constructor = Child3;\n  <span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> Child3();\n  <span class="hljs-built_in">console</span>.log(s3.getName());  <span class="hljs-comment">// \'parent3\'</span>\n</code></pre>\n<p data-nodeid="5008">关于继承的内容在这里就不过多讲解了，另外这些方法类似的应用场景还有很多，关键在于它们借用方法的理念，如果对这部分内容不理解的话，你可以再多看几遍。</p>\n<h3 data-nodeid="5009">如何自己实现这些方法</h3>\n<p data-nodeid="5010">在互联网大厂的面试中，手写实现 new、call、apply、bind 一直是比较高频的题目，结合本讲的内容，我们一起来手工实现一下这几个方法。</p>\n<h4 data-nodeid="5011">new 的实现</h4>\n<p data-nodeid="5012">我们刚才在讲 new 的原理时，介绍了执行 new 的过程。那么来看下在这过程中，new 被调用后大致做了哪几件事情。</p>\n<ol data-nodeid="5013">\n<li data-nodeid="5014">\n<p data-nodeid="5015">让实例可以访问到私有属性；</p>\n</li>\n<li data-nodeid="5016">\n<p data-nodeid="5017">让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</p>\n</li>\n<li data-nodeid="5018">\n<p data-nodeid="5019">构造函数返回的最后结果是引用数据类型。</p>\n</li>\n</ol>\n<p data-nodeid="5020">那么请你思考一下，自己实现 new 的代码应该如何写呢？下面我给你一个思路。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="5140"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_new</span>(<span class="hljs-params">ctor, ...args</span>) </span>{\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ctor !== <span class="hljs-string">\'function\'</span>) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-string">\'ctor must be a function\'</span>;\n    }\n    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();\n    obj.__proto__ = <span class="hljs-built_in">Object</span>.create(ctor.prototype);\n    <span class="hljs-keyword">let</span> res = ctor.apply(obj,  [...args]);\n\n    <span class="hljs-keyword">let</span> isObject = <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">\'object\'</span> &amp;&amp; res !== <span class="hljs-literal">null</span>;\n    <span class="hljs-keyword">let</span> isFunction = <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">\'function\'</span>;\n    <span class="hljs-keyword">return</span> isObject || isFunction ? res : obj;\n};\n</code></pre>\n\n<p data-nodeid="5022">接下来我们再看看 apply 和 call 的实现方法。</p>\n<h4 data-nodeid="5023">apply 和 call 的实现</h4>\n<p data-nodeid="5024">由于 apply 和 call 基本原理是差不多的，只是参数存在区别，因此我们将这两个的实现方法放在一起讲。</p>\n<p data-nodeid="5025">依然是结合方法“借用”的原理，我们一起来思考一下这两个方法如何实现，请看下面实现的代码。</p>\n<pre class="lang-javascript" data-nodeid="5026"><code data-language="javascript"><span class="hljs-built_in">Function</span>.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>{\n  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span>;\n  context.fn = <span class="hljs-keyword">this</span>;\n  <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">\'context.fn(...args)\'</span>);\n  <span class="hljs-keyword">delete</span> context.fn\n  <span class="hljs-keyword">return</span> result;\n}\n<span class="hljs-built_in">Function</span>.prototype.apply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) </span>{\n  <span class="hljs-keyword">let</span> context = context || <span class="hljs-built_in">window</span>;\n  context.fn = <span class="hljs-keyword">this</span>;\n  <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">\'context.fn(...args)\'</span>);\n  <span class="hljs-keyword">delete</span> context.fn\n  <span class="hljs-keyword">return</span> result;\n}\n</code></pre>\n<p data-nodeid="5027">从上面的代码可以看出，实现 call 和 apply 的关键就在 eval 这行代码。其中显示了用 context 这个临时变量来指定上下文，然后还是通过执行 eval 来执行 context.fn 这个函数，最后返回 result。</p>\n<p data-nodeid="5028">要注意这两个方法和 bind 的区别就在于，这两个方法是直接返回执行结果，而 bind 方法是返回一个函数，因此这里直接用 eval 执行得到结果。</p>\n<p data-nodeid="5029">如果让你去执行，这个区别一定要多加注意。紧接着我们就来看下 bind 的实现。</p>\n<h4 data-nodeid="5030">bind 的实现</h4>\n<p data-nodeid="5031">结合上面两个方法的实现，bind 的实现思路基本和 apply 一样，但是在最后实现返回结果这里，bind 和 apply 有着比较大的差异，bind 不需要直接执行，因此不再需要用 eval ，而是需要通过返回一个函数的方式将结果返回，之后再通过执行这个结果，得到想要的执行效果。</p>\n<p data-nodeid="5032">那么，结合这个思路，我们看下 bind 这个方法的底层逻辑实现的代码是什么样的，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="5033"><code data-language="javascript"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>{\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"this must be a function"</span>);\n    }\n    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;\n    <span class="hljs-keyword">var</span> fbound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> self ? <span class="hljs-keyword">this</span> : context, args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)));\n    }\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.prototype) {\n      fbound.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.prototype);\n    }\n    <span class="hljs-keyword">return</span> fbound;\n}\n</code></pre>\n<p data-nodeid="5034">从上面的代码中可以看到，实现 bind 的核心在于返回的时候需要返回一个函数，故这里的 fbound 需要返回，但是在返回的过程中原型链对象上的属性不能丢失。因此这里需要用Object.create 方法，将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。这样调用 bind 方法接收到函数的对象，再通过执行接收的函数，即可得到想要的结果。</p>\n<p data-nodeid="5035">那么讲到这里，你是不是已经清楚了 new、apply、call、bind 这些方法是如何实现的呢？如果还是一知半解，我建议你多动手实践几次。</p>\n<h3 data-nodeid="5036">总结</h3>\n<p data-nodeid="5037">这一讲的内容就介绍完了。我们通过原理以及对底层逻辑的剖析，介绍了日常开发中经常用的 new、apply、call、bind 这几种方法，最后带你一起动手进行了实践。</p>\n<p data-nodeid="5038">综上，我们可以看到这几个方法是有区别和联系的，通过下面的表格我们再来梳理一下这些方法的异同点，希望你可以更好地理解。</p>\n<p data-nodeid="5039"><img src="https://s0.lgstatic.com/i/image/M00/8E/04/Ciqc1GABa-2AO2DlAAD5wuBLNn8120.png" alt="图片5.png" data-nodeid="5133"></p>\n<p data-nodeid="5040">在日常的前端开发工作中，大家往往会忽视对这些方法的系统性学习，其实这些方法在高级 JavaScript 编程中经常出现，尤其是你去看一些比较好的开源项目，经常会通过“借用”的方式去复用已有的方法，来节约内存、优化代码。</p>\n<p data-nodeid="5041">而且这些方法的底层逻辑的实现，在互联网大厂的前端面试中出现的频率也比较高，每个实现的方法细节也比较零散，很多开发者很难有一个系统的、整体的学习，造成了在面试过程中遇到此类手写底层 API 等问题时，容易临场发怵。</p>\n<p data-nodeid="5042">因此我希望通过这一讲的学习，你能很好地掌握这部分内容，以便在面试中遇到这类题目的时候能够轻松应对。</p>\n<p data-nodeid="5043">在后续的课时中，我将继续带领你深入挖掘闭包的原理和底层知识。同时希望你多动手练习以熟练上面的代码，也欢迎你在下方留言讨论自己在学习过程中遇到的困惑，以及学习感悟等，让我们共同进步。</p>\n<p data-nodeid="5044" class="">我们下一课时再见~</p>',
          },
          {
            theme: '05 | 函数那些事：JS 闭包难点剖析',
            id: 16,
            content:
              '<p data-nodeid="18315" class="">我们上一讲介绍了 call、apply、bind 等方法的实现，而在这一讲中我将会带你一起剖析闭包这个难点。</p>\n<p data-nodeid="18316">JavaScript 中的闭包是相当重要的概念，并且与作用域相关知识的指向密切相关，在大厂的前端面试过程中经常会被提及。因此希望通过这一讲的学习，你能够彻底掌握它。</p>\n<p data-nodeid="18317">按照惯例，在课程开始前请你先思考几个问题。</p>\n<ol data-nodeid="18318">\n<li data-nodeid="18319">\n<p data-nodeid="18320">JavaScript 中的作用域是什么意思?</p>\n</li>\n<li data-nodeid="18321">\n<p data-nodeid="18322">闭包会在哪些场景中使用？</p>\n</li>\n<li data-nodeid="18323">\n<p data-nodeid="18324">通过定时器循环输出自增的数字通过 JS 的代码如何实现？</p>\n</li>\n</ol>\n<p data-nodeid="18325">在讲闭包之前，我要带你看一下作用域相关的知识点，以便你更好地理解本讲内容。</p>\n<h3 data-nodeid="18326">作用域基本介绍</h3>\n<p data-nodeid="18327">JavaScript 的作用域通俗来讲，就是指变量能够被访问到的范围，在 JavaScript 中作用域也分为好几种，ES5 之前只有全局作用域和函数作用域两种。ES6 出现之后，又新增了块级作用域，下面我们就来看下这三种作用域的概念，为闭包的学习打好基础。</p>\n<h4 data-nodeid="18328">全局作用域</h4>\n<p data-nodeid="18329">在编程语言中，不论 Java 也好，JavaScript 也罢，变量一般都会分为全局变量和局部变量两种。那么变量定义在函数外部，代码最前面的一般情况下都是全局变量。</p>\n<p data-nodeid="18330">在 JavaScript 中，全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量。下面通过看一段代码来说明一下什么是全局的作用域。</p>\n<pre class="lang-javascript" data-nodeid="18331"><code data-language="javascript"><span class="hljs-keyword">var</span> globalName = <span class="hljs-string">\'global\'</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{ \n  <span class="hljs-built_in">console</span>.log(globalName) <span class="hljs-comment">// global</span>\n  <span class="hljs-keyword">var</span> name = <span class="hljs-string">\'inner\'</span>\n  <span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// inner</span>\n} \ngetName();\n<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// </span>\n<span class="hljs-built_in">console</span>.log(globalName); <span class="hljs-comment">//global</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params"></span>)</span>{ \n  vName = <span class="hljs-string">\'setName\'</span>;\n}\nsetName();\n<span class="hljs-built_in">console</span>.log(vName); <span class="hljs-comment">// setName</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.vName) <span class="hljs-comment">// setName</span>\n</code></pre>\n<p data-nodeid="18332">从这段代码中我们可以看到，globalName 这个变量无论在什么地方都是可以被访问到的，所以它就是全局变量。而在 getName 函数中作为局部变量的 name 变量是不具备这种能力的。</p>\n<p data-nodeid="18333">如果在 JavaScript 中所有没有经过定义，而直接被赋值的变量默认就是一个全局变量，比如上面代码中 setName 函数里面的 vName 变量一样。</p>\n<p data-nodeid="18334">我们可以发现全局变量也是拥有全局的作用域，无论你在何处都可以使用它，在浏览器控制台输入 window.vName 的时候，就可以访问到 window 上所有全局变量。</p>\n<p data-nodeid="18335">当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域的问题。</p>\n<h4 data-nodeid="18336">函数作用域</h4>\n<p data-nodeid="18337">在 JavaScript 中，函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域，下面我们来看一段代码。</p>\n<pre class="lang-javascript" data-nodeid="18338"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> name = <span class="hljs-string">\'inner\'</span>;\n  <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">//inner</span>\n}\ngetName();\n<span class="hljs-built_in">console</span>.log(name);\n</code></pre>\n<p data-nodeid="18339">上面代码中，name 这个变量是在 getName 函数中进行定义的，所以 name 是一个局部的变量，它的作用域就是在 getName 这个函数里边，也称作函数作用域。</p>\n<p data-nodeid="18340">除了这个函数内部，其他地方都是不能访问到它的。同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以你会看到在 getName 函数外面的 name 是访问不到的。</p>\n<p data-nodeid="18341">下面再来看最后一个块级作用域。</p>\n<h4 data-nodeid="18342">块级作用域</h4>\n<p data-nodeid="18343">ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。</p>\n<p data-nodeid="18344">听起来好像还不是很能理解块级作用域的意思，那么我们来举个更形象例子，看看到底哪些才是块级作用域呢？其实就是在 JS 编码过程中 if 语句及 for 语句后面 {...} 这里面所包括的，就是块级作用域。</p>\n<p data-nodeid="18345">下面结合一段代码来说明。</p>\n<pre class="lang-javascript" data-nodeid="18346"><code data-language="javascript"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//a is not defined</span>\n<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){\n  <span class="hljs-keyword">let</span> a = <span class="hljs-string">\'123\'</span>；\n  <span class="hljs-built_in">console</span>.log(a)； <span class="hljs-comment">// 123</span>\n}\n<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//a is not defined</span>\n</code></pre>\n<p data-nodeid="18347">从这段代码可以看出，变量 a 是在 if 语句{...} 中由 let&nbsp;关键词进行定义的变量，所以它的作用域是 if 语句括号中的那部分，而在外面进行访问 a 变量是会报错的，因为这里不是它的作用域。所以在 if 代码块的前后输出 a 这个变量的结果，控制台会显示 a 并没有定义。</p>\n<p data-nodeid="18348">那么有了上面这几种作用域的概念做铺垫之后，下面我们就可以来学习闭包的概念。</p>\n<h3 data-nodeid="18349">什么是闭包？</h3>\n<p data-nodeid="18350">先来看下红宝书上和 MDN 上给出的闭包的概念。</p>\n<blockquote data-nodeid="18351">\n<p data-nodeid="18352">红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。<br>\nMDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p>\n</blockquote>\n<p data-nodeid="18353">乍一看上面的两个比较官方的定义，很难让人理解清晰，尤其是 MDN 的关于闭包的定义，真的比较让人“头晕”，那么现在就和你说说我是怎么理解的。</p>\n<h4 data-nodeid="18354">闭包的基本概念</h4>\n<p data-nodeid="18355">我在这里先通俗地讲解一下：闭包其实就是一个可以访问其他函数内部变量的<strong data-nodeid="18451">函数</strong>。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。</p>\n<p data-nodeid="18356">因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。下面我们通过代码先来看一个简单的例子。</p>\n<pre class="lang-javascript" data-nodeid="18357"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n\t\t<span class="hljs-built_in">console</span>.log(a);\n\t};\n}\nfun1();\n<span class="hljs-keyword">var</span> result = fun1();\nresult();  <span class="hljs-comment">// 1</span>\n</code></pre>\n<p data-nodeid="18358">结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值。</p>\n<p data-nodeid="18359">现在结合着上面那段闭包的概念，你是否能很清晰地了解闭包的作用了呢？不清楚的话，可以再多体会一下这段代码。</p>\n<h4 data-nodeid="18360">闭包产生的原因</h4>\n<p data-nodeid="18361">我们在前面介绍了作用域的概念，那么你还需要明白作用域链的基本概念。其实很简单，当访问一个变量时，代码解释器会首先在当前的作用域查找，如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，这样的链路就是作用域链。</p>\n<p data-nodeid="18362">需要注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。那么我们还是通过下面的代码来详细说明一下作用域链。</p>\n<pre class="lang-javascript" data-nodeid="18363"><code data-language="javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;\n    <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//3</span>\n  }\n}\n</code></pre>\n<p data-nodeid="18364">从中可以看出，fun1 函数的作用域指向全局作用域（window）和它自己本身；fun2 函数的作用域指向全局作用域 （window）、fun1 和它本身；而作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。</p>\n<p data-nodeid="18365">那么这就很形象地说明了什么是作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。</p>\n<p data-nodeid="18366">由此可见，闭包产生的本质就是：<strong data-nodeid="18465">当前环境中存在指向父级作用域的引用</strong>。那么还是拿上的代码举例。</p>\n<pre class="lang-javascript" data-nodeid="18367"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//2</span>\n  }\n  <span class="hljs-keyword">return</span> fun2;\n}\n<span class="hljs-keyword">var</span> result = fun1();\nresult();\n</code></pre>\n<p data-nodeid="18368"><img src="https://s0.lgstatic.com/i/image2/M01/06/F3/Cip5yGAGp-qABNSNAAUwQ25mVao838.png" alt="刘烨的js.png" data-nodeid="18468"></p>\n<p data-nodeid="18369">从上面这段代码可以看出，这里 result 会拿到父级作用域中的变量，输出 2。因为在当前环境中，含有对 fun2 函数的引用，fun2 函数恰恰引用了 window、fun1 和 fun2 的作用域。因此 fun2 函数是可以访问到 fun1 函数的作用域的变量。</p>\n<p data-nodeid="18370">那是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，<strong data-nodeid="18475">我们只需要让父级作用域的引用存在即可</strong>，因此还可以这么改代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="18371"><code data-language="javascript"><span class="hljs-keyword">var</span> fun3;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>\n  fun3 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(a);\n  }\n}\nfun1();\nfun3();\n</code></pre>\n<p data-nodeid="18372">可以看出，其中实现的结果和前一段代码的效果其实是一样的，就是在给 fun3 函数赋值后，fun3 函数就拥有了 window、fun1 和 fun3 本身这几个作用域的访问权限；然后还是从下往上查找，直到找到 fun1 的作用域中存在 a 这个变量；因此输出的结果还是 2，最后产生了闭包，形式变了，本质没有改变。</p>\n<p data-nodeid="18373">因此最后返回的不管是不是函数，也都不能说明没有产生闭包。讲到这里你这里可以再深入体会一下闭包的内涵。</p>\n<h4 data-nodeid="18374">闭包的表现形式</h4>\n<p data-nodeid="18375">那么明白了闭包的本质之后，我们来看看闭包的表现形式及应用场景到底有哪些呢？我总结了大概有四种场景。</p>\n<p data-nodeid="18376"><strong data-nodeid="18484">1</strong>. 返回一个函数，上面讲原因的时候已经说过，这里就不赘述了。</p>\n<p data-nodeid="18377"><strong data-nodeid="18489">2</strong>. 在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。请看下面这段代码，这些都是平常开发中用到的形式。</p>\n<pre class="lang-javascript" data-nodeid="18378"><code data-language="javascript"><span class="hljs-comment">// 定时器</span>\nsetTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1\'</span>);\n}，<span class="hljs-number">1000</span>);\n<span class="hljs-comment">// 事件监听</span>\n$(<span class="hljs-string">\'#app\'</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Event Listener\'</span>);\n});\n</code></pre>\n<p data-nodeid="18379"><strong data-nodeid="18494">3</strong>. 作为函数参数传递的形式，比如下面的例子。</p>\n<pre class="lang-javascript" data-nodeid="18380"><code data-language="javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(a);\n  }\n  bar(baz);\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">fn</span>)</span>{\n  <span class="hljs-comment">// 这就是闭包</span>\n  fn();\n}\nfoo();  <span class="hljs-comment">// 输出2，而不是1</span>\n</code></pre>\n<p data-nodeid="18381"><strong data-nodeid="18499">4</strong>. IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="18382"><code data-language="javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;\n(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IIFE</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">// 输出2</span>\n})();\n</code></pre>\n<p data-nodeid="18383">IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</p>\n<p data-nodeid="18384">以上关于闭包的基本概念、产生的原因及表现形式这三个方面，你已经有了一定的了解。那么最后一部分我们来看一个比较常见的开发应用场景。</p>\n<h3 data-nodeid="18385">如何解决循环输出问题？</h3>\n<p data-nodeid="18386">在互联网大厂的面试中，解决循环输出问题是比较高频的面试题，一般都会给一段这样的代码让你来解释，那么结合本课时所讲的内容，我们在这里一起看看这个题目，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="18387"><code data-language="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i ++){\n  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(i)\n  }, <span class="hljs-number">0</span>)\n}\n</code></pre>\n<p data-nodeid="18388">上面这段代码执行之后，从控制台执行的结果可以看出来，结果输出的是 5 个 6，那么一般面试官都会先问为什么都是 6？我想让你实现输出 1、2、3、4、5 的话怎么办呢？</p>\n<p data-nodeid="18389">因此结合本讲所学的知识我们来思考一下，应该怎么给面试官一个满意的解释。你可以围绕这两点来回答。</p>\n<ol data-nodeid="18390">\n<li data-nodeid="18391">\n<p data-nodeid="18392">setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。</p>\n</li>\n<li data-nodeid="18393">\n<p data-nodeid="18394">因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</p>\n</li>\n</ol>\n<p data-nodeid="18395">那么我们再来看看如何按顺序依次输出 1、2、3、4、5 呢？</p>\n<h4 data-nodeid="18396">利用 IIFE</h4>\n<p data-nodeid="18397">可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。</p>\n<pre class="lang-javascript" data-nodeid="18398"><code data-language="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">5</span>;i++){\n  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)</span>{\n    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>)</span>{\n      <span class="hljs-built_in">console</span>.log(j)\n    }, <span class="hljs-number">0</span>)\n  })(i)\n}\n</code></pre>\n<p data-nodeid="18399">可以看到，通过这样改造使用 IIFE（立即执行函数），可以实现序号的依次输出。</p>\n<h4 data-nodeid="18400">使用 ES6 中的 let</h4>\n<p data-nodeid="18401">ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。通过改造后的代码，可以实现上面想要的结果。</p>\n<pre class="lang-javascript" data-nodeid="18402"><code data-language="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++){\n  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(i);\n  },<span class="hljs-number">0</span>)\n}\n</code></pre>\n<p data-nodeid="18403">从上面的代码可以看出，通过 let 定义变量的方式，重新定义 i 变量，则可以用最少的改动成本，解决该问题。</p>\n<h4 data-nodeid="18404">定时器传入第三个参数</h4>\n<p data-nodeid="18405">setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，而第三个参数用得比较少。那么结合第三个参数，调整完之后的代码如下。</p>\n<pre class="lang-javascript" data-nodeid="18406"><code data-language="javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++){\n  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) </span>{\n    <span class="hljs-built_in">console</span>.log(j)\n  }, <span class="hljs-number">0</span>, i)\n}\n</code></pre>\n<p data-nodeid="18407">从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径。</p>\n<h3 data-nodeid="18408">总结</h3>\n<p data-nodeid="18409">到这里，本讲的内容就差不多结束了。这一讲我通过原理结合实践的方式，将闭包相关的知识点串起来剖析了一遍。你可以看到，其实闭包的知识整体上来说还是比较复杂的，它依赖一些相关的上游知识点。</p>\n<p data-nodeid="18410">另外，在日常的前端开发工作中，开发者往往会忽视对这部分知识的系统性学习，其实闭包的使用在日常的 JavaScript 编程中经常出现，使用的场景特别多而且复杂。由于闭包会使一些变量一直保存在内存中不会自动释放，所以如果大量使用的话就会消耗大量内存，从而影响网页性能。因此，你更应该深入理解闭包的原理，从而保证交付的代码性能更好。</p>\n<p data-nodeid="18411" class="te-preview-highlight">下一讲，我将带领你实现一个 JSON.stringify。同时希望你多动手练习，也欢迎你在下方留言，说说自己的学习感悟，加油！</p>',
          },
          {
            theme: '06 | 进阶练习：带你一起实现 JSON.Stringify 方法',
            id: 17,
            content:
              '<p data-nodeid="5493" class="">我在上一讲为你剖析了闭包这个难点，带你了解了作用域、闭包产生的原因及表现形式。那么这一讲，我们一起来手工实现一个 JSON.stringify 的方法。</p>\n<p data-nodeid="5494">这个方法能够站在全局考察你对 JS 各种数据类型理解的深度，对各种极端的边界情况处理能力，以及 JS 的编码能力。之所以将这篇作为这一模块的进阶，是因为我想把整个数据类型的知识点串起来，让你理解得更加融会贯通，能够更上一层楼。</p>\n<p data-nodeid="5626" class="te-preview-highlight">在大厂的前端面试过程中，这个题目也经常会被问到。大部分候选人只知道这个方法的作用，而如果让他自己实现一个 JSON.Srtingify 方法的话，大多数人都不一定能写出来，或者即便能写出来一些，但是考虑的问题又不够全面。</p>\n\n<p data-nodeid="5496">因此你要想夯实自身 JavaScript 的编程基础，通过实践来实现一些 JS API 方法，是非常有必要的，所以这一讲我就来帮你搞懂它。</p>\n<p data-nodeid="5497">那么，到底什么是 JSON.stringify 方法？</p>\n<h3 data-nodeid="5498">方法基本介绍</h3>\n<p data-nodeid="5499">JSON.stringify 是日常开发中经常用到的 JSON 对象中的一个方法，JSON 对象包含两个方法：一是用于解析成 JSON 对象的 parse()；二是用于将对象转换为 JSON 字符串方法的 stringify()。下面我们分别来看下两个方法的基本使用情况。</p>\n<h4 data-nodeid="5500">JSON.parse</h4>\n<p data-nodeid="5501">JSON.parse 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。该方法有两个参数：第一个参数是需要解析处理的 JSON 字符串，第二个参数是可选参数提供可选的&nbsp;reviver&nbsp;函数，用在返回之前对所得到的对象执行变换操作。</p>\n<blockquote data-nodeid="5502">\n<p data-nodeid="5503">该方法的语法为：JSON.parse(text[, reviver])</p>\n</blockquote>\n<p data-nodeid="5504">下面通过一段代码来看看这个方法以及 reviver 参数的用法，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="5505"><code data-language="javascript"><span class="hljs-keyword">const</span> json = <span class="hljs-string">\'{"result":true, "count":2}\'</span>;\n<span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">JSON</span>.parse(json);\n<span class="hljs-built_in">console</span>.log(obj.count);\n<span class="hljs-comment">// 2</span>\n<span class="hljs-built_in">console</span>.log(obj.result);\n<span class="hljs-comment">// true</span>\n<span class="hljs-comment">/* 带第二个参数的情况 */</span>\n<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">\'{"p": 5}\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, v</span>) </span>{\n    <span class="hljs-keyword">if</span>(k === <span class="hljs-string">\'\'</span>) <span class="hljs-keyword">return</span> v;     <span class="hljs-comment">// 如果k不是空，</span>\n    <span class="hljs-keyword">return</span> v * <span class="hljs-number">2</span>;              <span class="hljs-comment">// 就将属性值变为原来的2倍返回</span>\n});                            <span class="hljs-comment">// { p: 10 }</span>\n</code></pre>\n<p data-nodeid="5506">上面的代码说明了，我们可以将一个符合 JSON 格式的字符串转化成对象返回；带第二个参数的情况，可以将待处理的字符串进行一定的操作处理，比如上面这个例子就是将属性值乘以 2 进行返回。</p>\n<p data-nodeid="5507">下面我们来了解一下 JSON.stringify 的基本情况。</p>\n<h4 data-nodeid="5508">JSON.stringify</h4>\n<p data-nodeid="5509">JSON.stringify 方法是将一个 JavaScript&nbsp;对象或值转换为 JSON 字符串，默认该方法其实有三个参数：第一个参数是必选，后面两个是可选参数非必选。第一个参数传入的是要转换的对象；第二个是一个 replacer 函数，比如指定的&nbsp;replacer 是数组，则可选择性地仅处理包含数组指定的属性；第三个参数用来控制结果字符串里面的间距，后面两个参数整体用得比较少。</p>\n<blockquote data-nodeid="5510">\n<p data-nodeid="5511">该方法的语法为：JSON.stringify(value[, replacer [, space]])</p>\n</blockquote>\n<p data-nodeid="5512">下面我们通过一段代码来看看后面几个参数的妙用，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="5513"><code data-language="javascript"><span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> });\n<span class="hljs-comment">// "{"x":1,"y":2}"</span>\n<span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">x</span>: [<span class="hljs-number">10</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}, <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">\'\'</span>)] })\n<span class="hljs-comment">// "{"x":[10,null,null,null]}"</span>\n<span class="hljs-comment">/* 第二个参数的例子 */</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;\n  }\n  <span class="hljs-keyword">return</span> value;\n}\n<span class="hljs-keyword">var</span> foo = {<span class="hljs-attr">foundation</span>: <span class="hljs-string">"Mozilla"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"box"</span>, <span class="hljs-attr">week</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">transport</span>: <span class="hljs-string">"car"</span>, <span class="hljs-attr">month</span>: <span class="hljs-number">7</span>};\n<span class="hljs-keyword">var</span> jsonString = <span class="hljs-built_in">JSON</span>.stringify(foo, replacer);\n<span class="hljs-built_in">console</span>.log(jsonString);\n<span class="hljs-comment">// "{"week":4,"month":7}"</span>\n<span class="hljs-comment">/* 第三个参数的例子 */</span>\n<span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> }, <span class="hljs-literal">null</span>, <span class="hljs-string">" "</span>);\n<span class="hljs-comment">/* "{\n&nbsp;"a": 2\n}"*/</span>\n<span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> }, <span class="hljs-literal">null</span>, <span class="hljs-string">""</span>);\n<span class="hljs-comment">// "{"a":2}"</span>\n</code></pre>\n<p data-nodeid="5514">从上面的代码中可以看到，增加第二个参数 replacer 带来的变化：通过替换方法把对象中的属性为字符串的过滤掉，在 stringify 之后返回的仅为数字的属性变成字符串之后的结果；当第三个参数传入的是多个空格的时候，则会增加结果字符串里面的间距数量，从最后一段代码中可以看到结果。</p>\n<p data-nodeid="5515">下面我们再看下 JSON.stringify 的内部针对各种数据类型的转换方式。</p>\n<h3 data-nodeid="5516">如何自己手动实现？</h3>\n<p data-nodeid="5517">为了让你更好地理解实现的过程，请你回想一下“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601&amp;sid=20-h5Url-0#/detail/pc?id=6174" data-nodeid="5588">01 | 代码基本功测试（上）：JS 的数据类型你了解多少</a>”中的基本知识，我们当时讲了那么多种数据类型，如果它们都使用这个方法，返回的结果又会是怎么样的呢？</p>\n<h4 data-nodeid="5518">分析各种数据类型及边界情况</h4>\n<p data-nodeid="5519">我们来分析一下都有哪些数据类型传入，传入了之后会有什么返回，通过分析的结果我们之后才能更好地实现编码。大致的分析汇总如下表所示（可参考 MDN 文档）。</p>\n<p data-nodeid="5520"><img src="https://s0.lgstatic.com/i/image/M00/90/40/Ciqc1GAKhuuASWc7AAHWTgdfPTc220.png" alt="Lark20210122-160329.png" data-nodeid="5594"></p>\n<p data-nodeid="5521">上面这个表中，基本整理出了各种数据类型通过 JSON.stringify 这个方法之后返回对应的值，但是还有一个特殊情况需要注意：对于包含循环引用的对象（深拷贝那讲中也有提到）执行此方法，会抛出错误。</p>\n<p data-nodeid="5522">那么根据上面梳理的这个表格，我们来一起看下代码怎么编写吧。</p>\n<h4 data-nodeid="5523">代码逻辑实现</h4>\n<p data-nodeid="5524">我们先利用 typeof 把基础数据类型和引用数据类型分开，分开之后再根据不同情况来分别处理不同的情况，按照这个逻辑代码实现如下。</p>\n<pre class="lang-javascript" data-nodeid="5525"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonStringify</span>(<span class="hljs-params">data</span>) </span>{\n  <span class="hljs-keyword">let</span> type = <span class="hljs-keyword">typeof</span> data;\n\n  <span class="hljs-keyword">if</span>(type !== <span class="hljs-string">\'object\'</span>) {\n    <span class="hljs-keyword">let</span> result = data;\n    <span class="hljs-comment">//data 可能是基础数据类型的情况在这里处理</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isNaN(data) || data === <span class="hljs-literal">Infinity</span>) {\n       <span class="hljs-comment">//NaN 和 Infinity 序列化返回 "null"</span>\n       result = <span class="hljs-string">"null"</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">\'function\'</span> || type === <span class="hljs-string">\'undefined\'</span> || type === <span class="hljs-string">\'symbol\'</span>) {\n      <span class="hljs-comment">// 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理</span>\n       <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">\'string\'</span>) {\n       result = <span class="hljs-string">\'"\'</span> + data + <span class="hljs-string">\'"\'</span>;\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(result);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">\'object\'</span>) {\n     <span class="hljs-keyword">if</span> (data === <span class="hljs-literal">null</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">"null"</span>  <span class="hljs-comment">// 第01讲有讲过 typeof null 为\'object\'的特殊情况</span>\n     } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.toJSON &amp;&amp; <span class="hljs-keyword">typeof</span> data.toJSON === <span class="hljs-string">\'function\'</span>) {\n        <span class="hljs-keyword">return</span> jsonStringify(data.toJSON());\n     } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {\n        <span class="hljs-keyword">let</span> result = [];\n        <span class="hljs-comment">//如果是数组，那么数组里面的每一项类型又有可能是多样的</span>\n        data.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">\'undefined\'</span> || <span class="hljs-keyword">typeof</span> item === <span class="hljs-string">\'function\'</span> || <span class="hljs-keyword">typeof</span> item === <span class="hljs-string">\'symbol\'</span>) {\n               result[index] = <span class="hljs-string">"null"</span>;\n           } <span class="hljs-keyword">else</span> {\n               result[index] = jsonStringify(item);\n           }\n         });\n         result = <span class="hljs-string">"["</span> + result + <span class="hljs-string">"]"</span>;\n         <span class="hljs-keyword">return</span> result.replace(<span class="hljs-regexp">/\'/g</span>, <span class="hljs-string">\'"\'</span>);\n      } <span class="hljs-keyword">else</span> {\n         <span class="hljs-comment">// 处理普通对象</span>\n         <span class="hljs-keyword">let</span> result = [];\n         <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item !== <span class="hljs-string">\'symbol\'</span>) {\n              <span class="hljs-comment">//key 如果是 symbol 对象，忽略</span>\n              <span class="hljs-keyword">if</span> (data[item] !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> data[item] !== <span class="hljs-string">\'function\'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> data[item] !== <span class="hljs-string">\'symbol\'</span>) {\n                <span class="hljs-comment">//键值如果是 undefined、function、symbol 为属性值，忽略</span>\n                result.push(<span class="hljs-string">\'"\'</span> + item + <span class="hljs-string">\'"\'</span> + <span class="hljs-string">":"</span> + jsonStringify(data[item]));\n              }\n            }\n         });\n         <span class="hljs-keyword">return</span> (<span class="hljs-string">"{"</span> + result + <span class="hljs-string">"}"</span>).replace(<span class="hljs-regexp">/\'/g</span>, <span class="hljs-string">\'"\'</span>);\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="5526">手工实现一个 JSON.stringify 方法的基本代码如上面所示，有几个问题你还是需要注意一下：</p>\n<ol data-nodeid="5527">\n<li data-nodeid="5528">\n<p data-nodeid="5529">由于 function 返回 \'null\'， 并且 typeof function 能直接返回精确的判断，故在整体逻辑处理基础数据类型的时候，会随着 undefined，symbol 直接处理了；</p>\n</li>\n<li data-nodeid="5530">\n<p data-nodeid="5531">由于 01 讲说过 typeof null 的时候返回\'object\'，故 null 的判断逻辑整体在处理引用数据类型的逻辑里面；</p>\n</li>\n<li data-nodeid="5532">\n<p data-nodeid="5533">关于引用数据类型中的数组，由于数组的每一项的数据类型又有很多的可能性，故在处理数组过程中又将 undefined，symbol，function 作为数组其中一项的情况做了特殊处理；</p>\n</li>\n<li data-nodeid="5534">\n<p data-nodeid="5535">同样在最后处理普通对象的时候，key （键值）也存在和数组一样的问题，故又需要再针对上面这几种情况（undefined，symbol，function）做特殊处理；</p>\n</li>\n<li data-nodeid="5536">\n<p data-nodeid="5537">最后在处理普通对象过程中，对于循环引用的问题暂未做检测，如果是有循环引用的情况，需要抛出 Error；</p>\n</li>\n<li data-nodeid="5538">\n<p data-nodeid="5539">根据官方给出的 JSON.stringify 的第二个以及第三个参数的实现，本段模拟实现的代码并未实现，如果有兴趣你可以自己尝试一下。</p>\n</li>\n</ol>\n<p data-nodeid="5540">整体来说这段代码还是比较复杂的，如果在面试过程中让你当场手写，其实整体还是需要考虑很多东西的。当然上面的代码根据每个人的思路不同，你也可以写出自己认为更优的代码，比如你也可以尝试直接使用 switch 语句，来分别针对特殊情况进行处理，整体写出来可能看起来会比上面的写法更清晰一些，这些可以根据自己情况而定。</p>\n<h4 data-nodeid="5541">实现效果测试</h4>\n<p data-nodeid="5542">上面的这个方法已经实现了，那么用起来会不会有问题呢？我们就用上面的代码，来进行一些用例的检测吧。</p>\n<p data-nodeid="5543">上面自己实现的这个 jsonStringify 方法和真正的 JSON.stringify 想要得到的效果是否一样呢？请看下面的测试结果。</p>\n<pre class="lang-javascript" data-nodeid="5544"><code data-language="javascript"><span class="hljs-keyword">let</span> nl = <span class="hljs-literal">null</span>;\n<span class="hljs-built_in">console</span>.log(jsonStringify(nl) === <span class="hljs-built_in">JSON</span>.stringify(nl));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> und = <span class="hljs-literal">undefined</span>;\n<span class="hljs-built_in">console</span>.log(jsonStringify(<span class="hljs-literal">undefined</span>) === <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">undefined</span>));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> boo = <span class="hljs-literal">false</span>;\n<span class="hljs-built_in">console</span>.log(jsonStringify(boo) === <span class="hljs-built_in">JSON</span>.stringify(boo));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> nan = <span class="hljs-literal">NaN</span>;\n<span class="hljs-built_in">console</span>.log(jsonStringify(nan) === <span class="hljs-built_in">JSON</span>.stringify(nan));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> inf = <span class="hljs-literal">Infinity</span>;\n<span class="hljs-built_in">console</span>.log(jsonStringify(<span class="hljs-literal">Infinity</span>) === <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">Infinity</span>));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> str = <span class="hljs-string">"jack"</span>;\n<span class="hljs-built_in">console</span>.log(jsonStringify(str) === <span class="hljs-built_in">JSON</span>.stringify(str));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"\\w"</span>);\n<span class="hljs-built_in">console</span>.log(jsonStringify(reg) === <span class="hljs-built_in">JSON</span>.stringify(reg));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();\n<span class="hljs-built_in">console</span>.log(jsonStringify(date) === <span class="hljs-built_in">JSON</span>.stringify(date));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> sym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-number">1</span>);\n<span class="hljs-built_in">console</span>.log(jsonStringify(sym) === <span class="hljs-built_in">JSON</span>.stringify(sym));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];\n<span class="hljs-built_in">console</span>.log(jsonStringify(array) === <span class="hljs-built_in">JSON</span>.stringify(array));\n<span class="hljs-comment">// true</span>\n<span class="hljs-keyword">let</span> obj = {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">\'jack\'</span>,\n    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,\n    <span class="hljs-attr">attr</span>: [<span class="hljs-string">\'coding\'</span>, <span class="hljs-number">123</span>],\n    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),\n    <span class="hljs-attr">uni</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-number">2</span>),\n    <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hi"</span>)\n    },\n    <span class="hljs-attr">info</span>: {\n        <span class="hljs-attr">sister</span>: <span class="hljs-string">\'lily\'</span>,\n        <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>,\n        <span class="hljs-attr">intro</span>: {\n            <span class="hljs-attr">money</span>: <span class="hljs-literal">undefined</span>,\n            <span class="hljs-attr">job</span>: <span class="hljs-literal">null</span>\n        }\n    }\n}\n<span class="hljs-built_in">console</span>.log(jsonStringify(obj) === <span class="hljs-built_in">JSON</span>.stringify(obj));\n<span class="hljs-comment">// true</span>\n</code></pre>\n<p data-nodeid="5545">通过上面这些测试的例子可以发现，我们自己实现的 jsonStringify 方法基本和 JSON.stringify 转换之后的结果是一样的，不难看出 jsonStringify 基本满足了预期结果。</p>\n<p data-nodeid="5546">本讲的内容也就先介绍到这里。</p>\n<h3 data-nodeid="5547">总结</h3>\n<p data-nodeid="5548">这一讲，我利用原理结合实践的方式，带你实现了一个 JSON.stringify 的方法。从中你可以看到，要想自己实现一个 JSON.stringify 方法整体上来说并不容易，它依赖很多数据类型相关的知识点，而且还需要考虑各种边界情况。</p>\n<p data-nodeid="5549">希望你多加实践，如果在面试中也让你当场实现一个 JSON.stringify 方法，你才能够轻松应对。</p>\n<p data-nodeid="5550">另外，如果把本讲中的题目作为面试题的话，其实是对你的 JS 编码能力的一个很全面的考察，因此对于数据类型的相关知识还是很有必要系统性地学习，尤其是对于 JSON 的这两个方法，不常用的那几个参数你是否有了解？还有引用数据类型中对数组以及普通对象的处理，这部分手写起来会比基础数据类型复杂一些，在一些细节处理上会遇到问题。因此，你要好好理解。</p>\n<p data-nodeid="5551" class="">那么讲到这里，第一个模块的内容就介绍完毕了，涉及数据类型相关的知识就暂时告一段落了，马上我们进入全新的第二个模块深入数组的学习。在后续的课时中，我将带领你深入学习 JS 的数组相关知识。我们下一讲再见~</p>',
          },
        ],
      },
      {
        sectionName: '模块二：深入数组篇',
        sectionId: 3,
        courseList: [
          {
            theme: '07 | 数组原理（上）：帮你梳理眼花缭乱的数组 API',
            id: 18,
            content:
              '<p data-nodeid="2084" class="">欢迎来到第二个模块“深入数组篇”的学习。</p>\n<p data-nodeid="2085">JavaScript 数组的 API 经常会被 JS 开发者频繁使用，在整个 JavaScript 的学习过程中尤为重要。</p>\n<p data-nodeid="2086">数组作为一个最基础的一维数据结构，在各种编程语言中都充当着至关重要的角色，你很难想象没有数组的编程语言会是什么模样。特别是 JavaScript，它天生的灵活性，又进一步发挥了数组的特长，丰富了数组的使用场景。<strong data-nodeid="2221">可以毫不夸张地说，不深入地了解数组，就不足以写好 JavaScript。</strong></p>\n<p data-nodeid="2087">随着前端框架的不断演进，React 和 Vue 等 MVVM 框架的流行，数据更新的同时视图也会随之更新。在通过前端框架实现大量的业务代码中，开发者都会用数组来进行数据的存储和各种“增删改查”等操作，从而实现对应前端视图层的更新。可见熟练掌握数组各种方法，并深入了解数组是很有必要的。</p>\n<p data-nodeid="2088">因此，我希望这一模块，能让你对数组有更深一步的理解，更加得心应手地运用数组的各种 API，并可以轻松实现面试中遇到的数组题目。</p>\n<p data-nodeid="2089">据不完全统计，在 LeetCode 题库的 1800 多道题目中，和数组相关的题目是最多的，有 300 多道，例如“合并两个有序数组”“两个数组的交集”等。其中有个别题目是大厂的面试题目，如果你有兴趣可以自己尝试去解答，我也会在课程中穿插讲解其中的一些数组类题目，帮助你更好地理解这部分知识。</p>\n<p data-nodeid="2090">那么，在课程开始前请你先思考几个问题。</p>\n<ol data-nodeid="2091">\n<li data-nodeid="2092">\n<p data-nodeid="2093">数组的构造器有哪几种？</p>\n</li>\n<li data-nodeid="2094">\n<p data-nodeid="2095">哪些是改变自身的方法？</p>\n</li>\n<li data-nodeid="2096">\n<p data-nodeid="2097">哪些是不改变自身的方法？</p>\n</li>\n<li data-nodeid="2098">\n<p data-nodeid="2099">遍历的方法有哪些？</p>\n</li>\n</ol>\n<p data-nodeid="2100">不知道这几个问题你是否能够准确地回答出来？那么我们就带着以上几个思考，开始这一讲的学习。</p>\n<h3 data-nodeid="2101">数组概念的探究</h3>\n<p data-nodeid="2102">截至 ES7 规范，数组共包含 33 个标准的 API 方法和一个非标准的 API 方法，使用场景和使用方案纷繁复杂，其中还有不少坑。为了方便你可以循序渐进地学习这部分的内容，下面我将从数组的概念开始讲起。</p>\n<p data-nodeid="2103">由于数组的 API 较多，很多相近的名字也容易导致混淆，所以在这里我按照“会改变自身值的”“不会改变自身值的”“遍历方法”这三种类型分开讲解，让你对这些 API 形成更结构化的认识。</p>\n<h4 data-nodeid="2104">Array 的构造器</h4>\n<p data-nodeid="2105">Array 构造器用于创建一个新的数组。通常，我们推荐使用对象字面量的方式创建一个数组，例如 var a = [] 就是一个比较好的写法。但是，总有对象字面量表述乏力的时候，比如，我想创建一个长度为 6 的空数组，用对象字面量的方式是无法创建的，因此只能写成下述代码这样。</p>\n<pre class="lang-javascript" data-nodeid="2403"><code data-language="javascript"><span class="hljs-comment">// 使用 Array 构造器，可以自定义长度</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Array</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// [empty × 6]</span>\n<span class="hljs-comment">// 使用对象字面量</span>\n<span class="hljs-keyword">var</span> b = [];\nb.length = <span class="hljs-number">6</span>; <span class="hljs-comment">// [undefined × 6]</span>\n</code></pre>\n\n<p data-nodeid="2107" class="te-preview-highlight">Array 构造器根据参数长度的不同，有如下两种不同的处理方式：</p>\n<ul data-nodeid="2108">\n<li data-nodeid="2109">\n<p data-nodeid="2110"><strong data-nodeid="2244">new Array(arg1, arg2,…)</strong>，参数长度为 0 或长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；</p>\n</li>\n<li data-nodeid="2111">\n<p data-nodeid="2112"><strong data-nodeid="2249">new Array(len)</strong>，当 len 不是数值时，处理同上，返回一个只包含 len 元素一项的数组；当 len 为数值时，len 最大不能超过 32 位无符号整型，即需要小于 2 的 32 次方（len 最大为 Math.pow(2,32)），否则将抛出 RangeError。</p>\n</li>\n</ul>\n<p data-nodeid="2113">以上就是 Array 构造器的基本情况，我们来看下 ES6 新增的几个构造方法。</p>\n<h4 data-nodeid="2114">ES6 新增的构造方法：Array.of 和 Array.from</h4>\n<p data-nodeid="2115">鉴于数组的常用性，ES6 专门扩展了数组构造器 Array&nbsp;，新增了 2 个方法：Array.of、Array.from。其中，Array.of 整体用得比较少；而 Array.from 具有灵活性，你在平常开发中应该会经常使用。那么关于两者的使用细节你真的了解吗？下面展开来聊下这两个方法。</p>\n<p data-nodeid="2116"><strong data-nodeid="2256">Array.of</strong></p>\n<p data-nodeid="2117">Array.of 用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其他。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。</p>\n<p data-nodeid="2118">比如，在下面的这几行代码中，你可以看到区别：当参数为两个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组。</p>\n<pre data-nodeid="2119"><code>Array.of(8.0); // [8]\nArray(8.0); // [empty × 8]\nArray.of(8.0, 5); // [8, 5]\nArray(8.0, 5); // [8, 5]\nArray.of(\'8\'); // ["8"]\nArray(\'8\'); // ["8"]\n</code></pre>\n<p data-nodeid="2120"><strong data-nodeid="2262">Array.from</strong></p>\n<p data-nodeid="2121">Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实就是，只要一个对象有迭代器，Array.from 就能把它变成一个数组（注意：是返回新的数组，不改变原对象）。</p>\n<p data-nodeid="2122">从语法上看，Array.from 拥有 3 个参数：</p>\n<ol data-nodeid="2123">\n<li data-nodeid="2124">\n<p data-nodeid="2125">类似数组的对象，必选；</p>\n</li>\n<li data-nodeid="2126">\n<p data-nodeid="2127">加工函数，新生成的数组会经过该函数的加工再返回；</p>\n</li>\n<li data-nodeid="2128">\n<p data-nodeid="2129">this 作用域，表示加工函数执行时 this 的值。</p>\n</li>\n</ol>\n<p data-nodeid="2130">这三个参数里面第一个参数是必选的，后两个参数都是可选的。我们通过一段代码来看看它的用法。</p>\n<pre class="lang-javascript" data-nodeid="2131"><code data-language="javascript"><span class="hljs-keyword">var</span> obj = {<span class="hljs-number">0</span>: <span class="hljs-string">\'a\'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">\'b\'</span>, <span class="hljs-number">2</span>:<span class="hljs-string">\'c\'</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>};\n<span class="hljs-built_in">Array</span>.from(obj, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(value, index, <span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>.length);\n  <span class="hljs-keyword">return</span> value.repeat(<span class="hljs-number">3</span>);   <span class="hljs-comment">//必须指定返回值，否则返回 undefined</span>\n}, obj);\n</code></pre>\n<p data-nodeid="2132">结果如下图所示。<br>\n<img src="https://s0.lgstatic.com/i/image2/M01/09/B2/CgpVE2APjSiAGLqXAAB5v09b2C4966.png" alt="WechatIMG13.png" data-nodeid="2273"></p>\n<p data-nodeid="2133">结果中可以看出 console.log(value, index, this, arguments.length) 对应的四个值，并且看到 return 的 value 重复了三遍，最后返回的数组为 ["aaa","bbb","ccc"]。</p>\n<p data-nodeid="2134">这表明了通过 Array.from 这个方法可以自己定义加工函数的处理方式，从而返回想要得到的值；如果不确定返回值，则会返回 undefined，最终生成的也是一个包含若干个 undefined 元素的空数组。</p>\n<p data-nodeid="2135">实际上，如果这里不指定 this 的话，加工函数完全可以是一个箭头函数。上述代码可以简写为如下形式。</p>\n<pre class="lang-javascript" data-nodeid="2136"><code data-language="javascript"><span class="hljs-built_in">Array</span>.from(obj, (value) =&gt; value.repeat(<span class="hljs-number">3</span>));\n<span class="hljs-comment">// &nbsp;控制台返回 (3) ["aaa", "bbb", "ccc"]</span>\n</code></pre>\n<p data-nodeid="2137">除了上述 obj 对象以外，拥有迭代器的对象还包括 String、Set、Map&nbsp;等，Array.from 统统可以处理，请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="2138"><code data-language="javascript"><span class="hljs-comment">// String</span>\n<span class="hljs-built_in">Array</span>.from(<span class="hljs-string">\'abc\'</span>);         <span class="hljs-comment">// ["a", "b", "c"]</span>\n<span class="hljs-comment">// Set</span>\n<span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">\'abc\'</span>, <span class="hljs-string">\'def\'</span>])); <span class="hljs-comment">// ["abc", "def"]</span>\n<span class="hljs-comment">// Map</span>\n<span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">\'ab\'</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">\'de\'</span>]])); \n<span class="hljs-comment">// [[1, \'ab\'], [2, \'de\']]</span>\n</code></pre>\n<p data-nodeid="2139">关于数组构造器 Array&nbsp;新增的两个方法就讲解到这，下面接着介绍如何进行 Array 的判断。</p>\n<h4 data-nodeid="2140">Array 的判断</h4>\n<p data-nodeid="2141">Array.isArray 用来判断一个变量是否为数组类型，我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6174" data-nodeid="2299">01 | 代码基本功测试（上）：JS 的数据类型你了解多少</a>”中也讲过如何判断数据类型，不过那时只是针对 JS 的所有数据类型做一个判断，数组的判断当时并未详细讲解，那么我们现在来学习一下。</p>\n<p data-nodeid="2142">在 ES5 提供该方法之前，我们至少有如下 5 种方式去判断一个变量是否为数组。</p>\n<pre class="lang-javascript" data-nodeid="2143"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [];\n<span class="hljs-comment">// 1.基于instanceof</span>\na <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>;\n<span class="hljs-comment">// 2.基于constructor</span>\na.constructor === <span class="hljs-built_in">Array</span>;\n<span class="hljs-comment">// 3.基于Object.prototype.isPrototypeOf</span>\n<span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(a);\n<span class="hljs-comment">// 4.基于getPrototypeOf</span>\n<span class="hljs-built_in">Object</span>.getPrototypeOf(a) === <span class="hljs-built_in">Array</span>.prototype;\n<span class="hljs-comment">// 5.基于Object.prototype.toString</span>\n<span class="hljs-built_in">Object</span>.prototype.toString.apply(a) === <span class="hljs-string">\'[object Array]\'</span>;\n</code></pre>\n<p data-nodeid="2144">上面这 5 个判断全部为 True，这里应该没什么疑问。实际上，通过 Object.prototype.toString 去判断一个值的类型，也是模块一的 01 讲判断数据类型中我给你推荐的方法。</p>\n<p data-nodeid="2145">ES6 之后新增了一个 Array.isArray 方法，能直接判断数据类型是否为数组，但是如果 isArray 不存在，那么 Array.isArray 的 polyfill 通常可以这样写：</p>\n<pre class="lang-javascript" data-nodeid="2146"><code data-language="javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray){\n  <span class="hljs-built_in">Array</span>.isArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>)</span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(arg) === <span class="hljs-string">\'[object Array]\'</span>;\n  };\n}\n</code></pre>\n<p data-nodeid="2147">数组的基本概念到这里基本讲得差不多了，下面我们就来看看让人眼花缭乱的 30 多个数组的基本方法。</p>\n<h3 data-nodeid="2148">改变自身的方法</h3>\n<p data-nodeid="2149">基于 ES6，会改变自身值的方法一共有 9 个，分别为 pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。</p>\n<p data-nodeid="2150">接下来我们看一段代码，快速了解这些方法最基本的用法。</p>\n<pre class="lang-javascript" data-nodeid="2151"><code data-language="javascript"><span class="hljs-comment">// pop方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"cat"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"cow"</span>, <span class="hljs-string">"chicken"</span>, <span class="hljs-string">"mouse"</span>];\n<span class="hljs-keyword">var</span> item = array.pop();\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// ["cat", "dog", "cow", "chicken"]</span>\n<span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// mouse</span>\n<span class="hljs-comment">// push方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"football"</span>, <span class="hljs-string">"basketball"</span>,  <span class="hljs-string">"badminton"</span>];\n<span class="hljs-keyword">var</span> i = array.push(<span class="hljs-string">"golfball"</span>);\n<span class="hljs-built_in">console</span>.log(array); \n<span class="hljs-comment">// ["football", "basketball", "badminton", "golfball"]</span>\n<span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 4</span>\n<span class="hljs-comment">// reverse方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];\n<span class="hljs-keyword">var</span> array2 = array.reverse();\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// [5,4,3,2,1]</span>\n<span class="hljs-built_in">console</span>.log(array2===array); <span class="hljs-comment">// true</span>\n<span class="hljs-comment">// shift方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];\n<span class="hljs-keyword">var</span> item = array.shift();\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// [2,3,4,5]</span>\n<span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// 1</span>\n<span class="hljs-comment">// unshift方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"blue"</span>];\n<span class="hljs-keyword">var</span> length = array.unshift(<span class="hljs-string">"yellow"</span>);\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// ["yellow", "red", "green", "blue"]</span>\n<span class="hljs-built_in">console</span>.log(length); <span class="hljs-comment">// 4</span>\n<span class="hljs-comment">// sort方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"apple"</span>,<span class="hljs-string">"Boy"</span>,<span class="hljs-string">"Cat"</span>,<span class="hljs-string">"dog"</span>];\n<span class="hljs-keyword">var</span> array2 = array.sort();\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// ["Boy", "Cat", "apple", "dog"]</span>\n<span class="hljs-built_in">console</span>.log(array2 == array); <span class="hljs-comment">// true</span>\n<span class="hljs-comment">// splice方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"apple"</span>,<span class="hljs-string">"boy"</span>];\n<span class="hljs-keyword">var</span> splices = array.splice(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// ["apple"]</span>\n<span class="hljs-built_in">console</span>.log(splices); <span class="hljs-comment">// ["boy"]</span>\n<span class="hljs-comment">// copyWithin方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; \n<span class="hljs-keyword">var</span> array2 = array.copyWithin(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);\n<span class="hljs-built_in">console</span>.log(array===array2,array2);  <span class="hljs-comment">// true [4, 5, 3, 4, 5]</span>\n<span class="hljs-comment">// fill方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];\n<span class="hljs-keyword">var</span> array2 = array.fill(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);\n<span class="hljs-built_in">console</span>.log(array===array2,array2); \n<span class="hljs-comment">// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span>\n</code></pre>\n<p data-nodeid="2152">我希望你能通过上面的代码，对这些方法形成一个直观的印象，并且能自己进行一定的实践来加深印象。不过上面的 sort() 方法的内涵比较多，在第 11 讲我会专门讲解，这里先不做过多的介绍了。</p>\n<p data-nodeid="2153">下面为了让你对这些 API 方法有更深刻的印象，我结合 Leetcode 中的第 88 题 《合并两个有序数组》，带你看下如何利用数组的多个改变自身的方法来解决这道题，题目是这样的：</p>\n<pre class="lang-java" data-nodeid="2154"><code data-language="java">给你两个有序整数数组&nbsp;nums1&nbsp;和&nbsp;nums2，请你将&nbsp;nums2&nbsp;合并到&nbsp;nums1&nbsp;中，使&nbsp;nums1&nbsp;成为一个有序数组。\n输入:\nnums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]； m = <span class="hljs-number">3</span>\nnums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]；&nbsp; &nbsp; &nbsp; &nbsp;n = <span class="hljs-number">3</span>\n输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]\n</code></pre>\n<p data-nodeid="2155">你可以仔细看下题目要求：</p>\n<ul data-nodeid="2156">\n<li data-nodeid="2157">\n<p data-nodeid="2158">首先是将 nums2 合并到 nums1 里面，不新开数组，否则将无法通过；</p>\n</li>\n<li data-nodeid="2159">\n<p data-nodeid="2160">其次是合并完了之后 nums1 还是一个有序数组，这里也是需要注意的；</p>\n</li>\n<li data-nodeid="2161">\n<p data-nodeid="2162">另外样例里面 nums1 和 nums2 都有“2”这个数，也都需要将重复的合并进去。</p>\n</li>\n</ul>\n<p data-nodeid="2163">我们看上面这三点，可以思考下，既然要求不能新开数组，那么就需要利用数组改变自身的方法完成这个题目，应该怎么做呢？你可以试着先将想法写下来，之后再来看我提供的答案。</p>\n<p data-nodeid="2164">答案就是巧妙地利用数组的 API 中的 splice、push、sort 这三个方法，在原数组上进行操作，最终完成如下代码：</p>\n<pre class="lang-javascript" data-nodeid="2165"><code data-language="javascript"><span class="hljs-keyword">var</span>&nbsp;merge&nbsp;=&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums1,&nbsp;m,&nbsp;nums2,&nbsp;n</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;nums1.splice(m);\n&nbsp;&nbsp;&nbsp;&nbsp;nums2.splice(n);\n&nbsp;&nbsp;&nbsp;&nbsp;nums1.push(...nums2);\n&nbsp;&nbsp;&nbsp;&nbsp;nums1.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)&nbsp;=&gt;</span>&nbsp;a - b);  <span class="hljs-comment">// nums1从小到大排列，所以是a-b</span>\n};\n</code></pre>\n<p data-nodeid="2166">我上面提供的这段代码是可以在 LeetCode 88 题提交 AC 通过的，没写出来的话你可以试着再敲一遍，最后提交完成通过。</p>\n<p data-nodeid="2167">改变数组自身的 9 个方法理解起来并不复杂，只要你对上面这些代码理解了，并且多加实践就够了，因此就讲解到这里。下面我们再来看看那些不改变自身的方法都是怎么使用的。</p>\n<h3 data-nodeid="2168">不改变自身的方法</h3>\n<p data-nodeid="2169">基于 ES7，不会改变自身的方法也有 9 个，分别为 concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未形成标准的 toSource，以及 ES7 新增的方法 includes。</p>\n<p data-nodeid="2170">我们还是通过代码，快速了解这些方法的最基本用法。</p>\n<pre class="lang-javascript" data-nodeid="2171"><code data-language="javascript"><span class="hljs-comment">// concat方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-keyword">var</span> array2 = array.concat(<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]);\n<span class="hljs-built_in">console</span>.log(array2); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// [1, 2, 3], 可见原数组并未被修改</span>\n<span class="hljs-comment">// join方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">\'We\'</span>, <span class="hljs-string">\'are\'</span>, <span class="hljs-string">\'Chinese\'</span>];\n<span class="hljs-built_in">console</span>.log(array.join()); <span class="hljs-comment">// "We,are,Chinese"</span>\n<span class="hljs-built_in">console</span>.log(array.join(<span class="hljs-string">\'+\'</span>)); <span class="hljs-comment">// "We+are+Chinese"</span>\n<span class="hljs-comment">// slice方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>,<span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>];\n<span class="hljs-built_in">console</span>.log(array.slice()); <span class="hljs-comment">// ["one", "two", "three","four", "five"]</span>\n<span class="hljs-built_in">console</span>.log(array.slice(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// ["three"]</span>\n<span class="hljs-comment">// toString方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">\'Jan\'</span>, <span class="hljs-string">\'Feb\'</span>, <span class="hljs-string">\'Mar\'</span>, <span class="hljs-string">\'Apr\'</span>];\n<span class="hljs-keyword">var</span> str = array.toString();\n<span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">// Jan,Feb,Mar,Apr</span>\n<span class="hljs-comment">// tolocalString方法</span>\n<span class="hljs-keyword">var</span> array= [{<span class="hljs-attr">name</span>:<span class="hljs-string">\'zz\'</span>}, <span class="hljs-number">123</span>, <span class="hljs-string">"abc"</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()];\n<span class="hljs-keyword">var</span> str = array.toLocaleString();\n<span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">// [object Object],123,abc,2016/1/5 下午1:06:23</span>\n<span class="hljs-comment">// indexOf方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">\'abc\'</span>, <span class="hljs-string">\'def\'</span>, <span class="hljs-string">\'ghi\'</span>,<span class="hljs-string">\'123\'</span>];\n<span class="hljs-built_in">console</span>.log(array.indexOf(<span class="hljs-string">\'def\'</span>)); <span class="hljs-comment">// 1</span>\n<span class="hljs-comment">// includes方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">-0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];\n<span class="hljs-built_in">console</span>.log(array.includes(+<span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span>\n<span class="hljs-built_in">console</span>.log(array.includes(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-literal">NaN</span>];\n<span class="hljs-built_in">console</span>.log(array.includes(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span>\n</code></pre>\n<p data-nodeid="2172">上面我把不会改变数组的几个方法大致做了一个回顾，其中 includes 方法需要注意的是，如果元素中有 0，那么在判断过程中不论是 +0 还是 -0 都会判断为 True，这里的 includes 忽略了 +0 和 -0。</p>\n<p data-nodeid="2173">另外还有一个值得强调的是<strong data-nodeid="2344">slice 不改变自身，而 splice 会改变自身</strong>，你还是需要注意不要记错了。其中，slice 的语法是：arr.slice([start[, end]])，而 splice 的语法是：arr.splice(start,deleteCount[, item1[, item2[, …]]])。我们可以看到从第二个参数开始，二者就已经有区别了，splice 第二个参数是删除的个数，而 slice 的第二个参数是 end 的坐标（可选）。</p>\n<p data-nodeid="2174">此外，lastIndexOf 和 indexOf 基本功能差不多，不过 lastIndexOf 是从后面寻找元素的下标；而 toSource 方法还未形成标准，因此在这里不做过多介绍了。</p>\n<p data-nodeid="2175">不改变数组自身的 9 个方法到这里也基本回顾差不多了，下面我们接着看看数组遍历的方法都是怎么用的。</p>\n<h3 data-nodeid="2176">数组遍历的方法</h3>\n<p data-nodeid="2177">基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为 forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findIndex、keys、values。</p>\n<p data-nodeid="2178">我们还是先看一段代码，快速了解它们的基本用法。</p>\n<pre class="lang-javascript" data-nodeid="2179"><code data-language="javascript"><span class="hljs-comment">// forEach方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];\n<span class="hljs-keyword">var</span> obj = {<span class="hljs-attr">name</span>:<span class="hljs-string">\'cc\'</span>};\n<span class="hljs-keyword">var</span> sReturn = array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array</span>)</span>{\n  array[index] = value;\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name); <span class="hljs-comment">// cc被打印了三次, this指向obj</span>\n},obj);\n<span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">// [1, 3, 5]</span>\n<span class="hljs-built_in">console</span>.log(sReturn); <span class="hljs-comment">// undefined, 可见返回值为undefined</span>\n<span class="hljs-comment">// every方法</span>\n<span class="hljs-keyword">var</span> o = {<span class="hljs-number">0</span>:<span class="hljs-number">10</span>, <span class="hljs-number">1</span>:<span class="hljs-number">8</span>, <span class="hljs-number">2</span>:<span class="hljs-number">25</span>, <span class="hljs-attr">length</span>:<span class="hljs-number">3</span>};\n<span class="hljs-keyword">var</span> bool = <span class="hljs-built_in">Array</span>.prototype.every.call(o,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, obj</span>)</span>{\n  <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">8</span>;\n},o);\n<span class="hljs-built_in">console</span>.log(bool); <span class="hljs-comment">// true</span>\n<span class="hljs-comment">// some方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">35</span>, <span class="hljs-number">80</span>];\n<span class="hljs-keyword">var</span> isExist = array.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array</span>)</span>{\n&nbsp; <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">20</span>;\n});\n<span class="hljs-built_in">console</span>.log(isExist); <span class="hljs-comment">// true </span>\n<span class="hljs-comment">// map 方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">35</span>, <span class="hljs-number">80</span>];\narray.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item + <span class="hljs-number">1</span>);\n<span class="hljs-built_in">console</span>.log(array);  <span class="hljs-comment">// [19, 10, 11, 36, 81]</span>\n<span class="hljs-comment">// filter 方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">35</span>, <span class="hljs-number">80</span>];\n<span class="hljs-keyword">var</span> array2 = array.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array</span>)</span>{\n  <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">20</span>;\n});\n<span class="hljs-built_in">console</span>.log(array2); <span class="hljs-comment">// [35, 80]</span>\n<span class="hljs-comment">// reduce方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];\n<span class="hljs-keyword">var</span> s = array.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">previousValue, value, index, array</span>)</span>{\n  <span class="hljs-keyword">return</span> previousValue * value;\n},<span class="hljs-number">1</span>);\n<span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">// 24</span>\n<span class="hljs-comment">// ES6写法更加简洁</span>\narray.reduce(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> p * v); <span class="hljs-comment">// 24</span>\n<span class="hljs-comment">// reduceRight方法 (和reduce的区别就是从后往前累计)</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];\narray.reduceRight(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> p * v); <span class="hljs-comment">// 24</span>\n<span class="hljs-comment">// entries方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>];\n<span class="hljs-keyword">var</span> iterator = array.entries();\n<span class="hljs-built_in">console</span>.log(iterator.next().value); <span class="hljs-comment">// [0, "a"]</span>\n<span class="hljs-built_in">console</span>.log(iterator.next().value); <span class="hljs-comment">// [1, "b"]</span>\n<span class="hljs-built_in">console</span>.log(iterator.next().value); <span class="hljs-comment">// [2, "c"]</span>\n<span class="hljs-built_in">console</span>.log(iterator.next().value); <span class="hljs-comment">// undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span>\n<span class="hljs-comment">// find &amp; findIndex方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">value, index, array</span>)</span>{\n  <span class="hljs-keyword">return</span> value%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;     <span class="hljs-comment">// 返回偶数</span>\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params">value, index, array</span>)</span>{\n  <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">20</span>;     <span class="hljs-comment">// 返回大于20的数</span>\n}\n<span class="hljs-built_in">console</span>.log(array.find(f)); <span class="hljs-comment">// 8</span>\n<span class="hljs-built_in">console</span>.log(array.find(f2)); <span class="hljs-comment">// undefined</span>\n<span class="hljs-built_in">console</span>.log(array.findIndex(f)); <span class="hljs-comment">// 4</span>\n<span class="hljs-built_in">console</span>.log(array.findIndex(f2)); <span class="hljs-comment">// -1</span>\n<span class="hljs-comment">// keys方法</span>\n[...Array(<span class="hljs-number">10</span>).keys()];     <span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>\n[...new <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>).keys()]; <span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>\n<span class="hljs-comment">// values方法</span>\n<span class="hljs-keyword">var</span> array = [<span class="hljs-string">"abc"</span>, <span class="hljs-string">"xyz"</span>];\n<span class="hljs-keyword">var</span> iterator = array.values();\n<span class="hljs-built_in">console</span>.log(iterator.next().value);<span class="hljs-comment">//abc</span>\n<span class="hljs-built_in">console</span>.log(iterator.next().value);<span class="hljs-comment">//xyz</span>\n</code></pre>\n<p data-nodeid="2180">其中，要注意有些遍历方法不会返回处理之后的数组，比如 forEach；有些方法会返回处理之后的数组，比如 filter。这个细节你需要牢记，这样才会在面试过程中正确作答。</p>\n<p data-nodeid="2181">reduce 方法也需要重点关注，其参数复杂且多，通常一些复杂的逻辑处理，其实使用 reduce 很容易就可以解决。我们重点看一下，reduce 到底能解决什么问题呢？先看下 reduce 的两个参数。</p>\n<p data-nodeid="2182">首先是 callback（一个在数组的每一项中调用的函数，接受四个参数）：</p>\n<ol data-nodeid="2183">\n<li data-nodeid="2184">\n<p data-nodeid="2185">previousValue（上一次调用回调函数时的返回值，或者初始值）</p>\n</li>\n<li data-nodeid="2186">\n<p data-nodeid="2187">currentValue（当前正在处理的数组元素）</p>\n</li>\n<li data-nodeid="2188">\n<p data-nodeid="2189">currentIndex（当前正在处理的数组元素下标）</p>\n</li>\n<li data-nodeid="2190">\n<p data-nodeid="2191">array（调用 reduce() 方法的数组）</p>\n</li>\n</ol>\n<p data-nodeid="2192">然后是 initialValue（可选的初始值，作为第一次调用回调函数时传给 previousValue 的值）。</p>\n<p data-nodeid="2193">光靠文字描述其实看着会比较懵，我们还是通过一个例子来说明 reduce 的功能到底有多么强大。</p>\n<pre class="lang-javascript" data-nodeid="2194"><code data-language="javascript"><span class="hljs-comment">/* 题目：数组 arr = [1,2,3,4] 求数组的和：*/</span>\n<span class="hljs-comment">// 第一种方法：</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];\n<span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;\narr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{sum += e;}); <span class="hljs-comment">// sum = 10</span>\n<span class="hljs-comment">//&nbsp;第二种方法</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];\n<span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;\narr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)</span>{sum += obj});\n<span class="hljs-comment">//&nbsp;第三种方法</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];\narr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pre,cur</span>)</span>{<span class="hljs-keyword">return</span> pre + cur});\n</code></pre>\n<p data-nodeid="2195">从上面代码可以看出，我们分别用了 forEach 和 map 都能实现数组的求和，其中需要另外新定义一个变量 sum，再进行累加求和，最后再来看 sum 的值，而 reduce 不仅可以少定义一个变量，而且也会直接返回最后累加的结果，是不是问题就可以轻松解决了？</p>\n<p data-nodeid="2196">那么我们结合一道题目来看看 reduce 怎么用。</p>\n<p data-nodeid="2197"><strong data-nodeid="2380">题目：</strong> var arr = [ {name: \'brick1\'}, {name: \'brick2\'}, {name: \'brick3\'} ]</p>\n<p data-nodeid="2198">希望最后返回到 arr 里面每个对象的 name 拼接数据为 \'brick1, brick2 &amp; brick3\' ，如果用 reduce 如何实现呢？</p>\n<pre class="lang-javascript" data-nodeid="2199"><code data-language="javascript"><span class="hljs-keyword">var</span> arr =  [ {<span class="hljs-attr">name</span>: <span class="hljs-string">\'one\'</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">\'two\'</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">\'three\'</span>} ];\narr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, current, index, array</span>)</span>{\n  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>){\n    <span class="hljs-keyword">return</span> current.name;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === array.length - <span class="hljs-number">1</span>){\n    <span class="hljs-keyword">return</span> prev + <span class="hljs-string">\' &amp; \'</span> + current.name;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> prev + <span class="hljs-string">\', \'</span> + current.name;\n  }\n}, <span class="hljs-string">\'\'</span>);\n<span class="hljs-comment">// 返回结果 "one, two &amp; three"</span>\n</code></pre>\n<p data-nodeid="2200">从上面的答案也可以看出来，用 reduce 就能很轻松地对数组进行遍历，然后进行一些复杂的累加处理操作即可。<br>\n到这里，数组遍历的方法也基本讲解差不多了，这一讲也将告一段落。</p>\n<h3 data-nodeid="2201">总结</h3>\n<p data-nodeid="2202">下面我将令人“眼花缭乱”的数组的基础 API 简单做了个总结表格，方便你更清晰地回顾本课时所讲的内容。</p>\n<p data-nodeid="2203"><img src="https://s0.lgstatic.com/i/image2/M01/09/CC/Cip5yGAP1k2ACVqpAAE5zFVPD7o375.png" alt="Lark20210126-164334.png" data-nodeid="2395"></p>\n<p data-nodeid="2204">以上，数组的各方法基本讲解完毕，这些方法之间存在很多共性，如下：</p>\n<ul data-nodeid="2205">\n<li data-nodeid="2206">\n<p data-nodeid="2207">所有插入元素的方法，比如 push、unshift 一律返回数组新的长度；</p>\n</li>\n<li data-nodeid="2208">\n<p data-nodeid="2209">所有删除元素的方法，比如 pop、shift、splice 一律返回删除的元素，或者返回删除的多个元素组成的数组；</p>\n</li>\n<li data-nodeid="2210">\n<p data-nodeid="2211">部分遍历方法，比如 forEach、every、some、filter、map、find、findIndex，它们都包含 function(value,index,array){}&nbsp;和&nbsp;thisArg&nbsp;这样两个形参。</p>\n</li>\n</ul>\n<p data-nodeid="2212">在日常的前端开发工作中，开发者往往会忽视对数组 API 方法的系统性学习，但其实因为数组的方法较多，每个方法的参数和细节也比较零散，很多开发者很难有一个系统的、整体的认识，在开发过程中还要频繁地查询 MDN 文档，造成效率低下以及代码能力难以进一步提升等问题。</p>\n<p data-nodeid="2213">因此我希望通过这一讲的学习，你能很好地掌握数组的 API 方法，以便在开发中规避我所说的这些问题。</p>\n<p data-nodeid="2214" class="">在后续的课程中，我将继续带领你尝试一些数组 API 方法的手工实现。同时希望你多动手练习以熟练使用所学的知识点，也欢迎你在下方留言讨论自己在学习过程中遇到的困惑，以及学习感悟等，让我们共同进步。</p>',
          },
          {
            theme: '08 | 数组原理（中）：如何理解 JS 的类数组？',
            id: 19,
            content:
              '<p data-nodeid="869" class="">我在上一讲带你梳理了数组那令人眼花缭乱的各种方法，其实 JS 中一直存在一种类数组的对象，它们不能直接调用数组的方法，但是又和数组比较类似，在某些特定的编程场景中会出现，这会让很多 JS 的初学者比较困惑。那么通过本讲的学习，希望你能更好地去理解类数组原理，以及类数组的转换。</p>\n<p data-nodeid="870">我们先来看看在 JavaScript 中有哪些情况下的对象是类数组呢？主要有以下几种：</p>\n<ol data-nodeid="871">\n<li data-nodeid="872">\n<p data-nodeid="873">函数里面的参数对象 arguments；</p>\n</li>\n<li data-nodeid="874">\n<p data-nodeid="875">用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection；</p>\n</li>\n<li data-nodeid="876">\n<p data-nodeid="877">用 querySelector 获得的 NodeList。</p>\n</li>\n</ol>\n<p data-nodeid="878">上述这些基本就是你在 JavaScript 编程过程中经常会遇到的，希望通过这一讲，你能够彻底掌握它们。</p>\n<p data-nodeid="879">在课程开始前请你先思考几个问题：</p>\n<ol data-nodeid="880">\n<li data-nodeid="881">\n<p data-nodeid="882">类数组是否能使用数组的方法呢？</p>\n</li>\n<li data-nodeid="883">\n<p data-nodeid="884">类数组有哪些方式可以转换成数组？</p>\n</li>\n</ol>\n<p data-nodeid="885">如果你不能准确地回答出这两个问题，那么就要认真学习了，下面开始进入我们的课程。</p>\n<h3 data-nodeid="886">类数组基本介绍</h3>\n<h4 data-nodeid="887">arguments</h4>\n<p data-nodeid="888">先来重点讲讲 arguments 对象，我们在日常开发中经常会遇到各种类数组对象，最常见的便是在函数中使用的 arguments，它的对象只定义在函数体中，包括了函数的参数和其他属性。我们通过一段代码来看下 arguments 的使用方法，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="889"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex</span>) </span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>);\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">arguments</span>));\n}\nfoo(<span class="hljs-string">\'jack\'</span>, <span class="hljs-string">\'18\'</span>, <span class="hljs-string">\'male\'</span>);\n</code></pre>\n<p data-nodeid="890">这段代码比较容易，就是直接将这个函数的 arguments 在函数内部打印出来，那么我们看下这个 arguments 打印出来的结果，请看控制台的这张截图。</p>\n<p data-nodeid="891"><img src="https://s0.lgstatic.com/i/image/M00/92/B6/CgqCHmASb-KAQewJAACk1n_5Leg936.png" alt="Drawing 0.png" data-nodeid="987"></p>\n<p data-nodeid="892">从结果中可以看到，typeof 这个 arguments 返回的是 object，通过 Object.prototype.toString.call 返回的结果是 \'[object arguments]\'，可以看出来返回的不是 \'[object array]\'，说明 arguments 和数组还是有区别的。</p>\n<p data-nodeid="893">length 属性很好理解，它就是函数参数的长度，我们从打印出的代码也可以看得出来。另外可以看到 arguments 不仅仅有一个 length 属性，还有一个 callee 属性，我们接下来看看这个 callee 是干什么的，代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="894"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, sex</span>) </span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.callee);\n}\nfoo(<span class="hljs-string">\'jack\'</span>, <span class="hljs-string">\'18\'</span>, <span class="hljs-string">\'male\'</span>);\n</code></pre>\n<p data-nodeid="895">请看这段代码的执行结果。</p>\n<p data-nodeid="896"><img src="https://s0.lgstatic.com/i/image/M00/92/AB/Ciqc1GASb-6AIWzeAAApfkowKxg460.png" alt="Drawing 1.png" data-nodeid="1005"></p>\n<p data-nodeid="897">从控制台可以看到，输出的就是函数自身，如果在函数内部直接执行调用 callee 的话，那它就会不停地执行当前函数，直到执行到内存溢出，有兴趣的话你可以自己试一下。</p>\n<p data-nodeid="898">接下来我们再看看下面这种类数组。</p>\n<h4 data-nodeid="899">HTMLCollection</h4>\n<p data-nodeid="900">HTMLCollection 简单来说是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象，如果用 typeof 来判断的话，它返回的是 \'object\'。它是及时更新的，当文档中的 DOM 变化时，它也会随之变化。</p>\n<p data-nodeid="901">描述起来比较抽象，还是通过一段代码来看下 HTMLCollection 最后返回的是什么，我们先随便找一个页面中<strong data-nodeid="1019">有 form 表单</strong>的页面，在控制台中执行下述代码。</p>\n<pre class="lang-javascript" data-nodeid="902"><code data-language="javascript"><span class="hljs-keyword">var</span> elem1, elem2;\n<span class="hljs-comment">// document.forms 是一个 HTMLCollection</span>\nelem1 = <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>];\nelem2 = <span class="hljs-built_in">document</span>.forms.item(<span class="hljs-number">0</span>);\n<span class="hljs-built_in">console</span>.log(elem1);\n<span class="hljs-built_in">console</span>.log(elem2);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> elem1);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(elem1));\n</code></pre>\n<p data-nodeid="903">在这个有 form 表单的页面执行上面的代码，得到的结果如下。</p>\n<p data-nodeid="904"><img src="https://s0.lgstatic.com/i/image/M00/92/AB/Ciqc1GASb_aAIALvAABrmMnCsmM219.png" alt="Drawing 2.png" data-nodeid="1023"><br>\n可以看到，这里打印出来了页面第一个 form 表单元素，同时也打印出来了判断类型的结果，说明打印的判断的类型和 arguments 返回的也比较类似，typeof 返回的都是 \'object\'，和上面的类似。</p>\n<p data-nodeid="905">另外需要注意的一点就是 HTML DOM 中的&nbsp;HTMLCollection&nbsp;是即时更新的，当其所包含的文档结构发生改变时，它会自动更新。下面我们再看最后一个 NodeList 类数组。</p>\n<h4 data-nodeid="906">NodeList</h4>\n<p data-nodeid="907">NodeList&nbsp;对象是节点的集合，通常是由 querySlector 返回的。NodeList 不是一个数组，也是一种类数组。虽然 NodeList 不是一个数组，但是可以使用&nbsp;for...of&nbsp;来迭代。在一些情况下，NodeList&nbsp;是一个实时集合，也就是说，如果文档中的节点树发生变化，NodeList&nbsp;也会随之变化。我们还是利用代码来理解一下 Nodelist 这种类数组。</p>\n<pre class="lang-javascript" data-nodeid="908"><code data-language="javascript"><span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">\'input[type=checkbox]\'</span>);\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> checkbox <span class="hljs-keyword">of</span> list) {\n  checkbox.checked = <span class="hljs-literal">true</span>;\n}\n<span class="hljs-built_in">console</span>.log(list);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> list);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(list));\n</code></pre>\n<p data-nodeid="909">从上面的代码执行的结果中可以发现，我们是通过有 CheckBox 的页面执行的代码，在结果可中输出了一个 NodeList 类数组，里面有一个 CheckBox 元素，并且我们判断了它的类型，和上面的 arguments 与 HTMLCollection 其实是类似的，执行结果如下图所示。</p>\n<p data-nodeid="910"><img src="https://s0.lgstatic.com/i/image/M00/92/B6/CgqCHmAScACATLmOAABMWBjjtBc436.png" alt="Drawing 3.png" data-nodeid="1036"></p>\n<p data-nodeid="911">好了，现在你已经了解了上面这三种类数组，那么结合这些，我们再看看类数组有哪些应用的场景呢？</p>\n<h3 data-nodeid="912">类数组应用场景</h3>\n<p data-nodeid="913">我在这里为你介绍三种场景，这些也是最常见的。</p>\n<h4 data-nodeid="914">遍历参数操作</h4>\n<p data-nodeid="915">我们在函数内部可以直接获取 arguments 这个类数组的值，那么也可以对于参数进行一些操作，比如下面这段代码，我们可以将函数的参数默认进行求和操作。</p>\n<pre class="lang-javascript" data-nodeid="916"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> sum =<span class="hljs-number">0</span>,\n        len = <span class="hljs-built_in">arguments</span>.length;\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++){\n        sum += <span class="hljs-built_in">arguments</span>[i];\n    }\n    <span class="hljs-keyword">return</span> sum;\n}\nadd()                           <span class="hljs-comment">// 0</span>\nadd(<span class="hljs-number">1</span>)                          <span class="hljs-comment">// 1</span>\nadd(<span class="hljs-number">1</span>，<span class="hljs-number">2</span>)                       <span class="hljs-comment">// 3</span>\nadd(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);                   <span class="hljs-comment">// 10</span>\n</code></pre>\n<p data-nodeid="917">结合上面这段代码，我们在函数内部可以将参数直接进行累加操作，以达到预期的效果，参数多少也可以不受限制，根据长度直接计算，返回出最后函数的参数的累加结果，其他的操作也都可以仿照这样的方式来做。我们再看下一种场景。</p>\n<h4 data-nodeid="918">定义链接字符串函数</h4>\n<p data-nodeid="919">我们可以通过 arguments 这个例子定义一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下。</p>\n<pre class="lang-javascript" data-nodeid="920"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myConcat</span>(<span class="hljs-params">separa</span>) </span>{\n  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);\n  <span class="hljs-keyword">return</span> args.join(separa);\n}\nmyConcat(<span class="hljs-string">", "</span>, <span class="hljs-string">"red"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-string">"blue"</span>);\n<span class="hljs-comment">// "red, orange, blue"</span>\nmyConcat(<span class="hljs-string">"; "</span>, <span class="hljs-string">"elephant"</span>, <span class="hljs-string">"lion"</span>, <span class="hljs-string">"snake"</span>);\n<span class="hljs-comment">// "elephant; lion; snake"</span>\nmyConcat(<span class="hljs-string">". "</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>);\n<span class="hljs-comment">// "one. two. three. four. five"</span>\n</code></pre>\n<p data-nodeid="921">这段代码说明了，你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表进行拼接。从这个例子中也可以看出，我们可以在日常编码中采用这样的代码抽象方式，把需要解决的这一类问题，都抽象成通用的方法，来提升代码的可复用性。</p>\n<p data-nodeid="922">下面我们再看另外一种使用场景。</p>\n<h4 data-nodeid="923">传递参数使用</h4>\n<p data-nodeid="924">我在第 4 讲中已经介绍过了 apply 和 call 的使用访问，结合这一讲的内容，我们来研究一下，如果再结合 arguments，还能实现什么？可以借助 arguments 将参数从一个函数传递到另一个函数，请看下面这个例子。</p>\n<pre class="lang-javascript" data-nodeid="925"><code data-language="javascript"><span class="hljs-comment">// 使用 apply 将 foo 的参数传递给 bar</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n    bar.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">a, b, c</span>) </span>{\n   <span class="hljs-built_in">console</span>.log(a, b, c);\n}\nfoo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment">//1 2 3</span>\n</code></pre>\n<p data-nodeid="926">上述代码中，通过在 foo 函数内部调用 apply 方法，用 foo 函数的参数传递给 bar 函数，这样就实现了借用参数的妙用。你可以结合这个例子再思考一下，对于 foo 这样的函数可以灵活传入参数数量，通过这样的代码编写方式是不是也可以实现一些功能的拓展场景呢？</p>\n<h3 data-nodeid="927">如何将类数组转换成数组</h3>\n<p data-nodeid="928">在互联网大厂的面试中，类数组转换成数组这样的题目经常会问，也会问你 arguments 的相关问题，那么结合本讲的内容，下面我带你思考一下如何将类数组转换为数组。大致的实现方式有两种，我将依次讲解。</p>\n<h4 data-nodeid="929">类数组借用数组方法转数组</h4>\n<p data-nodeid="930">apply 和 call 方法之前我们有详细讲过，类数组因为不是真正的数组，所以没有数组类型上自带的那些方法，我们就需要利用下面这几个方法去借用数组的方法。比如借用数组的 push 方法，请看下面的一段代码。</p>\n<pre class="lang-javascript" data-nodeid="931"><code data-language="javascript"><span class="hljs-keyword">var</span> arrayLike = { \n  <span class="hljs-number">0</span>: <span class="hljs-string">\'java\'</span>,\n  <span class="hljs-number">1</span>: <span class="hljs-string">\'script\'</span>,\n  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>\n} \n<span class="hljs-built_in">Array</span>.prototype.push.call(arrayLike, <span class="hljs-string">\'jack\'</span>, <span class="hljs-string">\'lily\'</span>); \n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> arrayLike); <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-built_in">console</span>.log(arrayLike);\n<span class="hljs-comment">// {0: "java", 1: "script", 2: "jack", 3: "lily", length: 4}</span>\n</code></pre>\n<p data-nodeid="932">从中可以看到，arrayLike 其实是一个对象，模拟数组的一个类数组，从数据类型上说它是一个对象，新增了一个 length 的属性。从代码中还可以看出，用 typeof 来判断输出的是 \'object\'，它自身是不会有数组的 push 方法的，这里我们就用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 arrayLike 添加新的元素。</p>\n<p data-nodeid="933">从控制台的结果可以看出，数组的 push 方法满足了我们想要实现添加元素的诉求。我们再来看下 arguments 如何转换成数组，请看下面这段代码。</p>\n<pre class="lang-javascript" data-nodeid="934"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{\n  <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);\n <span class="hljs-comment">// let args = [].slice.call(arguments); // 这样写也是一样效果</span>\n  <span class="hljs-built_in">console</span>.log(args.reduce(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));\n}\nsum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 3</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{\n  <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.concat.apply([], <span class="hljs-built_in">arguments</span>);\n  <span class="hljs-built_in">console</span>.log(args.reduce(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));\n}\nsum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 3</span>\n</code></pre>\n<p data-nodeid="935">这段代码中可以看到，还是借用 Array 原型链上的各种方法，来实现 sum 函数的参数相加的效果。一开始都是将 arguments 通过借用数组的方法转换为真正的数组，最后都又通过数组的 reduce 方法实现了参数转化的真数组 args 的相加，最后返回预期的结果。</p>\n<h4 data-nodeid="936">ES6 的方法转数组</h4>\n<p data-nodeid="937">对于类数组转换成数组的方式，我们还可以采用 ES6 新增的 Array.from 方法以及展开运算符的方法。那么还是围绕上面这个 sum 函数来进行改变，我们看下用 Array.from 和展开运算符是怎么实现转换数组的，请看下面一段代码的例子。</p>\n<pre class="lang-javascript" data-nodeid="938"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{\n  <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>);\n  <span class="hljs-built_in">console</span>.log(args.reduce(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));\n}\nsum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 3</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{\n  <span class="hljs-keyword">let</span> args = [...arguments];\n  <span class="hljs-built_in">console</span>.log(args.reduce(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));\n}\nsum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 3</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(args.reduce(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur));\n}\nsum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 3</span>\n</code></pre>\n<p data-nodeid="939">从代码中可以看出，Array.from 和 ES6 的展开运算符，都可以把 arguments 这个类数组转换成数组 args，从而实现调用 reduce 方法对参数进行累加操作。其中第二种和第三种都是用 ES6 的展开运算符，虽然写法不一样，但是基本都可以满足多个参数实现累加的效果。</p>\n<p data-nodeid="940">讲到这里你可以再思考一下这两种类数组转换数组的方法，是不是很好理解呢？</p>\n<h3 data-nodeid="941">总结</h3>\n<p data-nodeid="942">在这一讲中，我把日常开发中有可能遇到的几种类数组分别介绍了一遍，又结合类数组相关的应用场景进行了全方位的讲解，类数组应用场景的几个例子希望能为你的 JS 编码能力的提升带来帮助和启发。最后我又讲了类数组转换成数组的两种方式。</p>\n<p data-nodeid="943">综上你可以看到，类数组这节课的知识点与第 4 讲中 apply、call 还是有紧密联系的，你可以通过下面的表格再重新梳理一下类数组和数组的异同点。</p>\n<p data-nodeid="1086" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image2/M01/0B/01/Cip5yGATsruASQJ4AACaWT-dhLQ096.png" alt="Lark20210129-150051.png" data-nodeid="1089"></p>\n\n<p data-nodeid="968">在前端工作中，开发者往往会忽视对类数组的学习，其实在高级 JavaScript 编程中经常需要将类数组向数组转化，尤其是一些比较复杂的开源项目，经常会看到函数中处理参数的写法，例如：[].slice.call(arguments) 这行代码。</p>\n<p data-nodeid="969">通过本讲的学习，希望你以后在阅读别人代码的时候，能更清楚地理解高手们处理类数组的逻辑，以便在面试或者编码中能够轻松应对。</p>\n<p data-nodeid="970" class="">下一讲，我们来聊聊数组扁平化的相关内容，欢迎提前预习，届时我们再好好讨论。</p>',
          },
          {
            theme: '09 | 数组原理（下）：实现数组扁平化的 6 种方式',
            id: 110,
            content:
              '<p data-nodeid="1912" class="">我在前两讲给你介绍了类数组的相关知识，那么这一讲会结合之前的内容，来聊聊数组相关的应用——如何实现数组扁平化。数组扁平化在一些多维数组的应用场景中会出现，我将围绕 6 种方式来带你实现它。</p>\n<p data-nodeid="1913">此外，关于数组除了扁平化也有其他问题，比如数组去重等，也是面试中经常会问到的。本讲的目的是将扁平化作为一个切入点，这种思路对于你解决其他类似的问题也是一个很好的启发。</p>\n<p data-nodeid="1914">按照惯例，在课程开始前请你先思考几个问题：</p>\n<ol data-nodeid="1915">\n<li data-nodeid="1916">\n<p data-nodeid="1917">怎样用最普通的方法解决数组扁平化问题？</p>\n</li>\n<li data-nodeid="1918">\n<p data-nodeid="1919">ES6 里面是否有一些高级的方法能够直接实现？</p>\n</li>\n</ol>\n<p data-nodeid="1920">下面开始说说什么是数组扁平化，如何实现它呢？</p>\n<h3 data-nodeid="1921">扁平化的实现</h3>\n<p data-nodeid="1922">数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。举个简单的例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果如下面这段代码所示。</p>\n<pre class="lang-javascript" data-nodeid="1923"><code data-language="javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>，<span class="hljs-number">5</span>]]];\n<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// [1, 2, 3, 4，5]</span>\n</code></pre>\n<p data-nodeid="1924">其实就是把多维的数组“拍平”，输出最后的一维数组。那么你知道了效果是什么样的了，下面就尝试着写一个 flatten 函数吧。实现方式有下述几种。</p>\n<h4 data-nodeid="1925">方法一：普通的递归实</h4>\n<p data-nodeid="1926">普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接。我们来看下这个方法是如何实现的，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1927"><code data-language="javascript"><span class="hljs-comment">// 方法1</span>\n<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>{\n  <span class="hljs-keyword">let</span> result = [];\n\n  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {\n    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(arr[i])) {\n      result = result.concat(flatten(arr[i]));\n    } <span class="hljs-keyword">else</span> {\n      result.push(arr[i]);\n    }\n  }\n  <span class="hljs-keyword">return</span> result;\n}\nflatten(a);  <span class="hljs-comment">// &nbsp;[1, 2, 3, 4，5]</span>\n</code></pre>\n<p data-nodeid="1928">从上面这段代码可以看出，最后返回的结果是扁平化的结果，这段代码核心就是循环遍历过程中的递归操作，就是在遍历过程中发现数组元素还是数组的时候进行递归操作，把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组。</p>\n<p data-nodeid="1929">下面我们来看看另一种实现方式。</p>\n<h4 data-nodeid="1930">方法二：利用 reduce 函数迭代</h4>\n<p data-nodeid="1931">从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么我们其实也可以用第 7 讲中说的 reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="1932"><code data-language="javascript"><span class="hljs-comment">// 方法2</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>{\n    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)</span>{\n        <span class="hljs-keyword">return</span> prev.concat(<span class="hljs-built_in">Array</span>.isArray(next) ? flatten(next) : next)\n    }, [])\n}\n<span class="hljs-built_in">console</span>.log(flatten(arr));<span class="hljs-comment">// &nbsp;[1, 2, 3, 4，5]</span>\n</code></pre>\n<p data-nodeid="1933">这段代码在控制台执行之后，也可以得到想要的结果。这里你可以回忆一下之前说的 reduce 的参数问题，我们可以看到 reduce 的第一个参数用来返回最后累加的结果，思路和第一种递归方法是一样的，但是通过使用 reduce 之后代码变得更简洁了，也同样解决了扁平化的问题。</p>\n<p data-nodeid="1934">下面我们来看看下一种实现方式。</p>\n<h4 data-nodeid="1935">方法三：扩展运算符实现</h4>\n<p data-nodeid="1936">这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的，还是来看一下代码。</p>\n<pre class="lang-javascript" data-nodeid="1937"><code data-language="javascript"><span class="hljs-comment">// 方法3</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>{\n    <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item))) {\n        arr = [].concat(...arr);\n    }\n    <span class="hljs-keyword">return</span> arr;\n}\n<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// &nbsp;[1, 2, 3, 4，5]</span>\n</code></pre>\n<p data-nodeid="1938">从执行的结果中可以发现，我们先用数组的 some 方法把数组中仍然是组数的项过滤出来，然后执行 concat 操作，利用 ES6 的展开运算符，将其拼接到原数组中，最后返回原数组，达到了预期的效果。</p>\n<p data-nodeid="1939">前三种实现数组扁平化的方式其实是最基本的思路，都是通过最普通递归思路衍生的方法，尤其是前两种实现方法比较类似。值得注意的是 reduce 方法，它可以在很多应用场景中实现，由于 reduce 这个方法提供的几个参数比较灵活，能解决很多问题，所以是值得熟练使用并且精通的。</p>\n<p data-nodeid="1940">那么除此之外，是否还有其他实现方式呢？请你接着往下看。</p>\n<h4 data-nodeid="1941">方法四：split 和 toString 共同处理</h4>\n<p data-nodeid="1942">我们也可以通过 split 和 toString 两个方法，来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="2258"><code data-language="javascript"><span class="hljs-comment">// 方法4</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>{\n    <span class="hljs-keyword">return</span> arr.toString().split(<span class="hljs-string">\',\'</span>);\n}\n<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// &nbsp;[1, 2, 3, 4]</span>\n</code></pre>\n\n\n<p data-nodeid="1944">通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组，你可以在控制台执行一下查看结果。</p>\n<p data-nodeid="1945">下面我们看看 ES6 有什么方式可以直接实现数组的扁平化。</p>\n<h4 data-nodeid="1946">方法五：调用 ES6 中的 flat</h4>\n<p data-nodeid="1947">我们还可以直接调用 ES6 中的 flat 方法，可以直接实现数组扁平化。先来看下 flat 方法的语法：</p>\n<blockquote data-nodeid="1948">\n<p data-nodeid="1949">arr.flat([depth])</p>\n</blockquote>\n<p data-nodeid="1950">其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。那么如果多层的该怎么处理呢？参数也可以传进 Infinity，代表不论多少层都要展开。那么我们来看下，用 flat 方法怎么实现，请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="1951"><code data-language="javascript"><span class="hljs-comment">// 方法5</span>\n<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>{\n  <span class="hljs-keyword">return</span> arr.flat(<span class="hljs-literal">Infinity</span>);\n}\n<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// &nbsp;[1, 2, 3, 4，5]</span>\n</code></pre>\n<p data-nodeid="1952">可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。</p>\n<p data-nodeid="1953">因此，你在编程过程中，发现对数组的嵌套层数不确定的时候，最好直接使用 Infinity，可以达到扁平化。下面我们再来看最后一种场景。</p>\n<h4 data-nodeid="1954">方法六：正则和 JSON 方法共同处理</h4>\n<p data-nodeid="1955">我们在第四种方法中已经尝试了用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组。请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="1956"><code data-language="javascript"><span class="hljs-comment">// 方法 6</span>\n<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>{\n  <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(arr);\n  str = str.replace(<span class="hljs-regexp">/(\\[|\\])/g</span>, <span class="hljs-string">\'\'</span>);\n  str = <span class="hljs-string">\'[\'</span> + str + <span class="hljs-string">\']\'</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(str); \n}\n<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// &nbsp;[1, 2, 3, 4，5]</span>\n</code></pre>\n<p data-nodeid="1957">可以看到，其中先把传入的数组转换成字符串，然后通过正则表达式的方式把括号过滤掉，这部分正则的表达式你不太理解的话，可以看看下面的图片。<br>\n<img src="https://s0.lgstatic.com/i/image/M00/94/9B/Ciqc1GAY_EWAE3pDAAERgfI0plY241.png" alt="Lark20210202-151541.png" data-nodeid="2010"></p>\n<p data-nodeid="1958">通过这个在线网站 <a href="https://regexper.com/" data-nodeid="2014">https://regexper.com/</a> 可以把正则分析成容易理解的可视化的逻辑脑图。其中我们可以看到，匹配规则是：全局匹配（g）左括号或者右括号，将它们替换成空格，最后返回处理后的结果。之后拿着正则处理好的结果重新在外层包裹括号，最后通过 JSON.parse 转换成数组返回。</p>\n<p data-nodeid="1959">以上就是这六种实现数组扁平化的方式，你可以再思考下看看是否还有更多的实现方式，我们可以交流一下。</p>\n<h3 data-nodeid="1960">总结</h3>\n<p data-nodeid="1961">本讲的内容就介绍这么多了。我将日常开发中有可能遇到数组扁平化的几种方法分别讲了一遍，又在最后一个方法中给你推荐了一个比较容易理解的正则表达式的分析工具。希望这几种方法能为你提升 JS 编码能力带来帮助和启发。</p>\n<p data-nodeid="1962">综上我们可以看到，数组扁平化这节课的知识点结合了数组 API、ES6，以及 JSON 方法的相关知识。你可以通过下面的表格再来看一下这六种方式的代码思路。</p>\n<p data-nodeid="1963"><img src="https://s0.lgstatic.com/i/image2/M01/0C/93/CgpVE2AY_DiAQNC5AAFrgibLZp4762.png" alt="Lark20210202-151546.png" data-nodeid="2022"></p>\n<p data-nodeid="1964">表格列举了这几种方法实现的难易程度，以及编码思路的描述。希望你能对这几种方法融会贯通，如果在未来的面试中遇到这样的题目，愿你能够轻松应对，给面试官一个满意的答复。</p>\n<p data-nodeid="1965">在日常的前端开发工作中，你往往会在业务开发的时候遇到各种数组问题，所以你要思考最合适的解决方式。其实扁平化只是其中的一个引子，其他涉及数组的相关知识点还有很多。</p>\n<p data-nodeid="1966">我最后给你留一个和数组相关的作业：试着写出实现数组去重的方式，看看你能够写出几种呢？</p>\n<p data-nodeid="1967" class="">下一讲，我们来说说数组排序，这也是数据结构中必不可少的知识，我们到时见。</p>',
          },
          {
            theme: '10 | 数组排序（上）：如何用 JS 实现各种数组排序',
            id: 111,
            content:
              '<p data-nodeid="561" class="">我们上一讲学习了数组扁平化的相关知识，那么这一讲的内容和之前相比，较为独立，要说的是数组排序那些事儿。数组排序是你在 JavaScript 的编程过程中经常会遇到的，也是大厂面试中会考察的，尤其是调用 sort 方法，不过今天我们主要围绕数据结构排队进行讲解，关于 sort 方法的详细剖析我会在下一讲和你探讨。</p>\n<p data-nodeid="562">那么，为了方便你更好地理解本讲的内容，在课程开始前请你先思考几个问题。</p>\n<ol data-nodeid="563">\n<li data-nodeid="564">\n<p data-nodeid="565">数据结构中稳定的排序算法有哪些？不稳定的排序算法有哪些？</p>\n</li>\n<li data-nodeid="566">\n<p data-nodeid="567">时间复杂度和空间复杂度分别代表了什么？</p>\n</li>\n</ol>\n<p data-nodeid="568">带着这样的思考，我们开始今天的学习。</p>\n<h3 data-nodeid="569">时间复杂度&amp;空间复杂度</h3>\n<p data-nodeid="570">在说排序算法之前，你需要重新了解一下时间复杂度和空间复杂度。</p>\n<p data-nodeid="571">关于时间复杂度，我们说的更多的是通过 O(nlogn) 以及 O(n) 等来衡量。其实大多数时候我们对此并未建立形象的认知，到底哪一种算法更快、更好呢？下面是一张时间复杂度的曲线图（来源于 <a href="https://gitee.com/webfrontup/javascript-algorithms" data-nodeid="639">https://gitee.com/webfrontup/javascript-algorithms</a>），方便你来理解。</p>\n<p data-nodeid="572"><img src="https://s0.lgstatic.com/i/image/M00/94/9D/Ciqc1GAZALGARectAANRfAJPMN8925.png" alt="Drawing 1.png" data-nodeid="643"></p>\n<p data-nodeid="573">图中用颜色区分了最优的、一般的以及比较差的时间复杂度，可以看到有这几种分类：Excellent、Good、Fair、Bad、Horrible，通过这张图可以一目了然。因此你在面试或者日常工作中编写代码的时候，要努力将代码的时间复杂度维持在 O(nlogn) 以下，要知道凡是超过 n 平方的时间复杂度都是难以接受的。</p>\n<p data-nodeid="574">此外，关于哪些循环嵌套是 n 平方，哪些是 nlogn，我想你已经有一定的基础认知了，这里我就不过多讲解了。</p>\n<p data-nodeid="575">空间复杂度比较容易理解，就是对一个算法在运行过程中临时占用存储空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模有关，如果规模越大，则占的存储单元越多。比如，归并排序和快速排序的空间复杂度就是不太一样的。</p>\n<p data-nodeid="576">有了这样的前提，我们就来研究各种排序的实现方法吧。</p>\n<h3 data-nodeid="577">各种排序的 JS 实现</h3>\n<p data-nodeid="578">数据结构算法中排序有很多种，常见的、不常见的，至少包含十种以上。根据它们的特性，可以大致分为两种类型：比较类排序和非比较类排序。</p>\n<ul data-nodeid="579">\n<li data-nodeid="580">\n<p data-nodeid="581"><strong data-nodeid="654">比较类排序</strong>：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。</p>\n</li>\n<li data-nodeid="582">\n<p data-nodeid="583"><strong data-nodeid="659">非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>\n</li>\n</ul>\n<p data-nodeid="584">我们通过一张图片来看看这两种分类方式分别包括哪些排序方法。</p>\n<p data-nodeid="585"><img src="https://s0.lgstatic.com/i/image/M00/94/A8/CgqCHmAZALyAd98RAAE5AoAl_us191.png" alt="Drawing 3.png" data-nodeid="663"></p>\n<p data-nodeid="586">非比较类的排序在实际情况中用的比较少，故本讲主要围绕比较类排序展开讲解。其实根据排序的稳定性，也可以分为稳定排序和不稳定排序，例如快速排序就是不稳定的排序、冒泡排序就是稳定的排序。我在最后总结的部分会帮助你再次区分。</p>\n<p data-nodeid="587">那么我们先从最简单的排序开始学习吧，先看下冒泡排序。</p>\n<h4 data-nodeid="588">冒泡排序</h4>\n<p data-nodeid="589">冒泡排序是最基础的排序，一般在最开始学习数据结构的时候就会接触它。冒泡排序是一次比较两个元素，如果顺序是错误的就把它们交换过来。走访数列的工作会重复地进行，直到不需要再交换，也就是说该数列已经排序完成。请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="590"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">222</span>, <span class="hljs-number">6</span>, <span class="hljs-number">456</span>, <span class="hljs-number">221</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">array</span>) </span>{\n  <span class="hljs-keyword">const</span> len = array.length\n  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> array\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {\n      <span class="hljs-keyword">if</span> (array[j] &gt; array[i]) {\n        <span class="hljs-keyword">const</span> temp = array[j]\n        array[j] = array[i]\n        array[i] = temp\n      }\n    }\n  }\n  <span class="hljs-keyword">return</span> array\n}\nbubbleSort(a);  <span class="hljs-comment">// [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]</span>\n</code></pre>\n<p data-nodeid="591">从上面这段代码可以看出，最后返回的是排好序的结果。因为冒泡排序实在太基础和简单，这里就不过多赘述了。下面我们来看看快速排序法。</p>\n<h4 data-nodeid="592">快速排序</h4>\n<p data-nodeid="593">快速排序的基本思想是通过一趟排序，将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<p data-nodeid="594">请看下面的代码。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="1263"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">222</span>, <span class="hljs-number">6</span>, <span class="hljs-number">456</span>, <span class="hljs-number">221</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">array</span>) </span>{\n  <span class="hljs-keyword">var</span> quick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{\n    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr\n    <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">Math</span>.floor(len &gt;&gt; <span class="hljs-number">1</span>)\n    <span class="hljs-keyword">const</span> pivot = arr.splice(index, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]\n    <span class="hljs-keyword">const</span> left = []\n    <span class="hljs-keyword">const</span> right = []\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {\n      <span class="hljs-keyword">if</span> (arr[i] &gt; pivot) {\n        right.push(arr[i])\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt;= pivot) {\n        left.push(arr[i])\n      }\n    }\n    <span class="hljs-keyword">return</span> quick(left).concat([pivot], quick(right))\n  }\n  <span class="hljs-keyword">const</span> result = quick(array)\n  <span class="hljs-keyword">return</span> result\n}\nquickSort(a);<span class="hljs-comment">// &nbsp;[1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]</span>\n</code></pre>\n\n\n\n<p data-nodeid="596">上面的代码在控制台执行之后，也可以得到预期的结果。最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成，这就是快排的思路。</p>\n<p data-nodeid="597">下面我们来看看插入排序的实现方式。</p>\n<h4 data-nodeid="598">插入排序</h4>\n<p data-nodeid="599">插入排序算法描述的是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，从而达到排序的效果。来看一下代码。</p>\n<pre class="lang-javascript" data-nodeid="600"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">222</span>, <span class="hljs-number">6</span>, <span class="hljs-number">456</span>, <span class="hljs-number">221</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">array</span>) </span>{\n  <span class="hljs-keyword">const</span> len = array.length\n  <span class="hljs-keyword">let</span> current\n  <span class="hljs-keyword">let</span> prev\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {\n    current = array[i]\n    prev = i - <span class="hljs-number">1</span>\n    <span class="hljs-keyword">while</span> (prev &gt;= <span class="hljs-number">0</span> &amp;&amp; array[prev] &gt; current) {\n      array[prev + <span class="hljs-number">1</span>] = array[prev]\n      prev--\n    }\n    array[prev + <span class="hljs-number">1</span>] = current\n  }\n  <span class="hljs-keyword">return</span> array\n}\ninsertSort(a); <span class="hljs-comment">// [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]</span>\n</code></pre>\n<p data-nodeid="601">从执行的结果中可以发现，通过插入排序这种方式实现了排序效果。插入排序的思路是基于数组本身进行调整的，首先循环遍历从 i 等于 1 开始，拿到当前的 current 的值，去和前面的值比较，如果前面的大于当前的值，就把前面的值和当前的那个值进行交换，通过这样不断循环达到了排序的目的。</p>\n<p data-nodeid="602">下面说说选择排序的实现方式。</p>\n<h4 data-nodeid="603">选择排序</h4>\n<p data-nodeid="604">选择排序是一种简单直观的排序算法。它的工作原理是，首先将最小的元素存放在序列的起始位置，再从剩余未排序元素中继续寻找最小元素，然后放到已排序的序列后面……以此类推，直到所有元素均排序完毕。请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="605"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">222</span>, <span class="hljs-number">6</span>, <span class="hljs-number">456</span>, <span class="hljs-number">221</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">array</span>) </span>{\n  <span class="hljs-keyword">const</span> len = array.length\n  <span class="hljs-keyword">let</span> temp\n  <span class="hljs-keyword">let</span> minIndex\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) {\n    minIndex = i\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) {\n      <span class="hljs-keyword">if</span> (array[j] &lt;= array[minIndex]) {\n        minIndex = j\n      }\n    }\n    temp = array[i]\n    array[i] = array[minIndex]\n    array[minIndex] = temp\n  }\n  <span class="hljs-keyword">return</span> array\n}\nselectSort(a); <span class="hljs-comment">// [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]</span>\n</code></pre>\n<p data-nodeid="606">这样，通过选择排序的方法同样也可以实现数组的排序，从上面的代码中可以看出该排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n 平方) 的时间复杂度，所以用到它的时候，数据规模越小越好。</p>\n<p data-nodeid="607">下面我们看看堆排序是怎样实现的。</p>\n<h4 data-nodeid="608">堆排序</h4>\n<p data-nodeid="609">堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆的底层实际上就是一棵完全二叉树，可以用数组实现。</p>\n<p data-nodeid="610">根节点最大的堆叫作大根堆，根节点最小的堆叫作小根堆，你可以根据从大到小排序或者从小到大来排序，分别建立对应的堆就可以。请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="611"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">222</span>, <span class="hljs-number">6</span>, <span class="hljs-number">456</span>, <span class="hljs-number">221</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heap_sort</span>(<span class="hljs-params">arr</span>) </span>{\n  <span class="hljs-keyword">var</span> len = arr.length\n  <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">i, j</span>) </span>{\n    <span class="hljs-keyword">var</span> temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max_heapify</span>(<span class="hljs-params">start, end</span>) </span>{\n    <span class="hljs-keyword">var</span> dad = start\n    <span class="hljs-keyword">var</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>\n    <span class="hljs-keyword">if</span> (son &gt;= end) <span class="hljs-keyword">return</span>\n    <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt; end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) {\n      son++\n    }\n    <span class="hljs-keyword">if</span> (arr[dad] &lt;= arr[son]) {\n      swap(dad, son)\n      max_heapify(son, end)\n    }\n  }\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {\n    max_heapify(i, len)\n  }\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = len - <span class="hljs-number">1</span>; j &gt; k; j--) {\n    swap(<span class="hljs-number">0</span>, j)\n    max_heapify(<span class="hljs-number">0</span>, j)\n  }\n\n  <span class="hljs-keyword">return</span> arr\n}\nheap_sort(a); <span class="hljs-comment">// [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]</span>\n</code></pre>\n<p data-nodeid="612">从代码来看，堆排序相比上面几种排序整体上会复杂一些，不太容易理解。不过你应该知道两点：一是堆排序最核心的点就在于排序前先建堆；二是由于堆其实就是完全二叉树，如果父节点的序号为 n，那么叶子节点的序号就分别是 2n 和 2n+1。</p>\n<p data-nodeid="613">你理解了这两点，再看代码就比较好理解了。堆排序最后有两个循环：第一个是处理父节点的顺序；第二个循环则是根据父节点和叶子节点的大小对比，进行堆的调整。通过这两轮循环的调整，最后堆排序完成。</p>\n<p data-nodeid="614">下面我们再来看最后一种归并排序。</p>\n<h4 data-nodeid="615">归并排序</h4>\n<p data-nodeid="616">归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。我们先看一下代码。</p>\n<pre class="lang-javascript" data-nodeid="617"><code data-language="javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">222</span>, <span class="hljs-number">6</span>, <span class="hljs-number">456</span>, <span class="hljs-number">221</span>];\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">array</span>) </span>{\n  <span class="hljs-keyword">const</span> merge = <span class="hljs-function">(<span class="hljs-params">right, left</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> result = []\n    <span class="hljs-keyword">let</span> il = <span class="hljs-number">0</span>\n    <span class="hljs-keyword">let</span> ir = <span class="hljs-number">0</span>\n    <span class="hljs-keyword">while</span> (il &lt; left.length &amp;&amp; ir &lt; right.length) {\n      <span class="hljs-keyword">if</span> (left[il] &lt; right[ir]) {\n        result.push(left[il++])\n      } <span class="hljs-keyword">else</span> {\n        result.push(right[ir++])\n      }\n    }\n    <span class="hljs-keyword">while</span> (il &lt; left.length) {\n      result.push(left[il++])\n    }\n    <span class="hljs-keyword">while</span> (ir &lt; right.length) {\n      result.push(right[ir++])\n    }\n    <span class="hljs-keyword">return</span> result\n  }\n  <span class="hljs-keyword">const</span> mergeSort = <span class="hljs-function"><span class="hljs-params">array</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (array.length === <span class="hljs-number">1</span>) { <span class="hljs-keyword">return</span> array }\n    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(array.length / <span class="hljs-number">2</span>)\n    <span class="hljs-keyword">const</span> left = array.slice(<span class="hljs-number">0</span>, mid)\n    <span class="hljs-keyword">const</span> right = array.slice(mid, array.length)\n    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right))\n  }\n  <span class="hljs-keyword">return</span> mergeSort(array)\n}\nmergeSort(a); <span class="hljs-comment">// [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]</span>\n</code></pre>\n<p data-nodeid="618">从上面这段代码中可以看到，通过归并排序可以得到想要的结果。上面提到了分治的思路，你可以从 mergeSort 方法中看到，通过 mid 可以把该数组分成左右两个数组，分别对这两个进行递归调用排序方法，最后将两个数组按照顺序归并起来。</p>\n<p data-nodeid="619">归并排序是一种稳定的排序方法，和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好得多，因为始终都是 O(nlogn) 的时间复杂度。而代价是需要额外的内存空间。</p>\n<p data-nodeid="620">以上就是今天要介绍的六种实现数组排序的算法，你有兴趣的话可以自己再学习下非比较类排序的那三种方法。</p>\n<h3 data-nodeid="621">总结</h3>\n<p data-nodeid="622">这一讲，我们把平常开发中常见的几种排序方法分别介绍了一遍。我整理了一个表格，汇总了它们各自的时间复杂度和空间复杂度，你可以对比着来回顾一下本讲的内容。</p>\n<p data-nodeid="623"><img src="https://s0.lgstatic.com/i/image2/M01/0C/93/Cip5yGAZAM-AD3aBAAE-rytK4O4585.png" alt="Drawing 4.png" data-nodeid="697"></p>\n<p data-nodeid="624">其中你可以看到排序相关的时间复杂度和空间复杂度以及稳定性的情况，如果遇到需要自己实现排序的时候，可以根据它们的空间和时间复杂度综合考量，选择最适合的排序方法。</p>\n<p data-nodeid="625">接下来的一讲我们将要分析 JS 的 sort 方法的实现，这一讲作为下节课的基础，我还是希望你能彻底理解上面的代码，从而提升 JavaScript 的编程能力和理解能力。本讲所说的各种排序算法的 JS 实现只是其中的引子，下节课的内容会相对难一些。如果你还是对个别排序算法不理解，可以试着自己多实现几遍，就会发现其中很多细节和你只是看一遍是不一样的。</p>\n<p data-nodeid="626" class="">感谢学习，我们下一讲再见。</p>',
          },
          {
            theme: '11 | 数组排序（下）：sort 排序方法的实现原理',
            id: 112,
            content:
              '<p data-nodeid="737" class="">我在上一讲为你介绍了用 JS 实现数组的各种排序，那么这一讲作为进阶，我要带你了解一下 JS 提供的数组排序的 sort 方法。数组排序在日常工作中经常会出现，除了上一讲介绍的排序算法外，通过 sort 方法也可以实现数组的排序，因此这一讲我会带你剖析 JS 数组 sort 方法的底层实现。</p>\n<p data-nodeid="738">我们比较常用的是直接调用 JS 的 sort 方法，这一讲会围绕原生 JS 方法，并结合 V8 排序的代码一起来分析，以便你碰到类似的 JS 排序问题时能够轻松应对。</p>\n<p data-nodeid="739">那么，在课程开始前请你先思考一下：</p>\n<ol data-nodeid="740">\n<li data-nodeid="741">\n<p data-nodeid="742">sort 方法到底是用了哪种排序思路？</p>\n</li>\n<li data-nodeid="743">\n<p data-nodeid="744">sort 方法里面的参数对比函数是什么意思？</p>\n</li>\n</ol>\n<p data-nodeid="745">带着问题，我们开始说说 sort 方法的基本内容。</p>\n<h3 data-nodeid="746">sort 方法的基本使用</h3>\n<p data-nodeid="747">sort 方法是对数组元素进行排序，默认排序顺序是先将元素转换为字符串，然后再进行排序，先来看一下它的语法：</p>\n<blockquote data-nodeid="748">\n<p data-nodeid="749">arr.sort([compareFunction])</p>\n</blockquote>\n<p data-nodeid="750">其中 compareFunction 用来指定按某种顺序进行排列的函数，如果省略不写，元素按照转换为字符串的各个字符的 Unicode 位点进行排序。我们来看一下代码。</p>\n<pre class="lang-javascript" data-nodeid="751"><code data-language="javascript"><span class="hljs-keyword">const</span> months = [<span class="hljs-string">\'March\'</span>, <span class="hljs-string">\'Jan\'</span>, <span class="hljs-string">\'Feb\'</span>, <span class="hljs-string">\'Dec\'</span>];\nmonths.sort();\n<span class="hljs-built_in">console</span>.log(months);\n<span class="hljs-comment">// ["Dec", "Feb", "Jan", "March"]</span>\n<span class="hljs-keyword">const</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, <span class="hljs-number">4</span>, <span class="hljs-number">21</span>, <span class="hljs-number">100000</span>];\narray1.sort();\n<span class="hljs-built_in">console</span>.log(array1);\n<span class="hljs-comment">// [1, 100000, 21, 30, 4]</span>\n</code></pre>\n<p data-nodeid="752">从上面的执行结果可以看出，如果不加参数，在第二段代码中，21 会排到 4 的前面。这样按照从小到大的逻辑是行不通的，如果想要按照从小到大排序或者从大到小排序，那么上面的代码就需要调整为下面这样。</p>\n<pre class="lang-javascript" data-nodeid="753"><code data-language="javascript"><span class="hljs-keyword">const</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, <span class="hljs-number">4</span>, <span class="hljs-number">21</span>, <span class="hljs-number">100000</span>];\narray1.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> b - a);\n<span class="hljs-built_in">console</span>.log(array1);    <span class="hljs-comment">// [100000, 30, 21, 4, 1]</span>\n<span class="hljs-keyword">const</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, <span class="hljs-number">4</span>, <span class="hljs-number">21</span>, <span class="hljs-number">100000</span>];\narray1.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a - b);\n<span class="hljs-built_in">console</span>.log(array1);    <span class="hljs-comment">// [1, 4, 21, 30, 100000]</span>\n</code></pre>\n<p data-nodeid="754">如果指明了&nbsp;compareFunction 参数&nbsp;，那么数组会按照调用该函数的返回值排序，即&nbsp;a 和 b 是两个将要被比较的元素：</p>\n<ul data-nodeid="755">\n<li data-nodeid="756">\n<p data-nodeid="757">如果&nbsp;compareFunction（a, b）小于 0，那么 a 会被排列到 b 之前；</p>\n</li>\n<li data-nodeid="758">\n<p data-nodeid="759">如果&nbsp;compareFunction（a, b）等于 0，a 和 b 的相对位置不变；</p>\n</li>\n<li data-nodeid="760">\n<p data-nodeid="761">如果&nbsp;compareFunction（a, b）大于 0，b 会被排列到 a 之前。</p>\n</li>\n</ul>\n<p data-nodeid="762">说完 sort 方法的对比函数，下面我们来看一下 sort 的底层实现。</p>\n<h3 data-nodeid="763">sort 方法的底层实现</h3>\n<p data-nodeid="764">相信你对 JS 数组的 sort 方法已经不陌生了，上面我也对它的用法进行了详细的介绍。那么它的内部是如何实现的呢？如果你能够进入它的内部看一看源码，理解背后的设计，这对编程思维的提升是一个很好的帮助。</p>\n<p data-nodeid="765">sort 方法在 V8 内部相较于其他方法而言是一个比较难的算法，对于很多边界情况结合排序算法做了反复的优化，但是这里我不会直接拿源码来讲，而是会根据源码的思路，循序善诱地带你实现一个跟引擎性能类似的排序算法，并且一步步拆解其中的奥秘。</p>\n<p data-nodeid="766">这里你需要回顾上一讲说的插入排序和快速排序，接下来我们就对 sort 源码进行分析。</p>\n<h4 data-nodeid="767">底层 sort 源码分析</h4>\n<p data-nodeid="768">先大概来梳理一下源码中排序的思路（下面的源码均来自 V8 源码中关于 sort 排序的摘要，地址：<a href="https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L709" data-nodeid="858">V8 源码 sort 排序部分</a>）。</p>\n<p data-nodeid="769">通过研究源码我们先直接看一下结论，如果要排序的元素个数是 n 的时候，那么就会有以下几种情况：</p>\n<ol data-nodeid="770">\n<li data-nodeid="771">\n<p data-nodeid="772">当 n&lt;=10 时，采用插入排序；</p>\n</li>\n<li data-nodeid="773">\n<p data-nodeid="774">当 n&gt;10 时，采用三路快速排序；</p>\n</li>\n<li data-nodeid="775">\n<p data-nodeid="776">10&lt;n &lt;=1000，采用中位数作为哨兵元素；</p>\n</li>\n<li data-nodeid="777">\n<p data-nodeid="778">n&gt;1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。</p>\n</li>\n</ol>\n<p data-nodeid="779">在得出这个结论之前，我觉得有必要让你了解为什么这么做。下面就一起来思考两个问题。</p>\n<p data-nodeid="780"><strong data-nodeid="879">1. 为什么元素个数少的时候要采用插入排序？</strong></p>\n<p data-nodeid="781">虽然插入排序理论上是平均时间复杂度为 O(n^2) 的算法，快速排序是一个平均 O(nlogn) 级别的算法。但是别忘了，这只是理论上平均的时间复杂度估算，但是它们也有最好的时间复杂度情况，而插入排序在最好的情况下时间复杂度是 O(n)。</p>\n<p data-nodeid="782">在实际情况中两者的算法复杂度前面都会有一个系数，当 n 足够小的时候，快速排序 nlogn 的优势会越来越小。倘若插入排序的 n 足够小，那么就会超过快排。而事实上正是如此，插入排序经过优化以后，对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。因此，对于很小的数据量，应用插入排序是一个非常不错的选择。</p>\n<p data-nodeid="783"><strong data-nodeid="887">2. 为什么要花这么大的力气选择哨兵元素？</strong></p>\n<p data-nodeid="784">因为快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。如果这么排下去，递归的层数就达到了 n , 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2) 级别。</p>\n<p data-nodeid="785">这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的各种优化了。</p>\n<p data-nodeid="786">接下来，我们看一下官方实现的 sort 排序算法的代码基本结构。</p>\n<pre class="lang-javascript" data-nodeid="787"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ArraySort</span>(<span class="hljs-params">comparefn</span>) </span>{\n\t  CHECK_OBJECT_COERCIBLE(<span class="hljs-keyword">this</span>,<span class="hljs-string">"Array.prototype.sort"</span>);\n\t  <span class="hljs-keyword">var</span> array = TO_OBJECT(<span class="hljs-keyword">this</span>);\n\t  <span class="hljs-keyword">var</span> length = TO_LENGTH(array.length);\n\t  <span class="hljs-keyword">return</span> InnerArraySort(array, length, comparefn);\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InnerArraySort</span>(<span class="hljs-params">array, length, comparefn</span>) </span>{\n  <span class="hljs-comment">// 比较函数未传入</span>\n  <span class="hljs-keyword">if</span> (!IS_CALLABLE(comparefn)) {\n\t    comparefn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>{\n\t      <span class="hljs-keyword">if</span> (x === y) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\t      <span class="hljs-keyword">if</span> (%_IsSmi(x) &amp;&amp; %_IsSmi(y)) {\n\t        <span class="hljs-keyword">return</span> %SmiLexicographicCompare(x, y);\n\t      }\n\t      x = TO_STRING(x);\n\t      y = TO_STRING(y);\n\t      <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n\t      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> x &lt; y ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;\n\t };\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InsertionSort</span>(<span class="hljs-params">a, from, to</span>) </span>{\n    <span class="hljs-comment">// 插入排序</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-keyword">from</span> + <span class="hljs-number">1</span>; i &lt; to; i++) {\n\t      <span class="hljs-keyword">var</span> element = a[i];\n\t      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-keyword">from</span>; j--) {\n\t        <span class="hljs-keyword">var</span> tmp = a[j];\n\t        <span class="hljs-keyword">var</span> order = comparefn(tmp, element);\n\t        <span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span>) {\n\t          a[j + <span class="hljs-number">1</span>] = tmp;\n\t        } <span class="hljs-keyword">else</span> {\n\t          <span class="hljs-keyword">break</span>;\n\t        }\n\t      }\n\t    a[j + <span class="hljs-number">1</span>] = element;\n\t }\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetThirdIndex</span>(<span class="hljs-params">a, from, to</span>) </span>{   <span class="hljs-comment">// 元素个数大于1000时寻找哨兵元素</span>\n    <span class="hljs-keyword">var</span> t_array = <span class="hljs-keyword">new</span> InternalArray();\n\t<span class="hljs-keyword">var</span> increment = <span class="hljs-number">200</span> + ((to - <span class="hljs-keyword">from</span>) &amp; <span class="hljs-number">15</span>);\n\t<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">from</span> += <span class="hljs-number">1</span>;\n\tto -= <span class="hljs-number">1</span>;\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-keyword">from</span>; i &lt; to; i += increment) {\n\t   t_array[j] = [i, a[i]];\n\t   j++;\n\t}\n\tt_array.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{\n\t   <span class="hljs-keyword">return</span> comparefn(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]);\n\t});\n\t<span class="hljs-keyword">var</span> third_index = t_array[t_array.length &gt;&gt; <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];\n\t<span class="hljs-keyword">return</span> third_index;\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params">a, from, to</span>) </span>{  <span class="hljs-comment">// 快速排序实现</span>\n        <span class="hljs-comment">//哨兵位置</span>\n\t    <span class="hljs-keyword">var</span> third_index = <span class="hljs-number">0</span>;\n\t    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n\t      <span class="hljs-keyword">if</span> (to - <span class="hljs-keyword">from</span> &lt;= <span class="hljs-number">10</span>) {\n\t        InsertionSort(a, <span class="hljs-keyword">from</span>, to); <span class="hljs-comment">// 数据量小，使用插入排序，速度较快</span>\n\t        <span class="hljs-keyword">return</span>;\n\t      }\n\t      <span class="hljs-keyword">if</span> (to - <span class="hljs-keyword">from</span> &gt; <span class="hljs-number">1000</span>) {\n\t        third_index = GetThirdIndex(a, <span class="hljs-keyword">from</span>, to);\n\t      } <span class="hljs-keyword">else</span> {\n            <span class="hljs-comment">// 小于1000 直接取中点</span>\n\t        third_index = <span class="hljs-keyword">from</span> + ((to - <span class="hljs-keyword">from</span>) &gt;&gt; <span class="hljs-number">1</span>);\n\t      }\n          <span class="hljs-comment">// 下面开始快排</span>\n\t      <span class="hljs-keyword">var</span> v0 = a[<span class="hljs-keyword">from</span>];\n\t      <span class="hljs-keyword">var</span> v1 = a[to - <span class="hljs-number">1</span>];\n\t      <span class="hljs-keyword">var</span> v2 = a[third_index];\n\t      <span class="hljs-keyword">var</span> c01 = comparefn(v0, v1);\n\t      <span class="hljs-keyword">if</span> (c01 &gt; <span class="hljs-number">0</span>) {\n\t        <span class="hljs-keyword">var</span> tmp = v0;\n\t        v0 = v1;\n\t        v1 = tmp;\n\t      }\n\t      <span class="hljs-keyword">var</span> c02 = comparefn(v0, v2);\n\t      <span class="hljs-keyword">if</span> (c02 &gt;= <span class="hljs-number">0</span>) {\n\t        <span class="hljs-keyword">var</span> tmp = v0;\n\t        v0 = v2;\n\t        v2 = v1;\n\t        v1 = tmp;\n\t      } <span class="hljs-keyword">else</span> {\n\t        <span class="hljs-keyword">var</span> c12 = comparefn(v1, v2);\n\t        <span class="hljs-keyword">if</span> (c12 &gt; <span class="hljs-number">0</span>) {\n\t          <span class="hljs-keyword">var</span> tmp = v1;\n\t          v1 = v2;\n\t          v2 = tmp;\n\t        }\n\t      }\n\t      a[<span class="hljs-keyword">from</span>] = v0;\n\t      a[to - <span class="hljs-number">1</span>] = v2;\n\t      <span class="hljs-keyword">var</span> pivot = v1;\n\t      <span class="hljs-keyword">var</span> low_end = <span class="hljs-keyword">from</span> + <span class="hljs-number">1</span>; \n\t      <span class="hljs-keyword">var</span> high_start = to - <span class="hljs-number">1</span>;\n\t      a[third_index] = a[low_end];\n\t      a[low_end] = pivot;\n\t      partition: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = low_end + <span class="hljs-number">1</span>; i &lt; high_start; i++) {\n\t        <span class="hljs-keyword">var</span> element = a[i];\n\t        <span class="hljs-keyword">var</span> order = comparefn(element, pivot);\n\t        <span class="hljs-keyword">if</span> (order &lt; <span class="hljs-number">0</span>) {\n\t          a[i] = a[low_end];\n\t          a[low_end] = element;\n\t          low_end++;\n\t        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span>) {\n\t          <span class="hljs-keyword">do</span> {\n\t            high_start--;\n\t            <span class="hljs-keyword">if</span> (high_start == i) <span class="hljs-keyword">break</span> partition;\n\t            <span class="hljs-keyword">var</span> top_elem = a[high_start];\n\t            order = comparefn(top_elem, pivot);\n\t          } <span class="hljs-keyword">while</span> (order &gt; <span class="hljs-number">0</span>);\n\t          a[i] = a[high_start];\n\t          a[high_start] = element;\n\t          <span class="hljs-keyword">if</span> (order &lt; <span class="hljs-number">0</span>) {\n\t            element = a[i];\n\t            a[i] = a[low_end];\n\t            a[low_end] = element;\n\t            low_end++;\n\t          }\n\t        }\n\t      }\n          <span class="hljs-comment">// 快排的核心思路，递归调用快速排序方法</span>\n\t      <span class="hljs-keyword">if</span> (to - high_start &lt; low_end - <span class="hljs-keyword">from</span>) {\n\t        QuickSort(a, high_start, to);\n\t        to = low_end;\n\t      } <span class="hljs-keyword">else</span> {\n\t        QuickSort(a, <span class="hljs-keyword">from</span>, low_end);\n\t        <span class="hljs-keyword">from</span> = high_start;\n\t      }\n\t  }\n&nbsp; }\n</code></pre>\n<p data-nodeid="788">从上面的源码分析来看，当数据量小于 10 的时候用插入排序；当数据量大于 10 之后采用三路快排；当数据量为 10~1000 时候直接采用中位数为哨兵元素；当数据量大于 1000 的时候就开始寻找哨兵元素。</p>\n<p data-nodeid="789">我们直接从上面的源码中就可以看到整个 sort 源码的编写逻辑，也就是上面总结分析的逻辑对应实现。如果你还是没有理解得很好，我建议你再重新看一下插入排序和快速排序的核心逻辑。其实关键点在于根据数据量的大小，从而确定用什么排序来解决；时间复杂度是根据数据量的大小，从而进行变化的，这一点需要深入理解。</p>\n<h3 data-nodeid="790">总结</h3>\n<p data-nodeid="791">那么关于 sort 排序方法我就介绍到这里了。这一讲，我把 JS 中的 sort 方法详细讲解了一遍，同时又带你剖析了 sort 方法中内部的原理实现，你需要好好学习排序相关的算法，才能真正理解 V8 源码中实现的排序逻辑。</p>\n<p data-nodeid="792">此外，关于排序时间复杂度也不用死记硬背，在不同的数据量情况下，不代表某种排序一定就要比另外一种排序速度快，这点你要牢记，然后根据不同的场景进行不同的分析。</p>\n<p data-nodeid="793">那么讲到这里，我们再来整理一下快速排序和插入排序的最好以及最快情况下的时间复杂度的对比，请看下面的表格。</p>\n<p data-nodeid="1195" class="te-preview-highlight">|<img src="https://s0.lgstatic.com/i/image6/M00/04/2B/Cgp9HWAib-6AdHI6AADCTvUUDdI454.png" alt="图片2.png" data-nodeid="1199"></p>\n\n\n<p data-nodeid="826">将这两个排序的时间复杂度对比来看，如果当 n 足够小的时候，最好的情况下，插入排序的时间复杂度为 O(n) 要优于快速排序的 O(nlogn)，因此就解释了这里当 V8 实现 JS 数组排序算法时，数据量较小的时候会采用插入排序的原因了。</p>\n<p data-nodeid="827">在日常的前端开发工作中，对此的应用会比较多，研究源码的机会也是相对较少的。通过本讲的学习，我还是希望你能够多想想日常工作中经常用到的 JS 方法，及其底层源代码的实现逻辑，从而整体提升 JS 的编程能力和理解能力。</p>\n<p data-nodeid="828">这一讲我只是带你剖析了 sort 的源码实现，下一讲我会带你手写 JS 数组多个方法的底层实现。</p>\n<p data-nodeid="829" class="">另外在后面的课程中，类似这样的源码剖析还会有很多，在看每一个部分的同时，希望你能多练习、多研究，也欢迎你在下方留言发表自己在学习过程中遇到的困惑以及学习感悟等，让我们共同进步。</p>',
          },
          {
            theme: '12 | 进阶练习：带你手写 JS 数组多个方法的底层实现',
            id: 113,
            content:
              '<p data-nodeid="2084" class="">我们都知道，比较常用的数组方法有 push、pop、slice、map 和 reduce 等。上一讲我带你剖析了 sort 方法以及 V8 源码中关于排序的内容，本讲则会围绕这几个常用方法，并结合 V8 的源代码带你手写这些方法的底层实现。</p>\n<p data-nodeid="2085">那么，为了方便你更好地理解本讲的内容，在课程开始前请你先回想一下：</p>\n<ol data-nodeid="2086">\n<li data-nodeid="2087">\n<p data-nodeid="2088">reduce 方法里面的参数都是什么作用？</p>\n</li>\n<li data-nodeid="2089">\n<p data-nodeid="2090">push 和 pop 的底层逻辑是什么样的呢？</p>\n</li>\n</ol>\n<p data-nodeid="2091">带着思考，我们开始今天的学习。</p>\n<h3 data-nodeid="2092">push 方法的底层实现</h3>\n<p data-nodeid="2093">为了更好地实现 push 的底层方法，你可以先去 ECMA 的官网去查一下关于 push 的基本描述（链接：<a href="https://tc39.es/ecma262/#sec-array.prototype.push" data-nodeid="2170">ECMA 数组的 push 标准</a>），我们看下其英文的描述，如下所示。</p>\n<pre class="lang-plain" data-nodeid="2094"><code data-language="plain">When the&nbsp;push&nbsp;method is called with zero or more arguments, the following steps are taken:\n1. Let&nbsp;O&nbsp;be ?&nbsp;ToObject(this&nbsp;value).\n2. Let&nbsp;len&nbsp;be ?&nbsp;LengthOfArrayLike(O).\n3. Let&nbsp;argCount&nbsp;be the number of elements in&nbsp;items.\n4. If&nbsp;len&nbsp;+&nbsp;argCount&nbsp;&gt; 2^53&nbsp;- 1, throw a&nbsp;TypeError&nbsp;exception.\n5. For each element&nbsp;E&nbsp;of&nbsp;items, do\n  a. Perform ?&nbsp;Set(O, !&nbsp;ToString(F(len)),&nbsp;E,&nbsp;true).\n  b. Set&nbsp;len&nbsp;to&nbsp;len&nbsp;+ 1.\n6. Perform ?&nbsp;Set(O,&nbsp;"length",&nbsp;F(len),&nbsp;true).\n7. Return&nbsp;F(len).\n</code></pre>\n<p data-nodeid="2095">从上面的描述可以看到边界判断逻辑以及实现的思路，根据这段英文，我们将其转换为容易理解代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="2096"><code data-language="javascript"><span class="hljs-built_in">Array</span>.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...items</span>) </span>{\n  <span class="hljs-keyword">let</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// ecma 中提到的先转换为对象</span>\n  <span class="hljs-keyword">let</span> len = <span class="hljs-keyword">this</span>.length &gt;&gt;&gt; <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> argCount = items.length &gt;&gt;&gt; <span class="hljs-number">0</span>;\n  <span class="hljs-comment">// 2 ^ 53 - 1 为JS能表示的最大正整数</span>\n  <span class="hljs-keyword">if</span> (len + argCount &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">53</span> - <span class="hljs-number">1</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"The number of array is over the max value"</span>)\n  }\n  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; argCount; i++) {\n    O[len + i] = items[i];\n  }\n  <span class="hljs-keyword">let</span> newLength = len + argCount;\n  O.length = newLength;\n  <span class="hljs-keyword">return</span> newLength;\n}\n</code></pre>\n<p data-nodeid="2097">从上面的代码可以看出，关键点就在于给数组本身循环添加新的元素 item，然后调整数组的长度 length 为最新的长度，即可完成 push 的底层实现。</p>\n<p data-nodeid="2098">其中关于长度的部分需要做无符号位移，无符号位移在很多源码中你都会看到。关于为什么一些变量要进行无符号位移，你可以自己研究一下，比如在 Stack Overflow 中有一些高票的回答，这里就不占用篇幅了。下面我们再看来一下 pop 的实现。</p>\n<h3 data-nodeid="2099">pop 方法的底层实现</h3>\n<p data-nodeid="2100">同样我们也一起来看下 pop 的底层实现，你也可以先去 ECMA 的官网去查一下关于 pop 的基本描述（链接：<a href="https://tc39.es/ecma262/#sec-array.prototype.pop" data-nodeid="2179">ECMA 数组的 pop 标准</a>），我们还是同样看下英文的描述。</p>\n<pre class="lang-plain" data-nodeid="2101"><code data-language="plain">When the&nbsp;pop&nbsp;method is called, the following steps are taken:\n1. Let&nbsp;O&nbsp;be ?&nbsp;ToObject(this&nbsp;value).\n2. Let&nbsp;len&nbsp;be ?&nbsp;LengthOfArrayLike(O).\n3. If&nbsp;len&nbsp;= 0, then\n    Perform ?&nbsp;Set(O,&nbsp;"length",&nbsp;+0F,&nbsp;true).\n    Return&nbsp;undefined.\n4. Else,\n  Assert:&nbsp;len&nbsp;&gt; 0.\n  Let&nbsp;newLen&nbsp;be&nbsp;F(len&nbsp;- 1).\n  Let&nbsp;index&nbsp;be !&nbsp;ToString(newLen).\n  Let&nbsp;element&nbsp;be ?&nbsp;Get(O,&nbsp;index).\n  Perform ?&nbsp;DeletePropertyOrThrow(O,&nbsp;index).\n  Perform ?&nbsp;Set(O,&nbsp;"length",&nbsp;newLen,&nbsp;true).\n  Return&nbsp;element.\n</code></pre>\n<p data-nodeid="2102">从上面的描述可以看到边界判断逻辑以及实现的思路，根据上面的英文，我们同样将其转换为可以理解的代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="2103"><code data-language="javascript"><span class="hljs-built_in">Array</span>.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">let</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);\n  <span class="hljs-keyword">let</span> len = <span class="hljs-keyword">this</span>.length &gt;&gt;&gt; <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) {\n    O.length = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;\n  }\n  len --;\n  <span class="hljs-keyword">let</span> value = O[len];\n  <span class="hljs-keyword">delete</span> O[len];\n  O.length = len;\n  <span class="hljs-keyword">return</span> value;\n}\n</code></pre>\n<p data-nodeid="2104">其核心思路还是在于删掉数组自身的最后一个元素，index 就是数组的 len 长度，然后更新最新的长度，最后返回的元素的值，即可达到想要的效果。另外就是在当长度为 0 的时候，如果执行 pop 操作，返回的是 undefined，需要做一下特殊处理。</p>\n<p data-nodeid="2105">看完了 pop 的实现，我们再来看一下 map 方法的底层逻辑。</p>\n<h3 data-nodeid="2106">map 方法的底层实现</h3>\n<p data-nodeid="2107">同样你可以去 ECMA 的官网去查一下关于 map 的基本描述（链接：<a href="https://tc39.es/ecma262/#sec-array.prototype.map" data-nodeid="2188">ECMA 数组的 map 标准</a>），请看英文的表述。</p>\n<pre class="lang-plain" data-nodeid="2108"><code data-language="plain">When the&nbsp;map&nbsp;method is called with one or two arguments, the following steps are taken:\n1. Let&nbsp;O&nbsp;be ?&nbsp;ToObject(this&nbsp;value).\n2. Let&nbsp;len&nbsp;be ?&nbsp;LengthOfArrayLike(O).\n3. If&nbsp;IsCallable(callbackfn) is&nbsp;false, throw a&nbsp;TypeError&nbsp;exception.\n4. Let&nbsp;A&nbsp;be ?&nbsp;ArraySpeciesCreate(O,&nbsp;len).\n5. Let&nbsp;k&nbsp;be 0.\n6. Repeat, while&nbsp;k&nbsp;&lt;&nbsp;len,\n    a. Let&nbsp;Pk&nbsp;be !&nbsp;ToString(F(k)).\n    b. Let&nbsp;kPresent&nbsp;be ?&nbsp;HasProperty(O,&nbsp;Pk).\n    c. If&nbsp;kPresent&nbsp;is&nbsp;true, then\n        Let&nbsp;kValue&nbsp;be ?&nbsp;Get(O,&nbsp;Pk).\n        Let&nbsp;mappedValue&nbsp;be ?&nbsp;Call(callbackfn,&nbsp;thisArg, «&nbsp;kValue,&nbsp;F(k),&nbsp;O&nbsp;»).\n        Perform ?&nbsp;CreateDataPropertyOrThrow(A,&nbsp;Pk,&nbsp;mappedValue).\n    d. Set&nbsp;k&nbsp;to&nbsp;k&nbsp;+ 1.\n7. Return&nbsp;A.\n</code></pre>\n<p data-nodeid="2109">同样的，根据上面的英文，我们将其转换为可理解的代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="2110"><code data-language="javascript"><span class="hljs-built_in">Array</span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callbackFn, thisArg</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span> === <span class="hljs-literal">undefined</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot read property \'map\' of null"</span>);\n  }\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="hljs-string">"[object Function]"</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callbackfn + <span class="hljs-string">\' is not a function\'</span>)\n  }\n  <span class="hljs-keyword">let</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);\n  <span class="hljs-keyword">let</span> T = thisArg;\n\n  <span class="hljs-keyword">let</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);\n  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) {\n    <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) {\n      <span class="hljs-keyword">let</span> kValue = O[k];\n      <span class="hljs-comment">// 依次传入this, 当前项，当前索引，整个数组</span>\n      <span class="hljs-keyword">let</span> mappedValue = callbackfn.call(T, KValue, k, O);\n      A[k] = mappedValue;\n    }\n  }\n  <span class="hljs-keyword">return</span> A;\n}\n</code></pre>\n<p data-nodeid="2111">有了上面实现 push 和 pop 的基础思路，map 的实现也不会太难了，基本就是再多加一些判断，循环遍历实现 map 的思路，将处理过后的 mappedValue 赋给一个新定义的数组 A，最后返回这个新数组 A，并不改变原数组的值。</p>\n<p data-nodeid="2112">我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6180" data-nodeid="2197">07 | 数组原理（上）：帮你梳理眼花缭乱的数组 API</a>”中也介绍过数据的方法分类，遍历类型的方法最后返回的都是一个新数组，并不改变原有数组的值，这点你需要牢记。</p>\n<p data-nodeid="2113">最后我们来看看 reduce 的实现。</p>\n<h3 data-nodeid="2114">reduce 方法的底层实现</h3>\n<p data-nodeid="2115">ECMA 官网关于 reduce 的基本描述（链接：<a href="https://tc39.es/ecma262/#sec-array.prototype.pop" data-nodeid="2204">ECMA 数组的 pop 标准</a>），如下所示。</p>\n<pre class="lang-plain" data-nodeid="2116"><code data-language="plain">When the&nbsp;reduce&nbsp;method is called with one or two arguments, the following steps are taken:\n1. Let&nbsp;O&nbsp;be ?&nbsp;ToObject(this&nbsp;value).\n2. Let&nbsp;len&nbsp;be ?&nbsp;LengthOfArrayLike(O).\n3. If&nbsp;IsCallable(callbackfn) is&nbsp;false, throw a&nbsp;TypeError&nbsp;exception.\n4. If&nbsp;len&nbsp;= 0 and&nbsp;initialValue&nbsp;is not present, throw a&nbsp;TypeError&nbsp;exception.\n5. Let&nbsp;k&nbsp;be 0.\n6. Let&nbsp;accumulator&nbsp;be&nbsp;undefined.\n7. If&nbsp;initialValue&nbsp;is present, then\n    Set&nbsp;accumulator&nbsp;to&nbsp;initialValue.\n8. Else,\n    Let&nbsp;kPresent&nbsp;be&nbsp;false.\n    Repeat, while&nbsp;kPresent&nbsp;is&nbsp;false&nbsp;and&nbsp;k&nbsp;&lt;&nbsp;len,\n        Let&nbsp;Pk&nbsp;be !&nbsp;ToString(F(k)).\n        Set&nbsp;kPresent&nbsp;to ?&nbsp;HasProperty(O,&nbsp;Pk).\n        If&nbsp;kPresent&nbsp;is&nbsp;true, then\n        Set&nbsp;accumulator&nbsp;to ?&nbsp;Get(O,&nbsp;Pk).\n        Set&nbsp;k&nbsp;to&nbsp;k&nbsp;+ 1.\n    If&nbsp;kPresent&nbsp;is&nbsp;false, throw a&nbsp;TypeError&nbsp;exception.\n9. Repeat, while&nbsp;k&nbsp;&lt;&nbsp;len,\n    Let&nbsp;Pk&nbsp;be !&nbsp;ToString(F(k)).\n    Let&nbsp;kPresent&nbsp;be ?&nbsp;HasProperty(O,&nbsp;Pk).\n    If&nbsp;kPresent&nbsp;is&nbsp;true, then\n        Let&nbsp;kValue&nbsp;be ?&nbsp;Get(O,&nbsp;Pk).\n        Set&nbsp;accumulator&nbsp;to ?&nbsp;Call(callbackfn,&nbsp;undefined, «&nbsp;accumulator,&nbsp;kValue,&nbsp;F(k),&nbsp;O&nbsp;»).\n    Set&nbsp;k&nbsp;to&nbsp;k&nbsp;+ 1.\n10. Return&nbsp;accumulator.\n</code></pre>\n<p data-nodeid="2117">还是将其转换为我们自己的代码，如下所示。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="3828"><code data-language="javascript"><span class="hljs-built_in">Array</span>.prototype.reduce  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callbackfn, initialValue</span>) </span>{\n  <span class="hljs-comment">// 异常处理，和 map 类似</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span> === <span class="hljs-literal">undefined</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot read property \'reduce\' of null"</span>);\n  }\n  <span class="hljs-comment">// 处理回调类型异常</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="hljs-string">"[object Function]"</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callbackfn + <span class="hljs-string">\' is not a function\'</span>)\n  }\n  <span class="hljs-keyword">let</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);\n  <span class="hljs-keyword">let</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> accumulator = initialValue;  <span class="hljs-comment">// reduce方法第二个参数作为累加器的初始值</span>\n  <span class="hljs-keyword">if</span> (accumulator === <span class="hljs-literal">undefined</span>) {  \n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">\'Each element of the array is empty\'</span>);\n      <span class="hljs-comment">// 初始值不传的处理</span>\n    <span class="hljs-keyword">for</span>(; k &lt; len ; k++) {\n      <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) {\n        accumulator = O[k];\n        k++;\n        <span class="hljs-keyword">break</span>;\n      }\n    }\n  }\n  <span class="hljs-keyword">for</span>(;k &lt; len; k++) {\n    <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) {\n      <span class="hljs-comment">// 注意 reduce 的核心累加器</span>\n      accumulator = callbackfn.call(<span class="hljs-literal">undefined</span>, accumulator, O[k], O);\n    }\n  }\n  <span class="hljs-keyword">return</span> accumulator;\n}\n</code></pre>\n\n\n\n\n\n\n\n<p data-nodeid="2119">根据上面的代码及注释，有几个关键点你需要重点关注：</p>\n<ol data-nodeid="2120">\n<li data-nodeid="2121">\n<p data-nodeid="2122">初始值默认值不传的特殊处理；</p>\n</li>\n<li data-nodeid="2123">\n<p data-nodeid="2124">累加器以及 callbackfn 的处理逻辑。</p>\n</li>\n</ol>\n<p data-nodeid="2125">这两个关键问题处理好，其他的地方和上面几个方法实现的思路是基本类似的，你要学会举一反三。</p>\n<h3 data-nodeid="2126">总结</h3>\n<p data-nodeid="2127">到这里，本讲的内容就先告一段落了。这一讲内容虽少，但却是你必须要掌握的内容。</p>\n<p data-nodeid="2128">这一讲中，我把 JS 的 push 、pop、map、reduce 的底层方法挨个带你实现了一遍，希望你能对此形成一套自己的思路。我所提供的实现代码，虽然不能完全和 V8 源码中实现的代码媲美，但是在正常的使用中，你如果自己能实现到这个程度，基本也可以满足要求了。</p>\n<p data-nodeid="2129">讲到这里，我再贴一下 V8 数组关于各种方法的实现源码地址，如下表所示。</p>\n<table data-nodeid="2131">\n<thead data-nodeid="2132">\n<tr data-nodeid="2133">\n<th align="center" data-nodeid="2135">数组方法</th>\n<th data-nodeid="2136">V8 源码地址</th>\n</tr>\n</thead>\n<tbody data-nodeid="2139">\n<tr data-nodeid="2140">\n<td align="center" data-nodeid="2141">pop</td>\n<td data-nodeid="2142"><a href="https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L394" data-nodeid="2220">V8 源码 pop 的实现</a></td>\n</tr>\n<tr data-nodeid="2143">\n<td align="center" data-nodeid="2144">push</td>\n<td data-nodeid="2145"><a href="https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L414" data-nodeid="2224">V8 源码 push 的实现</a></td>\n</tr>\n<tr data-nodeid="2146">\n<td align="center" data-nodeid="2147">map</td>\n<td data-nodeid="2148"><a href="https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L1036" data-nodeid="2228">V8 源码 map 的实现</a></td>\n</tr>\n<tr data-nodeid="2149">\n<td align="center" data-nodeid="2150">slice</td>\n<td data-nodeid="2151"><a href="https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L586" data-nodeid="2232">V8 源码 slice 的实现</a></td>\n</tr>\n<tr data-nodeid="2152">\n<td align="center" data-nodeid="2153">filter</td>\n<td data-nodeid="2154"><a href="https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L1024" data-nodeid="2236">V8 源码 filter 的实现</a></td>\n</tr>\n<tr data-nodeid="2155">\n<td align="center" data-nodeid="2156">...</td>\n<td data-nodeid="2157">...</td>\n</tr>\n</tbody>\n</table>\n<p data-nodeid="2158">关于本讲内容没有提到的代码及方法，你可以根据自己的兴趣，尝试着实现其中的某个方法。</p>\n<p data-nodeid="2159">同时也希望你能够多思考日常工作中都有哪些经常用到的 JS 方法，并且去研究其底层源代码的实现逻辑，找机会自己实现一遍，来整体提升你的 JavaScript 的编程能力和对底层的理解能力。</p>\n<p data-nodeid="2160" class="">下一讲我们将会进入一个全新的模块——JS 的异步编程篇，期待你能从中学习到更多的东西。每天进步一点点，加油！</p>',
          },
        ],
      },
      {
        sectionName: '模块三：异步编程篇',
        sectionId: 4,
        courseList: [
          {
            theme: '13 | 异步编程（上）：JS 异步编程都有哪些方案？',
            id: 114,
            content:
              '<p data-nodeid="549" class="">上一个模块我们学习了 JS 数组相关的知识，那么从这一讲开始就进入一个崭新的模块，也是 JS 学习过程中比较重要的部分——JS 异步编程。</p>\n<p data-nodeid="550">JS 的异步编程可以说在日常的前端业务开发中经常出现，你需要深刻理解其思路，才能更好地加以运用。</p>\n<p data-nodeid="551">先一起来回想一下，我们在日常开发中都用过哪些 JS 异步编程的方式？总结起来无外乎有这几种：回调函数、事件监听、Promise、Generator、async/await，这几种 JS 的编程方式都是异步编程。回调函数方式是最早的 JS 异步编程的方式，后随着 ES 标准的发展，Promise、Generator 和 async/await 接连出现。关于这几种方式，我会在后面的课时中分别为你介绍。这一讲的目的是帮你回顾，并对此形成一个整体的认识。</p>\n<p data-nodeid="552">那么在课程开始前请你先回想一下：</p>\n<ol data-nodeid="553">\n<li data-nodeid="554">\n<p data-nodeid="555">同步编程和异步编程的区别在哪里？</p>\n</li>\n<li data-nodeid="556">\n<p data-nodeid="557">回调地狱有哪些方法可以解决？</p>\n</li>\n</ol>\n<p data-nodeid="558">我首先为你解答与此相关联的问题。</p>\n<h3 data-nodeid="559">什么是同步？</h3>\n<p data-nodeid="560">所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。</p>\n<h3 data-nodeid="561">什么是异步？</h3>\n<p data-nodeid="562">所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。</p>\n<h3 data-nodeid="563">JS 编程中为什么需要异步？</h3>\n<p data-nodeid="564">我们都知道 JavaScript 是单线程的，如果 JS 都是同步代码执行意味着什么呢？这样可能会造成阻塞，如果当前我们有一段代码需要执行时，如果使用同步的方式，那么就会阻塞后面的代码执行；而如果使用异步则不会阻塞，我们不需要等待异步代码执行的返回结果，可以继续执行该异步任务之后的代码逻辑。因此在 JS 编程中，会大量使用异步来进行编程，这也是我要专门讲解这部分的原因。</p>\n<h3 data-nodeid="565">JS 异步编程方式发展历程</h3>\n<p data-nodeid="566">说完了异步编程的基本概念，下面我们按照时间顺序来看一下 JS 异步编程的实现方式。</p>\n<h4 data-nodeid="567">回调函数</h4>\n<p data-nodeid="568">从历史发展的脉络来看，早些年为了实现 JS 的异步编程，一般都采用回调函数的方式，比如比较典型的事件的回调，或者用 setTimeout/ setInterval 来实现一些异步编程的操作，但是使用回调函数来实现存在一个很常见的问题，那就是回调地狱。</p>\n<p data-nodeid="569">这里我列举了一种现实开发中会遇到的场景，我们来看一下代码。</p>\n<pre class="lang-javascript" data-nodeid="570"><code data-language="javascript">fs.readFile(A, <span class="hljs-string">\'utf-8\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{\n    fs.readFile(B, <span class="hljs-string">\'utf-8\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{\n        fs.readFile(C, <span class="hljs-string">\'utf-8\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{\n            fs.readFile(D, <span class="hljs-string">\'utf-8\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) </span>{\n                <span class="hljs-comment">//....</span>\n            });\n        });\n    });\n});\n</code></pre>\n<p data-nodeid="571">从上面的代码可以看出，其逻辑为先读取 A 文本内容，再根据 A 文本内容读取 B，然后再根据 B 的内容读取 C。为了实现这个业务逻辑，上面实现的代码就很容易形成回调地狱。回调实现异步编程的场景也有很多，比如：</p>\n<ol data-nodeid="572">\n<li data-nodeid="573">\n<p data-nodeid="574">ajax 请求的回调；</p>\n</li>\n<li data-nodeid="575">\n<p data-nodeid="576">定时器中的回调；</p>\n</li>\n<li data-nodeid="577">\n<p data-nodeid="578">事件回调；</p>\n</li>\n<li data-nodeid="579">\n<p data-nodeid="580">Nodejs 中的一些方法回调。</p>\n</li>\n</ol>\n<p data-nodeid="581">异步回调如果层级很少，可读性和代码的维护性暂时还是可以接受，一旦层级变多就会陷入回调地狱，上面这些异步编程的场景都会涉及回调地狱的问题。下面我们来看一下针对上面这个业务场景，改成 Promise 来实现异步编程，会是什么样子的呢？</p>\n<h4 data-nodeid="582">Promise</h4>\n<p data-nodeid="583">为了解决回调地狱的问题，之后社区提出了 Promise 的解决方案，ES6 又将其写进了语言标准，采用 Promise 的实现方式在一定程度上解决了回调地狱的问题。</p>\n<p data-nodeid="584">我们还是针对上面的这个场景来看下先读取 A 文本内容，再根据 A 文本内容读取 B 文件，接着再根据 B 文件的内容读取 C 文件。我们看这样的实现通过 Promise 改造之后是什么样的，请看代码。</p>\n<pre class="lang-javascript" data-nodeid="585"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params">url</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n        fs.readFile(url, <span class="hljs-string">\'utf8\'</span>, (err, data) =&gt; {\n            <span class="hljs-keyword">if</span>(err) reject(err);\n            resolve(data);\n        });\n    });\n}\nread(A).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> read(B);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> read(C);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> read(D);\n}).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(reason);\n});\n</code></pre>\n<p data-nodeid="586">从上面的代码可以看出，针对回调地狱进行这样的改进，可读性的确有一定的提升，优点是可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，但是 Promise 也存在一些问题，即便是使用 Promise 的链式调用，如果操作过多，其实并没有从根本上解决回调地狱的问题，只是换了一种写法，可读性虽然有所提升，但是依旧很难维护。不过 Promise 又提供了一个 all 方法，对于这个业务场景的代码，用 all 来实现可能效果会更好。</p>\n<p data-nodeid="587">下面我们就来看一个用 all 来实现的代码片段。</p>\n<pre class="lang-javascript" data-nodeid="588"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params">url</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n        fs.readFile(url, <span class="hljs-string">\'utf8\'</span>, (err, data) =&gt; {\n            <span class="hljs-keyword">if</span>(err) reject(err);\n            resolve(data);\n        });\n    });\n}\n<span class="hljs-comment">// 通过 Promise.all 可以实现多个异步并行执行，同一时刻获取最终结果的问题</span>\n<span class="hljs-built_in">Promise</span>.all([read(A), read(B), read(C)]).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(data);\n}).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> \n    <span class="hljs-built_in">console</span>.log(err)\n);\n</code></pre>\n<p data-nodeid="589">这样改造之后是不是比上面直接使用 Promise 来实现，看起来更清晰一目了然了？下面我们再来看下另外一种 JS 的异步编程方式，同样也是 ES6 才引入的 Generator 的方式。</p>\n<h4 data-nodeid="590">Generator</h4>\n<p data-nodeid="591">Generator 也是一种异步编程解决方案，它最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注。Generator 函数一般配合 yield 使用，Generator 函数最后返回的是迭代器。如果你对迭代器不太了解，可以自行补习一下这部分内容。</p>\n<p data-nodeid="592">下面我们来看一下 Generator 的简单使用，请看这段代码。</p>\n<pre class="lang-javascript" data-nodeid="593"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span>;\n    <span class="hljs-built_in">console</span>.log(a);\n    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span>;\n    <span class="hljs-built_in">console</span>.log(b);\n    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span>;\n    <span class="hljs-built_in">console</span>.log(c);\n    <span class="hljs-keyword">let</span> d = <span class="hljs-keyword">yield</span> <span class="hljs-number">444</span>;\n    <span class="hljs-built_in">console</span>.log(d);\n}\n<span class="hljs-keyword">let</span> t = gen();\nt.next(<span class="hljs-number">1</span>); <span class="hljs-comment">//第一次调用next函数时，传递的参数无效，故无打印结果</span>\nt.next(<span class="hljs-number">2</span>); <span class="hljs-comment">// a输出2;</span>\nt.next(<span class="hljs-number">3</span>); <span class="hljs-comment">// b输出3; </span>\nt.next(<span class="hljs-number">4</span>); <span class="hljs-comment">// c输出4;</span>\nt.next(<span class="hljs-number">5</span>); <span class="hljs-comment">// d输出5;</span>\n</code></pre>\n<p data-nodeid="594">从上面的代码中可以看到输出结果，第一次的 next 虽然执行了但是并未输出结果，后面的每次执行 next 会把参数传入然后打印出来，等到最后一次 next 对应的 yield 执行完之后，控制台会打印 “{value: undefined, done: true}” 的输出结果，标识该 Generator 函数已经执行完毕，即 done：true。</p>\n<p data-nodeid="595">那么看完了 Generator 方式之后，我们再来研究最后一种 async/await 的实现方式。</p>\n<h4 data-nodeid="596">async/await</h4>\n<p data-nodeid="597">ES6 之后 ES7 中又提出了新的异步解决方案：async/await，async 是 Generator 函数的语法糖，async/await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链），可以处理回调地狱的问题。async/await 写起来使得 JS 的异步代码看起来像同步代码，其实异步编程发展的目标就是让异步逻辑的代码看起来像同步一样容易理解。</p>\n<p data-nodeid="598">我们来看下 async/await 的基本用法，代码如下所示。</p>\n<pre class="lang-javascript" data-nodeid="599"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWait</span>(<span class="hljs-params"></span>) </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{\n&nbsp; &nbsp; &nbsp; &nbsp; setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"testWait"</span>);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resolve();\n&nbsp; &nbsp; &nbsp; &nbsp; }, <span class="hljs-number">1000</span>);\n&nbsp; &nbsp; })\n}\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testAwaitUse</span>(<span class="hljs-params"></span>)</span>{\n&nbsp; &nbsp; <span class="hljs-keyword">await</span> testWait()\n&nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);\n&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;\n&nbsp; &nbsp; <span class="hljs-comment">// 输出顺序：testWait，hello</span>\n&nbsp; &nbsp; <span class="hljs-comment">// 第十行如果不使用await输出顺序：hello , testWait</span>\n}\n<span class="hljs-built_in">console</span>.log(testAwaitUse());\n</code></pre>\n<p data-nodeid="600">执行上面的代码，从结果中可以看出，在正常的执行顺序下，testWait 这个函数由于使用的是 setTimeout 的定时器，回调会在一秒之后执行，但是由于执行到这里采用了 await 关键词，testAwaitUse 函数在执行的过程中需要等待 testWait 函数执行完成之后，再执行打印 hello 的操作。但是如果去掉 await ，打印结果的顺序就会变化。</p>\n<p data-nodeid="601">因此，async/await 不仅仅是 JS 的异步编程的一种方式，其可读性也接近于同步代码，让人更容易理解。</p>\n<h3 data-nodeid="602">总结</h3>\n<p data-nodeid="603">这一讲我带你把 JS 的异步编程方式回顾了一遍。希望通过这几个方式的讲解，你能够对 JS 异步编程形成一个全局的认识，其中关于 Promise、Generator 和 async/await 相关知识点，在后面的课程中我会专门针对每一个知识点进行更详细的剖析和挖掘。</p>\n<p data-nodeid="896">下面我整理了一个表格，是对本讲内容的简单总结。</p>\n<p data-nodeid="897" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/04/78/Cgp9HWAsdpyACe2BAAECu34UBgk670.png" alt="图片1.png" data-nodeid="901"></p>\n\n\n<p data-nodeid="627">现阶段，如果你能自己实现一个完善的 Promise，其实也可以满足面试以及日常工作的基本需求了。</p>\n<p data-nodeid="628">如果你对此有不理解的地方，可以大致列举出来，在接下来的课程中也好有针对性地进行学习。下一讲我会和你详细聊聊 Promise 相关内容，期待你能从中学到更多的东西，并且能够很好地运用起来。</p>\n<p data-nodeid="629" class="">我们下一讲再见。</p>',
          },
          {
            theme: '14 | 异步编程（中）：如何深入理解异步编程的核心 Promise？',
            id: 115,
            content:
              '<p data-nodeid="793" class="">上一讲，我们聊了关于 JS 异步编程的发展历程以及异步编程的几种方式，那么从这一讲开始，就要深入学习了，今天要和你说的就是异步编程的核心 Promise。</p>\n<p data-nodeid="794">其实在 ES6 标准出现之前，社区就最早提出了 Promise 的方案，后随着 ES6 将其加入进去，才统一了其用法，并提供了原生的 Promise 对象。Promise 也是日常前端开发使用比较多的编程方式，因此希望通过这一讲的学习，你能够对 Promise 异步编程的思路有更深刻的理解。</p>\n<p data-nodeid="795">按照惯例，我先给你抛出几个问题：</p>\n<ol data-nodeid="796">\n<li data-nodeid="797">\n<p data-nodeid="798">Promise 内部究竟有几种状态？</p>\n</li>\n<li data-nodeid="799">\n<p data-nodeid="800">Promise 是怎么解决回调地狱问题的？</p>\n</li>\n</ol>\n<p data-nodeid="801">现在请你带着思考，跟我一起回顾 Promise 的相关内容吧。</p>\n<h3 data-nodeid="802">Promise 的基本情况</h3>\n<p data-nodeid="803">如果一定要解释 Promise 到底是什么，简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n<p data-nodeid="804">Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。我们来简单看一下 Promise 实现的链式调用代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="805"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params">url</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n        fs.readFile(url, <span class="hljs-string">\'utf8\'</span>, (err, data) =&gt; {\n            <span class="hljs-keyword">if</span>(err) reject(err);\n            resolve(data);\n        });\n    });\n}\nread(A).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> read(B);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> read(C);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> read(D);\n}).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(reason);\n});\n</code></pre>\n<p data-nodeid="806">结合上面的代码，我们一起来分析一下 Promise 内部的状态流转情况，Promise&nbsp;对象在被创建出来时是待定的状态，它让你能够把异步操作返回最终的成功值或者失败原因，和相应的处理程序关联起来。</p>\n<p data-nodeid="807">一般&nbsp;Promise&nbsp;在执行过程中，必然会处于以下几种状态之一。</p>\n<ol data-nodeid="808">\n<li data-nodeid="809">\n<p data-nodeid="810">待定（pending）：初始状态，既没有被完成，也没有被拒绝。</p>\n</li>\n<li data-nodeid="811">\n<p data-nodeid="812">已完成（fulfilled）：操作成功完成。</p>\n</li>\n<li data-nodeid="813">\n<p data-nodeid="814">已拒绝（rejected）：操作失败。</p>\n</li>\n</ol>\n<p data-nodeid="815">待定状态的 Promise 对象执行的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生时，我们用 Promise 的 then 方法排列起来的相关处理程序就会被调用。因为最后&nbsp;Promise.prototype.then 和&nbsp;Promise.prototype.catch&nbsp;方法返回的是一个 Promise， 所以它们可以继续被链式调用。</p>\n<p data-nodeid="816">关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况，如下所示（图片来源于网络）。</p>\n<p data-nodeid="817"><img src="https://s0.lgstatic.com/i/image6/M01/05/09/Cgp9HWAvhIyAH1WgAAES_06spV4639.png" alt="Drawing 1.png" data-nodeid="901"></p>\n<p data-nodeid="818">从上图可以看出，我们最开始创建一个新的 Promise 返回给 p1 ，然后开始执行，状态是 pending，当执行 resolve 之后状态就切换为 fulfilled，执行 reject 之后就变为 rejected 的状态。</p>\n<p data-nodeid="819">关于 Promise 的状态切换如果你想深入研究，可以学习一下“有限状态机”这个知识点。日常中比较常见的状态机有很多，比如马路上的红绿灯。</p>\n<p data-nodeid="820">那么，Promise 的基本情况先介绍到这里，我们再一起来分析下，Promise 如何解决回调地狱的问题。</p>\n<h3 data-nodeid="821">Promise 如何解决回调地狱</h3>\n<p data-nodeid="822">首先，请你再回想一下什么是回调地狱，回调地狱有两个主要的问题：</p>\n<ol data-nodeid="823">\n<li data-nodeid="824">\n<p data-nodeid="825">多层嵌套的问题；</p>\n</li>\n<li data-nodeid="826">\n<p data-nodeid="827">每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</p>\n</li>\n</ol>\n<p data-nodeid="828">这两种问题在“回调函数时代”尤为突出，Promise 的诞生就是为了解决这两个问题。Promise 利用了三大技术手段来解决回调地狱：回调函数延迟绑定、返回值穿透、错误冒泡。</p>\n<p data-nodeid="829">下面我们通过一段代码来说明，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="830"><code data-language="javascript"><span class="hljs-keyword">let</span> readFilePromise = <span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    fs.readFile(filename, (err, data) =&gt; {\n      <span class="hljs-keyword">if</span> (err) {\n        reject(err)\n      } <span class="hljs-keyword">else</span> {\n        resolve(data)\n      }\n    })\n  })\n}\nreadFilePromise(<span class="hljs-string">\'1.json\'</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n  <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'2.json\'</span>)\n});\n</code></pre>\n<p data-nodeid="831">从上面的代码中可以看到，回调函数不是直接声明的，而是通过后面的 then 方法传入的，即延迟传入，这就是回调函数延迟绑定。接下来我们针对上面的代码做一下微调，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="832"><code data-language="javascript"><span class="hljs-keyword">let</span> x = readFilePromise(<span class="hljs-string">\'1.json\'</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n  <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'2.json\'</span>)  <span class="hljs-comment">//这是返回的Promise</span>\n});\nx.then(<span class="hljs-comment">/* 内部逻辑省略 */</span>)\n</code></pre>\n<p data-nodeid="833">我们根据 then 中回调函数的传入值创建不同类型的 Promise，然后把返回的 Promise 穿透到外层，以供后续的调用。这里的 x 指的就是内部返回的 Promise，然后在 x 后面可以依次完成链式调用。这便是返回值穿透的效果，这两种技术一起作用便可以将深层的嵌套回调写成下面的形式。</p>\n<pre class="lang-javascript" data-nodeid="834"><code data-language="javascript">readFilePromise(<span class="hljs-string">\'1.json\'</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'2.json\'</span>);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'3.json\'</span>);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'4.json\'</span>);\n});\n</code></pre>\n<p data-nodeid="835">这样就显得清爽了许多，更重要的是，它更符合人的线性思维模式，开发体验也更好，两种技术结合产生了链式调用的效果。</p>\n<p data-nodeid="836">这样解决了多层嵌套的问题，那另外一个问题，即每次任务执行结束后分别处理成功和失败的情况怎么解决的呢？Promise 采用了错误冒泡的方式。其实很容易理解，我们来看看效果。</p>\n<pre class="lang-javascript" data-nodeid="837"><code data-language="javascript">readFilePromise(<span class="hljs-string">\'1.json\'</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'2.json\'</span>);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'3.json\'</span>);\n}).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> readFilePromise(<span class="hljs-string">\'4.json\'</span>);\n}).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {\n  <span class="hljs-comment">// xxx</span>\n})\n</code></pre>\n<p data-nodeid="838">这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。从上面的这些代码中可以看到，Promise 解决效果也比较明显：实现链式调用，解决多层嵌套问题；实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题。</p>\n<p data-nodeid="839">接下来我们再看看 Promise 提供了哪些静态的方法。</p>\n<h3 data-nodeid="840">Promise 的静态方法</h3>\n<p data-nodeid="841">我会从语法、参数以及方法的代码几个方面来分别介绍 all、allSettled、any、race 这四种方法。</p>\n<h4 data-nodeid="842">all 方法</h4>\n<p data-nodeid="843"><strong data-nodeid="924">语法：</strong> Promise.all（iterable）</p>\n<p data-nodeid="844"><strong data-nodeid="929">参数：</strong> 一个可迭代对象，如 Array。</p>\n<p data-nodeid="845"><strong data-nodeid="934">描述：</strong> 此方法对于汇总多个 promise 的结果很有用，在 ES6 中可以将多个 Promise.all 异步请求并行操作，返回结果一般有下面两种情况。</p>\n<ol data-nodeid="846">\n<li data-nodeid="847">\n<p data-nodeid="848">当所有结果成功返回时按照请求顺序返回成功。</p>\n</li>\n<li data-nodeid="849">\n<p data-nodeid="850">当其中有一个失败方法时，则进入失败方法。</p>\n</li>\n</ol>\n<p data-nodeid="851">我们来看下业务的场景，对于下面这个业务场景页面的加载，将多个请求合并到一起，用 all 来实现可能效果会更好，请看代码片段。</p>\n<pre class="lang-javascript" data-nodeid="852"><code data-language="javascript"><span class="hljs-comment">//1.获取轮播数据列表</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBannerList</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{\n      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n        resolve(<span class="hljs-string">\'轮播数据\'</span>)\n      },<span class="hljs-number">300</span>) \n  })\n}\n<span class="hljs-comment">//2.获取店铺列表</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStoreList</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{\n    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n      resolve(<span class="hljs-string">\'店铺数据\'</span>)\n    },<span class="hljs-number">500</span>)\n  })\n}\n<span class="hljs-comment">//3.获取分类列表</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCategoryList</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{\n    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n      resolve(<span class="hljs-string">\'分类数据\'</span>)\n    },<span class="hljs-number">700</span>)\n  })\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initLoad</span>(<span class="hljs-params"></span>)</span>{ \n  <span class="hljs-built_in">Promise</span>.all([getBannerList(),getStoreList(),getCategoryList()])\n  .then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>{\n    <span class="hljs-built_in">console</span>.log(res) \n  }).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>{\n    <span class="hljs-built_in">console</span>.log(err)\n  })\n} \ninitLoad()\n</code></pre>\n<p data-nodeid="853">从上面代码中可以看出，在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 Promise.all 来实现，看起来更清晰、一目了然。</p>\n<p data-nodeid="854">下面我们再来看另一种方法。</p>\n<h4 data-nodeid="855">allSettled 方法</h4>\n<p data-nodeid="856">Promise.allSettled 的语法及参数跟 Promise.all 类似，其参数接受一个 Promise 的数组，返回一个新的 Promise。唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。</p>\n<p data-nodeid="857">我们来看一下用 allSettled 实现的一段代码。</p>\n<pre class="lang-javascript" data-nodeid="858"><code data-language="javascript"><span class="hljs-keyword">const</span> resolved = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);\n<span class="hljs-keyword">const</span> rejected = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">-1</span>);\n<span class="hljs-keyword">const</span> allSettledPromise = <span class="hljs-built_in">Promise</span>.allSettled([resolved, rejected]);\nallSettledPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(results);\n});\n<span class="hljs-comment">// 返回结果：</span>\n<span class="hljs-comment">// [</span>\n<span class="hljs-comment">//    { status: \'fulfilled\', value: 2 },</span>\n<span class="hljs-comment">//    { status: \'rejected\', reason: -1 }</span>\n<span class="hljs-comment">// ]</span>\n</code></pre>\n<p data-nodeid="859">从上面代码中可以看到，Promise.allSettled 最后返回的是一个数组，记录传进来的参数中每个 Promise 的返回值，这就是和 all 方法不太一样的地方。你也可以根据 all 方法提供的业务场景的代码进行改造，其实也能知道多个请求发出去之后，Promise 最后返回的是每个参数的最终状态。</p>\n<p data-nodeid="860">接下来看一下 any 这个方法。</p>\n<h4 data-nodeid="861">any 方法</h4>\n<p data-nodeid="862"><strong data-nodeid="950">语法：</strong> Promise.any（iterable）</p>\n<p data-nodeid="863"><strong data-nodeid="955">参数：</strong> iterable 可迭代的对象，例如 Array。</p>\n<p data-nodeid="864"><strong data-nodeid="960">描述：</strong> any 方法返回一个 Promise，只要参数 Promise 实例有一个变成 fulfilled 状态，最后 any 返回的实例就会变成 fulfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</p>\n<p data-nodeid="865">还是对上面 allSettled 这段代码进行改造，我们来看下改造完的代码和执行结果。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="4564"><code data-language="javascript"><span class="hljs-keyword">const</span> resolved = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);\n<span class="hljs-keyword">const</span> rejected = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">-1</span>);\n<span class="hljs-keyword">const</span> anyPromise = <span class="hljs-built_in">Promise</span>.any([resolved, rejected]);\nanyPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(results);\n});\n<span class="hljs-comment">// 返回结果：</span>\n<span class="hljs-comment">// 2</span>\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="867">从改造后的代码中可以看出，只要其中一个 Promise 变成 fulfilled 状态，那么 any 最后就返回这个 Promise。由于上面 resolved 这个 Promise 已经是 resolve 的了，故最后返回结果为 2。</p>\n<p data-nodeid="868">我们最后来看一下 race 方法。</p>\n<h4 data-nodeid="869">race 方法</h4>\n<p data-nodeid="870"><strong data-nodeid="969">语法：</strong> Promise.race（iterable）</p>\n<p data-nodeid="871"><strong data-nodeid="974">参数：</strong> iterable 可迭代的对象，例如 Array。</p>\n<p data-nodeid="872"><strong data-nodeid="979">描述：</strong> race 方法返回一个 Promise，只要参数的 Promise 之中有一个实例率先改变状态，则 race 方法的返回状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 race 方法的回调函数。</p>\n<p data-nodeid="873">我们来看一下这个业务场景，对于图片的加载，特别适合用 race 方法来解决，将图片请求和超时判断放到一起，用 race 来实现图片的超时判断。请看代码片段。</p>\n<pre class="lang-javascript" data-nodeid="874"><code data-language="javascript"><span class="hljs-comment">//请求某个图片资源</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestImg</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>{\n    <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();\n    img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ resolve(img); }\n    img.src = <span class="hljs-string">\'http://www.baidu.com/img/flexible/logo/pc/result.png\'</span>;\n  });\n  <span class="hljs-keyword">return</span> p;\n}\n<span class="hljs-comment">//延时函数，用于给请求计时</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>{\n    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ reject(<span class="hljs-string">\'图片请求超时\'</span>); }, <span class="hljs-number">5000</span>);\n  });\n  <span class="hljs-keyword">return</span> p;\n}\n<span class="hljs-built_in">Promise</span>.race([requestImg(), timeout()])\n.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(results);\n})\n.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(reason);\n});\n</code></pre>\n<p data-nodeid="875">从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场景。</p>\n<p data-nodeid="876">综上，这四种方法的参数传递形式基本是一致的，但是最后每个方法实现的功能还是略微有些差异的，这一点你需要留意。</p>\n<h3 data-nodeid="877">总结</h3>\n<p data-nodeid="878">好了，这一讲内容就介绍到这了。这两讲，我将 Promise 的异步编程方式带你学习了一遍，希望你能对此形成更深刻的认知。关于如何自己实现一个符合规范的 Promise，在后面的进阶课程中我会带你一步步去实现，这两讲也是为后面的实践打下基础，因此希望你能好好掌握。</p>\n<p data-nodeid="879">我最后整理了一下 Promise 的几个方法，你可以根据下面的表格再次复习。</p>\n<p data-nodeid="880"><img src="https://s0.lgstatic.com/i/image6/M01/05/09/Cgp9HWAvhLCAXDoCAAETMiO3QTA853.png" alt="Drawing 2.png" data-nodeid="988"></p>\n<p data-nodeid="881">在后续的课程中，我还会继续对 JS 异步编程的知识点进行更详细的剖析，你要及时发现自身的不足，有针对性地学习薄弱的知识。</p>\n<p data-nodeid="882" class="">下一讲，我们来聊聊 Generator 和 async/await，这些语法糖也是你需要掌握的内容。我们到时见。</p>',
          },
          {
            theme:
              '15 | 异步编程（下）：如何理解 Generator、Async/await 等异步编程的语法糖？',
            id: 116,
            content:
              '<p data-nodeid="645" class="">前两讲我们探讨了 JS 异步编程以及其中 Promise 的编程方式，那么这一讲作为延续，我再带你了解另外两种异步编程的方式。Generator 是 ES6 标准中的异步编程方式，而 async/await 是 ES7 标准中的。希望通过本讲的学习，你能对这两种编程方式有更深的理解。</p>\n<p data-nodeid="646">那么在课程开始前请你先思考一下：</p>\n<ol data-nodeid="647">\n<li data-nodeid="648">\n<p data-nodeid="649">Generator 执行之后，最后返回的是什么？</p>\n</li>\n<li data-nodeid="650">\n<p data-nodeid="651">async/await 的方式比 Promise 和 Generator 好在哪里？</p>\n</li>\n</ol>\n<p data-nodeid="652">现在让我们带着思考，开始学习。</p>\n<h3 data-nodeid="653">Generator 基本介绍</h3>\n<p data-nodeid="654">Generator（生成器）是 ES6 的新关键词，学习起来比较晦涩难懂，那么什么是 Generator 的函数呢？通俗来讲 Generator 是一个带星号的“函数”（它并不是真正的函数，下面的代码会为你验证），可以配合 yield 关键字来暂停或者执行函数。我们来看一段使用 Generator 的代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="655"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"enter"</span>);\n  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">yield</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>})();\n  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;\n}\n<span class="hljs-keyword">var</span> g = gen()           <span class="hljs-comment">// 阻塞住，不会执行任何语句</span>\n<span class="hljs-built_in">console</span>.log(g.next())\n<span class="hljs-built_in">console</span>.log(g.next())\n<span class="hljs-built_in">console</span>.log(g.next())\n<span class="hljs-built_in">console</span>.log(g.next()) \n<span class="hljs-comment">//&nbsp;output:</span>\n<span class="hljs-comment">// { value: 1, done: false }</span>\n<span class="hljs-comment">// { value: 2, done: false }</span>\n<span class="hljs-comment">// { value: 3, done: true }</span>\n<span class="hljs-comment">// { value: undefined, done: true }</span>\n</code></pre>\n<p data-nodeid="656">结合上面的代码，我们分析一下 Generator 函数的执行情况。Generator 中配合使用 yield 关键词可以控制函数执行的顺序，每当执行一次 next 方法，Generator 函数会执行到下一个存在 yield 关键词的位置。</p>\n<p data-nodeid="657">总结下来，Generator 的执行有这几个关键点。</p>\n<ol data-nodeid="658">\n<li data-nodeid="659">\n<p data-nodeid="660">调用 gen() 后，程序会阻塞住，不会执行任何语句。</p>\n</li>\n<li data-nodeid="661">\n<p data-nodeid="662">调用 g.next() 后，程序继续执行，直到遇到 yield 关键词时执行暂停。</p>\n</li>\n<li data-nodeid="663">\n<p data-nodeid="664">一直执行 next 方法，最后返回一个对象，其存在两个属性：value&nbsp;和&nbsp;done。</p>\n</li>\n</ol>\n<p data-nodeid="665">这就是 Generator 的基本内容，其中提到了 yield 这个关键词，下面我们就来看看它的基本情况。</p>\n<h3 data-nodeid="666">yield基本介绍</h3>\n<p data-nodeid="667">yield 同样也是 ES6 的新关键词，配合 Generator 执行以及暂停。yield 关键词最后返回一个迭代器对象，该对象有 value 和 done 两个属性，其中 done 属性代表返回值以及是否完成。yield 配合着 Generator，再同时使用 next 方法，可以主动控制 Generator 执行进度。</p>\n<p data-nodeid="668">前面说 Generator 的时候，我举的是一个生成器函数的示例，下面我们看看多个 Generator 配合 yield 使用的情况，请看下面一段代码。</p>\n<pre class="lang-java" data-nodeid="669"><code data-language="java">function* gen1() {\n    yield <span class="hljs-number">1</span>;\n    yield* gen2();\n    yield <span class="hljs-number">4</span>;\n}\nfunction* gen2() {\n    yield <span class="hljs-number">2</span>;\n    yield <span class="hljs-number">3</span>;\n}\n<span class="hljs-keyword">var</span> g = gen1();\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\n<span class="hljs-comment">// output:</span>\n<span class="hljs-comment">// { value: 1, done: false }</span>\n<span class="hljs-comment">// { value: 2, done: false }</span>\n<span class="hljs-comment">// { value: 3, done: false }</span>\n<span class="hljs-comment">// { value: 4, done: false }</span>\n<span class="hljs-comment">// {value: undefined, done: true}</span>\n</code></pre>\n<p data-nodeid="670">从上面的代码中可以看出，使用 yield 关键词的话还可以配合着 Generator 函数嵌套使用，从而控制函数执行进度。这样对于 Generator 的使用，以及最终函数的执行进度都可以很好地控制，从而形成符合你设想的执行顺序。即便 Generator 函数相互嵌套，也能通过调用 next 方法来按照进度一步步执行。</p>\n<p data-nodeid="671">那么讲到这里你可能会有几个疑惑，Generator 和异步编程有什么联系？怎么才可以把 Generator 函数按照顺序一次性执行完呢？接着往下看，你就会明白了。</p>\n<h3 data-nodeid="672">thunk 函数介绍</h3>\n<p data-nodeid="673">下面我带你看一下 thunk 函数，直接说概念可能会有些晦涩，我们通过一段代码来了解一下什么是 thunk 函数，就拿判断数据类型来举例，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="674"><code data-language="javascript"><span class="hljs-keyword">let</span> isString = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">\'[object String]\'</span>;\n};\n<span class="hljs-keyword">let</span> isFunction = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">\'[object Function]\'</span>;\n};\n<span class="hljs-keyword">let</span> isArray = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">\'[object Array]\'</span>;\n};\n....\n</code></pre>\n<p data-nodeid="675">可以看到，其中出现了非常多重复的数据类型判断逻辑，平常业务开发中类似的重复逻辑的场景也同样会有很多。我们将它们做一下封装，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="676"><code data-language="javascript"><span class="hljs-keyword">let</span> isType = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">`[object <span class="hljs-subst">${type}</span>]`</span>;\n  }\n}\n</code></pre>\n<p data-nodeid="677">那么封装了之后我们可以这么来使用，从而来减少重复的逻辑代码，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="678"><code data-language="javascript"><span class="hljs-keyword">let</span> isString = isType(<span class="hljs-string">\'String\'</span>);\n<span class="hljs-keyword">let</span> isArray = isType(<span class="hljs-string">\'Array\'</span>);\nisString(<span class="hljs-string">"123"</span>);    <span class="hljs-comment">// true</span>\nisArray([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);   <span class="hljs-comment">// true</span>\n</code></pre>\n<p data-nodeid="679">相应的&nbsp;isString 和 isArray 是由 isType 方法生产出来的函数，通过上面的方式来改造代码，明显简洁了不少。像 isType 这样的函数我们称为 thunk 函数，它的基本思路都是接收一定的参数，会生产出定制化的函数，最后使用定制化的函数去完成想要实现的功能。</p>\n<p data-nodeid="680">这样的函数在 JS 的编程过程中会遇到很多，尤其是你在阅读一些开源项目时，抽象度比较高的 JS 代码往往都会采用这样的方式。</p>\n<p data-nodeid="681">那么请你想一下，Generator 和 thunk 函数的结合是否能为我们带来一定的便捷性呢？</p>\n<h3 data-nodeid="682">Generator 和 thunk 结合</h3>\n<p data-nodeid="683">下面我以文件操作的代码为例，看一下 Generator 和 thunk 的结合能够对异步操作产生什么样的效果。</p>\n<pre class="lang-javascript" data-nodeid="684"><code data-language="javascript"><span class="hljs-keyword">const</span> readFileThunk = <span class="hljs-function">(<span class="hljs-params">filename</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> {\n    fs.readFile(filename, callback);\n  }\n}\n<span class="hljs-keyword">const</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">yield</span> readFileThunk(<span class="hljs-string">\'1.txt\'</span>)\n  <span class="hljs-built_in">console</span>.log(data1.toString())\n  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">yield</span> readFileThunk(<span class="hljs-string">\'2.txt\'</span>)\n  <span class="hljs-built_in">console</span>.log(data2.toString)\n}\n<span class="hljs-keyword">let</span> g = gen();\ng.next().value(<span class="hljs-function">(<span class="hljs-params">err, data1</span>) =&gt;</span> {\n  g.next(data1).value(<span class="hljs-function">(<span class="hljs-params">err, data2</span>) =&gt;</span> {\n    g.next(data2);\n  })\n})\n</code></pre>\n<p data-nodeid="685">readFileThunk 就是一个 thunk 函数，上面的这种编程方式就让&nbsp;Generator&nbsp;和异步操作关联起来了。上面第三段代码执行起来嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可读性不强，因此我们有必要把执行的代码封装优化一下，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="686"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">gen</span>)</span>{\n  <span class="hljs-keyword">const</span> next = <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {\n    <span class="hljs-keyword">let</span> res = gen.next(data);\n    <span class="hljs-keyword">if</span>(res.done) <span class="hljs-keyword">return</span>;\n    res.value(next);\n  }\n  next();\n}\nrun(g);\n</code></pre>\n<p data-nodeid="687">改造完之后，我们可以看到 run 函数和上面的执行效果其实是一样的。代码虽然只有几行，但其包含了递归的过程，解决了多层嵌套的问题，并且完成了异步操作的一次性的执行效果。这就是通过 thunk 函数完成异步操作的情况，你可以好好体会一下。</p>\n<p data-nodeid="688">以上介绍了 Generator 和 thunk 结合的情况，其实 Promise 也可以和 Generator 配合，以实现上面的效果，下面我们来看一下这种情况。</p>\n<h3 data-nodeid="689">Generator 和 Promise 结合</h3>\n<p data-nodeid="690">还是利用上面的输出文件的例子，对代码进行改造，如下所示。</p>\n<pre class="lang-javascript te-preview-highlight" data-nodeid="1129"><code data-language="javascript"><span class="hljs-comment">// 最后包装成 Promise 对象进行返回</span>\n<span class="hljs-keyword">const</span> readFilePromise = <span class="hljs-function">(<span class="hljs-params">filename</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    fs.readFile(filename, (err, data) =&gt; {\n      <span class="hljs-keyword">if</span>(err) {\n        reject(err);\n      }<span class="hljs-keyword">else</span> {\n        resolve(data);\n      }\n    })\n  }).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res);\n}\n <span class="hljs-keyword">let</span> g = gen();\n<span class="hljs-comment">// 这块和上面 thunk 的方式一样</span>\n<span class="hljs-keyword">const</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">yield</span> readFilePromise(<span class="hljs-string">\'1.txt\'</span>)\n  <span class="hljs-built_in">console</span>.log(data1.toString())\n  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">yield</span> readFilePromise(<span class="hljs-string">\'2.txt\'</span>)\n  <span class="hljs-built_in">console</span>.log(data2.toString)\n}\n<span class="hljs-comment">// 这块和上面 thunk 的方式一样</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">gen</span>)</span>{\n  <span class="hljs-keyword">const</span> next = <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {\n    <span class="hljs-keyword">let</span> res = gen.next(data);\n    <span class="hljs-keyword">if</span>(res.done) <span class="hljs-keyword">return</span>;\n    res.value.then(next);\n  }\n  next();\n}\nrun(g);\n</code></pre>\n\n\n<p data-nodeid="692">从上面的代码可以看出，thunk 函数的方式和通过 Promise 方式执行效果本质上是一样的，只不过通过 Promise 的方式也可以配合 Generator 函数实现同样的异步操作。希望你能参照上面 thunk 的例子，仔细体会一下递归调用的过程。</p>\n<h3 data-nodeid="693">co 函数库</h3>\n<p data-nodeid="694">co 函数库是著名程序员 TJ 发布的一个小工具，用于处理 Generator 函数的自动执行。核心原理其实就是上面讲的通过和 thunk 函数以及 Promise 对象进行配合，包装成一个库。它使用起来非常简单，比如还是用上面那段代码，第三段代码就可以省略了，直接引用 co 函数，包装起来就可以使用了，代码如下。</p>\n<pre class="lang-java" data-nodeid="695"><code data-language="java"><span class="hljs-keyword">const</span> co = require(<span class="hljs-string">\'co\'</span>);\nlet g = gen();\nco(g).then(res =&gt;{\n  console.log(res);\n})\n</code></pre>\n<p data-nodeid="696">这段代码比较简单，几行就完成了之前写的递归的那些操作。那么为什么 co 函数库可以自动执行 Generator 函数，它的处理原理是什么呢？</p>\n<ol data-nodeid="697">\n<li data-nodeid="698">\n<p data-nodeid="699">因为 Generator 函数就是一个异步操作的容器，它需要一种自动执行机制，co 函数接受 Generator 函数作为参数，并最后返回一个 Promise 对象。</p>\n</li>\n<li data-nodeid="700">\n<p data-nodeid="701">在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数；如果不是就返回，并将 Promise 对象的状态改为 resolved。</p>\n</li>\n<li data-nodeid="702">\n<p data-nodeid="703">co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。</p>\n</li>\n<li data-nodeid="704">\n<p data-nodeid="705">关键的是 next 函数，它会反复调用自身。</p>\n</li>\n</ol>\n<p data-nodeid="706">关于 co 的内部原理，你可以去 <a href="https://github.com/tj/co/blob/master/index.js" data-nodeid="776">co 的源码库</a>学习。代码不是很多，也比较清晰，按照上面我所讲的思路，你可以试着去理解，这对于提升你的 JavaScript 编码能力是很有帮助的。</p>\n<p data-nodeid="707">那么，说完了 co 函数库，我们最后就来探究异步编程的终极解决方案：async/await。</p>\n<h3 data-nodeid="708">async/await 介绍</h3>\n<p data-nodeid="709">JS 的异步编程从最开始的回调函数的方式，演化到使用 Promise 对象，再到 Generator+co 函数的方式，每次都有一些改变，但又让人觉得不彻底，都需要理解底层运行机制。</p>\n<p data-nodeid="710">而 async/await 被称为 JS 中异步终极解决方案，它既能够像 co+Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无须借助任何第三方库。</p>\n<p data-nodeid="711">接下来，我们就从原理的角度来看看 async/await 这个语法糖背后到底做了哪些优化和改进，使得我们用起来会更加方便。还是按照上面 Generator 和 Promise 结合的例子，使用 async/await 语法糖来进行改造，请看改造后的代码。</p>\n<pre class="lang-javascript" data-nodeid="712"><code data-language="javascript"><span class="hljs-comment">// readFilePromise 依旧返回 Promise 对象</span>\n<span class="hljs-keyword">const</span> readFilePromise = <span class="hljs-function">(<span class="hljs-params">filename</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    fs.readFile(filename, (err, data) =&gt; {\n      <span class="hljs-keyword">if</span>(err) {\n        reject(err);\n      }<span class="hljs-keyword">else</span> {\n        resolve(data);\n      }\n    })\n  }).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res);\n}\n<span class="hljs-comment">// 这里把 Generator的 * 换成 async，把 yield 换成 await</span>\n<span class="hljs-keyword">const</span> gen = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">await</span> readFilePromise(<span class="hljs-string">\'1.txt\'</span>)\n  <span class="hljs-built_in">console</span>.log(data1.toString())\n  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">await</span> readFilePromise(<span class="hljs-string">\'2.txt\'</span>)\n  <span class="hljs-built_in">console</span>.log(data2.toString)\n}\n</code></pre>\n<p data-nodeid="713">从上面的代码中可以看到，虽然我们简单地将 Generator 的 * 号换成了 async，把 yield 换成了 await，但其实 async 的内部做了不少工作。我们根据 async 的原理详细拆解一下，看看它到底做了哪些工作。</p>\n<p data-nodeid="714">总结下来，async 函数对 Generator 函数的改进，主要体现在以下三点。</p>\n<ol data-nodeid="715">\n<li data-nodeid="716">\n<p data-nodeid="717">内置执行器：Generator 函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co 函数库。但是，async 函数和正常的函数一样执行，也不用 co 函数库，也不用使用 next 方法，而 async 函数自带执行器，会自动执行。</p>\n</li>\n<li data-nodeid="718">\n<p data-nodeid="719">适用性更好：co 函数库有条件约束，yield 命令后面只能是 Thunk 函数或 Promise 对象，但是 async 函数的 await 关键词后面，可以不受约束。</p>\n</li>\n<li data-nodeid="720">\n<p data-nodeid="721">可读性更好：async 和 await，比起使用 * 号和 yield，语义更清晰明了。</p>\n</li>\n</ol>\n<p data-nodeid="722">说了这么多优点，我们还是通过一段简单的代码来看下 async 返回的结果，是不是使用起来更方便，请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="723"><code data-language="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;\n}\n<span class="hljs-built_in">console</span>.log(func());\n<span class="hljs-comment">// Promise {&lt;fulfilled&gt;: 100}</span>\n</code></pre>\n<p data-nodeid="724">从执行的结果可以看出，async 函数 func 最后返回的结果直接是 Promise 对象，比较方便让开发者继续往后处理。而之前 Generator 并不会自动执行，需要通过 next 方法控制，最后返回的也并不是 Promise 对象，而是需要通过 co 函数库来实现最后返回 Promise 对象。</p>\n<p data-nodeid="725">这样看来，ES7 加入的 async/await 的确解决了之前的问题，使开发者在编程过程中更容易理解，语法更清晰，并且也不用再单独引用 co 函数库了。因此用 async/await 写出的代码也更加优雅，相比于之前的 Promise 和 co+Generator 的方式更容易理解，上手成本也更低，不愧是 JS 异步的终极解决方案。</p>\n<p data-nodeid="726"><img src="https://s0.lgstatic.com/i/image6/M00/08/76/Cgp9HWA0wYmAKbOFAAVCoaU0ifI951.png" alt="金句1.png" data-nodeid="797"></p>\n<h3 data-nodeid="727">总结</h3>\n<p data-nodeid="728">这一讲，我带你把 Generator 以及 async/await 的异步编程方式学习了一遍，希望通过上面的介绍，你能够对 JS 异步编程理解更深一些。</p>\n<p data-nodeid="729">最后，我整理了这几个异步编程的特点，你可以对比着来回顾，以加深记忆，请看下面的表格。</p>\n<p data-nodeid="730"><img src="https://s0.lgstatic.com/i/image6/M01/08/70/Cgp9HWA0vFyAfpfGAAGGpm0z-f8269.png" alt="图片6.png" data-nodeid="803"></p>\n<p data-nodeid="731">现在你可以回过头思考我在这一讲开头提出的两个问题了，是不是比较容易回答出来了呢？如果你对这部分内容还有不清楚的地方，可以有针对性地去学习。</p>\n<p data-nodeid="732" class="">后面，我会继续带着你对 JS 异步编程的知识点进行更深入的剖析，下一讲我们就进入 EventEmitter 的学习，它是结合着设计模式实现 JS 异步编程的一种思路，也是值得深入研究和学习的。</p>',
          },
          {
            theme: '16 | 进阶练习（上）：怎样轻松实现一个 EventEmitter？',
            id: 117,
            content:
              '<p data-nodeid="889" class="">前两讲我们探讨了 JS 异步编程中 Generator 和 async/await 的相关内容，那么这一讲我们就进入 Node.js 的 events 模块以及 EventEmitter 的学习，并且我将带你在浏览器端实现一遍它的底层逻辑。</p>\n<p data-nodeid="890">之所以要特地讲解这部分知识，是因为虽然严格意义上来说，events 模块属于 Node.js 服务端的知识，但是由于大多数 Node.js 核心 API 构建用的是异步事件驱动架构，因此这里单独加了一讲来带你学习这部分内容。我希望通过这一讲的学习，你能够自己实现一个EventEmitter。</p>\n<p data-nodeid="891">那么，在课程开始前请你先思考几个问题：</p>\n<ol data-nodeid="892">\n<li data-nodeid="893">\n<p data-nodeid="894">EventEmitter 采用什么样的设计模式？</p>\n</li>\n<li data-nodeid="895">\n<p data-nodeid="896">EventEmitter 常用的API 是怎样实现的？</p>\n</li>\n</ol>\n<h3 data-nodeid="897">Events 基本介绍</h3>\n<p data-nodeid="898">你或多或少会了解一些 Node.js 相关的知识，应该知道Node.js 里面有很多模块，其中 events 就是比较重要的一个模块。</p>\n<p data-nodeid="899">Node.js的events 模块对外提供了一个 EventEmitter 对象，用于对 Node.js 中的事件进行统一管理。因为 Node.js 采用了事件驱动机制，而 EventEmitter 就是 Node.js 实现事件驱动的基础。在 EventEmitter 的基础上，Node.js 中几乎所有的模块都继承了这个类，以实现异步事件驱动架构。</p>\n<p data-nodeid="900">为了让你对此有一个大概的了解，我们先来看下 EventEmitter的简单使用情况，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="901"><code data-language="javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">var</span> eventEmitter = <span class="hljs-keyword">new</span> events.EventEmitter();\neventEmitter.on(<span class="hljs-string">\'say\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Hello\'</span>,name);\n})\neventEmitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'Jonh\'</span>);\n</code></pre>\n<p data-nodeid="902">以上代码中，新定义的eventEmitter 是接收 events.EventEmitter 模块 new 之后返回的一个实例，eventEmitter 的 emit 方法，发出 say 事件，通过 eventEmitter 的 on 方法监听，从而执行相应的函数。</p>\n<p data-nodeid="903" class="">这就是 Node.js的events 模块中 EventEmitter 的基本用法，下面来说说 EventEmitter 的各种方法以及功能的介绍。</p>\n<h3 data-nodeid="904" class="">常用的 EventEmitter 模块的 API</h3>\n<p data-nodeid="2177">除了上面的那段代码中已经使用的 on 和emit 这两个 API，EventEmitter还提供了其他的 API 方法，我通过一个表格简单整理了一下对应的方法和功能总结。</p>\n<p data-nodeid="2178" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/0E/14/Cgp9HWA8LMiAEVlGAAJEpecSYyo071.png" alt="图片1.png" data-nodeid="2182"></p>\n\n\n<p data-nodeid="1511">除此之外，还有两个特殊的事件，不需要额外手动添加，下表所示的就是 Node.js 的 EventEmitter 模块自带的特殊事件。</p>\n<p data-nodeid="1512" class=""><img src="https://s0.lgstatic.com/i/image6/M01/0E/14/Cgp9HWA8LLaAdnhdAADOmTg9zw8428.png" alt="图片2.png" data-nodeid="1516"></p>\n\n\n<p data-nodeid="963">从上面的表格可以看出，Node.js的EventEmitter 模块看起来方法很多且复杂，但通过仔细学习，其实其使用和实现并不困难。下面我就来挑几个比较重要 API 方法为你进行讲解。</p>\n<h4 data-nodeid="964">addListener 和 removeListener、on 和 off 方法对比</h4>\n<p data-nodeid="965">addListener 方法的作用是为指定事件添加一个监听器，其实和 on 方法实现的功能是一样的，on 其实就是 addListener 方法的一个别名。二者实现的作用是一样的，同时 removeListener 方法的作用是为移除某个事件的监听器，同样 off 也是 removeListener 的别名。</p>\n<p data-nodeid="966">下面我们来看看addListener 和removeListener 的用法，请看下面一段示例代码。</p>\n<pre class="lang-javascript" data-nodeid="967"><code data-language="javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.EventEmitter();\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello1</span>(<span class="hljs-params">name</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello 1"</span>,name);\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello2</span>(<span class="hljs-params">name</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello 2"</span>,name);\n}\nemitter.addListener(<span class="hljs-string">\'say\'</span>,hello1);\nemitter.addListener(<span class="hljs-string">\'say\'</span>,hello2);\nemitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'John\'</span>);\n<span class="hljs-comment">//输出hello 1 John </span>\n<span class="hljs-comment">//输出hello 2 John</span>\nemitter.removeListener(<span class="hljs-string">\'say\'</span>,hello1);\nemitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'John\'</span>);\n<span class="hljs-comment">//相应的，监听say事件的hello1事件被移除</span>\n<span class="hljs-comment">//只输出hello 2 John</span>\n</code></pre>\n<p data-nodeid="968">结合代码和注释来理解我上面的描述，是不是对于 addListener 和 removeListener、on 和 off 这两组方法的对比就一目了然了呢？下面我再来说说 removeListener 和 removeAllListeners 的对比。</p>\n<h4 data-nodeid="969">removeListener 和 removeAllListeners</h4>\n<p data-nodeid="970">removeListener 方法是指移除一个指定事件的某一个监听器，而 removeAllListeners 指的是移除某一个指定事件的全部监听器。</p>\n<p data-nodeid="971">这里举一个removeAllListeners 的代码例子，请看。</p>\n<pre class="lang-javascript" data-nodeid="972"><code data-language="javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.EventEmitter();\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello1</span>(<span class="hljs-params">name</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello 1"</span>,name);\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello2</span>(<span class="hljs-params">name</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello 2"</span>,name);\n}\nemitter.addListener(<span class="hljs-string">\'say\'</span>,hello1);\nemitter.addListener(<span class="hljs-string">\'say\'</span>,hello2);\nemitter.removeAllListeners(<span class="hljs-string">\'say\'</span>);\nemitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'John\'</span>);\n<span class="hljs-comment">//removeAllListeners 移除了所有关于 say 事件的监听</span>\n<span class="hljs-comment">//因此没有任何输出</span>\n</code></pre>\n<p data-nodeid="973">同样的，这两者的对比，通过代码和注释也比较好理解。</p>\n<h4 data-nodeid="974">on 和 once 方法区别</h4>\n<p data-nodeid="975">on 和 once 的区别是：on 的方法对于某一指定事件添加的监听器可以持续不断地监听相应的事件；而 once 方法添加的监听器，监听一次后，就会被消除。</p>\n<p data-nodeid="976">看一下这段代码，你就会明白了。</p>\n<pre class="lang-javascript" data-nodeid="977"><code data-language="javascript"><span class="hljs-keyword">var</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">var</span> emitter = <span class="hljs-keyword">new</span> events.EventEmitter();\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">name</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>,name);\n}\nemitter.on(<span class="hljs-string">\'say\'</span>,hello);\nemitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'John\'</span>);\nemitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'Lily\'</span>);\nemitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'Lucy\'</span>);\n<span class="hljs-comment">//会输出 hello John、hello Lily、hello Lucy，之后还要加也可以继续触发</span>\nemitter.once(<span class="hljs-string">\'see\'</span>,hello);\nemitter.emit(<span class="hljs-string">\'see\'</span>,<span class="hljs-string">\'Tom\'</span>);\n<span class="hljs-comment">//只会输出一次 hello Tom</span>\n</code></pre>\n<p data-nodeid="978">也就是说，on 方法监听的事件，可以持续不断地被触发，而 once 方法只会触发一次。</p>\n<p data-nodeid="979">讲到这里，你已经基本熟悉了Node.js 下的 EventEmitter 的基本情况。那么如果在浏览器端，我们想实现一个 EventEmitter 方法，应该用什么样的思路呢？请你再往下看。</p>\n<h3 data-nodeid="980">带你实现一个 EventEmitter</h3>\n<p data-nodeid="981">从上面的讲解中可以看到，EventEmitter 是在Node.js 中 events 模块里封装的，那么在浏览器端实现一个这样的 EventEmitter 是否可以呢？其实自己封装一个能在浏览器中跑的EventEmitter，并应用在你的业务代码中还是能带来不少方便的，它可以帮你实现自定义事件的订阅和发布，从而提升业务开发的便利性。</p>\n<p data-nodeid="982">那么结合上面介绍的内容，我们一起来实现一个基础版本的EventEmitter，包含基础的on、 of、emit、once、allof 这几个方法。</p>\n<p data-nodeid="983">首先，请你看一下 EventEmitter的初始化代码。</p>\n<pre class="lang-javascript" data-nodeid="984"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventEmitter</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.__events = {}\n}\nEventEmitter.VERSION = <span class="hljs-string">\'1.0.0\'</span>;\n</code></pre>\n<p data-nodeid="985">从上面的代码中可以看到，我们先初始化了一个内部的__events 的对象，用来存放自定义事件，以及自定义事件的回调函数。</p>\n<p data-nodeid="986">其次，我们来看看如何实现 EventEmitter的 on 的方法，请看下面的代码。</p>\n<pre class="lang-javascript" data-nodeid="987"><code data-language="javascript">EventEmitter.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, listener</span>)</span>{\n\t  <span class="hljs-keyword">if</span> (!eventName || !listener) <span class="hljs-keyword">return</span>;\n      <span class="hljs-comment">// 判断回调的 listener 是否为函数</span>\n\t  <span class="hljs-keyword">if</span> (!isValidListener(listener)) {\n\t       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">\'listener must be a function\'</span>);\n\t  }\n\t   <span class="hljs-keyword">var</span> events = <span class="hljs-keyword">this</span>.__events;\n\t   <span class="hljs-keyword">var</span> listeners = events[eventName] = events[eventName] || [];\n\t   <span class="hljs-keyword">var</span> listenerIsWrapped = <span class="hljs-keyword">typeof</span> listener === <span class="hljs-string">\'object\'</span>;\n       <span class="hljs-comment">// 不重复添加事件，判断是否有一样的</span>\n       <span class="hljs-keyword">if</span> (indexOf(listeners, listener) === <span class="hljs-number">-1</span>) {\n           listeners.push(listenerIsWrapped ? listener : {\n               <span class="hljs-attr">listener</span>: listener,\n               <span class="hljs-attr">once</span>: <span class="hljs-literal">false</span>\n           });\n       }\n\t   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n};\n<span class="hljs-comment">// 判断是否是合法的 listener</span>\n <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidListener</span>(<span class="hljs-params">listener</span>) </span>{\n     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> listener === <span class="hljs-string">\'function\'</span>) {\n         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n     } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (listener &amp;&amp; <span class="hljs-keyword">typeof</span> listener === <span class="hljs-string">\'object\'</span>) {\n         <span class="hljs-keyword">return</span> isValidListener(listener.listener);\n     } <span class="hljs-keyword">else</span> {\n         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n     }\n}\n<span class="hljs-comment">// 顾名思义，判断新增自定义事件是否存在</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOf</span>(<span class="hljs-params">array, item</span>) </span>{\n     <span class="hljs-keyword">var</span> result = <span class="hljs-number">-1</span>\n     item = <span class="hljs-keyword">typeof</span> item === <span class="hljs-string">\'object\'</span> ? item.listener : item;\n     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = array.length; i &lt; len; i++) {\n         <span class="hljs-keyword">if</span> (array[i].listener === item) {\n             result = i;\n             <span class="hljs-keyword">break</span>;\n         }\n     }\n     <span class="hljs-keyword">return</span> result;\n}\n</code></pre>\n<p data-nodeid="988">从上面的代码中可以看出，on 方法的核心思路就是，当调用订阅一个自定义事件的时候，只要该事件通过校验合法之后，就把该自定义事件 push 到 this.__events 这个对象中存储，等需要出发的时候，则直接从通过获取 __events 中对应事件的 listener 回调函数，而后直接执行该回调方法就能实现想要的效果。</p>\n<p data-nodeid="989">然后，我们再看看 emit 方法是怎么实现触发效果的，请看下面的代码实现逻辑。</p>\n<pre class="lang-javascript" data-nodeid="990"><code data-language="javascript">EventEmitter.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, args</span>) </span>{\n     <span class="hljs-comment">// 直接通过内部对象获取对应自定义事件的回调函数</span>\n     <span class="hljs-keyword">var</span> listeners = <span class="hljs-keyword">this</span>.__events[eventName];\n     <span class="hljs-keyword">if</span> (!listeners) <span class="hljs-keyword">return</span>;\n     <span class="hljs-comment">// 需要考虑多个 listener 的情况</span>\n     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {\n         <span class="hljs-keyword">var</span> listener = listeners[i];\n         <span class="hljs-keyword">if</span> (listener) {\n             listener.listener.apply(<span class="hljs-keyword">this</span>, args || []);\n             <span class="hljs-comment">// 给 listener 中 once 为 true 的进行特殊处理</span>\n             <span class="hljs-keyword">if</span> (listener.once) {\n                 <span class="hljs-keyword">this</span>.off(eventName, listener.listener)\n             }\n         }\n     }\n     <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n};\n\nEventEmitter.prototype.off = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, listener</span>) </span>{\n     <span class="hljs-keyword">var</span> listeners = <span class="hljs-keyword">this</span>.__events[eventName];\n     <span class="hljs-keyword">if</span> (!listeners) <span class="hljs-keyword">return</span>;\n     <span class="hljs-keyword">var</span> index;\n     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = listeners.length; i &lt; len; i++) {\n\t    <span class="hljs-keyword">if</span> (listeners[i] &amp;&amp; listeners[i].listener === listener) {\n           index = i;\n           <span class="hljs-keyword">break</span>;\n        }\n    }\n    <span class="hljs-comment">// off 的关键</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> index !== <span class="hljs-string">\'undefined\'</span>) {\n         listeners.splice(index, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>)\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n};\n</code></pre>\n<p data-nodeid="991">从上面的代码中可以看出 emit 的处理方式，其实就是拿到对应自定义事件进行 apply 执行，在执行过程中对于一开始 once 方法绑定的自定义事件进行特殊的处理，当once 为 true的时候，再触发 off 方法对该自定义事件进行解绑，从而实现自定义事件一次执行的效果。</p>\n<p data-nodeid="992">最后，我们再看下 once 方法和 alloff的实现。</p>\n<pre class="lang-javascript" data-nodeid="993"><code data-language="javascript">EventEmitter.prototype.once = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, listener）{\n    <span class="hljs-regexp">//</span> 直接调用 on 方法，once 参数传入 true，待执行之后进行 once 处理\n     return this.on(eventName, {\n         listener: listener,\n         once: true\n     }</span>)\n };\n<span class="hljs-title">EventEmitter</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">allOff</span> = <span class="hljs-title">function</span>(<span class="hljs-params">eventName</span>) </span>{\n     <span class="hljs-comment">// 如果该 eventName 存在，则将其对应的 listeners 的数组直接清空</span>\n     <span class="hljs-keyword">if</span> (eventName &amp;&amp; <span class="hljs-keyword">this</span>.__events[eventName]) {\n         <span class="hljs-keyword">this</span>.__events[eventName] = []\n     } <span class="hljs-keyword">else</span> {\n         <span class="hljs-keyword">this</span>.__events = {}\n     }\n};\n</code></pre>\n<p data-nodeid="994">从上面的代码中可以看到，once 方法的本质还是调用 on 方法，只不过传入的参数区分和非一次执行的情况。当再次触发 emit 方法的时候，once 绑定的执行一次之后再进行解绑。</p>\n<p data-nodeid="995">这样，alloff 方法也很好理解了，其实就是对内部的__events 对象进行清空，清空之后如果再次触发自定义事件，也就无法触发回调函数了。</p>\n<p data-nodeid="996">到这里，浏览器端的EventEmitter的基础版本就基本实现了，如果你对其他方法有兴趣，也可以尝试在上面基础版本的基础上进行扩展和添加。</p>\n<h3 data-nodeid="997">总结</h3>\n<p data-nodeid="998">这一讲，我把 EventEmitter 相关知识点带你梳理了一遍，并且最后也带你实现了一个浏览器端的EventEmitter。</p>\n<p data-nodeid="999">现在，你可以回过头思考一下我在开篇提到的问题：EventEmitter 采用的是什么样的设计模式？其实通过上面的学习你不难发现，EventEmitter 采用的正是发布-订阅模式。</p>\n<p data-nodeid="1000">另外，观察者模式和发布-订阅模式有些类似的地方，但是在细节方面还是有一些区别的，你要注意别把这两个模式搞混了。发布-订阅模式其实是观察者模式的一种变形，区别在于：<strong data-nodeid="1108">发布-订阅模式在观察者模式的基础上，在目标和观察者之间增加了一个调度中心</strong>。</p>\n<p data-nodeid="1001">通过这一学习，你应该基本能实现一个 EventEmitter 了。单就浏览器端使用场景来说，其实也有运用同样的思路解决问题的工具，在 Vue 框架中不同组件之间的通讯里，有一种解决方案叫 EventBus。和 EventEmitter的思路类似，它的基本用途是将 EventBus 作为组件传递数据的桥梁，所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所有组件都可以收到通知，使用起来非常便利，其核心其实就是发布-订阅模式的落地实现。</p>\n<p data-nodeid="1002" class="">好了，这一讲就先探讨到这，下一讲我们将继续进阶，带你实现一个符合规范的Promise。同时希望你能自己手动实现一遍代码，也欢迎你留言提出自己在学习过程中遇到的困惑，以及学习感悟等，让我们共同进步。</p>',
          },
          {
            theme: '16 | 进阶练习（上）：怎样轻松实现一个 EventEmitter？',
            id: 118,
            content:
              '<p data-nodeid="38688">我在上一讲带你实现了一个浏览器端的 EventEmitter，那么这一讲还是继续进阶，我们来实现一个符合 Promise/A+ 规范的 Promise。</p>\n<p data-nodeid="38689">其实在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6187" data-nodeid="38787">14 | 异步编程（中）：如何深入理解异步编程的核心 Promise</a>”中，我已经专门介绍了 Promise 的基本原理和使用情况。由于 Promise 在异步编程中的重要性不言而喻，因此在很多互联网大厂面试中，现场实现 Promise 相关方法的题目经常会出现，比如 all、race 或者 any 等。</p>\n<p data-nodeid="38690">因此这一讲，我将要带你一步步实现一个符合标准的 Promise，希望你在遇到相关题目时能够游刃有余。</p>\n<p data-nodeid="38691">在课程开始前请你先思考一下：</p>\n<ol data-nodeid="38692">\n<li data-nodeid="38693">\n<p data-nodeid="38694">Promise/A+ 约定了哪些规范？</p>\n</li>\n<li data-nodeid="38695">\n<p data-nodeid="38696">在手动实现 Promise 的过程中都遇到过哪些问题？</p>\n</li>\n</ol>\n<p data-nodeid="38697">在开始手动实现 Promise 之前，你有必要先了解 Promise/A+ 的规范。</p>\n<h3 data-nodeid="38698">Promise/A+ 规范</h3>\n<p data-nodeid="38699">只有对规范进行解读并且形成明确的认知，才能更好地实现 Promise。官方的地址为：<a href="https://promisesaplus.com/" data-nodeid="38798">https://promisesaplus.com/</a>，这是一个英文的版本，我把其中比较关键的部分挑了出来。</p>\n<h4 data-nodeid="38700">术语</h4>\n<p data-nodeid="38701">先来看看 Promise/A+ 规范的基本术语，如下所示。</p>\n<blockquote data-nodeid="38702">\n<p data-nodeid="38703">“promise” is an object or function with a&nbsp;then&nbsp;method whose behavior conforms to this specification.<br>\n“thenable” is an object or function that defines a&nbsp;then&nbsp;method.<br>\n“value” is any legal JavaScript value (including&nbsp;undefined, a thenable, or a promise).<br>\n“exception” is a value that is thrown using the&nbsp;throw&nbsp;statement.<br>\n“reason” is a value that indicates why a promise was rejected.</p>\n</blockquote>\n<p data-nodeid="38704">翻译过来，它所描述的就是以下五点。</p>\n<ol data-nodeid="38705">\n<li data-nodeid="38706">\n<p data-nodeid="38707">“promise”：是一个具有 then 方法的对象或者函数，它的行为符合该规范。</p>\n</li>\n<li data-nodeid="38708">\n<p data-nodeid="38709">“thenable”：是一个定义了 then 方法的对象或者函数。</p>\n</li>\n<li data-nodeid="38710">\n<p data-nodeid="38711">“value”：可以是任何一个合法的 JavaScript 的值（包括 undefined、thenable 或 promise）。</p>\n</li>\n<li data-nodeid="38712">\n<p data-nodeid="38713">“exception”：是一个异常，是在 Promise 里面可以用 throw 语句抛出来的值。</p>\n</li>\n<li data-nodeid="38714">\n<p data-nodeid="38715">“reason”：是一个 Promise 里 reject 之后返回的拒绝原因。</p>\n</li>\n</ol>\n<h4 data-nodeid="38716">状态描述</h4>\n<p data-nodeid="38717">看完了术语部分，我们再看下Promise/A+ 规范中，对 Promise 的内部状态的描述，如下所示。</p>\n<blockquote data-nodeid="38718">\n<p data-nodeid="38719">A promise must be in one of three states: pending, fulfilled, or rejected.<br>\nWhen pending, a promise:<br>\nmay transition to either the fulfilled or rejected state.<br>\nWhen fulfilled, a promise:<br>\nmust not transition to any other state.<br>\nmust have a value, which must not change.<br>\nWhen rejected, a promise:<br>\nmust not transition to any other state.<br>\nmust have a reason, which must not change.<br>\nHere, “must not change” means immutable identity (i.e.&nbsp;===), but does not imply deep immutability.</p>\n</blockquote>\n<p data-nodeid="38720">将上述描述总结起来，大致有以下几点。</p>\n<ol data-nodeid="38721">\n<li data-nodeid="38722">\n<p data-nodeid="38723">一个 Promise 有三种状态：pending、fulfilled 和 rejected。</p>\n</li>\n<li data-nodeid="38724">\n<p data-nodeid="38725">当状态为 pending 状态时，即可以转换为 fulfilled 或者 rejected 其中之一。</p>\n</li>\n<li data-nodeid="38726">\n<p data-nodeid="38727">当状态为 fulfilled 状态时，就不能转换为其他状态了，必须返回一个不能再改变的值。</p>\n</li>\n<li data-nodeid="38728">\n<p data-nodeid="38729">当状态为 rejected 状态时，同样也不能转换为其他状态，必须有一个原因的值也不能改变。</p>\n</li>\n</ol>\n<h4 data-nodeid="38730">then 方法</h4>\n<p data-nodeid="38731">关于 then 方法的英文解读和翻译，我直接总结了出来：一个 Promise 必须拥有一个 then 方法来访问它的值或者拒绝原因。</p>\n<p data-nodeid="38732">then 方法有两个参数：</p>\n<blockquote data-nodeid="38733">\n<p data-nodeid="38734">promise.then(onFulfilled, onRejected)</p>\n</blockquote>\n<p data-nodeid="38735">onFulfilled&nbsp;和&nbsp;onRejected&nbsp;都是可选参数。</p>\n<p data-nodeid="38736"><strong data-nodeid="38851">onFulfilled 和 onRejected&nbsp;特性</strong></p>\n<p data-nodeid="38737">如果&nbsp;onFulfilled&nbsp;是函数，则当 Promise 执行结束之后必须被调用，最终返回值为 value，其调用次数不可超过一次。而 onRejected 除了最后返回的是 reason 外，其他方面和 onFulfilled 在规范上的表述基本一样。</p>\n<p data-nodeid="38738"><strong data-nodeid="38856">多次调用</strong></p>\n<p data-nodeid="38739">then 方法其实可以被一个 Promise 调用多次，且必须返回一个 Promise 对象。then 的写法如下所示，其中 Promise1 执行了 then 的方法之后，返回的依旧是个 Promise2，然后我们拿着 Promise2 又可以执行 then 方法，而 Promise2 是一个新的 Promise 对象，又可以继续进行 then 方法调用。</p>\n<pre class="lang-javascript" data-nodeid="38740"><code data-language="javascript">promise2 = promise1.then(onFulfilled, onRejected);\n</code></pre>\n<p data-nodeid="38741">规范里面还有很大一部分讲解的是 Promise 的解决过程。其实只看规范的话，整体感觉很空洞，方才我已经将规范的主要部分为你讲解了，这些内容基本可以指导我们自己实现一个 Promise 了。</p>\n<p data-nodeid="38742">那么下面我们就理论结合实践，动手实现一个 Promise 吧。</p>\n<h3 data-nodeid="38743">一步步实现 Promise</h3>\n<p data-nodeid="38744">按照 Promise/A+ 的规范，第一步就是构造函数。</p>\n<h4 data-nodeid="38745">构造函数</h4>\n<p data-nodeid="38746">这一步的思路是：Promise 构造函数接受一个 executor 函数，executor 函数执行完同步或者异步操作后，调用它的两个参数 resolve 和 reject。请看下面的代码，大致的构造函数框架就是这样的。</p>\n<pre class="lang-javascript" data-nodeid="38747"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>{\n  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>\n  self.status = <span class="hljs-string">\'pending\'</span>   <span class="hljs-comment">// Promise当前的状态</span>\n  self.data = <span class="hljs-literal">undefined</span>     <span class="hljs-comment">// Promise的值</span>\n  self.onResolvedCallback = [] <span class="hljs-comment">// Promise resolve时的回调函数集</span>\n  self.onRejectedCallback = [] <span class="hljs-comment">// Promise reject时的回调函数集</span>\n  executor(resolve, reject) <span class="hljs-comment">// 执行executor并传入相应的参数</span>\n}\n</code></pre>\n<p data-nodeid="38748">从上面的代码中可以看出，我们先定义了一个 Promise 的初始状态 pending，以及参数执行函数 executor，并且按照规范设计了一个 resolve 回调函数集合数组 onResolvedCallback 以及 一个 reject 回调函数集合数组，那么构造函数的初始化就基本完成了。</p>\n<p data-nodeid="38749">接下来我们看看还需要添加什么东西呢？那就是需要在构造函数中完善 resolve 和 reject 两个函数，完善之后的代码如下。</p>\n<pre class="lang-javascript" data-nodeid="38750"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>{\n  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>\n  self.status = <span class="hljs-string">\'pending\'</span>   <span class="hljs-comment">// Promise当前的状态</span>\n  self.data = <span class="hljs-literal">undefined</span>    <span class="hljs-comment">// Promise的值</span>\n  self.onResolvedCallback = [] <span class="hljs-comment">// Promise resolve时的回调函数集</span>\n  self.onRejectedCallback = [] <span class="hljs-comment">// Promise reject时的回调函数集</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>{\n    <span class="hljs-comment">// TODO</span>\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>{\n    <span class="hljs-comment">// TODO</span>\n  }\n  <span class="hljs-keyword">try</span> { <span class="hljs-comment">// 考虑到执行过程中有可能出错，所以我们用try/catch块给包起</span>\n    executor(resolve, reject) <span class="hljs-comment">// 执行executor</span>\n  } <span class="hljs-keyword">catch</span>(e) {\n    reject(e)\n  }\n}\n</code></pre>\n<p data-nodeid="38751">resolve 和 reject 内部应该怎么实现呢？我们根据规范知道这两个方法主要做的事情就是返回对应状态的值 value 或者 reason，并把 Promise 内部的 status 从 pending 变成对应的状态，并且这个状态在改变了之后是不可以逆转的。</p>\n<p data-nodeid="38752">那么这两个函数应该怎么写呢？可以看下面的这段代码。</p>\n<pre class="lang-javascript" data-nodeid="38753"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>{\n  <span class="hljs-comment">// ...上面的省略</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>{\n    <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n      self.status = <span class="hljs-string">\'resolved\'</span>\n      self.data = value\n      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.onResolvedCallback.length; i++) {\n        self.onResolvedCallback[i](value)\n      }\n    }\n  }\n  \n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>{\n    <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n      self.status = <span class="hljs-string">\'rejected\'</span>\n      self.data = reason\n      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.onRejectedCallback.length; i++) {\n        self.onRejectedCallback[i](reason)\n      }\n    }\n  }\n  <span class="hljs-comment">// 下面的省略</span>\n}\n</code></pre>\n<p data-nodeid="38754">上述代码所展示的，基本就是在判断状态为 pending 之后，把状态改为相应的值，并把对应的 value 和 reason 存在内部的 data 属性上面，之后执行相应的回调函数。逻辑比较简单，无非是由于 onResolveCallback 和 onRejectedCallback 这两个是数组，需要通过循环来执行，这里就不多解释了，你应该会知道。</p>\n<p data-nodeid="38755">好了，构造函数基本就实现了，那么我们再看看如何实现 then 方法，从而保证可以实现链式调用。</p>\n<h4 data-nodeid="38756">实现 then 方法</h4>\n<p data-nodeid="38757">根据标准，我们要考虑几个问题。</p>\n<p data-nodeid="38758">then 方法是 Promise 执行完之后可以拿到 value 或者 reason 的方法，并且还要保持 then 执行之后，返回的依旧是一个 Promise 方法，还要支持多次调用（上面标准中提到过）。</p>\n<p data-nodeid="38759">因此 then 方法实现的思路也有了，请看下面的一段代码。</p>\n<pre class="lang-javascript" data-nodeid="38760"><code data-language="javascript"><span class="hljs-comment">// then方法接收两个参数onResolved和onRejected，分别为Promise成功或失败后的回调</span>\n<span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>{\n  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>\n  <span class="hljs-keyword">var</span> promise2\n  <span class="hljs-comment">// 根据标准，如果then的参数不是function，则需要忽略它</span>\n  onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">\'function\'</span> ? onResolved : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{}\n  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">\'function\'</span> ? onRejected : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>{}\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'resolved\'</span>) {\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n    })\n  }\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'rejected\'</span>) {\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n    })\n  }\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n    })\n  }\n}\n</code></pre>\n<p data-nodeid="38761">从上面的代码中可以看到，我们在 then 方法内部先初始化了 Promise2 的对象，用来存放执行之后返回的 Promise，并且还需要判断 then 方法传参进来的两个参数必须为函数，这样才可以继续执行。</p>\n<p data-nodeid="38762">上面我只是搭建了 then 方法框架的整体思路，但是不同状态的返回细节处理也需要完善，通过仔细阅读标准，完善之后的 then 的代码如下。</p>\n<pre class="lang-javascript" data-nodeid="38763"><code data-language="javascript"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>{\n  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>\n  <span class="hljs-keyword">var</span> promise2\n  <span class="hljs-comment">// 根据标准，如果then的参数不是function，则需要忽略它</span>\n  onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">\'function\'</span> ? onResolved : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{}\n  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">\'function\'</span> ? onRejected : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{}\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'resolved\'</span>) {\n    <span class="hljs-comment">// 如果promise1的状态已经确定并且是resolved，我们调用onResolved，考虑到有可能throw，所以还需要将其包在try/catch块里</span>\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">var</span> x = onResolved(self.data)\n        <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {\n<span class="hljs-comment">// 如果onResolved的返回值是一个Promise对象，直接取它的结果作为promise2的结果</span>\n          x.then(resolve, reject)\n        }\n        resolve(x) <span class="hljs-comment">// 否则，以它的返回值作为promise2的结果</span>\n      } <span class="hljs-keyword">catch</span> (e) {\n        reject(e) <span class="hljs-comment">// 如果出错，以捕获到的错误作为promise2的结果</span>\n      }\n    })\n  }\n  <span class="hljs-comment">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数</span>\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'rejected\'</span>) {\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-keyword">var</span> x = onRejected(self.data)\n        <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {\n          x.then(resolve, reject)\n        }\n      } <span class="hljs-keyword">catch</span> (e) {\n        reject(e)\n      }\n    })\n  }\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n  <span class="hljs-comment">// 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，只能等到Promise的状态确定后，才能确定如何处理</span>\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n      self.onResolvedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-keyword">var</span> x = onResolved(self.data)\n          <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {\n            x.then(resolve, reject)\n          }\n        } <span class="hljs-keyword">catch</span> (e) {\n          reject(e)\n        }\n      })\n      self.onRejectedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-keyword">var</span> x = onRejected(self.data)\n          <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {\n            x.then(resolve, reject)\n          }\n        } <span class="hljs-keyword">catch</span> (e) {\n          reject(e)\n        }\n      })\n    })\n  }\n}\n</code></pre>\n<p data-nodeid="38764">根据上面的代码可以看出，我们基本实现了一个符合标准的 then 方法。但是标准里提到了，还要支持不同的 Promise 进行交互，关于不同的 Promise 交互其实<a href="https://promisesaplus.com/#point-46" data-nodeid="38879">Promise 标准说明</a>中有提到。其中详细指定了如何通过 then 的实参返回的值来决定 Promise2 的状态。</p>\n<p data-nodeid="38765">关于为何需要不同的 Promise 实现交互，原因应该是 Promise 并不是 JS 一开始存在的标准，如果你使用的某一个库中封装了一个 Promise 的实现，想象一下如果它不能跟你自己使用的 Promise 实现交互的情况，其实还是会有问题的，因此我们还需要调整一下 then 方法中执行 Promise 的方法。</p>\n<p data-nodeid="38766">另外还有一个需要注意的是，在 Promise/A+ 规范中，onResolved 和 onRejected 这两项函数需要异步调用，关于这一点，标准里面是这么说的：</p>\n<blockquote data-nodeid="38767">\n<p data-nodeid="38768">In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack.</p>\n</blockquote>\n<p data-nodeid="38769">所以我们需要对代码做一点变动，即在处理 Promise 进行 resolve 或者 reject 的时候，加上 setTimeout(fn, 0)。</p>\n<p data-nodeid="38770">下面我就结合上面两点调整，给出完整版的代码，你可以根据注释关注一下我所做的调整。</p>\n<pre class="lang-javascript" data-nodeid="38771"><code data-language="javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Promise</span>\n} <span class="hljs-keyword">catch</span> (e) {}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>{\n  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>\n  self.status = <span class="hljs-string">\'pending\'</span>\n  self.onResolvedCallback = []\n  self.onRejectedCallback = []\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>{\n    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {\n      <span class="hljs-keyword">return</span> value.then(resolve, reject)\n    }\n    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 异步执行所有的回调函数</span>\n      <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n        self.status = <span class="hljs-string">\'resolved\'</span>\n        self.data = value\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.onResolvedCallback.length; i++) {\n          self.onResolvedCallback[i](value)\n        }\n      }\n    })\n  }\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>{\n    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 异步执行所有的回调函数</span>\n      <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n        self.status = <span class="hljs-string">\'rejected\'</span>\n        self.data = reason\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.onRejectedCallback.length; i++) {\n          self.onRejectedCallback[i](reason)\n        }\n      }\n    })\n  }\n  <span class="hljs-keyword">try</span> {\n    executor(resolve, reject)\n  } <span class="hljs-keyword">catch</span> (reason) {\n    reject(reason)\n  }\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>{\n  <span class="hljs-keyword">var</span> then\n  <span class="hljs-keyword">var</span> thenCalledOrThrow = <span class="hljs-literal">false</span>\n  <span class="hljs-keyword">if</span> (promise2 === x) {\n    <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">\'Chaining cycle detected for promise!\'</span>))\n  }\n  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {\n    <span class="hljs-keyword">if</span> (x.status === <span class="hljs-string">\'pending\'</span>) { \n      x.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{\n        resolvePromise(promise2, v, resolve, reject)\n      }, reject)\n    } <span class="hljs-keyword">else</span> {\n      x.then(resolve, reject)\n    }\n    <span class="hljs-keyword">return</span>\n  }\n  <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span>) &amp;&amp; ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">\'object\'</span>) || (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">\'function\'</span>))) {\n    <span class="hljs-keyword">try</span> {\n      then = x.then\n      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">\'function\'</span>) {\n        then.call(x, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rs</span>(<span class="hljs-params">y</span>) </span>{\n          <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span>\n          thenCalledOrThrow = <span class="hljs-literal">true</span>\n          <span class="hljs-keyword">return</span> resolvePromise(promise2, y, resolve, reject)\n        }, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rj</span>(<span class="hljs-params">r</span>) </span>{\n          <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span>\n          thenCalledOrThrow = <span class="hljs-literal">true</span>\n          <span class="hljs-keyword">return</span> reject(r)\n        })\n      } <span class="hljs-keyword">else</span> {\n        resolve(x)\n      }\n    } <span class="hljs-keyword">catch</span> (e) {\n      <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span>\n      thenCalledOrThrow = <span class="hljs-literal">true</span>\n      <span class="hljs-keyword">return</span> reject(e)\n    }\n  } <span class="hljs-keyword">else</span> {\n    resolve(x)\n  }\n}\n<span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>{\n  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>\n  <span class="hljs-keyword">var</span> promise2\n  onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">\'function\'</span> ? onResolved : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{\n    <span class="hljs-keyword">return</span> v\n  }\n  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">\'function\'</span> ? onRejected : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>) </span>{\n    <span class="hljs-keyword">throw</span> r\n  }\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'resolved\'</span>) {\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 异步执行onResolved</span>\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-keyword">var</span> x = onResolved(self.data)\n          resolvePromise(promise2, x, resolve, reject)\n        } <span class="hljs-keyword">catch</span> (reason) {\n          reject(reason)\n        }\n      })\n    })\n  }\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'rejected\'</span>) {\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 异步执行onRejected</span>\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-keyword">var</span> x = onRejected(self.data)\n          resolvePromise(promise2, x, resolve, reject)\n        } <span class="hljs-keyword">catch</span> (reason) {\n          reject(reason)\n        }\n      })\n    })\n  }\n  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">\'pending\'</span>) {\n    <span class="hljs-comment">// 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义</span>\n    <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n      self.onResolvedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-keyword">var</span> x = onResolved(value)\n          resolvePromise(promise2, x, resolve, reject)\n        } <span class="hljs-keyword">catch</span> (r) {\n          reject(r)\n        }\n      })\n      self.onRejectedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{\n          <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">var</span> x = onRejected(reason)\n            resolvePromise(promise2, x, resolve, reject)\n          } <span class="hljs-keyword">catch</span> (r) {\n            reject(r)\n          }\n        })\n    })\n  }\n}\n<span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected)\n}\n<span class="hljs-comment">// 最后这个是测试用的，后面会说</span>\n<span class="hljs-built_in">Promise</span>.deferred = <span class="hljs-built_in">Promise</span>.defer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> dfd = {}\n  dfd.promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{\n    dfd.resolve = resolve\n    dfd.reject = reject\n  })\n  <span class="hljs-keyword">return</span> dfd\n}\n</code></pre>\n<p data-nodeid="38772">上面这段代码就是通过一步步优化调整出来的最终版，其中细节也是比较多的，介于篇幅问题，暂时能讲的点就先说这么多。如果你还有哪里不清楚的，最好还是动手实践去理解。</p>\n<p data-nodeid="38773">最终版的 Promise 的实现还是需要经过规范的测试（Promise /A+ 规范测试的工具地址为：<a href="https://github.com/promises-aplus/promises-tests" data-nodeid="38890">https://github.com/promises-aplus/promises-tests</a>），需要暴露一个 deferred 方法（即 exports.deferred 方法），上面提供的代码中我已经将其加了进去。</p>\n<p data-nodeid="38774">最后，执行如下代码 npm 安装之后，即可执行测试。</p>\n<pre class="lang-java" data-nodeid="38775"><code data-language="java">npm i -g promises-aplus-tests\npromises-aplus-tests Promise.js\n</code></pre>\n<h3 data-nodeid="38776">总结</h3>\n<p data-nodeid="39758" class="te-preview-highlight">讲到这里，你可以再思考一下 Promise /A+ 规范中的一些细节，以及实现过程中需要注意的问题，如果你能够在面试中实现一个这样的 Promise，就基本可以满足岗位的需求了。</p>\n\n<p data-nodeid="38778">通过这一讲的学习，你应该能理解 Promise 底层的实现逻辑了，虽然并不一定有场景适合落地业务，但是整个手动实现的过程对于你 JS 编码能力的提升会很有帮助。</p>\n<p data-nodeid="38779">关于 Promise 还有很多 API 的方法，在已经实现的 Promise 的版本之上，你可以再尝试实现 all、race 以及 any 等方法，学会举一反三，才能在工作中游刃有余。</p>\n<p data-nodeid="38780">下一讲开始，我们就要进入一个新的模块——JS 引擎篇，我要带你了解 JS 引擎中的垃圾回收机制、事件轮询等，这对于写出高性能的 JavaScript 代码有着很好的帮助。</p>\n<p data-nodeid="38781">我们到时见。</p>',
          },
        ],
      },
      {
        sectionName: '模块四：JS 引擎篇',
        sectionId: 5,
        courseList: [
          {
            theme: '18 | 垃圾回收：释放内存，提升浏览器页面性能',
            id: 119,
            content:
              '<p data-nodeid="729" class="">这一讲开始，我们就进入一个全新的模块，探讨 JS 引擎相关的内容。这个模块是整个课程的最后一个模块，主要围绕 JS 引擎相关的知识来讲解，让你深入了解其底层运行逻辑。这对于日常开发中对高性能 JavaScript 的编写以及排查代码性能问题有着很好的帮助，同样也是 JavaScript 开发者进阶过程中必不可少的学习路径。</p>\n<p data-nodeid="730">这一讲主要通过讲解 JS 引擎底层的垃圾回收机制，希望帮助你了解更多的浏览器内核层面的东西，从而对 JS 的内存管理以及内存溢出等形成一定的认识。</p>\n<p data-nodeid="731">那么，在课程开始前，我有两个问题想要问你。你知道 JavaScript 的内存是怎么管理的吗？Chrome 浏览器又是如何进行垃圾回收的？</p>\n<p data-nodeid="732">这将是本讲所要解决的问题，现在请你带着思考，和我一起开启 JS 引擎篇的学习之路。</p>\n<h3 data-nodeid="733">JavaScript 的内存管理</h3>\n<p data-nodeid="734">不管是什么样的计算机程序语言，运行在对应的代码引擎上，对应的使用内存过程大致逻辑是一样的，可以分为这三个步骤：</p>\n<ol data-nodeid="735">\n<li data-nodeid="736">\n<p data-nodeid="737">分配你所需要的系统内存空间；</p>\n</li>\n<li data-nodeid="738">\n<p data-nodeid="739">使用分配到的内存进行读或者写等操作；</p>\n</li>\n<li data-nodeid="740">\n<p data-nodeid="741">不需要使用内存时，将其空间释放或者归还。</p>\n</li>\n</ol>\n<p data-nodeid="742">与其他需要手动管理内存的语言不太一样的地方是，在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。来看下面的例子。</p>\n<pre class="lang-javascript" data-nodeid="743"><code data-language="javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>; <span class="hljs-comment">// 给数值变量分配栈内存</span>\n<span class="hljs-keyword">var</span> etf = <span class="hljs-string">"ARK"</span>; <span class="hljs-comment">// 给字符串分配栈内存</span>\n<span class="hljs-comment">// 给对象及其包含的值分配堆内存</span>\n<span class="hljs-keyword">var</span> obj = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">\'tom\'</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">13</span>\n}; \n<span class="hljs-comment">// 给数组及其包含的值分配内存（就像对象一样）</span>\n<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"PSAC"</span>]; \n<span class="hljs-comment">// 给函数（可调用的对象）分配内存</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>)</span>{\n  <span class="hljs-keyword">return</span> a + b;\n}\n</code></pre>\n<p data-nodeid="744">当系统经过一段时间发现这些变量不会再被使用的时候，会通过垃圾回收机制的方式来处理掉这些变量所占用的内存，其实开发者不用过多关心内存问题。即便是这样，我们在开发过程中也需要了解 JavaScript 的内存管理机制，这样才能避免一些不必要的问题，在 JavaScript 中数据类型分为两类：简单类型和引用类型。关于 JavaScript 的数据类型相关的知识在 01 讲中有介绍过，这里就不多说了。</p>\n<p data-nodeid="745">对于简单的数据类型，内存是保存在栈（stack）空间中的；复杂数据类型，内存保存在堆（heap）空间中。简而言之，基本就是说明以下两点。</p>\n<ul data-nodeid="746">\n<li data-nodeid="747">\n<p data-nodeid="748">基本类型：这些类型在内存中会占据固定的内存空间，它们的值都保存在栈空间中，直接可以通过值来访问这些；</p>\n</li>\n<li data-nodeid="749">\n<p data-nodeid="750">引用类型：由于引用类型值大小不固定（比如上面的对象可以添加属性等），栈内存中存放地址指向堆内存中的对象，是通过引用来访问的。</p>\n</li>\n</ul>\n<p data-nodeid="751">因此总结来说：<strong data-nodeid="827">栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理</strong>。</p>\n<h3 data-nodeid="752">Chrome 内存回收机制</h3>\n<p data-nodeid="753">在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。</p>\n<p data-nodeid="754">那么请你思考一下，为什么要去限制内存使用呢？大致是两个原因：V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。</p>\n<p data-nodeid="755">下面我们来看下 Chrome 的内存回收机制。Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制，我们来分别看看这两种堆的内存回收机制是什么原理。</p>\n<h4 data-nodeid="756">新生代内存回收</h4>\n<p data-nodeid="3445">我们先来看下新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。首先系统会将分配给新生代的内存空间分为两部分，如下图所示。</p>\n<p data-nodeid="3446" class=""><img src="https://s0.lgstatic.com/i/image6/M01/15/DF/Cgp9HWBFyg-AFat5AACfc1G3XGY909.png" alt="图片1.png" data-nodeid="3450"></p>\n\n\n<p data-nodeid="759" class="te-preview-highlight">图中左边部分表示正在使用的内存空间，右边是目前闲置的内存空间。当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将左边的对象检查一遍。如果引擎检测是存活对象，那么会复制到右边的内存空间去；如果不是存活的对象，则直接进行系统回收。当所有左边的内存里的对象没有了的时候，等再有新生代的对象产生时，上面的部分左右对调，这样来循环处理。</p>\n<p data-nodeid="2719">如果是顺序放置的那比较好处理，可以按照上面所说的处理方式。但是如果是下图这样零散的场景怎么处理呢？</p>\n<p data-nodeid="2720" class=""><img src="https://s0.lgstatic.com/i/image6/M01/15/DC/CioPOWBFygeAdQcpAABnNfXN7sg370.png" alt="图片2.png" data-nodeid="2724"></p>\n\n\n<p data-nodeid="762">图中橙色的块代表存活对象，白色地方代表未分配的内存。正常情况下，由于堆内存是连续分配的，但是也有可能出现上图的这种内存分配情况，这种零散的分配情况就造成了内存碎片，会影响比较大的内存对象的放置。</p>\n<p data-nodeid="1993">因此这里介绍一个算法 Scavenge，它主要就是解决上图中内存碎片的情况，在通过算法处理过后，内存中对象的排布都会变成下图这个排列方式，请看效果。</p>\n<p data-nodeid="1994" class=""><img src="https://s0.lgstatic.com/i/image6/M01/15/DC/CioPOWBFyf2AOkMAAABanoDBiq0058.png" alt="图片3.png" data-nodeid="1998"></p>\n\n\n<p data-nodeid="765">进行这样的算法处理，明显会让内存排布变得更整齐了，这样就非常方便之后新来的对象的内存分配。Scavenge 算法更多的是偏向算法方面的知识，这里就不过多讲解了，如果你有兴趣可以自行学习一下。下面我们再来看看老生代的内存回收是怎么做的。</p>\n<h4 data-nodeid="766">老生代内存回收</h4>\n<p data-nodeid="767">上面讲解了新生代的回收方式，那么新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中。时间长了之后通过几个原因的判断，我们就会把这些变量进行 "晋升"，只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象。那么在进入老生代的内存回收机制中，就不能再用 Scavenge 的算法了。Scavenge 的算法是有其适用的场景，而对于内存空间比较大的，就不适合用 Scavenge 算法了。</p>\n<p data-nodeid="768">那么老生代内存中的垃圾回收，是采用什么样的策略进行的呢？这里采用了&nbsp;Mark-Sweep（标记清除） 和 Mark-Compact（标记整理）的策略，我们先来看下 Mark-Sweep 标记清除的策略。</p>\n<p data-nodeid="769"><strong data-nodeid="858">标记清除（Mark-Sweep）</strong></p>\n<p data-nodeid="770">通过名字你就可以理解，标记清除分为两个阶段：标记阶段和清除阶段。</p>\n<p data-nodeid="771">首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。</p>\n<p data-nodeid="772">听起来这一切都比较完美，但是其实通过标记清除之后，还是会出现上面图中的内存碎片的问题。内存碎片多了之后，如果要新来一个较大的内存对象需要存储，会造成影响。对于通过标记清除产生的内存碎片，还是需要通过另外一种方式进行解决，因此这里就不得不提到标记整理策略（Mark-Compact）了。下面我们就来看看标记整理策略是如何帮助清除内存碎片的问题的。</p>\n<p data-nodeid="773"><strong data-nodeid="865">标记整理（Mark-Compact）</strong></p>\n<p data-nodeid="774">经过标记清除策略调整之后，老生代的内存中因此产生了很多内存碎片，若不清理这些内存碎片，之后会对存储造成影响。</p>\n<p data-nodeid="1267">为了方便解决浏览器中的内存碎片问题，标记整理这个策略被提出。这个策略是在标记清除的基础上演进而来的，和标记清除来对比来看，标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存。其操作效果如下图所示。</p>\n<p data-nodeid="1268" class=""><img src="https://s0.lgstatic.com/i/image6/M00/15/DF/Cgp9HWBFye2AKyNcAABuuRzJxL4095.png" alt="图片4.png" data-nodeid="1272"></p>\n\n\n<p data-nodeid="777">可以看到，老生代内存的管理方式和新生代的内存管理方式区别还是比较大的。Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生。</p>\n<p data-nodeid="778">那么以上就是内存的垃圾回收机制的内容了。最后我们再看看日常在开发中，应该注意哪些问题来避免内存泄漏，从而提升你的代码的可靠性。</p>\n<h3 data-nodeid="779">内存泄漏与优化</h3>\n<p data-nodeid="780">平常用 JavaScript 开发代码，内存的泄漏和优化是应该经常留意的。内存泄漏是指 JavaScript 中，已经分配堆内存地址的对象由于长时间未释放或者无法释放，造成了长期占用内存，使内存浪费，最终会导致运行的应用响应速度变慢以及最终崩溃的情况。这种就是内存泄漏，你应该在日常开发和使用浏览器过程中也遇到过，那么我们来回顾一下内存泄漏的场景：</p>\n<ol data-nodeid="781">\n<li data-nodeid="782">\n<p data-nodeid="783">过多的缓存未释放；</p>\n</li>\n<li data-nodeid="784">\n<p data-nodeid="785">闭包太多未释放；</p>\n</li>\n<li data-nodeid="786">\n<p data-nodeid="787">定时器或者回调太多未释放；</p>\n</li>\n<li data-nodeid="788">\n<p data-nodeid="789">太多无效的 DOM 未释放；</p>\n</li>\n<li data-nodeid="790">\n<p data-nodeid="791">全局变量太多未被发现。</p>\n</li>\n</ol>\n<p data-nodeid="792">我大概总结了这几种场景，这些现象会在开发或者使用中造成内存泄漏，以至于你的浏览器卡顿、不响应、页面打不开等问题产生。那么这些问题该怎么优化呢？我们来看下这些场景都需要注意点什么。</p>\n<p data-nodeid="793"><strong data-nodeid="887">1. 减少不必要的全局变量，使用严格模式避免意外创建全局变量</strong>。例如：</p>\n<pre class="lang-javascript" data-nodeid="794"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-comment">// 全局变量=&gt; window.bar</span>\n    <span class="hljs-keyword">this</span>.bar = <span class="hljs-string">\'默认this指向全局\'</span>;\n    <span class="hljs-comment">// 没有声明变量，实际上是全局变量=&gt;window.bar</span>\n    bar = <span class="hljs-string">\'全局变量\'</span>; \n}\nfoo();\n</code></pre>\n<p data-nodeid="795">这段代码中，函数内部绑定了太多的 this 变量，虽然第一眼看不出问题，但仔细一分析，其实 this 下的属性默认都是绑定到 window 上的属性，均为全局变量，这一点是非常有必要注意的。</p>\n<p data-nodeid="796"><strong data-nodeid="895">2. 在你使用完数据后，及时解除引用</strong>（闭包中的变量，DOM 引用，定时器清除）。例如：</p>\n<pre class="lang-javascript" data-nodeid="797"><code data-language="javascript"><span class="hljs-keyword">var</span> someResource = getData();\nsetInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'Node\'</span>);\n    <span class="hljs-keyword">if</span>(node) {\n        node.innerHTML = <span class="hljs-built_in">JSON</span>.stringify(someResource));\n        <span class="hljs-comment">// 定时器也没有清除，可以清除掉</span>\n    }\n    <span class="hljs-comment">// node、someResource 存储了大量数据，无法回收</span>\n}, <span class="hljs-number">1000</span>);\n</code></pre>\n<p data-nodeid="798">比如上面代码中就缺少清除 setInterval 的代码，类似这样的代码增多会造成内存的占用过多，这是同样也需要注意的一点。</p>\n<p data-nodeid="799"><strong data-nodeid="903">3. 组织好你的代码逻辑，避免死循环等造成浏览器卡顿、崩溃的问题</strong>。例如，对于一些比较占用内存的对象提供手工释放内存的方法，请看下面代码：</p>\n<pre class="lang-javascript" data-nodeid="800"><code data-language="javascript"><span class="hljs-keyword">var</span> leakArray = [];\nexports.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    leakArray = [];\n}\n</code></pre>\n<p data-nodeid="801">比如这段代码提供了清空该数组内容的方法，使用完成之后可以根据合适业务时机进行操作释放。这样就能较好地避免对象数据量太大造成的内存溢出的问题。</p>\n<p data-nodeid="802">关于内存泄漏这部分，如果你想更好地去排查以及提前避免问题的发生，最好的解决方式是通过熟练使用 Chrome 的内存剖析工具，多分析多定位 Chrome 帮你分析保留的内存快照，来查看持续占用大量内存的对象。最好在业务代码上线前做好分析和诊断，之后才能保证线上业务的质量。</p>\n<p data-nodeid="803">好了，关于内存泄漏与优化就讲到这里。</p>\n<h3 data-nodeid="804">总结</h3>\n<p data-nodeid="805">这一讲我们聊了 JavaScript 的内存管理机制，以及浏览器的垃圾回收机制，最后我们又分析了一些日常编码中经常遇到的内存场景有可能会引发内存泄漏的问题，我也给出了避免产生这些问题的方法。</p>\n<p data-nodeid="806">虽然本讲偏理论，但是底层的一些原理也是需要深入理解的，这样可以更清楚 JS 引擎的运行机制，从而可以利用一些内存分析工具去剖析一些 Web 应用的卡顿问题。有兴趣的话，你可以尝试着自己利用 Chrome 控制台的内存分析工具感受一下。</p>\n<p data-nodeid="807" class="">下一讲我们就会进入 JS 引擎篇中的 EventLoop 的学习，EventLoop 也是 JS 引擎中一个比较重要的知识点。希望我的讲解可以为你带来帮助，让我们共同进步，下一讲再见。</p>',
          },
          {
            theme: '19 | 事件轮询：如何理解浏览器中的 EventLoop？',
            id: 120,
            content:
              '<p data-nodeid="1698" class="">上一讲我们探讨了 JavaScript 引擎的内存管理及垃圾回收机制，那么这一讲依然要讨论和 JS 引擎相关的 Eventloop，我会带你深入理解 JavaScript 引擎所做的工作。</p>\n<p data-nodeid="1699">我会先讲解浏览器端的 Eventloop 的运行机制，待你对浏览器端有了一定的理解之后，再带你设计一些 Node.js 的 Eventloop 的底层逻辑。你可以发现，无论是浏览器端还是服务端，都在使用 Eventloop，虽然两者机制不同，但都利用了 JavaScript 语言的单线程和非阻塞的特点。希望你能扎实地掌握这部分内容，因为这对你在工作中编写高性能的 JavaScript 代码有所帮助。</p>\n<p data-nodeid="1700">那么依照惯例，在课程开始前请你先思考两个问题：</p>\n<ol data-nodeid="1701">\n<li data-nodeid="1702">\n<p data-nodeid="1703">浏览器端的 Eventloop 起到了什么作用？</p>\n</li>\n<li data-nodeid="1704">\n<p data-nodeid="1705">Node.js 服务端的 Eventloop 的作用又表现在哪？</p>\n</li>\n</ol>\n<p data-nodeid="1706">现在开始跟着我一起探究浏览器端的 Eventloop 吧。</p>\n<h3 data-nodeid="1707">浏览器的 Eventloop</h3>\n<p data-nodeid="1708">Eventloop 是 JavaScript 引擎异步编程背后需要特别关注的知识点。JS 在单线程上执行所有操作，虽然是单线程，但是能够高效地解决问题，并能给我们带来一种“多线程”的错觉，这其实是通过使用一些比较合理的数据结构来达到此效果的。我们一起来看下 JavaScript 引擎背后都有哪些东西在同时运转。</p>\n<p data-nodeid="1709"><strong data-nodeid="1789">1.调用堆栈（call stack）负责跟踪所有要执行的代码</strong>。每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数；如果有代码需要进去执行的话，就进行 push 操作，如下图所示：</p>\n<p data-nodeid="1710"><img src="https://s0.lgstatic.com/i/image6/M00/17/42/CioPOWBHazGAfzOQAAIO77agDbw772.png" alt="图片4.png" data-nodeid="1792"></p>\n<p data-nodeid="1711"><strong data-nodeid="1797">2.事件队列（event queue）负责将新的 function 发送到队列中进行处理</strong>。它遵循 queue 的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行。如下图所示：</p>\n<p data-nodeid="1712"><img src="https://s0.lgstatic.com/i/image6/M00/17/46/Cgp9HWBHa0uAO5oEAAIrTDhci3M926.png" alt="图片5.png" data-nodeid="1800"></p>\n<p data-nodeid="1713"><strong data-nodeid="1805">3.每当调用事件队列（event queue）中的异步函数时，都会将其发送到浏览器 API</strong>。根据从调用堆栈收到的命令，API 开始自己的单线程操作。其中 setTimeout 方法就是一个比较典型的例子，在堆栈中处理 setTimeout 操作时，会将其发送到相应的 API，该 API 一直等到指定的时间将此操作送回进行处理。它将操作发送到哪里去呢？答案是事件队列（event queue）。这样，就有了一个循环系统，用于在 JavaScript 中运行异步操作。</p>\n<p data-nodeid="1714"><strong data-nodeid="1810">4.JavaScript 语言本身是单线程的，而浏览器 API 充当单独的线程</strong>。事件循环（Eventloop）促进了这一过程，它会不断检查调用堆栈是否为空。如果为空，则从事件队列中添加新的函数进入调用栈（call stack）；如果不为空，则处理当前函数的调用。我们把整个过程串起来就是这样的一个循环执行流程，如下图所示：</p>\n<p data-nodeid="1715"><img src="https://s0.lgstatic.com/i/image6/M00/17/43/CioPOWBHaz-AIvXzAAMjXUqLjBw024.png" alt="图片6.png" data-nodeid="1813"></p>\n<p data-nodeid="1716">通过上面这张图就能很清晰地看出调用栈、事件队列以及 Eventloop 和它们之间相互配合的关系。</p>\n<p data-nodeid="1717">那么看完了 JS 引擎的全局流程图，我们再看看 Eventloop 的内部都有哪些东西呢？简单来说 Eventloop 通过内部两个队列来实现 Event Queue 放进来的异步任务。以 setTimeout 为代表的任务被称为宏任务，放到宏任务队列（macrotask queue）中；而以 Promise&nbsp;为代表的任务被称为微任务，放到微任务队列（microtask queue）中。我们来看一下日常工作中经常遇到的哪些是宏任务，哪些是微任务，如下所示。</p>\n<pre class="lang-java" data-nodeid="1718"><code data-language="java">macrotasks(宏任务): \nscript(整体代码),setTimeout,setInterval,setImmediate,I/O,UI rendering,<span class="hljs-function">event listner\n<span class="hljs-title">microtasks</span><span class="hljs-params">(微任务)</span>: \nprocess.nextTick, Promises, Object.observe, MutationObserver\n</span></code></pre>\n<p data-nodeid="1719">我把主要的宏任务和微任务都列了出来，其实 Eventloop 在处理宏任务和微任务的逻辑其实还是有些不一样的，执行的情况大致如下：</p>\n<ol data-nodeid="1720">\n<li data-nodeid="1721">\n<p data-nodeid="1722">JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务；</p>\n</li>\n<li data-nodeid="1723">\n<p data-nodeid="1724">执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</p>\n</li>\n<li data-nodeid="1725">\n<p data-nodeid="1726">然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</p>\n</li>\n</ol>\n<p data-nodeid="2151" class="te-preview-highlight">总结起来就是：<strong data-nodeid="2161">一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务</strong>。<br>\n<img src="https://s0.lgstatic.com/i/image6/M00/17/45/CioPOWBHbTWAFHeGAAU2r3znzGU909.png" alt="刘烨的js.png" data-nodeid="2160"></p>\n\n\n<p data-nodeid="1728">关于宏任务和微任务暂时先说到这里，更详细的内容我会在“21 | 引擎进阶（上）：探究宏任务&amp;微任务的运行机制”中详细讲解。</p>\n<p data-nodeid="1729">那么初步看完了浏览器中 Eventloop 的情况，我们再来看下在 Node.js 服务端的 Eventloop 是怎么运作的。</p>\n<h3 data-nodeid="1730">Node.js 的 Eventloop</h3>\n<p data-nodeid="1731">关于在 Node.js 服务端 Eventloop，<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" data-nodeid="1836">Node.js 官网</a>是这么描述的：</p>\n<blockquote data-nodeid="1732">\n<p data-nodeid="1733"><em data-nodeid="1841">When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the REPL, which is not covered in this document) which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.</em></p>\n</blockquote>\n<p data-nodeid="1734">简单翻译过来就是：当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，process.nextTick() 方法会开始处理事件循环。下面就是 Node.js 官网提供的 Eventloop 事件循环参考流程。</p>\n<p data-nodeid="1735"><img src="https://s0.lgstatic.com/i/image6/M00/17/46/Cgp9HWBHaxyAMv7yAAC2Vr6vRw4319.png" alt="图片1.png" data-nodeid="1845"></p>\n<p data-nodeid="1736">整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程。我们来分别看下这六个阶段都做了哪些事情。</p>\n<ul data-nodeid="1737">\n<li data-nodeid="1738">\n<p data-nodeid="1739"><strong data-nodeid="1851">Timers 阶段</strong>：这个阶段执行 setTimeout 和 setInterval。</p>\n</li>\n<li data-nodeid="1740">\n<p data-nodeid="1741"><strong data-nodeid="1856">I/O callbacks 阶段</strong>：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。</p>\n</li>\n<li data-nodeid="1742">\n<p data-nodeid="1743"><strong data-nodeid="1861">idle，prepare 阶段</strong>：只是 Node.js 内部闲置、准备，可以忽略。</p>\n</li>\n<li data-nodeid="1744">\n<p data-nodeid="1745"><strong data-nodeid="1866">poll 阶段</strong>：poll 阶段是一个重要且复杂的阶段，几乎所有 I/O 相关的回调，都在这个阶段执行（除了setTimeout、setInterval、setImmediate 以及一些因为 exception 意外关闭产生的回调），这个阶段的主要流程如下图所示。</p>\n</li>\n</ul>\n<p data-nodeid="1746"><img src="https://s0.lgstatic.com/i/image6/M00/17/42/CioPOWBHawOAK71oAAFclaJ2RLA602.png" alt="图片2.png" data-nodeid="1869"></p>\n<ul data-nodeid="1747">\n<li data-nodeid="1748">\n<p data-nodeid="1749"><strong data-nodeid="1874">check 阶段</strong>：执行 setImmediate() 设定的 callbacks。</p>\n</li>\n<li data-nodeid="1750">\n<p data-nodeid="1751"><strong data-nodeid="1883">close callbacks 阶段</strong>：执行关闭请求的回调函数，比如 socket.on(\'close\', ...)。</p>\n</li>\n</ul>\n<p data-nodeid="1752">除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()。根据<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" data-nodeid="1887">官方文档的解释</a>：</p>\n<blockquote data-nodeid="1753">\n<p data-nodeid="1754">process.nextTick()is not technically part of the event loop. Instead, thenextTickQueuewill be processed after the current operation is completed, regardless of the current phase of the event loop. Here, an&nbsp;operation&nbsp;is defined as a transition from the underlying C/C++ handler, and handling the JavaScript that needs to be executed.</p>\n</blockquote>\n<p data-nodeid="1755">可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）。</p>\n<p data-nodeid="1756">Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。</p>\n<p data-nodeid="1757">这部分比较绕，你需要多琢磨几遍。那么讲完了 Eventloop，你以为可能就够用了，但是很快你就会发现，Eventloop 也会影响到渲染，下面的内容也许对你有帮助。</p>\n<h3 data-nodeid="1758">EventLoop 对渲染的影响</h3>\n<p data-nodeid="1759">想必你之前在业务开发中也遇到过 requestIdlecallback 和 requestAnimationFrame，这两个函数在我们之前的内容中没有讲过，但是当你开始考虑它们在 Eventloop 的生命周期的哪一步触发，或者这两个方法的回调会在微任务队列还是宏任务队列执行的时候，才发现好像没有想象中那么简单。这两个方法其实也并不属于 JS 的原生方法，而是浏览器宿主环境提供的方法，因为它们牵扯到另一个问题：渲染。</p>\n<p data-nodeid="1760">我们知道浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。</p>\n<p data-nodeid="1761">渲染原本就不应该出现在 Eventloop 相关的知识体系里，但是因为 Eventloop 显然是在讨论 JS 如何运行的问题，而渲染则是浏览器另外一个线程的工作。但是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" data-nodeid="1899">requestAnimationFrame</a> 的出现却把这两件事情给关联起来，你可以看下 RAF 的英文解释：</p>\n<blockquote data-nodeid="1762">\n<p data-nodeid="1763"><code data-backticks="1" data-nodeid="1901">requestAnimationFrame()</code>method tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation&nbsp;before the next repaint.</p>\n</blockquote>\n<p data-nodeid="1764">通过调用 requestAnimationFrame 我们可以在下次渲染之前执行回调函数。那下次渲染具体是哪个时间点呢？渲染和 Eventloop 有什么关系呢？我们在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity" data-nodeid="1906">HTML协议对 Eventloop 的规范</a> 里找到了答案。简单来说，就是在每一次 Eventloop 的末尾，判断当前页面是否处于渲染时机，就是重新渲染。而这个所谓的渲染时机是这样定义的：</p>\n<blockquote data-nodeid="1765">\n<p data-nodeid="1766">Rendering opportunities are determined based on hardware constraints such as display refresh rates and other factors such as page performance or whether the page is in the background. Rendering opportunities typically occur at regular intervals.</p>\n</blockquote>\n<p data-nodeid="1767">有屏幕的硬件限制，比如 60Hz 刷新率，简而言之就是 1 秒刷新了 60 次，16.6ms 刷新一次。这个时候浏览器的渲染间隔时间就没必要小于 16.6ms，因为就算渲染了屏幕上也看不到。当然浏览器也不能保证一定会每 16.6ms 会渲染一次，因为还会受到处理器的性能、JavaScript 执行效率等其他因素影响。</p>\n<p data-nodeid="1768">回到 requestAnimationFrame，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestAnimationFrame 更适合用来做针对每一帧来修改的动画效果。</p>\n<p data-nodeid="1769">当然 requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。</p>\n<p data-nodeid="1770">但是 requestIdlecallback&nbsp;却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务，如下图所示：</p>\n<p data-nodeid="1771"><img src="https://s0.lgstatic.com/i/image6/M01/17/45/Cgp9HWBHavCAdApzAACc58yaa0Q304.png" alt="图片3.png" data-nodeid="1915"></p>\n<p data-nodeid="1772">当然为了防止浏览器一直处于繁忙状态，导致 requestIdlecallback 可能永远无法执行回调，它还提供了一个额外的 timeout 参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。</p>\n<h3 data-nodeid="1773">总结</h3>\n<p data-nodeid="1774">那么现在让你回答我在开头提出的两个问题，你能准确说出来吗？回过头到文中仔细看看，相信不难回答。</p>\n<p data-nodeid="1775">到这里，你基本就能理解 Eventloop 在不同的端上的情况了。虽然说 Eventloop 本身并不是一个难理解的概念，但是由于 JS 不同平台的实现的差异，让这个知识点很难一下说清楚，因此我就拿出这一讲带你来分析 Eventloop。希望你可以反复琢磨这一概念，将它理解透彻。</p>\n<p data-nodeid="1776" class="">下一讲我们来聊聊 JS 的代码是如何被编译执行的。如果本讲的内容对你有帮助，就留言和我说说你的学习感悟吧。我们下一讲再见。</p>',
          },
          {
            theme: '20 | 原理解析：JS 代码是如何被浏览器引擎编译、执行的？',
            id: 121,
            content:
              '<p data-nodeid="593" class="">上一讲我们讨论了 JavaScript 引擎的 Eventloop 相关内容，今天我们来看看浏览器引擎是如何编译、执行 JS 代码的，目的是帮你深入理解浏览器引擎所做的工作。</p>\n<p data-nodeid="594">本讲我先带你分析浏览器引擎对 JS 代码的编译情况，并结合你日常的 JavaScript 开发经验，一起重新理解底层的编译解析机制。对其底层原理的理解，将有助于你理解前端的跨端应用，以及一套代码生成多种小程序相关框架的底层逻辑。</p>\n<p data-nodeid="595">那么，在课程开始前请你先思考：</p>\n<ol data-nodeid="596">\n<li data-nodeid="597">\n<p data-nodeid="598">JavaScript 代码被执行分为哪几个阶段？</p>\n</li>\n<li data-nodeid="599">\n<p data-nodeid="600">AST 到底是做什么用的？</p>\n</li>\n</ol>\n<p data-nodeid="601">带着思考去学习，相信你会收获更多。现在，就让我为你介绍 V8 引擎。</p>\n<h3 data-nodeid="602">V8 引擎介绍</h3>\n<p data-nodeid="603">我们先看一下当前百花齐放的编程语言，主要分为编译型语言和解释型语言。</p>\n<ol data-nodeid="604">\n<li data-nodeid="605">\n<p data-nodeid="606">编译型语言的特点是在代码运行前编译器直接将对应的代码转换成机器码，运行时不需要再重新翻译，直接可以使用编译后的结果。</p>\n</li>\n<li data-nodeid="607">\n<p data-nodeid="608">解释型语言也是需要将代码转换成机器码，但是和编译型的区别在于运行时需要转换。比较显著的特点是，解释型语言的执行速度要慢于编译型语言，因为解释型语言每次执行都需要把源码转换一次才能执行。</p>\n</li>\n</ol>\n<p data-nodeid="609">我们比较清楚的，像 Java 和 C++ 都是编译型语言；而 JavaScript 和 ruby 都是解释性语言，它们整体的执行速度都会略慢于编译型的语言。</p>\n<p data-nodeid="610">为了提高运行效率，很多浏览器厂商在也在不断努力。目前市面上有很多种 JS 引擎，例如 JavaScriptCore、chakra、V8 等。而比较现代的 JS 引擎，当数 V8，它引入了 Java 虚拟机和 C++ 编译器的众多技术，和早期的 JS 引擎工作方式已经有了很大的不同。</p>\n<p data-nodeid="611">V8 是众多浏览器的 JS 引擎中性能表现最好的一个，并且它是 Chrome 的内核，Node.js 也是基于 V8 引擎研发的。V8 引擎很具有代表性，因此你有必要好好了解和学习。</p>\n<p data-nodeid="612">那么我们来看下 V8 引擎执行 JS 代码都要经过哪些阶段。</p>\n<ol data-nodeid="613">\n<li data-nodeid="614">\n<p data-nodeid="615">Parse 阶段：V8 引擎负责将 JS 代码转换成 AST（抽象语法树）；</p>\n</li>\n<li data-nodeid="616">\n<p data-nodeid="617">Ignition 阶段：解释器将 AST 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；</p>\n</li>\n<li data-nodeid="618">\n<p data-nodeid="619">TurboFan 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；</p>\n</li>\n<li data-nodeid="620">\n<p data-nodeid="621">Orinoco 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。</p>\n</li>\n</ol>\n<p data-nodeid="622">其中，生成 AST、生成字节码、生成机器码是比较重要的三个阶段，下面我就对其进行详细分析，看看每个底层阶段到底做了哪些操作，会影响 JS 代码执行的编译执行。</p>\n<h3 data-nodeid="623">生成 AST</h3>\n<p data-nodeid="624">身为一名前端开发，你肯定在日常工作中用过 Eslint 和 Babel 这两个工具，这些工具每个都和 AST 脱不了干系。V8 引擎就是通过编译器（Parse）将源代码解析成 AST 的。</p>\n<p data-nodeid="625">AST 在实际工作中应用场景也比较多，我们来看看抽象语法树的应用场景，大致有下面几个：</p>\n<ol data-nodeid="626">\n<li data-nodeid="627">\n<p data-nodeid="628">JS 反编译，语法解析；</p>\n</li>\n<li data-nodeid="629">\n<p data-nodeid="630">Babel 编译 ES6 语法；</p>\n</li>\n<li data-nodeid="631">\n<p data-nodeid="632">代码高亮；</p>\n</li>\n<li data-nodeid="633">\n<p data-nodeid="634">关键字匹配；</p>\n</li>\n<li data-nodeid="635">\n<p data-nodeid="636">代码压缩。</p>\n</li>\n</ol>\n<p data-nodeid="637">这些场景的实现，都离不开通过将 JS 代码解析成 AST 来实现。生成 AST 分为两个阶段，一是词法分析，二是语法分析，我们来分别看下这两个阶段的情况。</p>\n<ol data-nodeid="638">\n<li data-nodeid="639">\n<p data-nodeid="640">词法分析：这个阶段会将源代码拆成最小的、不可再分的词法单元，称为 token。比如这行代码 var a =1；通常会被分解成 var 、a、=、2、; 这五个词法单元。另外刚才代码中的空格在 JavaScript 中是直接忽略的。</p>\n</li>\n<li data-nodeid="641">\n<p data-nodeid="642">语法分析：这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为抽象语法树。</p>\n</li>\n</ol>\n<p data-nodeid="643">下面我们来简单看一下解析成抽象语法树之后是什么样子的，代码如下。</p>\n<pre class="lang-javascript" data-nodeid="644"><code data-language="javascript"><span class="hljs-comment">// 第一段代码</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-comment">// 第二段代码</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a,b</span>) </span>{\n  <span class="hljs-keyword">return</span> a + b;\n}\n</code></pre>\n<p data-nodeid="645">将这两段代码，分别转换成 AST 抽象语法树之后返回的 JSON 格式如下。</p>\n<p data-nodeid="646"><strong data-nodeid="709">1</strong>. 第一段代码，编译后的结果：</p>\n<pre class="lang-json" data-nodeid="647"><code data-language="json">{\n&nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Program"</span>,\n&nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>,\n&nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">10</span>,\n&nbsp; <span class="hljs-attr">"body"</span>: [\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"VariableDeclaration"</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">10</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"declarations"</span>: [\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"VariableDeclarator"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">4</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">9</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"id"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Identifier"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">4</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"a"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"init"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Literal"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">8</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">9</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"value"</span>: <span class="hljs-number">1</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"raw"</span>: <span class="hljs-string">"1"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"kind"</span>: <span class="hljs-string">"var"</span>\n&nbsp; &nbsp; }\n&nbsp; ],\n&nbsp; <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>\n}\n</code></pre>\n<p data-nodeid="648"><strong data-nodeid="714">2</strong>. 第二段代码，编译出来的结果：</p>\n<pre class="lang-json" data-nodeid="649"><code data-language="json">{\n&nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Program"</span>,\n&nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>,\n&nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">38</span>,\n&nbsp; <span class="hljs-attr">"body"</span>: [\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"FunctionDeclaration"</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">38</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"id"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Identifier"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">9</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">12</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"sum"</span>\n&nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"expression"</span>: <span class="hljs-literal">false</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"generator"</span>: <span class="hljs-literal">false</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"async"</span>: <span class="hljs-literal">false</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"params"</span>: [\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Identifier"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">14</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">15</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"a"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Identifier"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">16</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">17</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"b"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"body"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"BlockStatement"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">19</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">38</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"body"</span>: [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"ReturnStatement"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">23</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">36</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"argument"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"BinaryExpression"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">30</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">35</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"left"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Identifier"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">30</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">31</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"a"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"operator"</span>: <span class="hljs-string">"+"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"right"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"type"</span>: <span class="hljs-string">"Identifier"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"start"</span>: <span class="hljs-number">34</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"end"</span>: <span class="hljs-number">35</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"b"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; ],\n&nbsp; <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>\n}\n</code></pre>\n<p data-nodeid="650">从上面编译出的结果可以看到，AST 只是源代码语法结构的一种抽象的表示形式，计算机也不会去直接去识别 JS 代码，转换成抽象语法树也只是识别这一过程中的第一步。</p>\n<p data-nodeid="651">前面我提到了前端领域经常使用一个工具 Babel，比如现在浏览器还不支持 ES6 语法，需要将其转换成 ES5 语法，这个过程就要借助 Babel 来实现。将 ES6 源码解析成 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。另外 ESlint 的原理也大致相同，检测流程也是将源码转换成抽象语法树，再利用它来检测代码规范。</p>\n<p data-nodeid="652">抽象语法树是一个很重要的概念，需要深入了解，才能更好地帮助我们理解所写代码。如果你想自己把代码翻译成 AST，我给你提供一个地址，代码帖进去就可以转换成相应的 AST：<a href="https://astexplorer.net/" data-nodeid="720">AST 在线转换</a>。</p>\n<p data-nodeid="653">好了，接下来我们讨论一下 AST 如何转换成字节码。</p>\n<h3 data-nodeid="654">生成字节码</h3>\n<p data-nodeid="655">将抽象语法树转换为字节码，也就是上面提到的 Ignition 阶段。这个阶段就是将 AST 转换为字节码，但是之前的 V8 版本不会经过这个过程，最早只是通过 AST 直接转换成机器码，而后面几个版本中才对此进行了改进。如果将 AST 直接转换为机器码还是会有一些问题存在的，例如：</p>\n<ol data-nodeid="656">\n<li data-nodeid="657">\n<p data-nodeid="658">直接转换会带来内存占用过大的问题，因为将抽象语法树全部生成了机器码，而机器码相比字节码占用的内存多了很多；</p>\n</li>\n<li data-nodeid="659">\n<p data-nodeid="660">某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些代码没必要生成机器码，进而尽可能减少了占用内存过大的问题。</p>\n</li>\n</ol>\n<p data-nodeid="661">而后，官方在 V8 的 v5.6 版本中还是将抽象语法树转换成字节码这一过程又加上了，重新加入了字节码的处理过程。再然后，V8 重新引进了 Ignition 解释器，将抽象语法树转换成字节码后，内存占用显著下降了，同时也可以使用 JIT 编译器做进一步的优化。</p>\n<p data-nodeid="662">其实字节码是介于 AST 和机器码之间的一种代码，需要将其转换成机器码后才能执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。这里你只需要知道这是个中间代码就够了，我们接着看最后一个阶段。</p>\n<h3 data-nodeid="663">生成机器码</h3>\n<p data-nodeid="664">在 Ignition 解释器处理完之后，如果发现一段代码被重复执行多次的情况，生成的字节码以及分析数据会传给 TurboFan 编译器，它会根据分析数据的情况生成优化好的机器码。再执行这段代码之后，只需要直接执行编译后的机器码，这样性能就会更好。</p>\n<p data-nodeid="665">这里简单说一下 TurboFan 编译器，它是 JIT 优化的编译器，因为 V8 引擎是多线程的，TurboFan 的编译线程和生成字节码不会在同一个线程上，这样可以和 Ignition 解释器相互配合着使用，不受另一方的影响。</p>\n<p data-nodeid="1029">由 Ignition 解释器收集的分析数据被 TurboFan 编译器使用，主要是通过一种推测优化的技术，生成已经优化的机器码来执行。这个过程我只是通过文字描述，可能你很难理解，你通过一张图来看下整个生成抽象语法树，再到转换成字节码以及机器码的一个过程。</p>\n<p data-nodeid="1030" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/1D/05/Cgp9HWBPFDuAS9GdAAGqbvfuWtc433.png" alt="图片3.png" data-nodeid="1034"></p>\n\n\n<p data-nodeid="668">上面这张图可以很清晰地看到整个 V8 引擎编译和解析代码的流程。那么到这里，关于 V8 引擎对 JS 的编译解析过程大致就讲完了。因为 V8 涉及的内容实在太多，想要将它理解深刻，你就需要反复琢磨其中的流程，以及我带你分析的每一个步骤。</p>\n<h3 data-nodeid="669">总结</h3>\n<p data-nodeid="670">目前市面上比较主流的 JavaScript 引擎编译过程大部分都类似，主要原因可能在于某些地方加入了特定的优化，但是其核心思路和 V8 大体上是一致的，感兴趣的话你可以了解一下其他引擎的情况，这里就不过多展开了。</p>\n<p data-nodeid="671">那么讲到这里，开篇我提出来的问题相信你基本就可以回答出来了。另外 AST 是比较重要的一个知识点，只有学习了 AST 之后，你才能在自己实现前端工具上面游刃有余。因此希望你可以多研究一些前端工具，来提升你的业务开发效率以及编程能力，这对你未来的成长和晋升是很有帮助的。</p>\n<p data-nodeid="672" class="">下一讲我要带你探究宏任务和微任务的运行机制，这也是 Eventloop 知识里面一个比较关键的知识点，你可以预习一下，届时我们再一起讨论。</p>',
          },
          {
            theme: '21 | 引擎进阶（上）：探究宏任务 & 微任务的运行机制',
            id: 122,
            content:
              '<p data-nodeid="633" class="">不知道你是否还记得在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6192" data-nodeid="721">第 19 讲</a>中，我对 Eventloop 的知识进行了讲解，其中对宏任务和微任务做了简单的铺垫，那么这一讲我们就来深挖一下它背后蕴含的原理。</p>\n<p data-nodeid="791" class="">我会先带你分析宏任务和微任务的运行机制，并针对你日常开发中遇到的各种宏任务&amp;微任务的方法，结合一些例子来看看代码运行的顺序逻辑，帮你把这部分知识点重新归纳和梳理。</p>\n\n<p data-nodeid="635">在日常开发中，例如 setTimeout 和 promise 都是经常会使用到的 JS 方法。当这些方法变多了之后，再结合 JS 的异步编程代码混合使用，最终的执行顺序也经常会让开发者迷惑，因此要把这些问题搞清楚，这部分你还是有必要好好学习一下。</p>\n<p data-nodeid="636">在课程开始前请你先思考一下：</p>\n<ol data-nodeid="637">\n<li data-nodeid="638">\n<p data-nodeid="639">宏任务和微任务分别有哪些方法？</p>\n</li>\n<li data-nodeid="640">\n<p data-nodeid="641">宏任务和微任务互相嵌套，执行顺序是什么样的？</p>\n</li>\n</ol>\n<h3 data-nodeid="642">代码执行顺序（一）</h3>\n<p data-nodeid="643">开始讲解正式内容之前，我们先看一段代码，算是开胃的前菜，如果你之前对这部分知识稍有了解，一般都应该可以回答正确。</p>\n<pre class="lang-javascript" data-nodeid="644"><code data-language="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'begin\'</span>);\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'setTimeout\'</span>)\n}, <span class="hljs-number">0</span>);\n<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'promise\'</span>);\n  resolve()\n}).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'then1\'</span>);\n  }).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'then2\'</span>);\n  });\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'end\'</span>);\n</code></pre>\n<p data-nodeid="645">这段代码应该比较简单，答案就是：</p>\n<pre class="lang-java" data-nodeid="646"><code data-language="java">begin\npromise\nend\nthen1\nthen2\nsetTimeout\n</code></pre>\n<p data-nodeid="647">其实这个就涉及了 JavaScript 事件轮询中的宏任务和微任务，如果你答对了，恭喜你，说明你的基本思路是没问题的。那么这里我就直接给出结论，宏任务和微任务的执行顺序基本是，在 EventLoop 中，每一次循环称为一次 tick，主要的任务顺序如下：</p>\n<ol data-nodeid="648">\n<li data-nodeid="649">\n<p data-nodeid="650">执行栈选择最先进入队列的宏任务，执行其同步代码直至结束；</p>\n</li>\n<li data-nodeid="651">\n<p data-nodeid="652">检查是否有微任务，如果有则执行直到微任务队列为空；</p>\n</li>\n<li data-nodeid="653">\n<p data-nodeid="654">如果是在浏览器端，那么基本要渲染页面了；</p>\n</li>\n<li data-nodeid="655">\n<p data-nodeid="656">开始下一轮的循环（tick），执行宏任务中的一些异步代码，例如 setTimeout 等。</p>\n</li>\n</ol>\n<p data-nodeid="657">那么结合这个结论，以及第 19 讲学习的 EventLoop 的内容，来看下它们的运转流程效果图。</p>\n<p data-nodeid="658"><img src="https://s0.lgstatic.com/i/image6/M00/1E/49/Cgp9HWBQhFyAf7TxAAK_oyhU5eM671.png" alt="图片1.png" data-nodeid="741"></p>\n<p data-nodeid="659">Call-Stack（调用栈）也就是执行栈，它是一个栈的结构，符合先进后出的机制，每次一个循环，先执行最先入队的宏任务，然后再执行微任务。不管微任务还是宏任务，它们只要按照顺序进入了执行栈，那么执行栈就还是按照先进后出的规则，一步一步执行。</p>\n<p data-nodeid="660">因此根据这个原则，最先进行调用栈的宏任务，一般情况下都是最后返回执行的结果。那么从上面的代码中可以看到 setTimeout 的确最后执行了打印的结果。</p>\n<p data-nodeid="661">这就是宏任务和微任务代码夹杂的情况下，代码的执行顺序，那么下面我们来专门看看宏任务到底有哪些，有什么值得关注的点。</p>\n<h3 data-nodeid="662">宏任务</h3>\n<p data-nodeid="663">如果在浏览器的环境下，宏任务主要分为下面这几个大类：</p>\n<ol data-nodeid="664">\n<li data-nodeid="665">\n<p data-nodeid="666">渲染事件（比如解析 DOM、计算布局、绘制）；</p>\n</li>\n<li data-nodeid="667">\n<p data-nodeid="668">用户交互事件（比如鼠标点击、滚动页面、放大缩小等）；</p>\n</li>\n<li data-nodeid="669">\n<p data-nodeid="670">setTimeout、setInterval 等；</p>\n</li>\n<li data-nodeid="671">\n<p data-nodeid="672">网络请求完成、文件读写完成事件。</p>\n</li>\n</ol>\n<p data-nodeid="673">为了让这些任务在主线程上执行，页面进程引入了消息队列和事件循环机制，我们把这些消息队列中的任务称为宏任务。宏任务基本上满足了日常的开发需求，而对于时间精度有要求的宏任务就不太能满足了，比如渲染事件、各种 I/O、用户交互的事件等，都随时有可能被添加到消息队列中，JS 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。</p>\n<p data-nodeid="674">为了方便理解，你可以看看下面的这段代码。</p>\n<pre class="lang-javascript" data-nodeid="675"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)\n    setTimeout(callback2,<span class="hljs-number">0</span>)\n}\nsetTimeout(callback,<span class="hljs-number">0</span>)\n</code></pre>\n<p data-nodeid="676">在上面这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务。但是实际情况我们难以控制，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。所以说宏任务的时间粒度比较大，执行的间隔是不能精确控制的。这就不适用于一些高实时性的需求了，比如后面要讲到的监听 DOM 变化。</p>\n<h3 data-nodeid="677">微任务</h3>\n<p data-nodeid="678">在理解了宏任务之后，下面我们就可以来看看什么是微任务了。微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>\n<p data-nodeid="679">我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，同时 V8 引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p>\n<p data-nodeid="680">那么微任务是怎么产生的呢？在现代浏览器里面，产生微任务有两种方式。</p>\n<ol data-nodeid="681">\n<li data-nodeid="682">\n<p data-nodeid="683">使用 MutationObserver 监控某个 DOM 节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p>\n</li>\n<li data-nodeid="684">\n<p data-nodeid="685">使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</p>\n</li>\n</ol>\n<p data-nodeid="686">通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JS 引擎按照顺序保存到微任务队列中。现在微任务队列中有了微任务，那么接下来就要看看微任务队列是何时被执行的。</p>\n<p data-nodeid="687">通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就是在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p>\n<p data-nodeid="688">如果在执行微任务的过程中，产生了新的微任务，一样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列清空才算执行结束。也就是说<strong data-nodeid="767">在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行</strong>，这点是需要注意的。</p>\n<p data-nodeid="689">以上就是微任务的工作流程，从上面的分析我们可以得出如下几个结论。</p>\n<ol data-nodeid="690">\n<li data-nodeid="691">\n<p data-nodeid="692">微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</p>\n</li>\n<li data-nodeid="693">\n<p data-nodeid="694">微任务的执行时长会影响当前宏任务的时长。比如一个宏任务在执行过程中，产生了 10 个微任务，执行每个微任务的时间是 10ms，那么执行这 10 个微任务的时间就是 100ms，也可以说这 10 个微任务让宏任务的执行时间延长了 100ms。</p>\n</li>\n<li data-nodeid="695">\n<p data-nodeid="696">在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</p>\n</li>\n</ol>\n<p data-nodeid="697">关于微任务就先说到这里，上面我提到了 MutationObserver，它又是什么呢？下面一起来看一下。</p>\n<h3 data-nodeid="698">监听 DOM 变化应用场景</h3>\n<p data-nodeid="699">MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师经常要做的事情之一。</p>\n<p data-nodeid="700">虽然监听 DOM 的需求是比较频繁的，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测。比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p>\n<p data-nodeid="701">从 DOM 4 开始，W3C 推出了 MutationObserver。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变更、节点的增加、内容的改变等。因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p>\n<p data-nodeid="702">综上所述，MutationObserver 采用了“异步 + 微任务”的策略：</p>\n<ul data-nodeid="703">\n<li data-nodeid="704">\n<p data-nodeid="705">通过异步操作解决了同步操作的性能问题；</p>\n</li>\n<li data-nodeid="706">\n<p data-nodeid="707">通过微任务解决了实时性的问题。</p>\n</li>\n</ul>\n<p data-nodeid="708">好了，到这里你对宏任务和微任务的原理，以及执行顺序的特点已经有一定的了解了，那么最后我再结合 JS 的异步编程，给你展示一段比开篇那段更复杂一些的代码片段，考考你是否能说出正确答案。</p>\n<h3 data-nodeid="709">代码执行顺序（二）</h3>\n<p data-nodeid="710">通过上面的原理学习，请你接着看下面的代码，它的执行结果是什么样的呢？</p>\n<pre class="lang-javascript" data-nodeid="711"><code data-language="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 start"</span>);\n  <span class="hljs-keyword">await</span> async2();\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 end"</span>);\n}\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async2"</span>);\n}\nasync1();\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"timeout"</span>);\n}, <span class="hljs-number">0</span>);\n<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise1"</span>);\n  resolve();\n}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise2"</span>);\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script end"</span>);\n</code></pre>\n<p data-nodeid="2701" class="te-preview-highlight">这段代码除了考察你对微任务和宏任务的理解外，也顺带考察了宏任务微任务结合异步编程最后的执行逻辑，这里你可以先按照自己的学习思路给出一个答案，之后再拿到浏览器端运行一下结果，对照着你的答案看是否正确，这里我就先不放答案了，因为怕会影响你的思考。</p>\n\n\n\n\n\n\n<h3 data-nodeid="713">总结</h3>\n<p data-nodeid="714">这一讲，我们一起探讨了宏任务和微任务的相关知识，针对宏任务和微任务的区别以及执行顺序，我这里总结了一个表格，方便你深入理解，请看。</p>\n<p data-nodeid="715"><img src="https://s0.lgstatic.com/i/image6/M00/1E/49/Cgp9HWBQhGiAIsk6AAE2uN-H8dg753.png" alt="图片2.png" data-nodeid="788"></p>\n<p data-nodeid="716">另外，关于我在文中提到的 MutationObserver，你可以进行一些实践，更深入地了解它的底层逻辑，介于篇幅的问题，这部分知识点我就不过多介绍了。</p>\n<p data-nodeid="717" class="">好了，这一讲就先说到这里了。接下来我们就要进入 JS 引擎篇的最后一讲 Process.nextTick 的原理学习，从上面的表格中你可以看出 Process.nextTick 也是微任务中的一种，它又会带给我们哪些思考呢？下一讲我会为你揭晓。</p>',
          },
          {
            theme: '22 | 引擎进阶（下）：如何理解 Process.nextTick 的原理？',
            id: 123,
            content:
              '<p data-nodeid="665" class="">上一讲我们讨论了宏任务和微任务的运行机制和原理，我在最后提到了 Process.nextTick 是微任务的其中一个，那么这一讲我们就来深挖一下 Process.nextTick 的相关知识。</p>\n<p data-nodeid="666">这一讲我除了结合上一讲说的究宏任务和微任务的运行机制外，还将通过一些代码片段来带你研究 Process.nextick 的执行逻辑，帮你把这块知识点重新梳理。在日常开发中，Process.nextick 在浏览器端代码中很少使用，但在 Node.js 开发种却极为常见，所以你要好好掌握。</p>\n<p data-nodeid="667">那么，为了方便你更好地理解本讲的内容，在课程开始前请你先思考：</p>\n<ol data-nodeid="668">\n<li data-nodeid="669">\n<p data-nodeid="670">Process.nextick 和其他微任务方法在一起的时候，执行顺序是怎么样的？</p>\n</li>\n<li data-nodeid="671">\n<p data-nodeid="672">Vue 也有个 nextick，它的逻辑又是什么样的？</p>\n</li>\n</ol>\n<p data-nodeid="673">带着疑问，我们先来了解一下 Process.nextick。</p>\n<h3 data-nodeid="674">基本语法</h3>\n<p data-nodeid="675">Process.nextick 的语法有两个参数：</p>\n<blockquote data-nodeid="676">\n<p data-nodeid="677">process.nextTick(callback[, ...args])</p>\n</blockquote>\n<p data-nodeid="678">其中，第一个参数是 callback 回调函数，第二个参数是 args 调用 callback 时额外传的参数，是可选参数。</p>\n<p data-nodeid="679">再来看下 Process.nextick 的运行逻辑：</p>\n<ol data-nodeid="680">\n<li data-nodeid="681">\n<p data-nodeid="682">Process.nextick 会将 callback 添加到“next tick queue”；</p>\n</li>\n<li data-nodeid="683">\n<p data-nodeid="684">“next tick queue”会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队；</p>\n</li>\n<li data-nodeid="685">\n<p data-nodeid="686">如果递归调用 Process.nextick 可能会导致一个无限循环，需要去适时终止递归。</p>\n</li>\n</ol>\n<p data-nodeid="687">可能你已经注意到 Process.nextick 其实是微任务，同时也是异步 API 的一部分。但是从技术上来说 Process.nextick 并不是事件循环（eventloop）的一部分，相反地，“next tick queue”将会在当前操作完成之后立即被处理，而不管当前处于事件循环的哪个阶段。</p>\n<p data-nodeid="688">思考一下上面的逻辑，如果任何时刻你在一个给定的阶段调用 Process.nextick，则所有被传入 Process.nextick 的回调将在事件循环继续往下执行前被执行。这可能会导致一些很糟的情形，因为它允许用户递归调用 Process.nextick 来挂起 I/O 进程的进行，这会导致事件循环永远无法到达轮询阶段。</p>\n<h3 data-nodeid="689">为什么使用 Process.nextTick()</h3>\n<p data-nodeid="690">那么为什么 Process.nextick 这样的 API 会被允许出现在 Node.js 中呢？一部分原因是设计理念，Node.js 中的 API 应该总是异步的，即使是那些不需要异步的地方。下面的代码片段展示了一个例子：</p>\n<pre class="lang-javascript" data-nodeid="691"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apiCall</span>(<span class="hljs-params">arg, callback</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">\'string\'</span>)\n  <span class="hljs-keyword">return</span> process.nextTick(callback, <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">\'argument should be     string\'</span>));\n}\n</code></pre>\n<p data-nodeid="692">通过上面的代码检查参数，如果检查不通过，它将一个错误对象传给回调。Node.js API 最近进行了更新，其已经允许向 Process.nextick 中传递参数来作为回调函数的参数，而不必写嵌套函数。</p>\n<p data-nodeid="693">我们所做的就是将一个错误传递给用户，但这只允许在用户代码被执行完毕后执行。使用 Process.nextick 我们可以保证 apicall() 的回调总是在用户代码被执行后，且在事件循环继续工作前被执行。为了达到这一点，JS 调用栈被允许展开，然后立即执行所提供的回调。该回调允许用户对 Process.nextick 进行递归调用，而不会达到 RangeError，即 V8 调用栈的最大值。</p>\n<p data-nodeid="694">这种设计理念会导致一些潜在的问题，观察下面的代码片段：</p>\n<pre class="lang-javascript" data-nodeid="695"><code data-language="javascript"><span class="hljs-keyword">let</span> bar;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAsyncApiCall</span>(<span class="hljs-params">callback</span>) </span>{ callback(); }\nsomeAsyncApiCall(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'bar\'</span>, bar);   <span class="hljs-comment">// undefined</span>\n});\nbar = <span class="hljs-number">1</span>;\n</code></pre>\n<p data-nodeid="696">用户定义函数 someAsyncApiCall() 有一个异步签名，但实际上它是同步执行的。当它被调用时，提供给 someAsyncApiCall() 的回调函数会在执行 someAsyncApiCall() 本身的同一个事件循环阶段被执行，因为 someAsyncApiCall() 实际上并未执行任何异步操作。结果就是，即使回调函数尝试引用变量 bar，但此时在作用域中并没有改变量。因为程序还没运行到对 bar 赋值的部分。</p>\n<p data-nodeid="697">将回调放到 Process.nextick 中，程序依然可以执行完毕，且所有的变量、函数等都在执行回调之前被初始化，它还具有不会被事件循环打断的优点。以下是将上面的例子改用 Process.nextick 的代码：</p>\n<pre class="lang-javascript" data-nodeid="698"><code data-language="javascript"><span class="hljs-keyword">let</span> bar;\n&nbsp;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAsyncApiCall</span>(<span class="hljs-params">callback</span>) </span>{\n  process.nextTick(callback);\n}\n&nbsp;\nsomeAsyncApiCall(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'bar\'</span>, bar); <span class="hljs-comment">// 1</span>\n});\n&nbsp;\nbar = <span class="hljs-number">1</span>;\n</code></pre>\n<p data-nodeid="699">通过这个例子，你就可以体会到 Process.nextick 的作用了。其实在日常的 Node.js 开发中，这样的情况也经常会遇见，之前在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6189&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="789">16 | 进阶练习（上）：怎样轻松实现一个 EventEmitter</a>”中我有讲过 EventEmitter，那么我们看下 EventEmitter 在 Node.js 的使用的一个例子。</p>\n<p data-nodeid="700">因为 Node.js 直接有 event 模块，其实就是一个 EventEmitter，下面代码是在造函数中触发一个事件：</p>\n<pre class="lang-javascript" data-nodeid="701"><code data-language="javascript"><span class="hljs-keyword">const</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'util\'</span>);\n&nbsp;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyEmitter</span>(<span class="hljs-params"></span>) </span>{\nEventEmitter.call(<span class="hljs-keyword">this</span>);\n<span class="hljs-keyword">this</span>.emit(<span class="hljs-string">\'event\'</span>);\n}\nutil.inherits(MyEmitter, EventEmitter);\n&nbsp;\n<span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> MyEmitter();\nmyEmitter.on(<span class="hljs-string">\'event\'</span>, () =&gt; {\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'an event occurred!\'</span>);\n});\n</code></pre>\n<p data-nodeid="702">你无法在构造函数中立即触发一个事件，因为此时程序还未运行到将回调赋值给事件的那段代码。因此，在构造函数内部，你可以使用 Process.nextick 设置一个回调以在构造函数执行完毕后触发事件，下面的代码满足了我们的预期。</p>\n<pre class="lang-javascript" data-nodeid="703"><code data-language="javascript"><span class="hljs-keyword">const</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'util\'</span>);\n&nbsp;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyEmitter</span>(<span class="hljs-params"></span>) </span>{\nEventEmitter.call(<span class="hljs-keyword">this</span>);\nprocess.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">\'event\'</span>);\n});\n}\nutil.inherits(MyEmitter, EventEmitter);\n&nbsp;\n<span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> MyEmitter();\n  myEmitter.on(<span class="hljs-string">\'event\'</span>, () =&gt; {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'an event occurred!\'</span>);\n});\n</code></pre>\n<p data-nodeid="704">通过上面的改造可以看出，使用 Process.nextick 就可以解决问题了，即使 event 事件还没进行绑定，但也可以让代码在前面进行触发，因为根据代码执行顺序，Process.nextick 是在每一次的事件循环最后执行的。因此这样写，代码也不会报错，同样又保持了代码的逻辑。</p>\n<p data-nodeid="705">通过这两个例子你应该对 Process.nextick 这个知识有了更好的理解了吧？下面我们再来看看浏览器端 Vue 框架的 nextick 是干什么用的，注意不要将二者混淆了，前面讲的是 Node.js 服务端的事情，而下面要说的是浏览器端 Vue 框架的知识。</p>\n<h3 data-nodeid="706">Vue 的 nextick 又是什么意思？</h3>\n<p data-nodeid="707">我们看下 Vue 官网最直白的解释：</p>\n<blockquote data-nodeid="708">\n<p data-nodeid="709">Vue 异步执行 DOM 的更新。当数据发生变化时，Vue 会开启一个队列，用于缓冲在同一事件循环中发生的所有数据改变的情况。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后在下一个的事件循环“tick”中。例如：当你设置 vm.someData = \'new value\'，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。</p>\n</blockquote>\n<p data-nodeid="710">我们细细地根据 Vue 的官网理解一下，其实是不是有点像 EventLoop 的味道，这里只不过是 Vue 开启了一个队列，当你在 nextick 方法中改变数据的时候，视图层不会立马更新，而是要在下次的时间循环队列中更新。</p>\n<p data-nodeid="711">这点是不是类似上面讲的 Node.js 的 Process.nextick 的意思？虽然运行的环境不一样，但是这个意思你可以细细品味一下。这里我们再来看一段 Vue 代码，让你理解 Vue 的 nextick 的作用。</p>\n<pre class="lang-xml" data-nodeid="712"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"msg"</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"msg1"</span>&gt;</span>Message got outside $nextTick: {{msg1}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"msg2"</span>&gt;</span>Message got inside $nextTick: {{msg2}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeMsg"</span>&gt;</span>\n      Change the Message\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">new</span> Vue({\n  <span class="hljs-attr">el</span>: <span class="hljs-string">\'.app\'</span>,\n  <span class="hljs-attr">data</span>: {\n    <span class="hljs-attr">msg</span>: <span class="hljs-string">\'Vue\'</span>,\n    <span class="hljs-attr">msg1</span>: <span class="hljs-string">\'\'</span>,\n    <span class="hljs-attr">msg2</span>: <span class="hljs-string">\'\'</span>,\n  },\n  <span class="hljs-attr">methods</span>: {\n    changeMsg() {\n      <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">"Hello world."</span>\n      <span class="hljs-keyword">this</span>.msg1 = <span class="hljs-keyword">this</span>.$refs.msg.innerHTML\n      <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.msg2 = <span class="hljs-keyword">this</span>.$refs.msg.innerHTML\n      })\n    }\n  }\n})\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p data-nodeid="713">你可以将这一段代码放到自己的 Vue 的项目里执行一下，看看通过按钮点击之后，div 里面的 msg1 和 msg2 的变化情况。你会发现第一次点击按钮调用 changeMsg 方法时，其实 msg2 并没有变化，因为 msg2 的变化是在下一个 tick 才进行执行的。</p>\n<p data-nodeid="714">最后我们再来看下 Vue 中 nextick 的源码。在 Vue 2.5+ 之后的版本中，有一个单独的 JS 文件来维护，路径是在 src/core/util/next-tick.js 中，源码如下：</p>\n<pre class="lang-javascript" data-nodeid="715"><code data-language="javascript"><span class="hljs-comment">/* @flow */</span>\n\t<span class="hljs-comment">/* globals MutationObserver */</span>\n\t\n\t<span class="hljs-keyword">import</span> { noop } <span class="hljs-keyword">from</span> <span class="hljs-string">\'shared/util\'</span>\n\t<span class="hljs-keyword">import</span> { handleError } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./error\'</span>\n\t<span class="hljs-keyword">import</span> { isIE, isIOS, isNative } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./env\'</span>\n\t\n\t<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> isUsingMicroTask = <span class="hljs-literal">false</span>\n\t\n\t<span class="hljs-keyword">const</span> callbacks = []\n\t<span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span>\n\t\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushCallbacks</span> (<span class="hljs-params"></span>) </span>{\n\t  pending = <span class="hljs-literal">false</span>\n\t  <span class="hljs-keyword">const</span> copies = callbacks.slice(<span class="hljs-number">0</span>)\n\t  callbacks.length = <span class="hljs-number">0</span>\n\t  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.length; i++) {\n\t    copies[i]()\n\t  }\n\t}\n\t\n\t<span class="hljs-comment">// Here we have async deferring wrappers using microtasks.</span>\n\t<span class="hljs-comment">// In 2.5 we used (macro) tasks (in combination with microtasks).</span>\n\t<span class="hljs-comment">// However, it has subtle problems when state is changed right before repaint</span>\n\t<span class="hljs-comment">// (e.g. #6813, out-in transitions).</span>\n\t<span class="hljs-comment">// Also, using (macro) tasks in event handler would cause some weird behaviors</span>\n\t<span class="hljs-comment">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span>\n\t<span class="hljs-comment">// So we now use microtasks everywhere, again.</span>\n\t<span class="hljs-comment">// A major drawback of this tradeoff is that there are some scenarios</span>\n\t<span class="hljs-comment">// where microtasks have too high a priority and fire in between supposedly</span>\n\t<span class="hljs-comment">// sequential events (e.g. #4521, #6690, which have workarounds)</span>\n\t<span class="hljs-comment">// or even between bubbling of the same event (#6566).</span>\n\t<span class="hljs-keyword">let</span> timerFunc\n\t\n\t<span class="hljs-comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span>\n\t<span class="hljs-comment">// via either native Promise.then or MutationObserver.</span>\n\t<span class="hljs-comment">// MutationObserver has wider support, however it is seriously bugged in</span>\n\t<span class="hljs-comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span>\n\t<span class="hljs-comment">// completely stops working after triggering a few times... so, if native</span>\n\t<span class="hljs-comment">// Promise is available, we will use it:</span>\n\t<span class="hljs-comment">/* istanbul ignore next, $flow-disable-line */</span>\n\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">\'undefined\'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) {\n\t  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()\n\t  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n\t    p.then(flushCallbacks)\n\t    <span class="hljs-comment">// In problematic UIWebViews, Promise.then doesn\'t completely break, but</span>\n\t    <span class="hljs-comment">// it can get stuck in a weird state where callbacks are pushed into the</span>\n\t    <span class="hljs-comment">// microtask queue but the queue isn\'t being flushed, until the browser</span>\n\t    <span class="hljs-comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>\n\t    <span class="hljs-comment">// "force" the microtask queue to be flushed by adding an empty timer.</span>\n\t     <span class="hljs-keyword">if</span> (isIOS) setTimeout(noop)\n\t  }\n\t  isUsingMicroTask = <span class="hljs-literal">true</span>\n\t} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">\'undefined\'</span> &amp;&amp; (\n\t  isNative(MutationObserver) ||\n\t  <span class="hljs-comment">// PhantomJS and iOS 7.x</span>\n\t  MutationObserver.toString() === <span class="hljs-string">\'[object MutationObserverConstructor]\'</span>\n\t)) {\n\t  <span class="hljs-comment">// Use MutationObserver where native Promise is not available,</span>\n\t  <span class="hljs-comment">// e.g. PhantomJS, iOS7, Android 4.4</span>\n\t  <span class="hljs-comment">// (#6466 MutationObserver is unreliable in IE11)</span>\n\t  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>\n\t  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks)\n\t  <span class="hljs-keyword">const</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter))\n\t  observer.observe(textNode, {\n\t    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span>\n\t  })\n\t  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n\t    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>\n\t    textNode.data = <span class="hljs-built_in">String</span>(counter)\n\t  }\n\t  isUsingMicroTask = <span class="hljs-literal">true</span>\n\t} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">\'undefined\'</span> &amp;&amp; isNative(setImmediate)) {\n\t  <span class="hljs-comment">// Fallback to setImmediate.</span>\n\t  <span class="hljs-comment">// Technically it leverages the (macro) task queue,</span>\n\t  <span class="hljs-comment">// but it is still a better choice than setTimeout.</span>\n\t  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n\t    setImmediate(flushCallbacks)\n\t  }\n\t} <span class="hljs-keyword">else</span> {\n\t  <span class="hljs-comment">// Fallback to setTimeout.</span>\n\t  timerFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n\t    setTimeout(flushCallbacks, <span class="hljs-number">0</span>)\n\t  }\n\t}\n\t\n\t<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb?: Function, ctx?: Object</span>) </span>{\n\t  <span class="hljs-keyword">let</span> _resolve\n\t  callbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n\t    <span class="hljs-keyword">if</span> (cb) {\n\t      <span class="hljs-keyword">try</span> {\n\t        cb.call(ctx)\n\t      } <span class="hljs-keyword">catch</span> (e) {\n\t        handleError(e, ctx, <span class="hljs-string">\'nextTick\'</span>)\n\t      }\n\t    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) {\n\t      _resolve(ctx)\n\t    }\n\t  })\n\t  <span class="hljs-keyword">if</span> (!pending) {\n\t    pending = <span class="hljs-literal">true</span>\n\t    timerFunc()\n\t  }\n\t  <span class="hljs-comment">// $flow-disable-line</span>\n\t  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">\'undefined\'</span>) {\n\t    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {\n\t      _resolve = resolve\n\t    })\n\t  }\n\t}\n</code></pre>\n<p data-nodeid="716">整体代码不是太多，注释比较多，其核心部分代码比较精简，主要在 40~80 行之间，核心在于 timerFunc 这个函数的逻辑实现，timerFunc 这个函数采用了好几种处理方式，主要是针对系统以及 Promise 的支持几个情况同时进行兼容性处理。处理逻辑情况是这样的：</p>\n<ol data-nodeid="717">\n<li data-nodeid="718">\n<p data-nodeid="719">首先判断是否原生支持 Promise，支持的话，利用 promise 来触发执行回调函数；</p>\n</li>\n<li data-nodeid="720">\n<p data-nodeid="721">如果不支持 Promise，再判断是否支持 MutationObserver，如果支持，那么生成一个对象来观察文本节点发生的变化，从而实现触发执行所有回调函数；</p>\n</li>\n<li data-nodeid="722">\n<p data-nodeid="723">如果 Promise 和 MutationObserver 都不支持，那么使用 setTimeout 设置延时为 0。</p>\n</li>\n</ol>\n<p data-nodeid="724">关于 Promise 以及 MutationObserver 的相关知识我已经在前面的课时中都讲过，因此这些方法你只要理解的话，那么再去理解这一讲 nextick 的 timerFunc 这个函数的逻辑就会比较轻松了。这里主要是一些兼容性的判断，即使你之前不清楚，但是看一下源码也就能很容易理解了，只要你的基础知识足够牢靠，学习这些并不复杂。</p>\n<h3 data-nodeid="725">总结</h3>\n<p data-nodeid="726">最后，针对 Process.nextick() 和 Vue 的 nextick 这两种不同的 tick ，我总结了下面这个表格，方便你深入理解。</p>\n<p data-nodeid="831" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/25/22/CioPOWBZZXWAct2kAAFSwK67cM8982.png" alt="图片4.png" data-nodeid="834"></p>\n\n<p data-nodeid="755">那么关于这部分知识，你如果有不理解的地方可以多学习几遍。我们的专栏主课内容到这里也就告一段落了，很高兴你能坚持到最后，也希望我的分享可以为你带来帮助。</p>\n<p data-nodeid="756" class="">别着急走开，之后我们将进入彩蛋环节，一来是帮你梳理前端面试中经常考察的知识点，二来要给你传递学习算法的思路，我想这些也是你前端进阶的必要内容，我们下一讲再见。</p>',
          },
        ],
      },
      {
        sectionName: '彩蛋',
        sectionId: 6,
        courseList: [
          {
            theme: '彩蛋 1 | 如何应对大厂面试官的灵魂拷问？',
            id: 124,
            content:
              '<p data-nodeid="3287" class="">你好，我们的正课内容已经全部结束了，不知道你掌握多少了，或者对我分享的内容有无疑问。课程结束了之后你也可以留言给我，我们可以就技术继续讨论。</p>\n<p data-nodeid="3288">那么这一篇彩蛋，我将结合咱们专栏的一些知识点，带你看看大厂面试都会考察哪些方面，并且我会列出注意事项，希望可以对你的前端进阶提供帮助。</p>\n<h3 data-nodeid="3289">关于岗位</h3>\n<p data-nodeid="3290">无论你是否处于求职阶段，都一定要对自己的职业规划有一个清晰的定位。因此，对于目标公司的选人标准你首先要搞清楚，这样才能有的放矢。如果你的目标是互联网大厂核心业务的前端岗位，那么首先你要找到这个部门招聘的 JD，去研究该部门对前端岗位的要求是什么样的。比如有些部门的诉求是精通 Node.js，另外一些部门要求有前端可视化经验，这里的确会根据每个部门的实际情况而定。</p>\n<p data-nodeid="3291">一起来看看某个一线大厂的前端岗位 JD。</p>\n<p data-nodeid="3292"><img src="https://s0.lgstatic.com/i/image6/M00/25/40/CioPOWBZhMmAey6FAABsTSE2Xzc783.png" alt="Drawing 0.png" data-nodeid="3354"></p>\n<p data-nodeid="3293">从上面的 JD 可以基本看出，这个职位需要候选人有跨端的经验，因此在面试之前你需要对前端动态化相关内容（RN、Weex 等）有一定了解，并且根据你自身的情况看是否匹配。另外，从这个 JD 可以明显看出，该职位做的是面向用户（toC）产品的业务，因为要求你对性能优化以及浏览器兼容问题有一定的理解。</p>\n<p data-nodeid="3294">因此在投递该职位的时候，如果你的技能 80%与之匹配，那么关于用人单位关注的这些点，你最好在简历中突出体现，这就不得不说简历的写法了，下面一起看看大厂都喜欢关注简历的哪些条件。</p>\n<h3 data-nodeid="3295">关于简历</h3>\n<p data-nodeid="3296">我对于简历的理解是，它的作用是让看简历的人能够快速、准确地捕捉到有用信息：你是谁、你做过什么、你的技能亮点体现在哪。</p>\n<p data-nodeid="3297">众所周知，简历除了基本信息外，最重要的是工作经历以及项目经历，下面我就结合自己的看法为你分析一下项目经历如何吸引面试官眼球。</p>\n<p data-nodeid="3298"><strong data-nodeid="3365">1. 真实参与的</strong></p>\n<p data-nodeid="3299">这点不用多说，一定得是自己做的项目。看别人的项目做得不错，就说成是自己做的，面试和背调环节都有可能穿帮。如果你并没有全程参与，而只是参与过其中一环，但如果你了解项目的全过程，那么这也是你的小小成就。</p>\n<p data-nodeid="3300"><strong data-nodeid="3372">2. 很熟悉的</strong></p>\n<p data-nodeid="3301">对于这个项目，你必须在业务和技术实现上都了如指掌。</p>\n<ul data-nodeid="3302">\n<li data-nodeid="3303">\n<p data-nodeid="3304">业务上：这个项目的业务背景是什么，在业务上有什么比较有技术含量的地方，推动了业务如何运行，等等；</p>\n</li>\n<li data-nodeid="3305">\n<p data-nodeid="3306">技术实现上：这个项目的整体技术实现思路是怎样的，项目中用了什么比较不错的技术，解决了什么比较困难的问题，等等。</p>\n</li>\n</ul>\n<p data-nodeid="3307"><strong data-nodeid="3380">注意千万不能有这个想法</strong>：项目中有一个很有技术含量的东西，但不是你实现的，你也完全不了解，就想写进项目里。</p>\n<p data-nodeid="3308"><strong data-nodeid="3386">3. 有亮点的</strong></p>\n<p data-nodeid="3309">面试官比较在意的还是这个项目表面上看不到并且很有趣的东西，像业务、技术都可以。</p>\n<ul data-nodeid="3310">\n<li data-nodeid="3311">\n<p data-nodeid="3312">你在这个项目做了什么有价值的事情；</p>\n</li>\n<li data-nodeid="3313">\n<p data-nodeid="3314">你在项目里做了什么有技术含量的事情；</p>\n</li>\n<li data-nodeid="3315">\n<p data-nodeid="3316">你用了什么样的技术解决了什么困难的问题；</p>\n</li>\n<li data-nodeid="3317">\n<p data-nodeid="3318">……</p>\n</li>\n</ul>\n<p data-nodeid="3319"><strong data-nodeid="3395">总结一下：项目经历一定是面试官比较关心的部分，面试中一定会细问，所以切记不要啰唆，挑有挑战的、有意思的东西写，并且自己能讲明白的。</strong></p>\n<p data-nodeid="3320">接下来还有重要的一环就是专业技能。</p>\n<p data-nodeid="3321">专业技能这部分很多人会这样写：精通 HTML/CSS/JavaScript 等，而且写得特别多，恨不得把自己用过的东西都写在这。</p>\n<p data-nodeid="3322">我个人建议这里不要写太多东西，而是可以写一些在项目经历里没提到的东西。举个例子，如果我的项目经历主要以 Vue 业务开发为主，我在这里就写 TypeScript/React/工程化/Node/MySQL 相关的，一些更细节化的东西会让面试官更全面地了解你。</p>\n<p data-nodeid="3323">如果面试官对此感兴趣，他会挑几个技术栈问你一些问题，如果你能答得很有条理且掺杂了个人想法，那必须是妥妥的加分项。当然了，这些技术栈必须是你了解掌握的，否则随便被问两个问题就不会了，面试成绩会大打折扣。</p>\n<p data-nodeid="3324">此外，从其他方面来说，如果你有想让面试官了解的东西，完全可以体现在简历中，比如对开源项目、博客的积累等。</p>\n<p data-nodeid="3325">综上也就映射出，掌握好专业技术是多么重要，因此面试前的充足准备，即技术复习是必不可少的。</p>\n<h3 data-nodeid="3326">关于复习</h3>\n<p data-nodeid="3327">复习专业知识你需要制定计划，三天打鱼两天晒网可不是个明智之举。最好也不要零散地阅读，而是进行系统地复习。准备面试之前，可以按照几个模块来复习，下面我给你梳理了前端面试可能遇到的知识体系架构，你可以结合自身情况有一个大概的了解。</p>\n<p data-nodeid="3807"><strong data-nodeid="3812">1.JavaScript 相关知识</strong></p>\n<p data-nodeid="3808" class=""><img src="https://s0.lgstatic.com/i/image6/M00/27/BD/CioPOWBdqTKABzwkAAS4O8a6zdg605.png" alt="替换1.png" data-nodeid="3815"></p>\n\n\n<p data-nodeid="3330"><strong data-nodeid="3414">2.CSS 相关知识</strong></p>\n<p data-nodeid="3331" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/25/79/CioPOWBZvCKARqbwAAcG8s48n48724.png" alt="图片2.png" data-nodeid="3417"></p>\n<p data-nodeid="3332"><strong data-nodeid="3421">3.前端框架相关知识</strong></p>\n<p data-nodeid="3333"><img src="https://s0.lgstatic.com/i/image6/M00/25/7C/Cgp9HWBZvCmARl8TAAJGsoqNml4712.png" alt="图片3.png" data-nodeid="3424"></p>\n<p data-nodeid="3334"><strong data-nodeid="3428">4.工程化相关知识</strong></p>\n<p data-nodeid="3335"><img src="https://s0.lgstatic.com/i/image6/M00/25/79/CioPOWBZvC-ADmXKAAaltQiapR0682.png" alt="图片4 (1).png" data-nodeid="3431"></p>\n<p data-nodeid="3336"><strong data-nodeid="3435">5.性能优化相关知识</strong></p>\n<p data-nodeid="3337"><img src="https://s0.lgstatic.com/i/image6/M00/25/7C/Cgp9HWBZvDqAbhRGAAOV9UkSVcc273.png" alt="图片5.png" data-nodeid="3438"></p>\n<p data-nodeid="3338"><strong data-nodeid="3442">6.计算机网络相关知识</strong></p>\n<p data-nodeid="3339"><img src="https://s0.lgstatic.com/i/image6/M00/25/79/CioPOWBZvEKAS-KyAAh_BgalLrE159.png" alt="图片6.png" data-nodeid="3445"></p>\n<p data-nodeid="3340"><strong data-nodeid="3449">7.前端安全相关知识</strong></p>\n<p data-nodeid="3341"><img src="https://s0.lgstatic.com/i/image6/M00/25/7C/Cgp9HWBZvEiAAd_BAAPw1O2oa_U241.png" alt="图片7.png" data-nodeid="3452"></p>\n<p data-nodeid="3342">上面这七大模块，你可以根据每个图的思维架构进行整体学习、复习和巩固。如果你对这些内容，甚至更细化的分支都了如指掌，那么恭喜你，通过大厂面试应该不会有太大问题。</p>\n<p data-nodeid="3343">另外，前端知识体系比较广并且发展迅速，我们一定要铭记：<strong data-nodeid="3459">基础知识是很重要的</strong>，把基础能力打牢，才能以不变应万变。</p>\n<p data-nodeid="3344">技术能力的提升其实也不是一朝一夕可以达成的，需要你从全方位来整体提升自身的技术水平。因此如果你现在身处小厂，技术天花板比较有限，并且你也不想满足于现状的话，你非常有必要从更多角度来提升自己的前端技术能力。</p>\n<p data-nodeid="3345">其实所谓大厂面试官的“灵魂拷问”并没有你想象中那么可怕，结合我自身经验来说，我也经历过很多年的社招/校招，面试候选人近千人。在我看来，我希望招聘的人才是具备扎实的前端编码基本功、超出当前资历的工作经验以及优秀的自主学习能力的。可以说，当你的潜力高出候选人平均水平时，那么你完全可以勇敢地向前迈进，大厂正在向你招手。</p>\n<p data-nodeid="3346" class="">最后，希望你的努力不是说说而已，加油年轻人！</p>',
          },
          {
            theme: '彩蛋 2 | 前端开发如何有针对性地学习算法？',
            id: 125,
            content:
              '<p data-nodeid="9318">为了应一些朋友的诉求，今天这节彩蛋我主要针对算法进行讲解，带你重新学习数据结构，以便更好地应对各种算法题目。</p>\n<p data-nodeid="9319">你也知道算法题目是各种大厂必考的题目，但是由于工作比较忙而没有时间刷题；即便想好好复习一下算法，却又因为知识点太多而无从下手；还有一些非计算机专业出身的前端同学，对数据结构算法并没有系统学习过，面对那么多知识点也比较盲从，不知道哪些需要掌握、哪些不需要掌握。那么希望这一讲彩蛋，能帮助你形成对数据结构算法学习的思路，提升你的学习效率。</p>\n<p data-nodeid="9320">话不多说，先来看看数据结构的存储方式。</p>\n<h3 data-nodeid="9321">数据结构的存储方式</h3>\n<p data-nodeid="9322"><strong data-nodeid="9402">数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）</strong>。根据这两种分类我们来分别看看几个数据结构的 JavaScript 代码描述方式。</p>\n<h4 data-nodeid="9323">顺序存储</h4>\n<p data-nodeid="9324">先来看看 JS 实现一个栈的代码，它是比较典型的顺序存储方式。</p>\n<pre class="lang-javascript" data-nodeid="9325"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-keyword">this</span>.items = []\n  }\n  \n  push(element) {\n    <span class="hljs-keyword">this</span>.items.push(element)\n  }\n  pop() {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.pop()\n  }\n  <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length\n  }\n  <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() {\n    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.items.length\n  }\n  clear() {\n    <span class="hljs-keyword">this</span>.items = []\n  }\n  print() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.items.toString())\n  }\n}\n<span class="hljs-comment">// 初始化一个栈</span>\n<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Stack()\ns.push(<span class="hljs-number">1</span>)\ns.push(<span class="hljs-number">2</span>)\ns.push(<span class="hljs-number">3</span>)\ns.push(<span class="hljs-number">4</span>)\n<span class="hljs-built_in">console</span>.log(s)\n<span class="hljs-built_in">console</span>.log(s.isEmpty)\n<span class="hljs-built_in">console</span>.log(s.size)\n</code></pre>\n<p data-nodeid="9326">上面的代码比较简单，通过 ES6 的语法 class 来描述非常简洁、容易让人理解。那么再看类似的队列，下面这个数据结构应该怎么用 JavaScript 来描述呢？</p>\n<pre class="lang-javascript" data-nodeid="9327"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-keyword">this</span>.items = []\n  }\n  enqueue(element) {\n    <span class="hljs-keyword">this</span>.items.push(element)\n  }\n  shift() {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.shift()\n  }\n  <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length\n  }\n  <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() {\n    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.items.length\n  }\n  clear() {\n    <span class="hljs-keyword">this</span>.items = []\n  }\n  print() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.items.toString())\n  }\n}\n<span class="hljs-comment">// 初始化一个队列</span>\n<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Queue()\ns.enqueue(<span class="hljs-number">1</span>)\ns.enqueue(<span class="hljs-number">2</span>)\ns.enqueue(<span class="hljs-number">3</span>)\ns.enqueue(<span class="hljs-number">4</span>)\n<span class="hljs-built_in">console</span>.log(s)\n<span class="hljs-built_in">console</span>.log(s.isEmpty)\n<span class="hljs-built_in">console</span>.log(s.size)\n</code></pre>\n<p data-nodeid="9328">从上面的两种数据结构的实现方式可以看出，队列和栈都是顺序存储结构，是用数组来模拟实现的，但是两者唯一的区别就在于一个是先进后出，另外一个是先进先出。</p>\n<p data-nodeid="9329">这两个数据结构模拟起来都比较简单，我们再看看较为复杂的链式存储、二叉树和链表等，都是怎么用 JavaScript 来描述的。</p>\n<h4 data-nodeid="9330">链式存储</h4>\n<p data-nodeid="9331">下面代码展示的是最基本的链表的 JS 实现逻辑，也是链式存储最典型的例子。</p>\n<pre class="lang-javascript" data-nodeid="9332"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{\n  <span class="hljs-keyword">constructor</span>(element) {\n    <span class="hljs-keyword">this</span>.element = element\n    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>\n  }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span>\n    <span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>\n  }\n  append(element) {\n    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> Node(element)\n    <span class="hljs-keyword">let</span> current = <span class="hljs-literal">null</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head == <span class="hljs-literal">null</span>) {\n      <span class="hljs-keyword">this</span>.head = node\n    } <span class="hljs-keyword">else</span> {\n      current = <span class="hljs-keyword">this</span>.head\n      <span class="hljs-keyword">while</span> (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    <span class="hljs-keyword">this</span>.length++\n  }\n  insert(position, element) {\n    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> &amp;&amp; position &gt; <span class="hljs-keyword">this</span>.length) {\n       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> \n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> Node(element)\n      <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head\n      <span class="hljs-keyword">let</span> previous = <span class="hljs-literal">null</span>\n      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>\n      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) {\n        <span class="hljs-keyword">this</span>.head = node\n        node.next = current\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">while</span> (index++ &lt; position) {\n          previous = current\n          current = current.next\n        }\n        node.next = current\n        previous.next = node\n      }\n      <span class="hljs-keyword">this</span>.length++\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n    }\n  }\n  \n  removeAt(position) {\n    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> &amp;&amp; position &gt; <span class="hljs-keyword">this</span>.length) {\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head\n      <span class="hljs-keyword">let</span> previous = <span class="hljs-literal">null</span>\n      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>\n      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) {\n        <span class="hljs-keyword">this</span>.head = current.next\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">while</span> (index++ &lt; position) {\n          previous = current\n          current = current.next\n        }\n        previous.next = current.next\n      }\n      <span class="hljs-keyword">this</span>.length--\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n    }\n  }\n  findIndex(element) {\n    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head\n    <span class="hljs-keyword">let</span> index = <span class="hljs-number">-1</span>\n    <span class="hljs-keyword">while</span> (current) {\n      <span class="hljs-keyword">if</span> (current.element === element) {\n        <span class="hljs-keyword">return</span> index + <span class="hljs-number">1</span>\n      }\n      index++\n      current = current.next\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>\n  }\n  remove(element) {\n    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.findIndex(element)\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.removeAt(index)\n  }\n  <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.length\n  }\n  <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() {\n    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.length\n  }\n  toString() {\n    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head\n    <span class="hljs-keyword">let</span> slink = <span class="hljs-string">\'\'</span>\n    <span class="hljs-keyword">while</span> (current) {\n      slink += <span class="hljs-string">`<span class="hljs-subst">${current.element}</span>-`</span>\n      current = current.next\n    }\n    <span class="hljs-keyword">return</span> slink\n  }\n}\n<span class="hljs-comment">// 初始化一个链表</span>\n<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> LinkedList()\ns.append(<span class="hljs-number">1</span>)\ns.append(<span class="hljs-number">2</span>)\ns.append(<span class="hljs-number">3</span>)\ns.append(<span class="hljs-number">4</span>)\n<span class="hljs-built_in">console</span>.log(s)\n<span class="hljs-built_in">console</span>.log(s.isEmpty)\n<span class="hljs-built_in">console</span>.log(s.size)\n</code></pre>\n<p data-nodeid="9333">这段代码同样用 ES6 比较简明的语法实现了链表的数据结构，只要你基本了解数据结构链表的思路，那么对上面的代码理解起来不是很难。</p>\n<p data-nodeid="9334">下面我们再看稍微复杂一些的二叉树的 JS 代码描述。</p>\n<pre class="lang-javascript" data-nodeid="9335"><code data-language="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{\n  <span class="hljs-keyword">constructor</span>(element) {\n    <span class="hljs-keyword">this</span>.element = element\n    <span class="hljs-keyword">this</span>.left = <span class="hljs-literal">null</span>\n    <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>\n  }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-keyword">this</span>.root = <span class="hljs-literal">null</span>\n  }\n  insert(element) {\n    <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">new</span> Node(element)\n    <span class="hljs-keyword">var</span> insertNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, node</span>) </span>{\n      <span class="hljs-keyword">if</span> (node.element &gt; root.element) {\n        <span class="hljs-keyword">if</span> (root.right === <span class="hljs-literal">null</span>) {\n          root.right = node\n        } <span class="hljs-keyword">else</span> {\n          insertNode(root.right, node)\n        }\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span>) {\n          root.left = node\n        } <span class="hljs-keyword">else</span> {\n          insertNode(root.left, node)\n        }\n      }\n    }\n    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.root) {\n      <span class="hljs-keyword">this</span>.root = temp\n    } <span class="hljs-keyword">else</span> {\n      insertNode(<span class="hljs-keyword">this</span>.root, temp)\n    }\n  }\n  <span class="hljs-comment">// 中序遍历</span>\n  inOrderTraverse(callback) {\n    <span class="hljs-keyword">const</span> inOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) {\n        inOrderTraverseNode(node.left, callback)\n        callback(node.element)\n        inOrderTraverseNode(node.right, callback)\n      }\n    }\n    inOrderTraverseNode(<span class="hljs-keyword">this</span>.root, callback)\n  }\n&nbsp; <span class="hljs-comment">// 前序遍历</span>\n  preOrderTraverse(callback) {\n    <span class="hljs-keyword">const</span> preOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) {\n        callback(node.element)\n        preOrderTraverseNode(node.left, callback)\n        preOrderTraverseNode(node.right, callback)\n      }\n    }\n    preOrderTraverseNode(<span class="hljs-keyword">this</span>.root, callback)\n  }\n&nbsp; <span class="hljs-comment">// 后序遍历</span>\n  postOrderTraverse(callback) {\n    <span class="hljs-keyword">const</span> postOrderTraverseNode = <span class="hljs-function">(<span class="hljs-params">node, callback</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) {\n        postOrderTraverseNode(node.left, callback)\n        postOrderTraverseNode(node.right, callback)\n        callback(node.element)\n      }\n    }\n    postOrderTraverseNode(<span class="hljs-keyword">this</span>.root, callback)\n  }\n  min() {\n    <span class="hljs-keyword">const</span> minNode = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> node ? (node.left ? minNode(node.left) : node) : <span class="hljs-literal">null</span>\n    }\n    <span class="hljs-keyword">return</span> minNode(<span class="hljs-keyword">this</span>.root)\n  }\n  max() {\n    <span class="hljs-keyword">const</span> maxNode = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> node ? (node.right ? maxNode(node.right) : node) : <span class="hljs-literal">null</span>\n    }\n    <span class="hljs-keyword">return</span> maxNode(<span class="hljs-keyword">this</span>.root)\n  }\n  search(key) {\n    <span class="hljs-keyword">const</span> searchNode = <span class="hljs-function">(<span class="hljs-params">node, key</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>\n      <span class="hljs-keyword">if</span> (node.element === key) {\n        <span class="hljs-built_in">console</span>.log(node)\n        <span class="hljs-keyword">return</span> node\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> searchNode((key &lt; node.element) ? node.left : node.right, key)\n      }\n    }\n    searchNode(<span class="hljs-keyword">this</span>.root, key)\n  }\n}\n<span class="hljs-comment">// 初始化一个BST</span>\n<span class="hljs-keyword">const</span> tree = <span class="hljs-keyword">new</span> BinarySearchTree()\ntree.insert(<span class="hljs-number">11</span>)\ntree.insert(<span class="hljs-number">7</span>)\ntree.insert(<span class="hljs-number">5</span>)\ntree.insert(<span class="hljs-number">3</span>)\ntree.insert(<span class="hljs-number">9</span>)\ntree.insert(<span class="hljs-number">8</span>)\ntree.insert(<span class="hljs-number">10</span>)\ntree.insert(<span class="hljs-number">13</span>)\ntree.insert(<span class="hljs-number">12</span>)\ntree.insert(<span class="hljs-number">14</span>)\ntree.insert(<span class="hljs-number">20</span>)\ntree.insert(<span class="hljs-number">18</span>)\ntree.insert(<span class="hljs-number">25</span>)\n<span class="hljs-built_in">console</span>.log(tree)\n<span class="hljs-comment">// 调用二叉树对应地获取最大最小，以及搜索的方法</span>\n<span class="hljs-keyword">var</span> m = tree.min()\n<span class="hljs-built_in">console</span>.log(m.element)\n<span class="hljs-keyword">var</span> max = tree.max()\n<span class="hljs-built_in">console</span>.log(max)\n<span class="hljs-keyword">var</span> r = tree.search(<span class="hljs-number">12</span>)\n<span class="hljs-built_in">console</span>.log(r)\n</code></pre>\n<p data-nodeid="9336">到这里是不是发现二叉树要比上面栈、队列以及链表要复杂一些了呢？仔细看二叉树的核心实现逻辑，不管是前、中、后序遍历，还是获取最值以及查找，本质上都是算法中一个比较重要的思想，那就是递归。递归调用自身的方法不断地往下遍历，这是二叉树相关题目比较重要的一个思路，你需要好好掌握，以便能轻松解决一系列二叉树的相关算法题目。</p>\n<p data-nodeid="9337">下面再和你说说关于算法该如何刷题。</p>\n<h3 data-nodeid="9338">算法刷题指南</h3>\n<p data-nodeid="9339">首先要明确的是数据结构是工具，<strong data-nodeid="9420">算法是通过合适的工具解决特定问题的方法</strong>。也就是说，学习算法之前，最起码得了解那些常用的数据结构，知道它们的特性和缺陷。</p>\n<p data-nodeid="9340">那么该如何在 LeetCode 刷题呢？我的建议是你在熟悉了基本数据结构，并且能很轻松用 JS 实现常见的数据结构之后，就可以去刷题了。LeetCode 刷题也有套路，建议你当数据结构基本都了解并能实现的基础上，可以先直接刷二叉树相关的题目，因为这块比较容易抽象出通用的思路（本讲的最后我会带你看二叉树这部分怎么突破）。</p>\n<p data-nodeid="9341">其实总结下来，算法刷题无非就是找到这几类题目的解题思路：</p>\n<ol data-nodeid="9342">\n<li data-nodeid="9343">\n<p data-nodeid="9344">If-else, switch（branch）</p>\n</li>\n<li data-nodeid="9345">\n<p data-nodeid="9346">for，while loop（Iteration）</p>\n</li>\n<li data-nodeid="9347">\n<p data-nodeid="9348">递归 Recursion（Divide, Backtrace）</p>\n</li>\n<li data-nodeid="9349">\n<p data-nodeid="9350">搜索 Search：深度优先搜索（Depth first search）、广度优先搜索（Breadth first search）、A* 等</p>\n</li>\n<li data-nodeid="9351">\n<p data-nodeid="9352">动态规划（Dynamic Programming）</p>\n</li>\n<li data-nodeid="9353">\n<p data-nodeid="9354">二分查找（Binary Search）</p>\n</li>\n<li data-nodeid="9355">\n<p data-nodeid="9356">贪心算法（Greedy）</p>\n</li>\n<li data-nodeid="9357">\n<p data-nodeid="9358">数学（Math）&amp; 位运算等</p>\n</li>\n</ol>\n<p data-nodeid="9359">上面提到的二叉树相关的实现思路以及相关的题目，其实就是第三类递归的思路，如果你把递归的思路掌握好，那对于二叉树相关的题目你将会得心应手。动态规划也类似，核心思路就是动态递推，从最小的开始计算，一步一步推导累加到第 n 次之后的结果。</p>\n<p data-nodeid="9360">针对算法和数据结构那么多知识点，我为你总结了一个脑图，方便你分别击破。</p>\n<h3 data-nodeid="9361">算法数据结构脑图</h3>\n<p data-nodeid="10028" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/29/9F/CioPOWBhenGAJGelAAc3iYTqAIw539.png" alt="2021329-145721.png" data-nodeid="10031"></p>\n\n<p data-nodeid="9363">里面的分支有很多，下面我们专门针对上面提到的二叉树来进行深入探讨，看看递归的思想是如何解决二叉树相关问题的。</p>\n<h3 data-nodeid="9364">带你攻克一个难点</h3>\n<p data-nodeid="9365">在看二叉树相关题目之前，你需要对上面的 JS 实现二叉树的代码非常了解，尤其是前、中、后序遍历的过程，以及递归找二叉树中的最值的思路。有了这些基础之后，我们挑 LeetCode 的几个例子，看看怎么用递归的思路解决二叉树一系列的问题，类似的题目如下：</p>\n<ol data-nodeid="9366">\n<li data-nodeid="9367">\n<p data-nodeid="9368">94 题：二叉树的中序遍历</p>\n</li>\n<li data-nodeid="9369">\n<p data-nodeid="9370">102 题：二叉树的层序遍历</p>\n</li>\n<li data-nodeid="9371">\n<p data-nodeid="9372">103 题：二叉树的锯齿形层序遍历</p>\n</li>\n<li data-nodeid="9373">\n<p data-nodeid="9374">104 题：二叉树的最大深度</p>\n</li>\n<li data-nodeid="9375">\n<p data-nodeid="9376">144 题：二叉树的前序遍历</p>\n</li>\n<li data-nodeid="9377">\n<p data-nodeid="9378">199 题：二叉树的右视图</p>\n</li>\n</ol>\n<p data-nodeid="9379">还有其他类似的题目，这里就不举例了，我们先看这六道题如何击破。</p>\n<p data-nodeid="9380">那么把这六道题目抽象起来，形成的思路以及代码模板大致如下：</p>\n<pre class="lang-java" data-nodeid="9381"><code data-language="java"><span class="hljs-comment">// root为传入的二叉树</span>\n<span class="hljs-keyword">var</span> XXXTraversal = function(root) {\n    <span class="hljs-comment">// 定义一个返回的遍历结果的组数</span>\n    let res = []\n    <span class="hljs-comment">// 定义一个内部需要不断递归的函数</span>\n    <span class="hljs-function">function <span class="hljs-title">traverse</span><span class="hljs-params">(r)</span> </span>{\n        <span class="hljs-keyword">if</span>(!r) <span class="hljs-keyword">return</span>;\n        traverse(r.left);  <span class="hljs-comment">// 递归遍历左子树</span>\n        res.push(r.val);    <span class="hljs-comment">// 将根节点push进待返回的数组</span>\n        traverse(r.right);  <span class="hljs-comment">// 递归遍历右子树</span>\n    }\n    traverse(root);    <span class="hljs-comment">// 循环遍历</span>\n    <span class="hljs-keyword">return</span> res;      <span class="hljs-comment">// 最后返回</span>\n};\n</code></pre>\n<p data-nodeid="9382">那么根据这个基本的模板，我们就可以衍生出上面几道题的答案了。只需要把 8、9、10 行代码的位置稍做调整，二叉树的前、中、后序遍历的题目就迎刃而解了。对于层序遍历，我们只需要根据上面稍加改造就能通过 LeetCode 的编译，如下所示。</p>\n<pre class="lang-javascript" data-nodeid="9383"><code data-language="javascript"><span class="hljs-keyword">var</span>&nbsp;levelOrder&nbsp;=&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;arr&nbsp;=[];\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">traverse</span>(<span class="hljs-params">root,&nbsp;depth</span>)&nbsp;</span>{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>(root&nbsp;===&nbsp;<span class="hljs-literal">null</span>)&nbsp;<span class="hljs-keyword">return</span>&nbsp;[];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>(arr[depth]&nbsp;===&nbsp;<span class="hljs-literal">undefined</span>)&nbsp;{ <span class="hljs-comment">// 改造外面定义的待返回的数组变成二维</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[depth]&nbsp;=&nbsp;[];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[depth].push(root.val);    <span class="hljs-comment">// 把根节点在最先push进去</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traverse(root.left,&nbsp;depth&nbsp;+&nbsp;<span class="hljs-number">1</span>);  <span class="hljs-comment">// 层数+1对应arr里的二维数组的序号 </span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traverse(root.right,&nbsp;depth&nbsp;+&nbsp;<span class="hljs-number">1</span>); <span class="hljs-comment">// 同上</span>\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;traverse(root,&nbsp;<span class="hljs-number">0</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;arr;\n};\n<span class="hljs-comment">/*\n  通过测试得到的返回结果是一个二维数组：[[3],[9,20],[15,7]] \n*/</span>\n</code></pre>\n<p data-nodeid="9384">那么第 102 道题的答案已经出来了。再看下第 199 题，如何在中序遍历递归的基础上实现二叉树的右视图？这道题其实就是通过递归的方式找到二叉树的右子树进行遍历输出，它的逻辑和层序遍历其实类似，只不过在递归的过程中进行拦截，确保层数和数组个数一致的时候，只存储右子树的节点就好。</p>\n<p data-nodeid="9385">看一下基于层序遍历改造之后的实现 199 题的代码逻辑。</p>\n<pre class="lang-javascript" data-nodeid="9386"><code data-language="javascript"><span class="hljs-keyword">var</span> rightSideView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>{\n    <span class="hljs-keyword">var</span> arr = [];\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">root, depth</span>) </span>{\n        <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;\n        <span class="hljs-keyword">if</span>(depth === arr.length) {  <span class="hljs-comment">// 这加了逻辑拦截，只能push一个右节点</span>\n            arr.push(root.val);\n        }\n        depth++;    <span class="hljs-comment">// 和层序遍历每进入一层 depth 加一逻辑基本一致</span>\n        traverse(root.right, depth);  <span class="hljs-comment">// 先进入右子树遍历，上面的if拦截</span>\n        traverse(root.left, depth);  <span class="hljs-comment">// 遍历的时候左子树已经存不进arr数组了</span>\n    }\n    traverse(root, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">return</span> arr;\n};\n</code></pre>\n<p data-nodeid="9387">通过上面几道二叉树的遍历的题目，就可以总结出这一系列题目的解题思路了。其核心都是用递归的思路来解决二叉树的遍历问题，只不过通过调整遍历的顺序以及存储数据的方式，把最后遍历的节点数字存储到对应的返回数组中，最后都能通过代码变化得到想要的效果。</p>\n<p data-nodeid="9388">那么类似的题目也就能迎刃而解了，二叉树是应用递归思路最多的例子，那么除了这部分，例如动态规划如何来刷题呢？思路也类似，找到一两道动态规划比较典型的题目，总结和抽象出通用的解题思路，之后就可以更容易地去解决类似的题目了。</p>\n<h3 data-nodeid="9389">总结</h3>\n<p data-nodeid="9390">这一讲我们讨论了前端开发如何学习数据结构和刷题的方法，根据脑图复习了数据结构和算法。你要知道，算法可是通往大厂的必备技能，面试中一定会出现相应的题目。因此如果你不能有效地刷题、找到解决算法和数据结构的通用方法，是很难应对 LeetCode 中那么多算法编程题目的。因为随便出一个变形的算法题目你可能就不会了，你非常有必要从每道题目的细节中提炼出解决某一类题目的通用方法，这样你才能灵活从容地应对面试。</p>\n<p data-nodeid="9391">希望我的分享可以为你算法的提升带来帮助，也希望你能在各种面试中脱颖而出，成为一名优秀的前端人。</p>',
          },
        ],
      },
      {
        sectionName: '结束语',
        sectionId: 7,
        courseList: [
          {
            theme: '结束语 | 面向未来，我们该如何提升自己？',
            id: 126,
            content:
              '<p data-nodeid="172">你好，我是若离，很高兴你能一直学习到最后。</p>\n\n\n<p data-nodeid="3">三个多月的时间转瞬即逝，我们的专栏已经走到了尾声。在这里，我要感谢你对我和这个专栏的鼓励和支持；也要向你表示祝贺：你已经完整地学习了专栏的全部课程，实现了 JavaScript 从入门到进阶的目标，你的坚持一定会有所收获。</p>\n<p data-nodeid="4">虽然专栏课程已经结束了，但还不能松懈，我们的 JavaScript 学习旅程并未结束，从进阶到精通还有很长的一段路要走，希望你能保持持续学习的习惯。</p>\n<h3 data-nodeid="5">回顾与展望</h3>\n<p data-nodeid="6">在这 22 讲中，我先后和你讨论了 JavaScript 语言基础语法及常见的 JS 特性；系统学习了 V8 引擎底层原理和核心思想，学习并掌握了 JavaScript 异步编程关键技术点；也带你深入分析了 JS 数组的底层原理，并讲解了大厂前端岗位高频面试题目，对一些比较典型的题目进行了剖析。</p>\n<p data-nodeid="7">目前，在前端和移动端的布局愿景和强力带动的形势下，跨端融合越来越多。不管是前端的各种框架还是 TS 的使用，其实都逃不过对 JS 底层的深入理解和融会贯通，JS 的发展方向越来越多元化。大前端的技术更新迭代快、东西多，你就不得不一下子学习很多知识，精力不够集中，导致所学内容只停留在表面。如果仅仅停留在对应用层 API 的使用上，不仅容易滋生“学不动”的困扰，也会让人产生“杂而不精”的看法。</p>\n<p data-nodeid="8">其实大前端技术都是相似相通的，我认为一名优秀的前端工程师应该具备以下特征：</p>\n<ol data-nodeid="9">\n<li data-nodeid="10">\n<p data-nodeid="11">在技术层面应该抛开对开发框架的站队，除了应用层 API 的使用之外，能够更多地关注其底层原理、设计思路和通用理念，对中短期技术发展方向有大致思路，并思考如何与过往的开发经验相结合，融进属于自己的知识体系抽象网络；</p>\n</li>\n<li data-nodeid="12">\n<p data-nodeid="13">而在业务上应该跳出自身职能的范围，更多关注上下游合作方背后的思考逻辑，在推进项目时，能够结合大前端直面用户的优势，将自己的专业性和影响力辐射到协作方上下游，综合提升自己统筹项目的能力。</p>\n</li>\n</ol>\n<p data-nodeid="14">做好一件事从来都不是一蹴而就的。以我写专栏的过程来说，我自认为在前端领域摸爬滚打多年，之前也自己写过博客，感觉撰写专栏应该是一件驾轻就熟的事情。但当真正要集中输出一定体系的技术文章的时候，从最开始的筹备阶段起，在编辑打磨过程中，我就慢慢发现这个事情远比我想象的要烦琐困难。与之前零散的总结输出相比，专栏的组织形式和交付方式需要花费数倍的精力。为了把每一个知识点讲透，我需要花费大量的时间和精力去构思文章结构、验证代码逻辑、准备素材等。这期间也不乏为了确认一个知识细节，花费数天时间去查阅资料、阅读源码、验证准确性。</p>\n<p data-nodeid="15">就这样整个周期持续了接近 6 个月，几乎是经常利用周末的时间，花费精力写作和录音，这个过程虽然很痛苦，但坚持下来对我来说收获是很大的——不仅可以好好梳理自己的知识体系，更能把这些干货分享给需要的人。</p>\n<p data-nodeid="16">进步很难，其实是因为那些可以让人进步的事情往往都是让人焦虑、具有压力的。而人生的高度，可能就在于你怎么面对困难，真正能够减轻焦虑的办法就是走出舒适区，迎难而上，去搞定那些给你带来焦虑和压力的事情，这样人生的高度才能被一点点垫起来。解决问题的过程通常并不是一帆风顺的，这就需要坚持。<strong data-nodeid="40">所谓胜利者，往往是能比别人多坚持一分钟的人</strong>。勿畏难，勿轻略，让我们在技术路上继续扩大自己的边界，保持学习，持续成长。</p>\n<p data-nodeid="17">我在最后的两个彩蛋中也梳理和总结了前端的知识体系以及算法的知识架构，你可以根据每个图的思维架构进行整体学习和巩固，当你能把其中列出的知识点很好地理解和掌握的话，我相信你通过大厂的面试应该不会有太大问题。前端知识体系比较广并且发展迅速，我们一定要铭记：<strong data-nodeid="46">前端基础是很重要的</strong>。把基础能力打牢，才能在市场竞争中以不变应万变。</p>\n<h3 data-nodeid="18">写在最后</h3>\n<p data-nodeid="19">我们生活在这个高速发展的时代，各种技术都在不断更新，各种思想也在不停地碰撞，而我们自身的年龄也在不断增加。各种压力袭来，想要直面它们，那就需要你把更多的精力放在自身的持续提升上。因为当你的成长远超周围的其他人，那时候你才可能得到这个社会带给你超额的奖励。当你能坚持看到这里，说明你有一颗想要改变和提升自己的决心，这样的决心一直坚持下去的话，你的目标终将实现。</p>\n<p data-nodeid="20">即便此刻你身处小厂，并且技术天花板很有限，如果你不满足于现状，那么就非常有必要从整体以及全局给自己制定很明确的目标和规划，按照整体的目标来提升自己各方面的前端技术能力，从而迈向更高的台阶，突破自身的瓶颈，走向更广阔的天空！</p>\n<p data-nodeid="21">最后，如果本专栏的知识让你有所收获，欢迎你在下方留言告诉我，希望你能积极和我讨论自己在学习/工作过程中遇到的困惑、学习感悟等，让我看到你努力改变自己的决心！同时，我也邀请你填写这份<a href="https://wj.qq.com/s2/8254352/d250/?fileGuid=K44wLnWvdQw1XUgl" data-nodeid="55">&gt;&gt;调查问卷&lt;&lt;</a>，对我、对专栏提出建设性的意见，我们一起努力朝更好的方向发展。</p>\n<p data-nodeid="22">未来，我们有缘再见。</p>',
          },
        ],
      },
    ],
  },
  //获取课程内容
  'GET /api/course': [
    {
      id: 11,
      theme: '开篇词 | 打好 JS 基石，走稳前端进阶之路',
    },
    {
      id: 12,
      theme: '01 | 代码基本功测试（上）：JS 的数据类型你了解多少？',
    },
  ],
};
