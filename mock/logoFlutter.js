export default {
  'GET /api/lago/courseList/flutter': {
    data: [
      {
        sectionName: '开篇词',
        sectionId: 0,
        courseList: [
          {
            theme: '开篇词 | 通往大前端的一把关键钥匙 Flutter',
            id: 31,
            content:
              '<p data-nodeid="3923" class="">你好，欢迎来到&nbsp;Flutter&nbsp;课程，我是清弦。</p>\n<p data-nodeid="3924">近 10 年来，我一直在一线大厂从事 Web 前端研发工作，负责前端、中台业务以及跨端平台的研发和团队管理。目前<strong data-nodeid="3974">大前端因为“一套代码，多端运行”的特性成为大势所趋</strong>，因此我也在致力于将团队培养为 Web 前端全栈及大前端双通道人员，借此提升前端技术人员在未来很长一段时间的竞争力，而其中选用的技术就是 Flutter。</p>\n<p data-nodeid="3925">从 Hybrid 到 Weex、React Native 这些跨端技术的出现，确实很好地解决了跨端技术不一致、热加载、提升开发效率，以及降低开发成本的问题，但<strong data-nodeid="3979">一个核心技术痛点“性能问题”却一直没有非常好的解决方案。而仅仅出道 2 年的 Flutter，通过自渲染模式，以及在体验和性能上的优异表现一时风头无两，其性能更是在跨端技术中处于领跑地位。</strong></p>\n<p data-nodeid="3926">除了大量为适应快速发展节奏和节省人力成本的中小型企业，很多一线互联网企业也在重要项目中落地了 Flutter 技术，包括阿里（闲鱼）、蚂蚁金服（蚂蚁财富）、腾讯（多款在线教育App）、字节跳动（头条和西瓜视频），以及美团（美团 App）和快手（快手 App），等等。</p>\n<p data-nodeid="3927"><img src="https://s0.lgstatic.com/i/image/M00/1A/8E/CgqCHl7dpHyAVUFFAAMDht1Dqhw894.png" alt="image.png" data-nodeid="3983"></p>\n<p data-nodeid="3928">有需求，就有人才市场。目前我们可以看到很多企业在招聘 Flutter 工程师，甚至一些前端或移动端的招聘岗位中也会备注“熟悉 Flutter 优先”，并且这些岗位大多来自一些知名企业，薪资优势也非常明显：</p>\n<p data-nodeid="3929"><img src="https://s0.lgstatic.com/i/image/M00/1A/8E/CgqCHl7dpImAb78FAABB4lUE4Eg359.png" alt="image (1).png" data-nodeid="3987"></p>\n<p data-nodeid="3930"><img src="https://s0.lgstatic.com/i/image/M00/1A/8F/CgqCHl7dpJWAPAEQAAA8gGP-BEU300.png" alt="image (2).png" data-nodeid="3990"></p>\n<p data-nodeid="3931">（来自：拉勾网）</p>\n<p data-nodeid="3932">市场需求已经验证，相信你也已经迫切想要追上这波技术红利，快速上手 Flutter 并获得理想的职位。但是，在学习和实践 Flutter 的过程中，很多技术人普遍面临这样几类问题。</p>\n<ul data-nodeid="3933">\n<li data-nodeid="3934">\n<p data-nodeid="3935"><strong data-nodeid="3996">学习资料大多从 0 到 1，偏入门+实战。</strong></p>\n</li>\n</ul>\n<p data-nodeid="3936">基础课程是掌握一门新技术的必备环节，但在足够系统的同时，也会有知识点重合度较高的问题。一些常见的知识点学习起来比较浪费时间，需要你自己去抽离重点，毕竟学 Flutter 的技术人，一般也都懂些基础内容。</p>\n<ul data-nodeid="3937">\n<li data-nodeid="3938">\n<p data-nodeid="3939"><strong data-nodeid="4001">实践及场景应用少，无法直接反馈到工作中。</strong></p>\n</li>\n</ul>\n<p data-nodeid="3940">学到了些 Flutter 核心技术，但缺少进阶和综合应用，混合开发的内容很少，所以无法开发出一个实际的项目应用，也没办法解决你工作上的实际问题，导致在 Flutter 上还是经常踩坑。</p>\n<ul data-nodeid="3941">\n<li data-nodeid="3942">\n<p data-nodeid="3943"><strong data-nodeid="4006">直接上手开发，却不了解核心原理，不能从源处寻找一些优化方向和优化策略。</strong></p>\n</li>\n</ul>\n<p data-nodeid="3944">工作中的开发往往只关注实际用法，很少有时间去注重基础原理，从而忽略了这块重要知识，导致优化方向只能从他人的经验中去学习。但是，很多问题都有一定的独特性，需要你具备快速定位和分析解决问题的能力，不能一切依靠“搜索”能力。</p>\n<p data-nodeid="3945">其实，学习一门新的语言或者框架无外乎这样一个路径：第一步，需要快速理清一些核心基础知识点，掌握编程语法和运行原理；第二步，实践应用开发，通过项目实践来熟悉开发过程中的一些工具、规范和常见问题；第三步，掌握核心设计思想和实现原理，能够基于一些核心原理寻找一些底层优化策略。</p>\n<p data-nodeid="3946">鉴于以上背景情况，我希望通过一个系统课程来帮助你快速、有效学习 Flutter 技术。我会带你体验最佳的学习路径，从实际工作场景中的应用问题出发，来给你呈现这个课程。本课程的核心优势，主要体现在以下 3 个方面：</p>\n<ul data-nodeid="3947">\n<li data-nodeid="3948">\n<p data-nodeid="3949"><strong data-nodeid="4014">抽离核心和重要知识点</strong>：通过对比 Web 前端技术来讲解 Flutter，着重介绍差异点及 Flutter 的核心功能，对于大家普遍熟悉或者已经掌握的知识点，我会选择性带过，在带你掌握最核心知识点的同时，帮你省时间。（当然，如果你了解 JavaScript 语言编程、React 或者 Vue 以及前端 MVVM 框架等前端知识，学习体验会非常好。但如果你是移动端开发者，也不用担心，文章中也是基于移动端应用为实践项目，因此也是移动端日常开发熟悉的学习过程。）</p>\n</li>\n<li data-nodeid="3950">\n<p data-nodeid="3951"><strong data-nodeid="4019">综合实战教学</strong>：为了让你跨越从理解概念知识到真正落地实践的鸿沟，我会用一个轻量 App 的开发实践过程，来串联讲解每个技术知识点。</p>\n</li>\n<li data-nodeid="3952">\n<p data-nodeid="3953"><strong data-nodeid="4024">贴近实际的应用场景</strong>：本课程列举了大部分项目开发中实际应用的功能点（比如红点功能、多导航功能，以及布局设计等），如果你在工作中没有实践场景，贴近应用场景的内容可以帮你更好地消化吸收理论知识。</p>\n</li>\n</ul>\n<p data-nodeid="3954">具体来讲，我将整个课程分成了<strong data-nodeid="4030">基础 + 项目实战 + 进阶原理</strong>三个大的模块。</p>\n<ul data-nodeid="3955">\n<li data-nodeid="3956">\n<p data-nodeid="3957"><strong data-nodeid="4035">模块一，Flutter 基础知识</strong>：带你掌握必备的基础知识，包括 Flutter 语法、运行原理、环境构建、代码规范、生命周期、状态管理，以及有无状态组件等。在这个模块中，我会带你从 Web 前端视角，去重新学习一个新的框架，减少你学习的时间成本。学完后，你将能够应用本模块的知识点完成一些组件开发。</p>\n</li>\n<li data-nodeid="3958">\n<p data-nodeid="3959"><strong data-nodeid="4040">模块二，项目实战</strong>：教你如何从立项到线上运营，开发出一款轻量级的 App 应用。其中涵盖但不限于 App 的基础功能点、导航栏设计、上拉刷新和加载、红点提醒、服务端协议交互、布局设计、打包与发布，以及线上运营和监控等内容。学完后，你将能够用 Flutter 开发完成实际项目。</p>\n</li>\n<li data-nodeid="3960">\n<p data-nodeid="3961"><strong data-nodeid="4045">模块三，进阶原理</strong>：在掌握了基础的开发能力后，进阶才是体现能力的部分。这个模块中，我抽取了 Flutter 的几个关键知识点，包括如何与原生平台相互调用、性能分析和优化实践、渲染原理，以及 Flutter 内部的架构设计整体实现。学完后，你不仅能够掌握如何设计与原生平台交互的通道，还能够掌握性能优化的策略，而不是照搬他人想法。</p>\n</li>\n</ul>\n<p data-nodeid="3962"><img src="https://s0.lgstatic.com/i/image/M00/1A/FA/Ciqc1F7d_AOAHF1SAAH-YX7OsXI340.png" alt="flutter.png" data-nodeid="4048"></p>\n<p data-nodeid="3963">此外，本课程还会为你提供一套 App 对应的 Node.js 服务端源码，按照源码指引将服务部署后，你可以将本课程实践的 App 应用发布到 Android 市场或者 App Store，作为一个线上的 App 进行运营。</p>\n<h3 data-nodeid="3964">讲师寄语</h3>\n<p data-nodeid="3965">查理·芒格说过这样一句话：“宏观是我们必须接受的，微观才是我们可以有所作为的。”而宏观上，我们正身处大前端的浪潮之中，微观上我们手握选择的权利。</p>\n<p data-nodeid="3966">因为前几年的技术红利，前端技术人才越来越多，企业对于人才的能力要求也水涨船高，仅掌握单一平台编程开发能力已经稍显欠缺。希望这个课程能助你一臂之力，让你在招聘面试和日常工作中取得更多竞争优势，让你的职业发展更加长劲、有力。</p>\n<p data-nodeid="3967" class="te-preview-highlight">假如你有任何问题，欢迎在留言区给我留言。</p>',
          },
          {
            theme:
              '导读 | 大前端趋势所向：这么多跨端技术，为什么选择 Flutter？',
            id: 32,
            content:
              '<p>你好，在课程的最开始，我想先来带你从跨多终端技术发展历程看看未来大前端的发展趋势。</p>\n<p>随着互联网技术的发展，业务平台对多设备、多终端的需求越来越多，因此，仅掌握单一平台编程开发能力已经稍显欠缺。由于在业务开发过程中，开发者大部分的时间都专研于一种编程语言，如果想要掌握多端开发能力，则又稍显力不从心。因此<strong>大前端</strong>的概念应运而生，本课时主要介绍大前端的发展历程，以及如何做好大前端技术的选型分析。</p>\n<h3>什么是大前端</h3>\n<p>大前端概念对于编程开发者来说早已耳熟能详，从我的角度来理解这个概念的话，主要是通过同一套编程代码，经过框架编译转化能够适应于多端平台的前端交互界面。当然这里只介绍目前应用较广的三个方面，即 iOS、Andorid 和 Web H5，之后可以再延伸到小程序、TV、Watch 等其他智能设备，如图 1 所示。</p>\n<p><img src="https://s0.lgstatic.com/i/image/M00/1A/92/CgqCHl7dpsyAGXTdAABOhwpYTPY773.jpg" alt="01-1-1.jpg"></p>\n<p>图 1 多端平台的前端交互界面</p>\n<p>大前端的核心是为了解决多端不一致和人力的问题。比如在一些交互复杂度不高的应用中，通过这种模式可以更好地节省人力成本，特别是在一些前期快速发展的创业公司，可以使用较少的人力来支撑一些核心业务功能。</p>\n<h3>跨端技术的发展</h3>\n<p>移动端跨平台技术经过了一个漫长的发展史，如图 2 所示。下面主要介绍下在这个发展过程中跨平台技术有了哪些进步或者做了哪些优化。</p>\n<p><img src="https://s0.lgstatic.com/i/image/M00/1A/87/Ciqc1F7dpuiAej-kAAAoqW57xyE079.jpg" alt="01-2-1.jpg"></p>\n<p>图 2 跨端技术的发展过程</p>\n<table>\n<thead>\n<tr>\n<th align="left"><strong>技术</strong></th>\n<th align="left"><strong>核心</strong></th>\n<th align="left"><strong>原生支持</strong></th>\n<th align="left"><strong>动态性</strong></th>\n<th align="left"><strong>性能</strong></th>\n<th align="left"><strong>体验</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">Ionic/Cordova</td>\n<td align="left">JSBridge 封装给 Web 调用</td>\n<td align="left">90%</td>\n<td align="left">中</td>\n<td align="left">差</td>\n<td align="left">差</td>\n</tr>\n<tr>\n<td align="left">React Native/Weex</td>\n<td align="left">JIT 模式应用 JS 与原生通信</td>\n<td align="left">20%</td>\n<td align="left">好</td>\n<td align="left">中</td>\n<td align="left">中</td>\n</tr>\n<tr>\n<td align="left">Flutter</td>\n<td align="left">自渲染</td>\n<td align="left">5%</td>\n<td align="left">优</td>\n<td align="left">良</td>\n<td align="left">优</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Ionic/Cordova（Hybrid），在技术原理上的核心是，将原生的一些能力通过 JSBridge 封装给 Web 来调用，扩充了 Web 应用能力。但是这种方法有两个不足，一是依赖客户端，二是在性能和体验上都非常依赖于 Web 端。因此，整体上的体验不可预知。目前这个技术还经常被应用到，例如，当前 App 内会提供白名单域名和可调用的 JSBridge 方法，由此来增强 H5 与客户端交互能力，从而提升 App 内 H5 的灵活性。</li>\n<li>React Native/Weex，在原来的 Hybrid 的 JSBridge 基础上进行改进，将 JavaScript 的界面以及交互转化为 Native 的控件，从而在体验上和原生界面基本一致。但因为是 JIT 模式，因此需要频繁地在 JavaScript 与 Native 之间进行通信，从而会有一定的性能损耗影响，导致体验上与原生会有一些差异。</li>\n<li>Flutter，取长补短，结合了之前的一些优点，解决了与 Native 之间通信的问题，同时也有了自渲染模式（框架自身实现了一套 UI 基础框架，与原来的渲染模式基本一致）。从而在体验和性能上相对之前的两种框架表现都较好，具体是如何做到的，我会在接下来的第 22 课时中详细介绍。</li>\n</ul>\n<p>经过上面的技术原理和优缺点对比，Flutter 在各方面都表现出了突出的优势，因此把 Flutter 作为入门大前端的核心框架。</p>\n<h3>选择 Flutter 的思考</h3>\n<p>大前端这个概念从开始到现在已经有整整 10 年时间，那为什么到现在还没有一统江湖呢？其实从我的角度来看，Flutter 也不会创造一统江湖的成果，因为多端或者智能设备的发展终究不会停止，也很难做到统一标准。那为什么我们还要选择 Flutter 来作为大前端核心框架呢？</p>\n<p>事实上 Flutter 的确能够为我们解决一些场景问题，<strong>节省人力成本，同时不影响用户体验</strong>。</p>\n<p>选择 Flutter 并不是为了代替 iOS 或者 Android，而是做一个技术互补，比如，Flutter 负责业务功能，而 iOS 和 Android 则负责部分的底层交互提供服务给到 Flutter 应用。Flutter 也是在这两年刚刚兴起的，在应用起步初期还需要部分底层的服务与原生平台进行交互。相信再经过一段时间的发展，Flutter 在这方面会不断地优化和提升，也将能够独立覆盖到更多复杂的业务场景。因此希望你能够明白大前端的概念，以及 Flutter 目前的应用场景。</p>\n<p>分析完后，下面对目前的技术团队和未来技术团队进行一个简单分析，也可以认为是一个预测。如果你觉得有帮助，那么可以往这方面进行一些尝试，如图 3 所示。大部分开发者会集中在跨端技术团队中；而另一部分核心技术攻坚则在相应的平台技术端（比如 Android 基础技术团队、iOS 基础技术团队或 Web 基础技术团队），为跨端技术团队提供基础技术服务支撑。当然如果跨端技术团队将组件完善并且可通用化，那么跨端技术团队的人员则可以更快地配置组装的方式构建业务功能。</p>\n<p><img src="https://s0.lgstatic.com/i/image/M00/1A/87/Ciqc1F7dpwCAfhZ3AAChalAD2J4693.png" alt="image (3).png"></p>\n<p>图 3 技术团队选型</p>\n<h3>总结</h3>\n<p>本课时首先介绍了大前端的概念以及发展历程，以及从发展历程来看我们选择 Flutter 的原因，其次也分析了未来跨端框架的发展思考，从而得出新大前端团队架构体系。相信通过本课时的学习，你对大前端的概念和发展以及未来的前景有一定的认识，并且在看过本课时以后，应该要为大前端的方向上做一定的技术积累和沉淀。</p>\n<p>下一课时，我将讲解 Flutter 框架中使用的编程语言 Dart，为了方便你更好地理解，我将从 JavaScript 角度来讲解。</p>',
          },
        ],
      },
      {
        sectionName: '第一部分：基础功能',
        sectionId: 1,
        courseList: [
          {
            theme: '01 | Flutter Dart 语法：从 JavaScript 角度学习 Dart',
            id: 33,
            content:
              '<p data-nodeid="7214" class="">本课时我主要从 JavaScript 角度来讲解如何学习 Dart。</p>\n<p data-nodeid="7215">在学习本课时之前，你需要有一定的 JavaScript 基础，比如基础数据类型、函数、基础运算符、类、异步原理和文件库引入等，这也是 JavaScript 的核心知识点。接下来将通过对比与 JavaScript 的差异点来学习 Dart 语言。</p>\n<h3 data-nodeid="7216">基础数据类型</h3>\n<p data-nodeid="7217">与 JavaScript 相比较，我们整体上看一下图 1 两种语言的对比情况，相似的部分这里就不介绍了，比如 Number 和 String，其使用方式基本一致。下面主要基于两者的差异点逐一讲解，避免混淆或错误使用。</p>\n<p data-nodeid="7218"><img src="https://s0.lgstatic.com/i/image/M00/1C/5F/CgqCHl7gWVGAdOndAACK0gUBRW0309.png" alt="image (4).png" data-nodeid="7298"></p>\n<p data-nodeid="7219">图 1 Dart 与 JavaScript 基础数据类型对比</p>\n<h4 data-nodeid="7220">Symbol 的区别</h4>\n<p data-nodeid="7221">在 JavaScript 中，Symbol 是将基础数据类型转换为唯一标识符，核心应用是可以将复杂引用数据类型转换为对象数据类型的键名。</p>\n<p data-nodeid="7222">在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol("t") 和 #t。</p>\n<pre class="lang-dart" data-nodeid="7223"><code data-language="dart"><span class="hljs-keyword">void</span> main() {\n  <span class="hljs-built_in">Map</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();\n  test[#t] = <span class="hljs-string">\'symbol test\'</span>;\n  <span class="hljs-built_in">print</span>(test);\n  <span class="hljs-built_in">print</span>(test[#t]);\n  <span class="hljs-built_in">print</span>(test[<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">\'t\'</span>)]);\n  <span class="hljs-built_in">print</span>(#t);\n}\n</code></pre>\n<p data-nodeid="7224">运行代码结果如下：</p>\n<pre class="lang-dart" data-nodeid="7225"><code data-language="dart">flutter: {<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"t"</span>): symbol test}\nflutter: symbol test\nflutter: symbol test\nflutter: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"t"</span>)\n</code></pre>\n<p data-nodeid="7226">其中，test 包含了一个有 Symbol 为对象的 Key，value 为 symbol test 字符串的对象。test 的 #t 与 Symbol("t") 打印结果一致，#t 则与 Symbol("t\') 是同一形式。</p>\n<p data-nodeid="7227">在上面的代码示例中，两者的核心在使用上基本是一致的，只是在理解方面相对不一样。<strong data-nodeid="7321">Symbol 在 Dart 中是一种反射概念，而在 JavaScript 中则是创建唯一标识的概念。</strong></p>\n<h4 data-nodeid="7228">Undefined 和 Null</h4>\n<p data-nodeid="7229">由于 Dart 是静态脚本语言，因此在 Dart 中如果没有定义一个变量是无法通过编译的；而 JavaScript 是动态脚本语言，因此存在脚本在运行期间未定义的情况。所以这一点的不同决定了 Dart 在 Undefined 类型上与 JavaScript 的差异。</p>\n<p data-nodeid="7230">null 在 Dart 中是的确存在的，官网上是这样解释的，null 是弱类型 object 的子类型，并非基础数据类型。所有数据类型，如果被初始化后没有赋值的话都将会被赋值 null 类型。</p>\n<p data-nodeid="7231">下面的代码，首先定义了一个弱类型 number，其次定义了 int 类型的 num2，number 类型的 num1 以及 double 类型的 num3 ，最后我们打印出这些只定义了未被赋值的值。</p>\n<pre class="lang-dart" data-nodeid="7232"><code data-language="dart"><span class="hljs-keyword">var</span> number;\n<span class="hljs-built_in">int</span> num2;\n<span class="hljs-built_in">num</span> num1;\n<span class="hljs-built_in">double</span> num3;\n<span class="hljs-built_in">print</span>(<span class="hljs-string">\'number is var:<span class="hljs-subst">$number</span>,num2 is int:<span class="hljs-subst">$num2</span>,num2 is num:<span class="hljs-subst">$num1</span>,num3 is double:<span class="hljs-subst">$num3</span>\'</span>);\n</code></pre>\n<p data-nodeid="7233">可以看到运行结果如下：</p>\n<pre class="lang-dart" data-nodeid="7234"><code data-language="dart">flutter: number <span class="hljs-keyword">is</span> <span class="hljs-keyword">var</span>:<span class="hljs-keyword">null</span>,num2 <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span>:<span class="hljs-keyword">null</span>,num2 <span class="hljs-keyword">is</span> <span class="hljs-built_in">num</span>:<span class="hljs-keyword">null</span>,num3 <span class="hljs-keyword">is</span> <span class="hljs-built_in">double</span>:<span class="hljs-keyword">null</span>\n</code></pre>\n<p data-nodeid="7235">从运行结果我们可以看到，代码中声明了变量，但未赋值的变量在运行时都会被赋值为 null，这就是 Dart 中 null 类型存在的目的。</p>\n<h4 data-nodeid="7236">Map 和 List</h4>\n<p data-nodeid="7237">Map 和 List 与 JavaScript 中的 Array 和 Map 基本一致，但在 JavaScript 中不是基本数据类型，都属于引用数据类型。因此也就是分类不同，但在用法和类型上基本没有太大差异。</p>\n<h4 data-nodeid="7238">弱类型（var、object 和 dynamic）</h4>\n<p data-nodeid="7239">相对 JavaScript 而言，Dart 也存在弱类型（可以使用 var、object 和 dynamic 来声明），不过在这方面为了避免弱类型导致的客户端（App）Crash 的异常，Dart 还是对弱类型加强了校验。</p>\n<p data-nodeid="7240">var 数据类型声明，第一次赋值时，将其数据类型绑定。下面代码使用 var 声明了一个弱类型 t，并赋值 String 类型 123，而接下来又对 t 进行其他类型的赋值。</p>\n<pre class="lang-dart" data-nodeid="7241"><code data-language="dart"><span class="hljs-keyword">var</span> t = <span class="hljs-string">\'123\'</span>;\nt = <span class="hljs-number">123</span>;\n</code></pre>\n<p data-nodeid="7242">这样的代码在 Dart 编译前就会报错，因为 t 在一次 var 赋值时就已经被绑定为 String 类型了，再进行赋值 Number 类型时就会报错。</p>\n<pre class="lang-dart" data-nodeid="7243"><code data-language="dart">Assign value to <span class="hljs-keyword">new</span> local variable\n</code></pre>\n<p data-nodeid="7244">object 可以进行任何赋值，没有约束，这一点类似 JavaScript 中的 var 关键词赋值。在编译期，object 会对数据调用做一定的判断，并且报错。例如，声明时为 String 类型，但是在调用 length 时，编译期就会报错。如果数据来自接口层，则很容易导致运行时报错。因此这个要尽量减少使用，避免运行时报错导致客户端（App）Crash 的异常。</p>\n<p data-nodeid="7245">dynamic 也是动态的数据类型，但如果数据类型调用异常，则只会在运行时报错，这点是非常危险的，因此在使用 dynamic 时要非常慎重。</p>\n<h3 data-nodeid="7246">基础运算符</h3>\n<p data-nodeid="7247">两种语言的基础运算符基本都一致。由于 Dart 是强数据类型，因此在 Dart 中没有 “=== ”的运算符。在 Dart 中有一些类型测试运算符，与 JavaScript 中的类型转换和 typeof 有点相似。</p>\n<p data-nodeid="7248">这里也介绍一些 Dart 中比较简洁的写法：</p>\n<ul data-nodeid="7249">\n<li data-nodeid="7250">\n<p data-nodeid="7251">?? 运算符，比如，t??\'test\' 是 t!= null ? t : \'test\' 的缩写；</p>\n</li>\n<li data-nodeid="7252">\n<p data-nodeid="7253">级联操作，允许对同一对象或者同一函数进行一系列操作，例如下面代码的 testObj 对象中有三个方法 add()、delete() 和 show()，应用级联操作可以依次进行调用。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="7254"><code data-language="dart">testObj.add(<span class="hljs-string">\'t\'</span>)\n..delete(<span class="hljs-string">\'d\'</span>)\n..<span class="hljs-keyword">show</span>()\n</code></pre>\n<h3 data-nodeid="7255">函数</h3>\n<p data-nodeid="7256">从我的理解来说，两者区别不大。箭头函数、函数闭包、匿名函数、高阶函数、参数可选等基本上都一样。在 Dart 中由于是强类型，因此在声明函数的时候可以增加一个返回类型，这点在 TypeScript 中的用法是一致的，对于前端开发人员来说，没有太多的差异点。</p>\n<h3 data-nodeid="7257">类</h3>\n<p data-nodeid="7258">类的概念在各种语言上大部分都是一致的，但在用法上可能存在差异，这里着重介绍一下 Dart 比较特殊的一些用法。</p>\n<h4 data-nodeid="7259">命名构造函数</h4>\n<p data-nodeid="7260">Dart 支持一个函数有多个构造函数，并且在实例化的时候可以选择不同的构造函数。</p>\n<p data-nodeid="7261">下面的代码声明了一个 Dog 类，类中有一个 color 变量属性和两个构造函数。red 构造函数设置 Dog 类的 color 属性为 red，black 构造函数设置 Dog 类的 color 属性为 black。最后在 main 函数中分别用两个构造函数创建两个实例，并分别打印实例的 color 属性。</p>\n<pre class="lang-dart" data-nodeid="7262"><code data-language="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{\n  <span class="hljs-built_in">String</span> color;\n  Dog.red(){\n    <span class="hljs-keyword">this</span>.color = <span class="hljs-string">\'red\'</span>;\n  }\n\n  Dog.black(){\n    <span class="hljs-keyword">this</span>.color = <span class="hljs-string">\'black\'</span>;\n  }\n}\n<span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) {\n  Dog redDog = <span class="hljs-keyword">new</span> Dog.red();\n  <span class="hljs-built_in">print</span>(redDog.color);\n\n  Dog blackDog = <span class="hljs-keyword">new</span> Dog.black();\n  <span class="hljs-built_in">print</span>(blackDog.color);\n}\n</code></pre>\n<p data-nodeid="7263">运行代码后输出了两种颜色，即 red 和 black。就代码而言，我们可以应用同一个类不同的构造函数实现类不同场景下的实例化。</p>\n<h4 data-nodeid="7264">访问控制</h4>\n<p data-nodeid="7265">默认情况下都是 public，如果需要设置为私有属性，则在方法或者属性前使用 “_”。</p>\n<h4 data-nodeid="7266">抽象类和泛型类</h4>\n<p data-nodeid="7267">抽象类和其他语言的抽象类概念一样，这里在 JavaScript 中没有这种概念，因此这里稍微提及一下，主要是实现一个类被用于其他子类继承，抽象类是无法实例化的。</p>\n<p data-nodeid="7268">下面的代码使用关键词 abstract 声明了一个有攻击性的武器抽象类，包含一个攻击函数和一个伤害力获取函数，Gun 和 BowAndArrow 都是继承抽象类，并需要实现抽象类中的方法。</p>\n<pre class="lang-dart" data-nodeid="7269"><code data-language="dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AggressiveArms</span> </span>{\n  attack();\n  hurt()；\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AggressiveArms</span> </span>{\n  attack() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"造成100点伤害"</span>);\n  }\n  hurt() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"可以造成100点伤害"</span>);\n  }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BowAndArrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AggressiveArms</span> </span>{\n  attack() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"造成20点伤害"</span>);\n  }\n  hurt() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"可以造成20点伤害"</span>);\n  }\n}\n</code></pre>\n<p data-nodeid="7270">泛型类，主要在不确定返回数据结构时使用，这点与 TypeScript 中的泛型概念一样。</p>\n<p data-nodeid="9127">在下面的代码中，我们不确定数组中存储的类型是 int 还是 string，又或者是 bool，这时候可以使用泛型 来表示。在使用泛型类的时候可以将设定为自己需要的类型，比如下面的 string 调用和 int 调用。</p>\n<pre class="lang-dart" data-nodeid="9128"><code data-language="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>{\n  <span class="hljs-built_in">List</span> _list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>&lt;T&gt;();\n  Array();\n  <span class="hljs-keyword">void</span> add&lt;T&gt;(T value) {\n    <span class="hljs-keyword">this</span>._list.add(value);\n  }\n  <span class="hljs-keyword">get</span> value{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._list;\n  }\n}\n<span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) {\n  Array arr = <span class="hljs-keyword">new</span> Array&lt;<span class="hljs-built_in">String</span>&gt;();\n  arr.add(<span class="hljs-string">\'aa\'</span>);\n  arr.add(<span class="hljs-string">\'bb\'</span>);\n  <span class="hljs-built_in">print</span>(arr.value);\n\n\n  Array arr2 = <span class="hljs-keyword">new</span> Array&lt;<span class="hljs-built_in">int</span>&gt;();\n  arr2.add(<span class="hljs-number">1</span>);\n  arr2.add(<span class="hljs-number">2</span>);\n  <span class="hljs-built_in">print</span>(arr2.value);\n}\n</code></pre>\n\n\n\n\n\n\n\n\n<h3 data-nodeid="7273">库与调用</h3>\n<h4 data-nodeid="7274">Dart 库管理</h4>\n<p data-nodeid="7275">Dart 和 JavaScript 一样，有一个库管理资源（<a href="http://pub.dev" data-nodeid="7375">pub.dev</a>）。你可以在这里搜索找到你想要的一些库，接下来只要在 Dart 的配置文件 pubspec.yaml 中增加该库即可。这点类似于在 JavaScript 的 package.json 中增加声明一样，同样也有 dependencies 和 dev_dependencies。</p>\n<p data-nodeid="7276">增加类似的数据配置，如下代码：</p>\n<pre class="lang-yaml" data-nodeid="7277"><code data-language="yaml"><span class="hljs-attr">dependencies:</span>\n  <span class="hljs-attr">cupertino_icons:</span> <span class="hljs-string">^0.1.2</span>\n  <span class="hljs-attr">dio:</span> <span class="hljs-string">^3.0.4</span>\n  <span class="hljs-attr">image_test_utils:</span> <span class="hljs-string">^1.0.0</span>\n<span class="hljs-attr">dev_dependencies:</span>\n  <span class="hljs-attr">flutter_test:</span>\n    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span>\n</code></pre>\n<h4 data-nodeid="7278">开发 Dart 库</h4>\n<p data-nodeid="7279">Dart 也支持开发者自己开发一些库，并且发布到 pub.dev 上，这点基本上和 npm 管理一致，这里我只介绍 pub.dev 库的基本格式。</p>\n<pre class="lang-yaml" data-nodeid="7280"><code data-language="yaml"><span class="hljs-string">dart_string_manip</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">example</span>\n<span class="hljs-string">|</span>  <span class="hljs-string">└──</span> <span class="hljs-string">main.dart</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">lib</span>\n<span class="hljs-string">|</span>  <span class="hljs-string">├──</span> <span class="hljs-string">dart_string_manip.dart</span>\n<span class="hljs-string">|</span>  <span class="hljs-string">└──</span> <span class="hljs-string">src</span>\n<span class="hljs-string">|</span>     <span class="hljs-string">├──</span> <span class="hljs-string">classes.dart</span>\n<span class="hljs-string">|</span>     <span class="hljs-string">└──</span> <span class="hljs-string">functions.dart</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">.gitignore</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">.packages</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">LICENSE</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">README.md</span>\n<span class="hljs-string">├──</span> <span class="hljs-string">pubspec.lock</span>\n<span class="hljs-string">└──</span> <span class="hljs-string">pubspec.yaml</span>\n</code></pre>\n<p data-nodeid="7281">对于前端开发人员来说，这个结构和我们所看到的 npm 模块很相似，pubspec 和 package 很相似，核心是 lib 中的库名对应的库文件 .dart，该文件是一个 dart 类。类的概念上面已经介绍过了，将私有方法使用 "_" 保护，其他就可以被引用该库的模块调用，如果是自身库的一些实现逻辑，可以放在 src 中。</p>\n<p data-nodeid="7282">开发完成该库以后，如果需要发布到 pub.dev，则可以参照<a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages" data-nodeid="7390">官网的说明</a>，按步骤进行即可。</p>\n<h4 data-nodeid="7283">Dart 调用库</h4>\n<p data-nodeid="7284">这里引入库的方式也与 ES6 的 import 语法很相似。先看看下面的一个例子，其目的是引入 pages 下的 homepage.dart 模块。</p>\n<pre class="lang-dart" data-nodeid="7285"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:startup_namer/pages/homepage.dart\'</span>;\n</code></pre>\n<p data-nodeid="7286">在上面的例子中，import 为关键词，package 为协议，可以使用 http 的方式，不过最好使用本地 package 方式，避免性能受影响。接下来的 startup_namer 为库名或者说是该项目名，pages 为 lib 下的一个文件夹，homepage.dart 则为具体需要引入的库文件名。</p>\n<p data-nodeid="7287">当然这里也可以使用相对路径的方式，不过建议使用 package 的方式，以保持整个项目代码的一致性，因为对于第三方模块则必须使用 package 的方式。</p>\n<h3 data-nodeid="7288">总结</h3>\n<p data-nodeid="7289">本课时首先介绍了 Dart 基础数据类型、基础运算符、类以及库与调用。然后通过对比 JavaScript 的一些特殊差异性，来加深前端开发人员对 Dart 语言编程的理解。相信你通过本课时的学习，可以掌握 Dart 的编程，并且能够写一些 Dart 的第三方库。</p>\n<p data-nodeid="7290">下一课时，我将介绍 Dart 的事件循环机制，掌握了其核心运行机制原理，才能编写出更高效、更有质量的代码。</p>\n<p data-nodeid="7291">点击这里下载本课时源码，Flutter 专栏，源码地址：<a href="https://github.com/love-flutter/flutter-column" data-nodeid="7404">https://github.com/love-flutter/flutter-column</a></p>',
          },
          {
            theme: '02 | 事件循环：Flutter 中代码是如何执行和运行的',
            id: 34,
            content:
              '<p data-nodeid="10386" class="">上节课介绍了 Dart 基础数据类型、基础运算符、类以及库与调用。本课时着重通过实践带你掌握 Dart 的运行原理。</p>\n<h3 data-nodeid="10387">Dart 单线程</h3>\n<p data-nodeid="10388">单线程在流畅性方面有一定安全保障，这点在 JavaScript 中存在类似的机制原理，其核心是分为主线程、微任务和宏任务。主线程执行主业务逻辑，网络 I/O 、本地文件 I/O 、异步事件等相关任务事件，应用事件驱动方式来执行。在 Dart 中同样是单线程执行，其次也包含了两个事件队列，一个是微任务事件队列，一个是事件队列。</p>\n<ul data-nodeid="10389">\n<li data-nodeid="10390">\n<p data-nodeid="10391">微任务队列</p>\n</li>\n</ul>\n<p data-nodeid="10392">微任务队列包含有 Dart 内部的微任务，主要是通过 scheduleMicrotask 来调度。</p>\n<ul data-nodeid="10393">\n<li data-nodeid="10394">\n<p data-nodeid="10395">事件队列</p>\n</li>\n</ul>\n<p data-nodeid="10396">事件队列包含外部事件，例如 I/O 、 Timer ，绘制事件等等。</p>\n<h4 data-nodeid="10397">事件循环</h4>\n<p data-nodeid="10398">既然 Dart 包含了微任务和事件任务，那么这两个任务之间是如何进行循环执行的呢？我们可以先看下 Dart 执行的逻辑过程（如图 1）：</p>\n<ol data-nodeid="10399">\n<li data-nodeid="10400">\n<p data-nodeid="10401">首先是执行 main 函数，并生产两个相应的微任务和事件任务队列；</p>\n</li>\n<li data-nodeid="10402">\n<p data-nodeid="10403">判断是否存在微任务，有则执行，执行完成后再继续判断是否还存在微任务，无则判断是否存在事件任务；</p>\n</li>\n<li data-nodeid="10404">\n<p data-nodeid="10405">如果没有可执行的微任务，则判断是否存在事件任务，有则执行，无则继续返回判断是否还存在微任务；</p>\n</li>\n<li data-nodeid="10406">\n<p data-nodeid="10407">在微任务和事件任务执行过程中，同样会产生微任务和事件任务，因此需要再次判断是否需要插入微任务队列和事件任务队列。</p>\n</li>\n</ol>\n<p data-nodeid="10408"><img src="https://s0.lgstatic.com/i/image/M00/1D/7D/Ciqc1F7h_D2ARi2aAAJ2G36y8Ng725.png" alt="Drawing 0.png" data-nodeid="10566"></p>\n<p data-nodeid="10409">图 1 Dart 事件循环机制</p>\n<p data-nodeid="10410">为了验证上面的运行原理，我实现了下面的示例代码，首先 import async 库，然后在 main 函数中首先打印 flow start ，接下来执行一个微任务事件，再执行一个事件任务，最后再打印 flow end 。</p>\n<pre class="lang-dart" data-nodeid="10411"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:async\'</span>;\n<span class="hljs-keyword">void</span> main() {\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'flow start\'</span>); <span class="hljs-comment">// 执行打印开始&nbsp;</span>\n\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\tTimer.run((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">print</span>(<span class="hljs-string">\'event\'</span>); <span class="hljs-comment">// 执行事件任务，打印标记</span>\n&nbsp; &nbsp;\t});\n&nbsp; &nbsp;\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列&nbsp;</span>\n\tscheduleMicrotask((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'microtask\'</span>); <span class="hljs-comment">// 执行微任务，打印标记</span>\n&nbsp; &nbsp; });\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'flow end\'</span>); <span class="hljs-comment">// 打印结束标记</span>\n}\n</code></pre>\n<p data-nodeid="10412">使用 Dart 运行如上命令。</p>\n<pre class="lang-shell" data-nodeid="10413"><code data-language="shell">dart flow.dart\n</code></pre>\n<p data-nodeid="10414">代码的实际运行过程如下：</p>\n<ul data-nodeid="10415">\n<li data-nodeid="10416">\n<p data-nodeid="10417">首先主线程逻辑，执行打印 start ；</p>\n</li>\n<li data-nodeid="10418">\n<p data-nodeid="10419">执行 Timer，为事件任务，将其增加到事件任务队列中；</p>\n</li>\n<li data-nodeid="10420">\n<p data-nodeid="10421">执行 scheduleMicrotask，为微任务队列，将其增加到微任务队列中；</p>\n</li>\n<li data-nodeid="10422">\n<p data-nodeid="10423">执行打印 flow end；</p>\n</li>\n<li data-nodeid="10424">\n<p data-nodeid="10425">判断是否存在微任务队列，存在则执行微任务队列，打印 mcrotask；</p>\n</li>\n<li data-nodeid="10426">\n<p data-nodeid="10427">判断是否还存在微任务队列，无则判断是否存在事件任务队列，存在执行事件任务队列，打印 event。</p>\n</li>\n</ul>\n<pre class="lang-sql" data-nodeid="10428"><code data-language="sql">flow <span class="hljs-keyword">start</span>\nflow <span class="hljs-keyword">end</span>\nmicrotask\n<span class="hljs-keyword">event</span>\n</code></pre>\n<p data-nodeid="10429">为了更清晰描述，可以我们使用图 2 动画来演示。</p>\n<p data-nodeid="10430"><img src="https://s0.lgstatic.com/i/image/M00/1D/8A/CgqCHl7h_RmAFXa9AAnXFc-CvdQ552.gif" alt="flutter-flow-new.gif" data-nodeid="10580"></p>\n<p data-nodeid="10431">图 2 Dart 主线程运行逻辑</p>\n<p data-nodeid="10432">介绍完 Dart 的运行原理，你可能会产生以下疑问。</p>\n<p data-nodeid="10433"><strong data-nodeid="10586">疑问1，为什么事件任务都执行完成了，还需要继续再循环判断是否有微任务？</strong></p>\n<p data-nodeid="10434">核心解释是：微任务在执行过程中，也会产生新的事件任务，事件任务在执行过程中也会产生新的微任务。产生的新微任务，按照执行流程，需要根据队列方式插入到任务队列最后。</p>\n<p data-nodeid="10435">我们通过代码来看下该过程。下面一段代码， import async 库，第一步打印 start ， 然后执行一个事件任务，在事件任务中打印 event 。接下来增加了一个微任务事件，在微任务事件中打印 microtask in event 。第二步执行微任务事件，在微任务事件中打印 microtask ，并且在其中增加事件任务队列，事件任务队列中打印 event in microtask ，最后再打印 flow end 。</p>\n<pre class="lang-dart" data-nodeid="10436"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:async\'</span>;\n<span class="hljs-keyword">void</span> main() {\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'flow start\'</span>); <span class="hljs-comment">// 执行打印开始</span>\n&nbsp;   <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\tTimer.run((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp;\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'event\'</span>); <span class="hljs-comment">// 执行事件任务，打印事件任务标记</span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列&nbsp;</span>\n&nbsp; &nbsp; &nbsp; &nbsp;\tscheduleMicrotask((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'microtask in event\'</span>); <span class="hljs-comment">// 执行微任务，打印微任务标记</span>\n&nbsp; &nbsp; \t});\n&nbsp; &nbsp;\t});\n&nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列&nbsp;</span>\n\tscheduleMicrotask((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'microtask\'</span>); <span class="hljs-comment">// 执行微任务，打印微任务执行标记</span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列&nbsp;</span>\n&nbsp; &nbsp; &nbsp; &nbsp; Timer.run((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'event in microtask\'</span>); <span class="hljs-comment">// 执行事件任务，打印事件任务标记</span>\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; });\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'flow end\'</span>); <span class="hljs-comment">// 打印结束标记</span>\n}\n</code></pre>\n<p data-nodeid="10437">使用 Dart 运行如上命令。</p>\n<pre class="lang-java" data-nodeid="10438"><code data-language="java">dart event_with_microtask.dart\n</code></pre>\n<p data-nodeid="10439">代码的实际运行过程如下：</p>\n<ul data-nodeid="10440">\n<li data-nodeid="10441">\n<p data-nodeid="10442">首先还是依次执行打印 flow start ；</p>\n</li>\n<li data-nodeid="10443">\n<p data-nodeid="10444">执行 Timer 为事件任务，添加事件任务队列中；</p>\n</li>\n<li data-nodeid="10445">\n<p data-nodeid="10446">执行 scheduleMicrotask 为微任务，添加到微任务队列中；</p>\n</li>\n<li data-nodeid="10447">\n<p data-nodeid="10448">打印 end ；</p>\n</li>\n<li data-nodeid="10449">\n<p data-nodeid="10450">执行微任务队列，打印 microtask ，其中包括了事件任务，将事件任务插入到事件任务中；</p>\n</li>\n<li data-nodeid="10451">\n<p data-nodeid="10452">执行事件任务队列，打印 event ，其中包括了微任务，将微任务插入到微任务队列中；</p>\n</li>\n<li data-nodeid="10453">\n<p data-nodeid="10454">微任务队列存在微任务，执行微任务队列，打印 microtask in event；</p>\n</li>\n<li data-nodeid="10455">\n<p data-nodeid="10456">微任务队列为空，存在事件任务队列，执行事件任务队列，打印 event in microtask；</p>\n</li>\n</ul>\n<p data-nodeid="10457">根据如上的运行过程，我们可以得出以下的一个运行结果，这点可以通过运行 Dart 命令得到实际的验证。</p>\n<pre class="lang-sql" data-nodeid="10458"><code data-language="sql">flow <span class="hljs-keyword">start</span>\nflow <span class="hljs-keyword">end</span>\nmicrotask\n<span class="hljs-keyword">event</span>\nmicrotask <span class="hljs-keyword">in</span> <span class="hljs-keyword">event</span>\n<span class="hljs-keyword">event</span> <span class="hljs-keyword">in</span> microtask\n</code></pre>\n<p data-nodeid="12184">为了更形象来描述，我使用图 3 动画来演示。</p>\n<p data-nodeid="12185" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/21/33/Ciqc1F7p3BCAAutpABeCx2dZvOo916.gif" alt="image" data-nodeid="12189"></p>\n\n\n<p data-nodeid="10461">图 3 多微任务和事件任务执行流程</p>\n<p data-nodeid="10462">一句话概括上面的实践运行结果：每次运行完一个事件后，都会判断微任务和事件任务，在两者都存在时，优先执行完微任务，只有微任务队列没有其他的任务了才会执行事件任务。</p>\n<p data-nodeid="10463"><strong data-nodeid="10609">疑问2，Dart 运行过程中是否会被事件运行卡住？</strong></p>\n<p data-nodeid="10464">答案是会，比如在运行某个微任务，该微任务非常的耗时，会导致其他微任务和事件任务卡住，从而影响到一些实际运行，这里我们可以看如下例子：</p>\n<pre class="lang-dart" data-nodeid="10465"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:async\'</span>;\n<span class="hljs-keyword">void</span> main() {\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'flow start\'</span>);&nbsp; <span class="hljs-comment">// 执行打印开始</span>\n&nbsp; <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\tTimer.run((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){ <span class="hljs-comment">// 大循环，为了卡住事件任务执行时间，检查是否会卡住其他任务执行</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1000000</span>){\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scheduleMicrotask((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'microtask in event\'</span>); <span class="hljs-comment">// 执行微任务，打印微任务标记</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'event\'</span>); <span class="hljs-comment">// 执行完事件任务，打印执行完事件任务标记</span>\n&nbsp; &nbsp;\t});\n&nbsp; <span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\tscheduleMicrotask((){&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'microtask\'</span>); <span class="hljs-comment">// 执行微任务，打印微任务标记</span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n&nbsp; &nbsp; &nbsp; &nbsp; Timer.run((){\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'event in microtask\'</span>); <span class="hljs-comment">// 执行事件任务，打印事件任务标记</span>\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; });\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'flow end\'</span>); <span class="hljs-comment">// 打印结束标记</span>\n}\n</code></pre>\n<p data-nodeid="10466">上面这段代码和之前的唯一不同点是在执行第一个事件任务的时候，使用了一个大的 for 循环，从运行结果会看到 event in microtask 和 microtask in event 打印的时间会被 event 的执行所 block 住。从结果分析来看 Dart 中事件运行是会被卡住的，因此在日常编程的时候要特别注意，避免因为某个事件任务密集计算，导致较差的用户操作体验。</p>\n<h3 data-nodeid="10467">Isolate 多线程</h3>\n<p data-nodeid="10468">上面我们介绍了 Dart 是单线程的，这里说的 Dart 的单线程，其实和操作系统的线程概念是存在一定区别的， Dart 的单线程叫作 isolate 线程，<strong data-nodeid="10617">每个 isolate 线程之间是不共享内存的，通过消息机制通信。</strong></p>\n<p data-nodeid="10469">我们看个例子，例子是利用 Dart 的 isolate 实现多线程的方式。</p>\n<pre class="lang-dart" data-nodeid="10470"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:async\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:isolate\'</span>;\nIsolate isolate;\n<span class="hljs-built_in">String</span> name = <span class="hljs-string">\'dart\'</span>;\n<span class="hljs-keyword">void</span> main() {\n\t<span class="hljs-comment">// 执行新线程创建函数</span>\n&nbsp;\tisolateServer();\n}\n<span class="hljs-comment">/// <span class="markdown">多线程函数</span></span>\n<span class="hljs-keyword">void</span> isolateServer()<span class="hljs-keyword">async</span>{\n\t<span class="hljs-comment">// 创建新的线程，并且执行回调 changName&nbsp;</span>\n\t<span class="hljs-keyword">final</span> receive = ReceivePort();\n\tisolate = <span class="hljs-keyword">await</span> Isolate.spawn(changName, receive.sendPort);\n\t<span class="hljs-comment">// 监听线程返回信息&nbsp;</span>\n\treceive.listen((data){\n\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">"Myname is <span class="hljs-subst">$data</span>"</span>); <span class="hljs-comment">// 打印线程返回的数据</span>\n\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">"Myname is <span class="hljs-subst">$name</span>"</span>); <span class="hljs-comment">// 打印全局 name 的数据</span>\n\t});\n}\n<span class="hljs-comment">/// <span class="markdown">线程回调处理函数</span></span>\n<span class="hljs-keyword">void</span> changName(SendPort port){\n\tname = <span class="hljs-string">\'dart isloate\'</span>; <span class="hljs-comment">// 修改当前全局 name 属性</span>\n\tport.send(name); <span class="hljs-comment">// 将当前name发送给监听方</span>\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">"Myname is <span class="hljs-subst">$name</span> in isloate"</span>); <span class="hljs-comment">// 打印当前线程中的 name</span>\n}\n</code></pre>\n<p data-nodeid="10471">使用 Dart 运行如上命令。</p>\n<pre class="lang-dart" data-nodeid="10472"><code data-language="dart">dart isolate.dart\n</code></pre>\n<p data-nodeid="10473">以上代码的执行运行流程如下：</p>\n<ul data-nodeid="10474">\n<li data-nodeid="10475">\n<p data-nodeid="10476">import 对应的库；</p>\n</li>\n<li data-nodeid="10477">\n<p data-nodeid="10478">声明两个变量，一个是 isolate 对象，一个是字符串类型的 name；</p>\n</li>\n<li data-nodeid="10479">\n<p data-nodeid="10480">执行 main 函数，main 函数中执行 isolateServer 异步函数；</p>\n</li>\n<li data-nodeid="10481">\n<p data-nodeid="10482">isolateServer 中创建了一个 isolate 线程，创建线程时候，可以传递接受回调的函数 changName；</p>\n</li>\n<li data-nodeid="10483">\n<p data-nodeid="10484">在 changName 中修改当前的全局变量 name ，并且发送消息给到接收的端口，并且打印该线程中的 name 属性；</p>\n</li>\n<li data-nodeid="10485">\n<p data-nodeid="10486">isolateServer 接收消息，接收消息后打印返回的数据和当前 name 变量。</p>\n</li>\n</ul>\n<p data-nodeid="10487">根据如上执行过程，可以得出如下的运行结果。</p>\n<pre class="lang-dart" data-nodeid="10488"><code data-language="dart">Myname <span class="hljs-keyword">is</span> dart isolate <span class="hljs-keyword">in</span> isolate\nMyname <span class="hljs-keyword">is</span> dart isolate\nMyname <span class="hljs-keyword">is</span> dart\n</code></pre>\n<p data-nodeid="10489">从运行结果中，可以看到新的线程修改了全局的 name，并且通过消息发送返回到主线程中。而主线程的 name 属性并没有因为创建的新线程中的 name 属性的修改而发生改变，这也印证了内存隔离这点。</p>\n<h3 data-nodeid="10490">综合示例</h3>\n<p data-nodeid="10491">了解完以上知识点后，我再从一个实际的例子进行综合的分析，让你进一步巩固对 Dart 运行原理的掌握。</p>\n<p data-nodeid="10492">假设一个项目，需要 2 个团队去完成，团队中包含多项任务。可以分为 2 个高优先级任务（高优先级的其中，会产生 2 个任务，一个是紧急一个是不紧急），和 2 个非高优先级任务（非高优先级的其中，会产生有 2 个任务，一个是紧急一个是不紧急）。其中还有一个是必须依赖其他团队去做的，因为本团队没有那方面的资源，第三方也会产生一个高优先级任务和一个低优先级任务。</p>\n<p data-nodeid="10493">根据以上假设，我们可以用表 1 任务划分来表示：</p>\n<table data-nodeid="10495">\n<thead data-nodeid="10496">\n<tr data-nodeid="10497">\n<th data-org-content="**主任务**" data-nodeid="10499"><strong data-nodeid="10636">主任务</strong></th>\n<th data-org-content="**高优先级任务（微任务）**" data-nodeid="10500"><strong data-nodeid="10640">高优先级任务（微任务）</strong></th>\n<th data-org-content="**低优先级任务（事件任务）**" data-nodeid="10501"><strong data-nodeid="10644">低优先级任务（事件任务）</strong></th>\n<th data-org-content="**第三方任务（isolate）**" data-nodeid="10502"><strong data-nodeid="10648">第三方任务（isolate）</strong></th>\n</tr>\n</thead>\n<tbody data-nodeid="10507">\n<tr data-nodeid="10508">\n<td data-org-content="H1" data-nodeid="10509">H1</td>\n<td data-org-content="h1-1" data-nodeid="10510">h1-1</td>\n<td data-org-content="l1-1" data-nodeid="10511">l1-1</td>\n<td data-org-content="否" data-nodeid="10512">否</td>\n</tr>\n<tr data-nodeid="10513">\n<td data-org-content="H2" data-nodeid="10514">H2</td>\n<td data-org-content="h2-1" data-nodeid="10515">h2-1</td>\n<td data-org-content="l2-1" data-nodeid="10516">l2-1</td>\n<td data-org-content="否" data-nodeid="10517">否</td>\n</tr>\n<tr data-nodeid="10518">\n<td data-org-content="L3" data-nodeid="10519">L3</td>\n<td data-org-content="h3-1" data-nodeid="10520">h3-1</td>\n<td data-org-content="l3-1" data-nodeid="10521">l3-1</td>\n<td data-org-content="否" data-nodeid="10522">否</td>\n</tr>\n<tr data-nodeid="10523">\n<td data-org-content="L4" data-nodeid="10524">L4</td>\n<td data-org-content="h4-1" data-nodeid="10525">h4-1</td>\n<td data-org-content="l4-1" data-nodeid="10526">l4-1</td>\n<td data-org-content="否" data-nodeid="10527">否</td>\n</tr>\n<tr data-nodeid="10528">\n<td data-org-content="C5" data-nodeid="10529">C5</td>\n<td data-org-content="ch5-1" data-nodeid="10530">ch5-1</td>\n<td data-org-content="cl5-1" data-nodeid="10531">cl5-1</td>\n<td data-org-content="是" data-nodeid="10532">是</td>\n</tr>\n</tbody>\n</table>\n<p data-nodeid="10533">表1 项目任务划分详情</p>\n<p data-nodeid="10534">然后我们按照 Dart 语言执行方式去安排这个项目的开发工作，我们看看安排的工作到底会是怎么样执行流程，代码实现方式如下。</p>\n<pre class="lang-dart" data-nodeid="10535"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:async\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:isolate\'</span>;\nIsolate isolate;\n<span class="hljs-keyword">void</span> main() {\n\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'project start\'</span>); <span class="hljs-comment">// 打印项目启动标记</span>\n\tctask(); <span class="hljs-comment">// 分配并执行 C 任务</span>\n\t<span class="hljs-comment">// 大循环，等待</span>\n\t<span class="hljs-comment">//for(int i=0; i&lt;1000000000; i++){</span>\n\t<span class="hljs-comment">//}</span>\n\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\tscheduleMicrotask((){\n\t\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\t\tscheduleMicrotask((){\n\t\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'h1-1 task complete\'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h1-1</span>\n\t\t});\n\t\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\t\tTimer.run((){\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'l1-1 task complete\'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l1-1</span>\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'H1 task complete\'</span>); <span class="hljs-comment">// 打印H1微任务执行标记</span>\n\t});\n\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\tscheduleMicrotask((){\n\t\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\t\tscheduleMicrotask((){\n\t\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'h2-1 task complete\'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h2-1</span>\n\t\t});\n\t\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\t\tTimer.run((){\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'l2-1 task complete\'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l2-1</span>\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'H2 task complete\'</span>); <span class="hljs-comment">// 打印H2微任务执行标记</span>\n\t});\n\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\tTimer.run((){\n\t\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\t\tscheduleMicrotask((){\n\t\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'h3-1 task complete\'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h3-1</span>\n\t\t});\n\t\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\t\tTimer.run((){\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'l3-1 task complete\'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l3-1</span>\n&nbsp; &nbsp; &nbsp; &nbsp; });\n\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'L3 task complete\'</span>); <span class="hljs-comment">// 打印L3事件任务执行标记</span>\n&nbsp; &nbsp; });\n\t\n\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\tTimer.run((){\n\t\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\t\tscheduleMicrotask((){\n\t\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'h4-1 task complete\'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级h4-1</span>\n\t\t});\n\t\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\t\tTimer.run((){\n&nbsp; &nbsp; &nbsp; &nbsp; \t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'l4-1 task complete\'</span>); <span class="hljs-comment">// 执行事件任务，并打印事件任务优先级l4-1</span>\n&nbsp; &nbsp; &nbsp; &nbsp; });\n\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'L4 task complete\'</span>); <span class="hljs-comment">// 打印L4事件任务执行标记</span>\n&nbsp; &nbsp; });\n}\n<span class="hljs-comment">/// <span class="markdown">C 任务具体代码，创建新的线程，并监听线程返回数据&nbsp;</span></span>\n<span class="hljs-keyword">void</span> ctask()<span class="hljs-keyword">async</span>{\n\t<span class="hljs-keyword">final</span> receive = ReceivePort();\n\tisolate = <span class="hljs-keyword">await</span> Isolate.spawn(doCtask, receive.sendPort);\n\treceive.listen((data){\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(data);\n\t});\n}\n<span class="hljs-comment">/// <span class="markdown">创建的新线程，具体执行的任务代码</span></span>\n<span class="hljs-keyword">void</span> doCtask(SendPort port){\n\t<span class="hljs-comment">// 执行判断为微任务，添加到微任务队列</span>\n\tscheduleMicrotask((){\n\t\t<span class="hljs-built_in">print</span>(<span class="hljs-string">\'ch5-1 task complete\'</span>); <span class="hljs-comment">// 执行微任务，并打印微任务优先级ch5-1&nbsp;</span>\n\t});\n\t<span class="hljs-comment">// 执行判断为事件任务，添加到事件任务队列</span>\n\tTimer.run((){\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">\'cl5-1 task complete\'</span>); <span class="hljs-comment">// 打印cl5-1事件任务执行标记</span>\n&nbsp; &nbsp; });\n\tport.send(<span class="hljs-string">\'C1 task complete\'</span>); <span class="hljs-comment">// 打印 C 任务执行标记</span>\n}\n</code></pre>\n<p data-nodeid="10536">使用 Dart 运行如上命令。</p>\n<pre class="lang-plain" data-nodeid="10537"><code data-language="plain">dart isolate.dart\n</code></pre>\n<p data-nodeid="10538">我们先来看下，上面代码的运行结果。</p>\n<pre class="lang-sql" data-nodeid="10539"><code data-language="sql">project <span class="hljs-keyword">start</span>\nH1 task <span class="hljs-keyword">complete</span>\nH2 task <span class="hljs-keyword">complete</span>\nh1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nh2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nL3 task <span class="hljs-keyword">complete</span>\nh3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nL4 task <span class="hljs-keyword">complete</span>\nh4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nch5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\ncl5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nC1 task <span class="hljs-keyword">complete</span>\n</code></pre>\n<p data-nodeid="10540">H 和 L 的运行原理，希望你用上面我所讲到的知识点，去一步步分析，可以像我们图 2 或者图 3 的方法，画两个队列，然后逐步去分析。<br>\n上面的运行结果中，非 C 任务的运行原理留给你自己去分析，这里我着重介绍下为什么 C 的任务一直在最后才完成。</p>\n<p data-nodeid="10541">由于 C 任务是由其他线程执行，因此这里存在一定的时间去创建线程。创建线程完成后，才会进行回调，回调后才会将相应的回调事件插入到事件任务队列中。因此 C1 task complete 会在最后的一个事件任务中执行。而 ch5-1 task complete 和 cl5-1 task complete 由于需要等线程创建完成才能执行，因此执行也在后面。为了验证上面的结论，我们在 ctask() 后面增加一段耗 CPU 计算的代码，让新的线程执行快于当前的主线程。</p>\n<pre class="lang-dart" data-nodeid="10542"><code data-language="dart">    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'project start\'</span>);\n\tctask();\n\t<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){\n\t}\n</code></pre>\n<p data-nodeid="10543">在运行代码后，你将看到这样的结果：</p>\n<pre class="lang-sql" data-nodeid="10544"><code data-language="sql">project <span class="hljs-keyword">start</span>\nch5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\ncl5<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nH1 task <span class="hljs-keyword">complete</span>\nH2 task <span class="hljs-keyword">complete</span>\nh1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nh2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nC1 task <span class="hljs-keyword">complete</span>\nL3 task <span class="hljs-keyword">complete</span>\nh3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nL4 task <span class="hljs-keyword">complete</span>\nh4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl1<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl2<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl3<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\nl4<span class="hljs-number">-1</span> task <span class="hljs-keyword">complete</span>\n</code></pre>\n<p data-nodeid="10545">首先就输出了 C 线程中的微任务和事件任务，C 任务完成后，向主线程的事件任务中插入事件任务。由于主线程还没有运行结束，接下来运行后会产生微任务和事件任务，由于 C 回调的事件任务最先插入，因此在事件任务中最先执行，但是会慢于微任务事件的执行。</p>\n<h3 data-nodeid="10546">总结</h3>\n<p data-nodeid="10547">本课时首先介绍了 Dart 中单线程两个概念微任务事件队列和事件任务队列，并通过实践代码运行来介绍 Dart 事件循环方式。其次介绍了在 Dart 中应用 isolate 实现多线程的方式。最后使用一个实际的例子，来练习掌握 Dart 运行原理。在综合例子里还涉及了多线程中微任务和事件任务的调度方式。</p>\n<p data-nodeid="10548">学完本课时，你需要掌握其单线程中微任务队列和事件任务队列的调度方式，其次知道线程创建需要处理时间，以及线程事件执行完成后的回调是一个事件任务，这样就可以掌握其整体的运行原理了。如果你还有其他困惑，可以在下方留言或加入学习交流群。</p>\n<p data-nodeid="10549">以上就是本课时的主要内容，下一课时，我将用“三步法”带你掌握 Flutter ，并开始你的第一个应用，这也是我们即将开始实际的代码编程的第一步。</p>\n<p data-nodeid="10550">点击这里下载本课时源码，Flutter 专栏，源码地址：<a href="https://github.com/love-flutter/flutter-column" data-nodeid="10686">https://github.com/love-flutter/flutter-column</a></p>',
          },
          {
            theme: '03 | Hello Flutter：三步法掌握 Flutter，开始你的第一个应用',
            id: 35,
            content:
              '<p data-nodeid="1285" class="">本课时将进入 Flutter 开发实践应用。在进入实践应用之前，我先讲解最基础的环境搭建，然后会应用 Dart 语言开发第一个 App  —  Hello Flutter，最后再讲解一些开发过程中常用的调试方法和工具。</p>\n\n\n<p data-nodeid="3" class="">本课时需要一定的实践动手能力，因此在学习的时候建议你打开电脑按照里面的步骤进行学习。</p>\n<h3 data-nodeid="4">第一步：环境搭建</h3>\n<p data-nodeid="2139" class="">环境构建方法在官网已提供了非常详细的指引，你可以参考官网指引<a href="https://flutterchina.club/get-started/install/" data-nodeid="2143">《起步:安装 Flutter》</a>。这里我先介绍一些共性的问题，然后再分别从  Mac 系统 和 Windows 系统介绍其中比较有代表性的问题。</p>\n\n<h4 data-nodeid="6">常见问题</h4>\n<p data-nodeid="7">以下是大家很容易忽视的几个问题。</p>\n<ul data-nodeid="2985">\n<li data-nodeid="2986">\n<p data-nodeid="2987"><strong data-nodeid="2999">环境要求</strong>，你需要注意 Flutter 的环境要求，很多人都会忽视这一点，导致在安装过程中遇到问题才会回头看环境要求，所以无论自己对配置如何了解，都需要按照官网的指引去检查每个配置项。</p>\n</li>\n<li data-nodeid="2988">\n<p data-nodeid="2989"><strong data-nodeid="3004">Flutter 下载</strong>，请尽量下载当前稳定版本，避免因为不稳定版本导致的其他环境要求，导致安装不成功。</p>\n</li>\n<li data-nodeid="2990">\n<p data-nodeid="2991"><strong data-nodeid="3013">Android Studio 工具安装</strong>，Flutter 的配置运行需要依赖 Android Studio 来完成，因此在安装之前可以先准备好 Android Studio 的安装配置，并且需要了解其中关于 Flutter 插件和 Dart 插件的安装，这些在 <a href="https://flutterchina.club/get-started/install/" data-nodeid="3011">Flutter 官网</a>有详细的解释说明。</p>\n</li>\n<li data-nodeid="2992">\n<p data-nodeid="2993" class=""><strong data-nodeid="3018">Anroid Studio 出现 unable to access android sdk add-on list</strong>，出现这个问题，可以修改 Android Studio 安装目录 bin 下的 idea.properties 文件，在文件最后一行增加如下配置。</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="4283"><code data-language="java">disable.android.first.run = <span class="hljs-keyword">true</span>\n</code></pre>\n\n\n\n\n<ul data-nodeid="7739">\n<li data-nodeid="7740">\n<p data-nodeid="7741"><strong data-nodeid="7751">Android Studio 网络代理</strong>，如果你的网络有代理，也需要进行配置，如果没有正确配置，将导致 Andorid Studio 提示 flutter pub upgrade 无法正常更新。</p>\n</li>\n<li data-nodeid="7742">\n<p data-nodeid="7743"><strong data-nodeid="7762">Flutter <strong data-nodeid="7761"><strong data-nodeid="7760">D</strong></strong>octor 核心点检查</strong>，需要认真检查其中的每一项，对于其中的问题项，Doctor 一般会提供具体的解决方案。</p>\n</li>\n<li data-nodeid="7744">\n<p data-nodeid="7745" class=""><strong data-nodeid="7767">点击 Finish 长久未响应</strong>（或者执行 flutter pub upgrade 未响应），这种情况会出现“This is taking an unexpectedly long time”提示，如果出现这个提示，很大可能是你的镜像配置没有按要求配置。你可以参考以下这段配置，第一个是 Flutter 的命令行工具，第二个则是 Dart 的命令行工具，后面两个镜像配置很关键。</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="8602"><code data-language="java">PATH=$PATH:/Users/用户名/Downloads/flutter-main/bin\nPATH=$PATH:/Users/用户名/Downloads/flutter-main/bin/cache/dart-sdk/bin\nPUB_HOSTED_URL=https:<span class="hljs-comment">//pub.flutter-io.cn</span>\nFLUTTER_STORAGE_BASE_URL=https:<span class="hljs-comment">//storage.flutter-io.cn</span>\n</code></pre>\n\n\n\n\n\n\n\n\n\n<ul data-nodeid="9437">\n<li data-nodeid="9438">\n<p data-nodeid="9439" class=""><strong data-nodeid="9445">Flutter SDK path not given</strong>，如果在创建 Flutter 项目时候提示“ Flutter SDK path not given“，则点击 Flutter SDK path 路径，然后选择我们前面安装的 Flutter SDK 路径即可。</p>\n</li>\n</ul>\n<h4 data-nodeid="9440">Mac 系统上注意的点</h4>\n\n\n<p data-nodeid="30">Mac 上的安装，我这里主要说明 Xcode 和 Mac 下的环境变量配置。</p>\n<ul data-nodeid="31">\n<li data-nodeid="32">\n<p data-nodeid="33">Xcode 要升级到指定版本以上，由于 Flutter 需要应用 iOS 模拟器，因此对 Xcode 版本有一定要求。</p>\n</li>\n<li data-nodeid="34">\n<p data-nodeid="35">Mac 下设置环境变量，其中涉及一些环境变量的配置，虽然网上有很多方法，官网也有提供，但我推荐大家使用如下方法，永久设置。</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="12794"><code data-language="java">sudo vim ~/.bash_profile\n</code></pre>\n<p data-nodeid="14496">配置添加 Flutter 的安装路径，一般情况下会安装在你解压后运行的路径下。例如，下面我自己安装后的路径，安装完成后确定具体路径，然后在 bash_profile 文件中增加这行配置即可。</p>\n<pre data-nodeid="16188" class=""><code>PATH=$PATH:/Users/用户名/Downloads/flutter-main/bin\n</code></pre>\n<p data-nodeid="16189">最后再运行加载，并运行测试。</p>\n\n\n\n\n\n\n\n\n\n\n<pre class="lang-java" data-nodeid="17830"><code data-language="java">source ~/.bash_profile\nflutter -h\n</code></pre>\n<h4 data-nodeid="17831">Windows 系统上注意的点</h4>\n\n\n\n\n<p data-nodeid="40">Widows 系统安装需注意以下几点。</p>\n<ul data-nodeid="41">\n<li data-nodeid="42">\n<p data-nodeid="43" class="">环境变量的设置，如果在 cmd 下没有 export 命令，前往系统属性下 -&gt; 环境变量，然后新建，按照变量名为  PUB_HOSTED_URL ，变量值为 <a href="https://pub.flutter-io.cn" data-nodeid="249">https://pub.flutter-io.cn</a> ，以及变量名为 FLUTTER_STORAGE_BASE_URL ，变量值为 <a href="https://storage.flutter-io.cn" data-nodeid="259">https://storage.flutter-io.cn</a> 进行配置，对应到官方文档如下配置。</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="19103"><code data-language="java">export PUB_HOSTED_URL=https:<span class="hljs-comment">//pub.flutter-io.cn</span>\nexport FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-comment">//storage.flutter-io.cn</span>\n</code></pre>\n\n\n<ul data-nodeid="45">\n<li data-nodeid="46">\n<p data-nodeid="47">配置 Flutter 运行环境，下载完成 Flutter SDK ，并放到指定的 C:\\src\\ 下，然后再次配置环境变量，需要在环境变量名为 PATH 的字段后面增加分号分割，并在分号后增加如下路径。</p>\n</li>\n</ul>\n<pre class="lang-plain" data-nodeid="48"><code data-language="plain">C:\\src\\flutter\\bin\n</code></pre>\n<ul data-nodeid="49">\n<li data-nodeid="50">\n<p data-nodeid="51">如果出现安装 Android SDK 时无法勾选 SDK ，需要重新卸载安装。这里需注意，在卸载时需勾选删除当前用户本地 Android Studio 配置，然后重新安装时，选择非 Program Files 目录。</p>\n</li>\n</ul>\n<h3 data-nodeid="52">第二步：创建项目运行</h3>\n<p data-nodeid="53">上面的配置安装完成后，我们就开始创建 Flutter 项目，这里我介绍的是 Android Studio IDE 的过程。</p>\n<ol data-nodeid="20788">\n<li data-nodeid="20789">\n<p data-nodeid="20790">选择新建一个 Start a new Flutter Project ，然后选择 Flutter Application ，如图 1。</p>\n</li>\n</ol>\n<p data-nodeid="21642" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/12/Ciqc1F7pvnuANcQpAACTMSsFoo0714.png" alt="image" data-nodeid="21645"><br>\n图 1 New Flutter Project</p>\n\n\n\n\n<ol start="2" data-nodeid="26351">\n<li data-nodeid="26352">\n<p data-nodeid="26353">然后依次填写相应的 Project name 、Flutter SDK Path（如果配置好了会默认填写上，如果没有可以去重新选择）、Project location （具体的项目保存地址）、Descrition ，填写完成后，点击下一步，然后点击 finish 即可。</p>\n</li>\n<li data-nodeid="26354">\n<p data-nodeid="26355">如果卡在 finish 这个环节，请强制退出，然后再重新打开，检查配置。具体解决办法可参考共性问题中的“点击 finish 长久未响应”问题。</p>\n</li>\n<li data-nodeid="26356" class="">\n<p data-nodeid="26357">创建完成后，会看到如图 2 的项目目录结构。</p>\n</li>\n</ol>\n\n\n\n<p data-nodeid="24207" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/12/Ciqc1F7pvouAKi3mAAC2vjxyHVc774.png" alt="image" data-nodeid="24213"><br>\n图 2 Flutter 项目目录结构</p>\n\n\n\n\n\n\n<ol start="5" data-nodeid="28479">\n<li data-nodeid="28480">\n<p data-nodeid="28481">成功创建后，我们选择一个模拟器，然后在运行入口文件选择 main.dart ，最后点击右侧启动按钮进行编译运行。<strong data-nodeid="28488">如果下拉没有模拟器，Android Studio 会提供指引前往配置</strong>。</p>\n</li>\n</ol>\n<p data-nodeid="28482" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/1D/CgqCHl7pvrmAKD3eAAAhuRZycV0676.png" alt="image" data-nodeid="28491"><br>\n图 3 运行启动说明</p>\n\n\n\n\n\n<ol start="6" data-nodeid="31030">\n<li data-nodeid="31031">\n<p data-nodeid="31032">运行成功后，将会打开 iPhone 11 模拟器，然后启动我们的应用，如图 3。</p>\n</li>\n</ol>\n<p data-nodeid="31033" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/12/Ciqc1F7pvsSAKTXCAAGu5cF8GWk440.png" alt="image" data-nodeid="31037"><br>\n图 4 iPhone 11 模拟器</p>\n\n\n\n\n\n<p data-nodeid="78">以上就成功配置了 Flutter 运行环境和开发工具。</p>\n<h3 data-nodeid="79">第三步：实现 Hello Flutter APP</h3>\n<p data-nodeid="80">在实现一些编程之前，我先详细介绍工程目录中每个目录的作用，其次介绍如何进行修改代码，实现界面显示 Hello Flutter，最后再介绍三个常见的调试方法。</p>\n<h4 data-nodeid="81">目录说明</h4>\n<p data-nodeid="34406">上述图 2 中已有相关工程目录的截图，我现在分别介绍下每个目录的作用。</p>\n<p data-nodeid="34407" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/1E/CgqCHl7pvuqAfnGbAAC2vjxyHVc400.png" alt="image" data-nodeid="34411"><br>\n图 2 Flutter 项目目录结构</p>\n\n\n\n\n\n\n<ul data-nodeid="85">\n<li data-nodeid="86">\n<p data-nodeid="87"><strong data-nodeid="308">.idea</strong></p>\n</li>\n</ul>\n<p data-nodeid="88">这个和 Flutter 无关，这里面主要是保留代码的修改历史。</p>\n<ul data-nodeid="89">\n<li data-nodeid="90">\n<p data-nodeid="91"><strong data-nodeid="313">android</strong></p>\n</li>\n</ul>\n<p data-nodeid="92">这个目录主要是和 Android 原生平台交互的工程代码，其目录结构和原生的 Android 项目基本一致，但是一些配置和代码结构是不同的。</p>\n<ul data-nodeid="93">\n<li data-nodeid="94">\n<p data-nodeid="95"><strong data-nodeid="318">ios</strong></p>\n</li>\n</ul>\n<p data-nodeid="96">这个目录主要也是和 iOS 原生平台交互的代码。</p>\n<ul data-nodeid="97">\n<li data-nodeid="98">\n<p data-nodeid="99"><strong data-nodeid="323">lib</strong></p>\n</li>\n</ul>\n<p data-nodeid="100">这个目录下的文件为 Flutter 项目核心代码，其中包含了一个 main.dart 入口文件。</p>\n<ul data-nodeid="101">\n<li data-nodeid="102">\n<p data-nodeid="103"><strong data-nodeid="328">test</strong></p>\n</li>\n</ul>\n<p data-nodeid="104">这个目录下的文件存放 Flutter 项目相关的测试文件。</p>\n<ul data-nodeid="105">\n<li data-nodeid="106">\n<p data-nodeid="107"><strong data-nodeid="333">pubspec.yaml</strong></p>\n</li>\n</ul>\n<p data-nodeid="108">该文件为 Flutter 项目配置文件，包括了项目名、项目描述、版本、运行环境以及开发和正式环境的第三方库，该文件与我们熟悉的 package.json 作用是类似的。</p>\n<ul data-nodeid="109">\n<li data-nodeid="110">\n<p data-nodeid="111"><strong data-nodeid="338">pubspec.lock</strong></p>\n</li>\n</ul>\n<p data-nodeid="112">这是自动生成的文件，里面指明了 pubspec.yaml 等依赖包和项目依赖库的具体版本号，该文件的功能和我们常见的 package.lock.json 作用类似。</p>\n<ul data-nodeid="113">\n<li data-nodeid="114">\n<p data-nodeid="115"><strong data-nodeid="343">.metadata</strong></p>\n</li>\n</ul>\n<p data-nodeid="116">这是自动生成的文件，里面记录了项目的属性信息。用于切换分支、升级 SDK 使用。</p>\n<ul data-nodeid="117">\n<li data-nodeid="118">\n<p data-nodeid="119"><strong data-nodeid="348">.packages</strong></p>\n</li>\n</ul>\n<p data-nodeid="120">这里面放置了项目依赖的库，对应在本机电脑上的绝对路径，为自动生成文件。如果项目出错或者无法找到某个库，可以把这个文件删除，重新自动配置即可。</p>\n<p data-nodeid="121">.gitignore、README.md 与前端项目中的文件作用是一致的，这里就不详加说明。</p>\n<p data-nodeid="122"><strong data-nodeid="372">在开发过程中我们只需要关注三个核心部分，代码开发<strong data-nodeid="367"><strong data-nodeid="366">放在</strong></strong> lib 下，test 存放我们的测试文件，项目配置文件<strong data-nodeid="369"><strong data-nodeid="368">放在</strong></strong> pubspec.yaml <strong data-nodeid="371"><strong data-nodeid="370">下</strong></strong>。</strong></p>\n<h4 data-nodeid="123">Hello Flutter</h4>\n<p data-nodeid="124">分析清楚文件目录后，在 lib 下修改 main.dart ，在该模块中打印 Hello Flutter 实现第一个 Flutter 应用开发。</p>\n<ol data-nodeid="125">\n<li data-nodeid="126">\n<p data-nodeid="127">打开 main.dart ，将文件中 MaterialApp 下的 title 名字修改为 “Two You” ，将 home 下的 title 修改为 “Two You”，相关代码如下所示。</p>\n</li>\n</ol>\n<pre class="lang-dart" data-nodeid="128"><code data-language="dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> MaterialApp(\n      title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// app 的title信息 </span>\n        primarySwatch: Colors.blue, <span class="hljs-comment">// 页面的主题颜色</span>\n      ),\n      home: MyHomePage(title: <span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 当前页面的 title 信息</span>\n    );\n  }\n}\n</code></pre>\n<ol start="2" data-nodeid="37804">\n<li data-nodeid="37805">\n<p data-nodeid="37806">将 main.dart 中 Scaffold 下的 body 下的 children 下的第一个 Text 内容修改为 “Hello Flutter”，并去掉下面一个 Text，如下图 5。</p>\n</li>\n</ol>\n<p data-nodeid="37807" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/1E/CgqCHl7pvyyAAoyEAAGmjIkimiw325.png" alt="image" data-nodeid="37811"><br>\n图 5 修改 main.dart 文件的代码指引</p>\n\n\n\n\n\n\n\n<p data-nodeid="39500">修改完成后，保存文件，然后按照本课时中的”第二步：创建项目运行“运行本程序即可（如果已经运行过，保存文件模拟器会热加载），你将看到如下的结果，如图 6 所示。</p>\n<p data-nodeid="39501" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/1E/CgqCHl7pvzyAHXDxAAGn0n0MOsU471.png" alt="image" data-nodeid="39505"><br>\n图 6 Hello Flutter 运行结果</p>\n\n\n\n\n<p data-nodeid="137">上面的代码是基于最开始的 main.dart 进行，如果觉得修改原文件比较麻烦，我们可以简化为如下的代码：</p>\n<pre class="lang-dart" data-nodeid="138"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> MaterialApp(\n      title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// app 的title信息&nbsp;</span>\n      theme: ThemeData(\n        primarySwatch: Colors.blue, <span class="hljs-comment">// 页面的主题颜色</span>\n      ),\n      home: Scaffold(\n          appBar: AppBar(\n            title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 当前页面的 title 信息</span>\n          ),\n          body:  Center(\n            child: Text(<span class="hljs-string">\'Hello Flutter\'</span>), <span class="hljs-comment">// 当前页面的显示的文本信息</span>\n          )\n      )\n    );\n  }\n}\n</code></pre>\n<h4 data-nodeid="139">调试方法</h4>\n<p data-nodeid="140">代码运行调试在各种语言中都是比较基本的知识点，在 Flutter 中也应该掌握，这里我只介绍 Flutter 不同于其他语言的调试方法，包含以下几类：</p>\n<ul data-nodeid="141">\n<li data-nodeid="142">\n<p data-nodeid="143"><strong data-nodeid="392">断点调试</strong></p>\n</li>\n</ul>\n<p data-nodeid="144">这个知识点和大家熟悉的 Chrome 的断点调试基本一致，核心是在断点处查看当前各个数据的状态情况，但是需要使用 debug 模式运行。</p>\n<ul data-nodeid="145">\n<li data-nodeid="146">\n<p data-nodeid="147"><strong data-nodeid="397">debugger 调试</strong></p>\n</li>\n</ul>\n<p data-nodeid="148">在代码中增加一个断点语法，可以通过条件式的判断来进行断点，同样需要使用 debug 模式运行。</p>\n<ul data-nodeid="149">\n<li data-nodeid="150">\n<p data-nodeid="151"><strong data-nodeid="402">界面调试</strong></p>\n</li>\n</ul>\n<p data-nodeid="152">为了能够掌握具体的布局问题，在 Web 端，我们可以通过 Chrome 工具进行分析。虽然在 Flutter 中是没有 Chrome 工具，但是 Flutter 提供了可视化的界面调试方法。</p>\n<p data-nodeid="153">上面提到的三点，其实在 Flutter 中提供了一个非常不错的工具。如果你是在 Android Studio 中的话，你可以直接点击下图 7 的按钮，将为你下载相应的组件，然后打开图 8 的界面调试框。如果你使用的是非 Android Studio ，可以使用命令行的方式，参考<a href="https://flutter.cn/docs/development/tools/devtools/cli" data-nodeid="407">官网</a>方式，首先安装 devtools 工具。</p>\n<pre class="lang-java" data-nodeid="40778"><code data-language="java">pub global activate devtools\n</code></pre>\n\n\n<p data-nodeid="155">安装完成后，运行以下命令启动运行。</p>\n<pre class="lang-java" data-nodeid="43312"><code data-language="java">pub global run devtools\n</code></pre>\n<p data-nodeid="45005"><img src="https://s0.lgstatic.com/i/image/M00/21/12/Ciqc1F7pv1iADPaQAABwzl3Sgow148.png" alt="image" data-nodeid="45009"><br>\n图 7 Flutter 调试工具按钮指引</p>\n<p data-nodeid="45006" class=""><img src="https://s0.lgstatic.com/i/image/M00/21/12/Ciqc1F7pv2CAVgmvAAMQ0qCy2Nw964.png" alt="image" data-nodeid="45014"><br>\n图 8 Dart DevTools 工具</p>\n\n\n\n\n\n\n\n\n\n<p data-nodeid="161">该套工具的详细介绍可以参考<a href="https://flutter.cn/docs/development/tools/devtools" data-nodeid="421">开发者工具</a>。</p>\n<h3 data-nodeid="162">总结</h3>\n<p data-nodeid="163">本课时介绍了如何三步开启第一个应用程序 Hello Flutter，包括环境搭建、创建项目以及运行、修改示例代码。学完本课时，你需要掌握环境搭建的方法以及如何创建运行项目。</p>\n\n<p data-nodeid="165"><a href="https://github.com/love-flutter/flutter-column" data-nodeid="428">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '04 | 代码规范：实践开发 Flutter 编程代码规范工具',
            id: 36,
            content:
              '<p data-nodeid="25489" class="te-preview-highlight">在实践编程之前，我们先来掌握代码规范，毕竟优秀的编程代码从规范开始。</p>\n<h3 data-nodeid="25490">命名规范</h3>\n<p data-nodeid="25491">命名规范中包括了文件以及文件夹的命名规范，常量和变量的命名规范，类的命令规范。Dart 中只包含这三种命名标识。</p>\n<ul data-nodeid="25492">\n<li data-nodeid="25493">\n<p data-nodeid="25494">AaBb 类规范，首字母大写驼峰命名法，例如 IsClassName，常用于类的命名。</p>\n</li>\n<li data-nodeid="25495">\n<p data-nodeid="25496">aaBb 类规范，首字母小写驼峰命名法，例如 isParameterName，常用于常量以及变量命名。</p>\n</li>\n<li data-nodeid="25497">\n<p data-nodeid="25498">aa_bb 类规范，小写字母下划线连接法，例如 is_a_flutter_file_name，常用于文件及文件夹命名。</p>\n</li>\n</ul>\n<h3 data-nodeid="25499">注释规范</h3>\n<p data-nodeid="25500">注释的目的是生成我们需要的文档，从而增强项目的可维护性。</p>\n<h4 data-nodeid="25501">单行注释</h4>\n<p data-nodeid="25502">单行注释主要是“ // ”这类标示的注释方法，这类注释与其他各类语言使用的规范一致。单行注释主要对于单行代码逻辑进行解释，为了避免过多注释，主要是在一些理解较为复杂的代码逻辑上进行注释。</p>\n<p data-nodeid="25503">比如，下面这段代码没有注释，虽然你看上下文也会知道这里表示的是二元一次方程的 ∆ ，但是却不知道如果 ∆ 大于 0 ，为什么 x 会等于 2。</p>\n<pre class="lang-dart" data-nodeid="25504"><code data-language="dart"><span class="hljs-keyword">if</span> ( b * b - <span class="hljs-number">4</span> * a * c &gt; <span class="hljs-number">0</span> ) {\n  x = <span class="hljs-number">2</span>;\n}\n</code></pre>\n<p data-nodeid="25505">如果加上注释则显得逻辑清晰容易理解，修改后如下所示。</p>\n<pre class="lang-dart" data-nodeid="25506"><code data-language="dart"><span class="hljs-comment">// 当∆大于0则表示方程x个解，x则为2</span>\n<span class="hljs-keyword">if</span> ( b * b - <span class="hljs-number">4</span> * a * c &gt; <span class="hljs-number">0</span> ) {\n  x = <span class="hljs-number">2</span>;\n}\n</code></pre>\n<p data-nodeid="25507">虽然单行注释大家都比较了解，但我这里还是多解释了下如何应用，主要是希望大家规范化使用，减少不必要的代码注释。</p>\n<h4 data-nodeid="25508">多行注释</h4>\n<p data-nodeid="25509">在 Dart 中由于历史原因（前后对多行注释方式进行了修改）有两种注释方式，一种是 /// ，另外一种则是 / **......* / 或者 /*......*/ ，这两种都可以使用。/**......*/ 和 /*......*/ 这种块级注释方式在其他语言（比如 JavaScript ）中是比较常用的，但是在 Dart 中我们更倾向于使用 /// ，后续我们所有的代码都按照这个规范来注释。</p>\n<p data-nodeid="25510">多行注释涉及类的注释和函数的注释。两者在注释方法上一致。首先是用一句话来解释该类或者函数的作用，其次使用空行将注释和详细注释进行分离，在空行后进行详细的说明。如果是类，在详细注释中，补充该类作用，其次应该介绍返回出去的对象功能，或者该类的核心方法。如果是函数，则在详细注释中，补充函数中的参数以及返回的数据对象。</p>\n<p data-nodeid="25511">假设有一个 App 首页的库文件，其中包含类 HomePage ， HomePage 中包含两个方法，一个是 getCurrentTime ，另一个是 build 方法，代码注释如下（未实现其他部分代码）。</p>\n<pre class="lang-dart" data-nodeid="25512"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">/// \n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; <span class="hljs-keyword">new</span> HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// [prefix]需要传入一个前缀信息</span></span>\n  <span class="hljs-comment">/// <span class="markdown">返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime(<span class="hljs-built_in">String</span> prefix) {\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<h4 data-nodeid="25513">注释文档生成</h4>\n<p data-nodeid="25514">根据上面的代码注释内容，我们利用一个官方工具来将当前项目中的注释转化为文档。该工具的执行命令在 Dart 执行命令的同一个目录下，如果你在课时 03 中已经添加了 dart 命令行工具，那么该工具就可以直接使用了，如果没有则需要按照 03 课时中的方法，重新配置 dart 的运行命令的环境变量，这里主要演示下通过规范化的代码注释生成的文档。</p>\n<p data-nodeid="25515">打开命令行工具进入当前项目，或者在 Android Studio 点击界面上的 Terminal 打开命令行窗口，运行如下命令。</p>\n<pre class="lang-java" data-nodeid="25516"><code data-language="java">dartdoc\n</code></pre>\n<p data-nodeid="25517">运行结束后，会在当前项目目录生成一个 doc 的文件夹。在生成文件夹中，可以直接打开 doc/api/index.html 文件，你就会看到如图 1 所示的文档界面。</p>\n<p data-nodeid="25518"><img src="https://s0.lgstatic.com/i/image/M00/22/66/Ciqc1F7sNjeAE5ykAAFKDSwqzfU381.png" alt="image (7).png" data-nodeid="25667"><br>\n图 1 生成文档的整体界面结构</p>\n<p data-nodeid="25519">接下来我们打开 HomePageState 类，可以看到如图 2 中的效果。</p>\n<p data-nodeid="25520"><img src="https://s0.lgstatic.com/i/image/M00/22/72/CgqCHl7sNkGAMQRQAADbY3c-XN8695.png" alt="image (8).png" data-nodeid="25673"><br>\n图 2 HomePageState 的注释文档</p>\n<p data-nodeid="25521">其次再打开函数 getCurrentTime 可以看到图 3 的效果。从效果看，我们的文档已经生成了，而且效果很好。</p>\n<p data-nodeid="25522"><img src="https://s0.lgstatic.com/i/image/M00/22/72/CgqCHl7sNkiAYZqRAAGMc2znMSs481.png" alt="image (9).png" data-nodeid="25679"><br>\n图 3 getCurrentTime 的注释文档</p>\n<p data-nodeid="25523">以上是使用标准的代码注释生成的文档，利用这种方式将大大提升项目的可维护性，希望大家在项目初期就要做好此类规范。</p>\n<h3 data-nodeid="25524">库引入规范</h3>\n<p data-nodeid="25525">Dart 为了保持代码的整洁，规范了 import 库的顺序。将 import 库分为了几个部分，每个部分使用空行分割。分为 dart 库、package 库和其他的未带协议头（例如下面中的 util.dart ）的库。其次相同部分按照模块的首字母的顺序来排列，例如下面的代码示例：</p>\n<pre class="lang-dart" data-nodeid="25526"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:developer\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/home_page.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'util.dart\'</span>;\n</code></pre>\n<h3 data-nodeid="25527">代码美化</h3>\n<p data-nodeid="25528">在 Dart 中同样有和前端一样的工具 pritter ，在 Dart 中叫作 dartfmt ，该工具和 dartdoc 一样，已经包含在 Dart SDK 中，因此可以直接运行如下命令检查是否生效。</p>\n<pre class="lang-java" data-nodeid="25529"><code data-language="java">dartfmt -h\n</code></pre>\n<p data-nodeid="25530">既然有此类工具，我们就来看下如何应用工具来规范和美化我们的代码结构。</p>\n<h4 data-nodeid="25531">dartfmt</h4>\n<p data-nodeid="25532">dartfmt 工具的规范包括了以下几点：</p>\n<ul data-nodeid="25533">\n<li data-nodeid="25534">\n<p data-nodeid="25535">使用空格而不是 tab；</p>\n</li>\n<li data-nodeid="25536">\n<p data-nodeid="25537">在一个完整的代码逻辑后面使用空行区分；</p>\n</li>\n<li data-nodeid="25538">\n<p data-nodeid="25539">二元或者三元运算符之间使用空格；</p>\n</li>\n<li data-nodeid="25540">\n<p data-nodeid="25541">在关键词 , 和 ; 之后使用空格；</p>\n</li>\n<li data-nodeid="25542">\n<p data-nodeid="25543">一元运算符后请勿使用空格；</p>\n</li>\n<li data-nodeid="25544">\n<p data-nodeid="25545">在流控制关键词，例如 for 和 while 后，使用空格区分；</p>\n</li>\n<li data-nodeid="25546">\n<p data-nodeid="25547">在 ( [ { } ] ) 符号后请勿使用空格；</p>\n</li>\n<li data-nodeid="25548">\n<p data-nodeid="25549">在 { 后前使用空格；</p>\n</li>\n<li data-nodeid="25550">\n<p data-nodeid="25551">使用 . 操作符，从第二个 . 符号后每次都使用新的一行。</p>\n</li>\n</ul>\n<p data-nodeid="25552">其他规范可以参考 <a href="https://github.com/dart-lang/dart_style/wiki/Formatting-Rules" data-nodeid="25706">dartfmt</a> 的官网。了解完以上规范后，我们现在将上面的 home_page.dart 进行修改，将部分代码修改为不按照上面规范的结构，代码修改如下：</p>\n<pre class="lang-dart" data-nodeid="25553"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; <span class="hljs-keyword">new</span> HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// [prefix]需要传入一个前缀信息</span></span>\n  <span class="hljs-comment">/// <span class="markdown">返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime( <span class="hljs-built_in">String</span> prefix ) {\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<p data-nodeid="25554">上面 getCurrentTime 的参数和 { 没有按照 dartfmt 规范来处理，在当前目录下打开 Terminal，然后先运行以下命令来修复当前的代码规范：</p>\n<pre class="lang-java" data-nodeid="25555"><code data-language="java">&nbsp;dartfmt -w --fix lib/\n</code></pre>\n<p data-nodeid="25556">运行成功后，你将看到当前 home_page.dart 修改为如下代码：</p>\n<pre class="lang-dart" data-nodeid="25557"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// [prefix]需要传入一个前缀信息</span></span>\n  <span class="hljs-comment">/// <span class="markdown">返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime(<span class="hljs-built_in">String</span> prefix) {}\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {}\n}\n</code></pre>\n<p data-nodeid="25558">可以看到两处不符合规范的被修复了，{ 前无空格问题，和 getCurrentTime 参数空格问题。</p>\n<h3 data-nodeid="25559">工具化</h3>\n<p data-nodeid="25560">上面介绍了这些规范，在 Dart 中同样存在和 eslint 一样的工具 dartanalyzer 来保证代码质量。</p>\n<p data-nodeid="25561">该工具（ dartanalyzer ）已经集成在 Dart SDK ，你只需要在 Dart 项目根目录下新增analysis_options.yaml 文件，然后在文件中按照规范填写你需要执行的规则检查即可，目前现有的检查规则可以参考 <a href="https://dart-lang.github.io/linter/lints/" data-nodeid="25722">Dart linter rules</a> 规范。</p>\n<p data-nodeid="25562">为了方便，我们可以使用现成已经配置好的规范模版，这里有两个库 <a href="https://s0pub0dev.icopy.site/packages/pedantic" data-nodeid="25727">pedantic</a> 和 <a href="https://s0dart0dev.icopy.site/guides/language/effective-dart" data-nodeid="25733">effective_dart</a> 可以参照使用。如果我们需要在项目中，使用它们两者之一，可以在项目配置文件（ pubspec.yaml ）中新增如下两行配置：</p>\n<pre class="lang-dart" data-nodeid="25563"><code data-language="dart">dependencies:\n  flutter:\n    sdk: flutter\n  pedantic: ^<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>\n  # The following adds the Cupertino Icons font to your application.\n  # Use <span class="hljs-keyword">with</span> the CupertinoIcons <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">for</span> <span class="hljs-title">iOS</span> <span class="hljs-title">style</span> <span class="hljs-title">icons</span>.\n  <span class="hljs-title">cupertino_icons</span>: ^0.1.2\n<span class="hljs-title">dev_dependencies</span>:\n  <span class="hljs-title">flutter_test</span>:\n    <span class="hljs-title">sdk</span>: <span class="hljs-title">flutter</span>\n  <span class="hljs-title">pedantic</span>: ^1.8.0\n</span></code></pre>\n<p data-nodeid="25564">配置完成以后，在当前项目路径下运行 flutter pub upgrade 。接下来在本地新增的 analysis_options.yaml 文件中新增如下配置：</p>\n<pre class="lang-java" data-nodeid="25565"><code data-language="java">include: <span class="hljs-keyword">package</span>:pedantic/analysis_options.<span class="hljs-number">1.8</span>.<span class="hljs-number">0.</span>yaml\n</code></pre>\n<p data-nodeid="25566">如果我们认为 pedantic 不满足我们的要求，我们再根据 <a href="https://dart-lang.github.io/linter/lints/" data-nodeid="25741">Dart linter rules</a> 规范，前往选择自己需要的规范配置，修改下面的配置：</p>\n<pre class="lang-dart" data-nodeid="25567"><code data-language="dart">include: package:pedantic/analysis_options<span class="hljs-number">.1</span><span class="hljs-number">.8</span><span class="hljs-number">.0</span>.yaml\nanalyzer:\n  strong-mode:\n    implicit-casts: <span class="hljs-keyword">false</span>\nlinter:\n  rules:\n    # STYLE\n    - camel_case_types\n    - camel_case_extensions\n    - file_names\n    - non_constant_identifier_names\n    - constant_identifier_names # prefer\n    - directives_ordering\n    - lines_longer_than_80_chars # avoid\n    # DOCUMENTATION\n    - package_api_docs # prefer\n    - public_member_api_docs # prefer\n</code></pre>\n<p data-nodeid="25568">我在 pedantic 的基础上又增加了一些对于样式和文档的规范，增加完成以上配置后，运行如下命令可进行检查。</p>\n<pre class="lang-plain" data-nodeid="25569"><code data-language="plain">dartanalyzer lib\n</code></pre>\n<p data-nodeid="25570">运行完成以后，你可以看到一些提示、警告或者报错信息，具体提示如图 4 的问题：</p>\n<p data-nodeid="25571"><img src="https://s0.lgstatic.com/i/image/M00/22/72/CgqCHl7sNqmAMpqEAAESy_g_9Ag796.png" alt="image (10).png" data-nodeid="25747"><br>\n图 4 dartanalyzer 规则检查运行结果</p>\n<p data-nodeid="25572">图 4 中的一些问题已经非常详细，包括以下几点：</p>\n<ul data-nodeid="25573">\n<li data-nodeid="25574">\n<p data-nodeid="25575">没有为 main 类中的 public 方法增加文档说明；</p>\n</li>\n<li data-nodeid="25576">\n<p data-nodeid="25577">在 main 类中 import 了developer 库，但是未使用；</p>\n</li>\n<li data-nodeid="25578">\n<p data-nodeid="25579">在 main 类中 import 了 home_page.dart 库，但是未使用；</p>\n</li>\n<li data-nodeid="25580">\n<p data-nodeid="25581">在 home_page.dart 中的 getCurrentTime 使用了 String 返回类型，但是未返回相应类型；</p>\n</li>\n<li data-nodeid="25582">\n<p data-nodeid="25583">在 home_page.dart 中的 build 方法 使用了 Widaget 返回类型，但是未返回相应类型。</p>\n</li>\n</ul>\n<p data-nodeid="25584">这些问题非常清晰地说明了我们目前代码存在的问题，有了以上工具化的校验检查，我们在做团队代码规范的时候，就非常简单。</p>\n<h3 data-nodeid="25585">综合实践</h3>\n<p data-nodeid="25586">学完本课时，我们按照以上的标准来实践一下。在上一课时中，我已经教大家怎么去实现一个比较简单的 Hello Flutter ，现在我希望实现一个显示当前时间的功能 APP 。</p>\n<p data-nodeid="25587">以下是我的开发步骤，这里就涉及了上面所有的命名规范：</p>\n<ol data-nodeid="25588">\n<li data-nodeid="25589">\n<p data-nodeid="25590">在 lib 下创建一个 pages 目录;</p>\n</li>\n<li data-nodeid="25591">\n<p data-nodeid="25592">在 pages 下创建一个类为 home_page.dart 文件;</p>\n</li>\n<li data-nodeid="25593">\n<p data-nodeid="25594">在 home_page.dart 文件中创建两个类，一个是 HomePage，另一个是 HomePageState；</p>\n</li>\n<li data-nodeid="25595">\n<p data-nodeid="25596">在 HomePageState 类创建两个方法，一个是带返回 String 类型的 getCurrentTime 方法，另一个是带返回 Widget 类型的 build 方法（类似于 React 中的 render 方法）；</p>\n</li>\n<li data-nodeid="25597">\n<p data-nodeid="25598">实现两个方法，具体可以查看以下代码；</p>\n</li>\n<li data-nodeid="25599">\n<p data-nodeid="25600">在 main 函数中引入 home_page.dart 模块，并调用 HomePage 类。</p>\n</li>\n</ol>\n<p data-nodeid="25601">具体 main.dart 和 home_page.dart 代码分别如下：</p>\n<ul data-nodeid="25602">\n<li data-nodeid="25603">\n<p data-nodeid="25604">main.dart</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="25605"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/home_page.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 核心入口文件</span></span>\n<span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());\n<span class="hljs-comment">/// <span class="markdown">MyApp 核心入口界面</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> MaterialApp(\n        title: <span class="hljs-string">\'Two You\'</span>,\n        theme: ThemeData(\n          primarySwatch: Colors.blue,\n        ),\n        home: Scaffold(\n            appBar: AppBar(\n              title: Text(<span class="hljs-string">\'Two You\'</span>),\n            ),\n            body: Center(\n              child: HomePage(),\n            )));\n  }\n}\n</code></pre>\n<ul data-nodeid="25606">\n<li data-nodeid="25607">\n<p data-nodeid="25608">home_page.dart</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="25609"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:intl/intl.dart\'</span>; <span class="hljs-comment">// 需要在pubspec.yaml增加该模块</span>\n\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// [prefix]需要传入一个前缀信息</span></span>\n  <span class="hljs-comment">/// <span class="markdown">返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime(<span class="hljs-built_in">String</span> prefix) {\n    <span class="hljs-built_in">DateTime</span> now = <span class="hljs-built_in">DateTime</span>.now();\n    <span class="hljs-keyword">var</span> formatter = DateFormat(<span class="hljs-string">\'yy-mm-dd H:m:s\'</span>);\n    <span class="hljs-built_in">String</span> nowTime = formatter.format(now);\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'<span class="hljs-subst">$prefix</span> <span class="hljs-subst">$nowTime</span>\'</span>;\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Text(\n      getCurrentTime(<span class="hljs-string">\'当前时间\'</span>)\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25610">然后我们再运行 dartfmt 来美化代码结构，其次运行 dartanalyzer 工具来校验是否按照规范进行开发。上面代码已经是标准规范，因此你不会发现任何问题，如果你自己开发过程中有问题，则按照提示进行修改即可。如果规范检查完成以后，都没有任何问题后，我们再运行当前程序，结果如图 5 所示的效果。</p>\n<p data-nodeid="25611"><img src="https://s0.lgstatic.com/i/image/M00/22/67/Ciqc1F7sNr-AAZloAAFNQgKibbk184.png" alt="image (11).png" data-nodeid="25788"><br>\n图 5 home_page 页面效果</p>\n<h3 data-nodeid="25612">总结</h3>\n<p data-nodeid="25613">本课时主要介绍了命名规范、注释规范以及文档生成、库引入规范、代码美化，最后利用 dartanalyzer 来进行工具化校验保证项目代码质量。学完本课时以后，你需要掌握这些基础规范，其次特别需要掌握 dartfmt 和 dartanalyzer 工具的使用。</p>\n<p data-nodeid="25614">为了上面演示效果更佳，我们可以将时间变成自动更新的方式，这里就会涉及 05 课时的生命周期内容。具体实现效果以及原理，我会在接下来的 05 课时生命周期以及 06 课时有/无状态组件中详细说明。</p>\n<p data-nodeid="25615"><a href="https://github.com/love-flutter/flutter-column" data-nodeid="25798">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '05 | 生命周期：掌握 Flutter 生命周期以及应用场景',
            id: 37,
            content:
              '<p data-nodeid="110783" class="">本课时将介绍 Flutter 的组件，以及组件的生命周期，其次结合上课时的例子实现一个自动更新展示最新时间的 Flutter 应用。</p>\n<h3 data-nodeid="110784">组件 Widget</h3>\n<p data-nodeid="110785">Flutter 中的组件与前端组件的理解和作用基本一致，但是没有一个明确的概念解释 Flutter 组件，这里我借用前端的组件定义来解释 Flutter 组件的概念。</p>\n<p data-nodeid="110786">一个 Flutter 组件，包含了组件的模板、样式和交互等内容，外部只要按照组件设定的属性、函数及事件处理等进行调用即可，完全不用考虑组件的内部实现逻辑。其中组件又包括无状态组件和有状态组件。</p>\n<ul data-nodeid="110787">\n<li data-nodeid="110788">\n<p data-nodeid="110789">无状态组件</p>\n</li>\n</ul>\n<p data-nodeid="110790">无状态组件，可以理解为将外部传入的数据转化为界面展示的内容，只会渲染一次。</p>\n<ul data-nodeid="110791">\n<li data-nodeid="110792">\n<p data-nodeid="110793">有状态组件</p>\n</li>\n</ul>\n<p data-nodeid="110794">有状态组件，是定义交互逻辑和业务数据，可以理解为具有动态可交互的内容界面，会根据数据的变化进行多次渲染。</p>\n<h3 data-nodeid="110795">生命周期</h3>\n<p data-nodeid="110796">在原生 Android 、原生 iOS 、前端 React 或者 Vue 都存在生命周期的概念，在 Flutter 中一样存在生命周期的概念，其基本概念和作用相似。 Flutter 中说的生命周期，也是指有状态组件，对于无状态组件生命周期只有 build 这个过程，也只会渲染一次，而有状态组件则比较复杂，下面我们就来看看有状态组件的生命周期过程。</p>\n<h4 data-nodeid="110797">生命周期的流转</h4>\n<p data-nodeid="110798">Flutter 中的生命周期，包含以下几个阶段：</p>\n<ul data-nodeid="110799">\n<li data-nodeid="110800">\n<p data-nodeid="110801"><strong data-nodeid="110924">createState</strong> ，该函数为 StatefulWidget 中创建 State 的方法，当 StatefulWidget 被调用时会立即执行 createState 。</p>\n</li>\n<li data-nodeid="110802">\n<p data-nodeid="110803"><strong data-nodeid="110929">initState</strong> ，该函数为 State 初始化调用，因此可以在此期间执行 State 各变量的初始赋值，同时也可以在此期间与服务端交互，获取服务端数据后调用 setState 来设置 State。</p>\n</li>\n<li data-nodeid="110804">\n<p data-nodeid="110805"><strong data-nodeid="110934">didChangeDependencies</strong> ，该函数是在该组件依赖的 State 发生变化时，这里说的 State 为全局 State ，例如语言或者主题等，类似于前端 Redux 存储的 State 。</p>\n</li>\n<li data-nodeid="110806">\n<p data-nodeid="110807"><strong data-nodeid="110939">build</strong> ，主要是返回需要渲染的 Widget ，由于 build 会被调用多次，因此在该函数中只能做返回 Widget 相关逻辑，避免因为执行多次导致状态异常。</p>\n</li>\n<li data-nodeid="110808">\n<p data-nodeid="110809"><strong data-nodeid="110944">reassemble</strong> ，主要是提供开发阶段使用，在 debug 模式下，每次热重载都会调用该函数，因此在 debug 阶段可以在此期间增加一些 debug 代码，来检查代码问题。</p>\n</li>\n<li data-nodeid="110810">\n<p data-nodeid="110811"><strong data-nodeid="110949">didUpdateWidget</strong> ，该函数主要是在组件重新构建，比如说热重载，父组件发生 build 的情况下，子组件该方法才会被调用，其次该方法调用之后一定会再调用本组件中的 build 方法。</p>\n</li>\n<li data-nodeid="110812">\n<p data-nodeid="110813"><strong data-nodeid="110954">deactivate</strong> ，在组件被移除节点后会被调用，如果该组件被移除节点，然后未被插入到其他节点时，则会继续调用 dispose 永久移除。</p>\n</li>\n<li data-nodeid="110814">\n<p data-nodeid="110815"><strong data-nodeid="110959">dispose</strong> ，永久移除组件，并释放组件资源。</p>\n</li>\n</ul>\n<p data-nodeid="110816"><img src="https://s0.lgstatic.com/i/image/M00/26/D4/CgqCHl7zAM2AFYCOAAFd30sb1Ck089.png" alt="image (7).png" data-nodeid="110962"><br>\n图 1 生命周期流程图</p>\n<p data-nodeid="110817">整个过程分为四个阶段：</p>\n<ol data-nodeid="110818">\n<li data-nodeid="110819">\n<p data-nodeid="110820">初始化阶段，包括两个生命周期函数 createState 和 initState；</p>\n</li>\n<li data-nodeid="110821">\n<p data-nodeid="110822">组件创建阶段，也可以称组件出生阶段，包括 didChangeDependencies 和 build；</p>\n</li>\n<li data-nodeid="110823">\n<p data-nodeid="110824">触发组件多次 build ，这个阶段有可能是因为 didChangeDependencies、setState 或者 didUpdateWidget 而引发的组件重新 build ，在组件运行过程中会多次被触发，这也是优化过程中需要着重需要注意的点；</p>\n</li>\n<li data-nodeid="110825">\n<p data-nodeid="110826">最后是组件销毁阶段，deactivate 和 dispose。</p>\n</li>\n</ol>\n<h4 data-nodeid="110827">组件首次加载执行过程</h4>\n<p data-nodeid="110828">我们先实现一段代码，来看下组件在首次创建的执行过程是否是按照图 1 的流程。</p>\n<p data-nodeid="110829">1、 在 lib 中 pages 下创建 test_stateful_widget.dart ；<br>\n2、 在 test_stateful_widget.dart 添加如下代码：</p>\n<pre class="lang-dart" data-nodeid="110830"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">创建有状态测试组件</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStatefulWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'create state\'</span>);\n    <span class="hljs-keyword">return</span> TestState();\n  }\n}\n<span class="hljs-comment">/// <span class="markdown">创建状态管理类，继承状态测试组件</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">TestStatefulWidget</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">定义 state [count] 计算器</span></span>\n  <span class="hljs-built_in">int</span> count = <span class="hljs-number">1</span>;\n  <span class="hljs-comment">/// <span class="markdown">定义 state [name] 为当前描述字符串</span></span>\n  <span class="hljs-built_in">String</span> name = <span class="hljs-string">\'test\'</span>;\n  <span class="hljs-meta">@override</span>\n  initState() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'init state\'</span>);\n    <span class="hljs-keyword">super</span>.initState();\n  }\n  <span class="hljs-meta">@override</span>\n  didChangeDependencies() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'did change dependencies\'</span>);\n    <span class="hljs-keyword">super</span>.didChangeDependencies();\n  }\n  <span class="hljs-meta">@override</span>\n  didUpdateWidget(TestStatefulWidget oldWidget) {\n    count++;\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'did update widget\'</span>);\n    <span class="hljs-keyword">super</span>.didUpdateWidget(oldWidget);\n  }\n  <span class="hljs-meta">@override</span>\n  deactivate() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'deactivate\'</span>);\n    <span class="hljs-keyword">super</span>.deactivate();\n  }\n  <span class="hljs-meta">@override</span>\n  dispose() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'dispose\'</span>);\n    <span class="hljs-keyword">super</span>.dispose();\n  }\n  <span class="hljs-meta">@override</span>\n  reassemble(){\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'reassemble\'</span>);\n    <span class="hljs-keyword">super</span>.reassemble();\n  }\n  <span class="hljs-comment">/// <span class="markdown">修改 state name</span></span>\n  <span class="hljs-keyword">void</span> changeName() {\n    setState(() {\n      <span class="hljs-built_in">print</span>(<span class="hljs-string">\'set state\'</span>);\n      <span class="hljs-keyword">this</span>.name = <span class="hljs-string">\'flutter\'</span>;\n    });\n  }\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'build\'</span>);\n    <span class="hljs-keyword">return</span> Column(\n      children: &lt;Widget&gt;[\n        FlatButton(\n          child: Text(<span class="hljs-string">\'<span class="hljs-subst">$name</span> <span class="hljs-subst">$count</span>\'</span>), <span class="hljs-comment">// 使用 Text 组件显示描述字符和当前计算</span>\n          onPressed:()=&gt; <span class="hljs-keyword">this</span>.changeName(), <span class="hljs-comment">// 点击触发修改描述字符 state name</span>\n        )\n      ],\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="110831">上述代码把有状态组件的一些生命周期函数都进行了重写，并且在执行中都打印了一些字符串标识，目的是可以看到该函数被执行。</p>\n<p data-nodeid="110832">3、 然后在 main.dart 中加载该组件，代码如下：</p>\n<pre class="lang-dart" data-nodeid="110833"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/test_stateful_widget.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 核心入口文件</span></span>\n<span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());\n<span class="hljs-comment">/// <span class="markdown">MyApp 核心入口界面</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> MaterialApp(\n        title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字</span>\n        theme: ThemeData(\n          primarySwatch: Colors.blue, <span class="hljs-comment">// APP 主题</span>\n        ),\n        home: Scaffold(\n            appBar: AppBar(\n              title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n            ),\n            body: Center(\n             child:\n              TestStatefulWidget(),\n            )\n        ));\n  }\n}\n</code></pre>\n<p data-nodeid="110834">代码修改后，我们打开手机模拟器，然后运行该 App ，在输出控制台可以看到下面的运行打印日志信息。</p>\n<pre class="lang-plain" data-nodeid="110835"><code data-language="plain">flutter: create state\nflutter: init state\nflutter: did change dependencies\nflutter: build\nflutter: reassemble\nflutter: did update widget\nflutter: build\n</code></pre>\n<p data-nodeid="113702" class="te-preview-highlight">运行结果中，打印过程可以看到是按照我们上面图 1 的执行流程在运行的，<strong data-nodeid="113708">但其中最值得关注的是 build 运行了两次</strong>。这是在开发模式下才会执行的过程，在正式环境是不会出现的，因为重新渲染成本非常大，这个问题可以使用打印 build 的调用堆栈即可发现。如果你要关闭两次 build 也可以实现，在 Flutter 框架中搜索 constants.dart 文件，并找到下面这行代码，将 defaultValue 从 false 修改为 true。</p>\n\n\n\n\n\n\n<pre class="lang-dart" data-nodeid="110837"><code data-language="dart"><span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span> kReleaseMode = <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">\'dart.vm.product\'</span>, defaultValue: <span class="hljs-keyword">true</span>);\n</code></pre>\n<p data-nodeid="110838">其实这里会<strong data-nodeid="110998">触发 didUpdateWidget 函数</strong>，是因为 TestStatefulWidget 组件是 MyApp 组件中的子组件，从而导致 MyApp 函数中的 build 触发子组件 didUpdateWidget 函数的执行，具体会在下面触发组件再次 build 中详细说明。</p>\n<h4 data-nodeid="110839">触发组件再次 build</h4>\n<p data-nodeid="110840">触发组件再次 build 有三种方式，一个是 setState ，另一个是 didChangeDependencies ，再一个是 didUpdateWidget 。</p>\n<p data-nodeid="110841">setState 比较容易理解，在数据状态进行变化时，触发组件 build ，在上面的代码运行后的界面中，点击中间的页面提示如图 2 位置，就可以看到在调用 setState 后，会调用 build 一个方法。</p>\n<p data-nodeid="110842"><img src="https://s0.lgstatic.com/i/image/M00/26/D4/CgqCHl7zAQmAWvyUAAE_mgzi5xE933.png" alt="image (8).png" data-nodeid="111004"><br>\n图 2 测试组件运行界面</p>\n<p data-nodeid="110843">didChangeDependencies ，你可以理解为本组件依赖的全局 state 的值发生了变化，例如前端的 redux 中的数据发生了变化，也会进行 build 操作。一般情况下我们会将一些比较基础的数据放到全局变量中，例如主题颜色、地区语言或者其他通用变量等。如果这些全局 state 发生状态变化则会触发该函数，而该函数之后就会触发 build 操作。</p>\n<p data-nodeid="110844">didUpdateWidget 触发 build 我们需要从代码层面来讲解下，现在我们需要设计两个组件，一个是我们刚实现的 TestStatefulWidget ，另外一个则是该组件的子组件，我们命名为SubStatefulWidget 。接下来我们在 TestStatefulWidget 加载该组件，在头部 import 该组件，然后将 build 中的代码修改为下面：</p>\n<pre class="lang-dart" data-nodeid="110845"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'build\'</span>);\n  <span class="hljs-keyword">return</span> Column(\n    children: &lt;Widget&gt;[\n      FlatButton(\n        child: Text(<span class="hljs-string">\'<span class="hljs-subst">$name</span> <span class="hljs-subst">$count</span>\'</span>), <span class="hljs-comment">// 使用 Text 组件显示描述字符和当前计算</span>\n        onPressed:()=&gt; <span class="hljs-keyword">this</span>.changeName(), <span class="hljs-comment">// 点击触发修改描述字符 state name</span>\n      ),\n      SubStatefulWidget() <span class="hljs-comment">// 加载子组件</span>\n    ],\n  );\n}\n</code></pre>\n<p data-nodeid="110846">接下来我们实现 SubStatefulWidget 子组件的代码，和父组件基本相似，只是在打印处都加了 sub ，其次 build 实现逻辑也修改了，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="110847"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">创建子组件类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubStatefulWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub create state\'</span>);\n    <span class="hljs-keyword">return</span> SubState();\n  }\n}\n<span class="hljs-comment">/// <span class="markdown">创建子组件状态管理类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">SubStatefulWidget</span>&gt; </span>{\n  <span class="hljs-built_in">String</span> name = <span class="hljs-string">\'sub test\'</span>;\n  <span class="hljs-meta">@override</span>\n  initState() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub init state\'</span>);\n    <span class="hljs-keyword">super</span>.initState();\n  }\n  <span class="hljs-meta">@override</span>\n  didChangeDependencies() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub did change dependencies\'</span>);\n    <span class="hljs-keyword">super</span>.didChangeDependencies();\n  }\n  <span class="hljs-meta">@override</span>\n  didUpdateWidget(SubStatefulWidget oldWidget) {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub did update widget\'</span>);\n    <span class="hljs-keyword">super</span>.didUpdateWidget(oldWidget);\n  }\n  <span class="hljs-meta">@override</span>\n  deactivate() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub deactivate\'</span>);\n    <span class="hljs-keyword">super</span>.deactivate();\n  }\n  <span class="hljs-meta">@override</span>\n  dispose() {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub dispose\'</span>);\n    <span class="hljs-keyword">super</span>.dispose();\n  }\n  <span class="hljs-meta">@override</span>\n  reassemble(){\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub reassemble\'</span>);\n    <span class="hljs-keyword">super</span>.reassemble();\n  }\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'sub build\'</span>);\n    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">\'subname <span class="hljs-subst">$name</span>\'</span>); <span class="hljs-comment">// 使用Text组件显示当前name state</span>\n  }\n}\n</code></pre>\n<p data-nodeid="110848">代码实现完成后，我们再重新加载 App ，可以看到如下运行日志信息。</p>\n<pre class="lang-sql" data-nodeid="110849"><code data-language="sql">flutter: <span class="hljs-keyword">create</span> state\nflutter: init state\nflutter: did <span class="hljs-keyword">change</span> dependencies\nflutter: <span class="hljs-keyword">build</span>\nflutter: sub <span class="hljs-keyword">create</span> state\nflutter: sub init state\nflutter: sub did <span class="hljs-keyword">change</span> dependencies\nflutter: sub <span class="hljs-keyword">build</span>\nflutter: reassemble\nflutter: sub reassemble\nflutter: did <span class="hljs-keyword">update</span> widget\nflutter: <span class="hljs-keyword">build</span>\nflutter: sub did <span class="hljs-keyword">update</span> widget\nflutter: sub <span class="hljs-keyword">build</span>\n</code></pre>\n<ul data-nodeid="110850">\n<li data-nodeid="110851">\n<p data-nodeid="110852">加载 TestStatefulWidget 组件，四个状态函数 createState、initState、didChangeDependencies 和 build；</p>\n</li>\n<li data-nodeid="110853">\n<p data-nodeid="110854">加载 SubStatefulWidget 组件，四个状态函数 createState、initState、didChangeDependencies 和 build；</p>\n</li>\n<li data-nodeid="110855">\n<p data-nodeid="110856">TestStatefulWidget 进行二次 build ，因为父组件需要重新 build 触发子组件的 didUpdateWidget ，didUpdateWidget 则触发 build。</p>\n</li>\n</ul>\n<p data-nodeid="110857">为了验证上面逻辑，我们现在再次点击图 3 中的红色部分，来触发 TestStatefulWidget 组件的 build ，看下是否会触发子组件的 didUpdateWidget 和 build。</p>\n<p data-nodeid="110858"><img src="https://s0.lgstatic.com/i/image/M00/26/D4/CgqCHl7zATCAcLoKAAEryO5AHrk427.png" alt="image (9).png" data-nodeid="111017"><br>\n图 3 增加子组件界面点击指示图</p>\n<p data-nodeid="110859">在运行日志窗口可以看到增加了下面的日志信息。</p>\n<pre class="lang-sql" data-nodeid="110860"><code data-language="sql">flutter: <span class="hljs-keyword">set</span> state\nflutter: <span class="hljs-keyword">build</span>\nflutter: sub did <span class="hljs-keyword">update</span> widget\nflutter: sub <span class="hljs-keyword">build</span>\n</code></pre>\n<p data-nodeid="110861">这就说明了父组件的变化会引发子组件的 build ，虽然子组件没有任何的改动。这点如果是在前端的话，是需要使用 shouldUpdateComponent ，来介绍重新构建，不过在 Flutter 中是没有该功能来减少重新 build 的。</p>\n<h4 data-nodeid="110862">组件销毁触发</h4>\n<p data-nodeid="110863">在上面的代码基础上，我们直接在 TestStatefulWidget 组件中注释子组件 SubStatefulWidget 的调用，然后<strong data-nodeid="111028">热重载</strong>即可看到下面的日志信息（请注意一定是需要热重载才会有效果，主要目的是一开始加载了该组件，后面再去掉该组件触发）。</p>\n<pre class="lang-yaml" data-nodeid="110864"><code data-language="yaml"><span class="hljs-attr">flutter:</span> <span class="hljs-string">reassemble</span>\n<span class="hljs-attr">flutter:</span> <span class="hljs-string">sub</span> <span class="hljs-string">reassemble</span>\n<span class="hljs-attr">flutter:</span> <span class="hljs-string">build</span>\n<span class="hljs-attr">flutter:</span> <span class="hljs-string">sub</span> <span class="hljs-string">deactivate</span>\n<span class="hljs-attr">flutter:</span> <span class="hljs-string">sub</span> <span class="hljs-string">dispose</span>\n</code></pre>\n<h3 data-nodeid="110865">综合实践</h3>\n<p data-nodeid="110866">上一课时，只是简单地显示了一个时间，这里需要动态地显示当前的时间。基于我们本课时的学习，我们需要实现以下几点：</p>\n<ol data-nodeid="110867">\n<li data-nodeid="110868">\n<p data-nodeid="110869">使用有状态组件来实现，需要创建两个类 StatefulWidget 和 State ，分别为 HomePage 和 HomePageState 对应到一个文件 home_page.dart ；</p>\n</li>\n<li data-nodeid="110870">\n<p data-nodeid="110871">定义一个当前时间的 state currentTimeStr ，定义一个获取当前时间的函数 getCurrentTime ，并在 initState 中调用一次该函数当前时间；</p>\n</li>\n<li data-nodeid="110872">\n<p data-nodeid="110873">实现函数 getCurrentTime 获取当前时间；</p>\n</li>\n<li data-nodeid="110874">\n<p data-nodeid="110875">定义并实现一个定时刷新的函数 refreshTimeStr ，在定时函数中使用 Timer 定时使用 setState 来更新 state，并在 initState 中执行该函数；</p>\n</li>\n<li data-nodeid="110876">\n<p data-nodeid="110877">build 中展示当前时间的 state 值，以及一个前缀信息；</p>\n</li>\n</ol>\n<p data-nodeid="110878">接下来我们按照上面的步骤来实现代码。</p>\n<h4 data-nodeid="110879">步骤一：创建有状态类</h4>\n<p data-nodeid="110880">使用有状态组件来实现，在 lib 的 pages 目录下创建 home_page.dart ，接下来在文件中创建两个类 StatefulWidget 和 State ，分别为 HomePage 和 HomePageState，代码如下。</p>\n<pre class="lang-dart" data-nodeid="110881"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">App 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-comment">/// <span class="markdown">[prefix]是显示在时间之前的一个字符串</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<h4 data-nodeid="110882">步骤二：增加状态变量，实现初始化</h4>\n<p data-nodeid="110883">定义一个当前时间的 state currentTimeStr ，定义一个获取当前时间的函数 getCurrentTime ，并在 initState 中调用一次该函数当前时间，代码如下。</p>\n<pre class="lang-dart" data-nodeid="110884"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-comment">/// <span class="markdown">[prefix]是显示在时间之前的一个字符串</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">展示当前时间字符串</span></span>\n  <span class="hljs-built_in">String</span> currentTimeStr;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    <span class="hljs-keyword">this</span>.currentTimeStr = getCurrentTime();\n  }\n\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// 返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime() {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>;\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<h4 data-nodeid="110885">步骤三：实现 getCurrentTime 方法</h4>\n<p data-nodeid="110886">实现函数 getCurrentTime 获取当前时间，代码如下。</p>\n<pre class="lang-dart" data-nodeid="110887"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:intl/intl.dart\'</span>; <span class="hljs-comment">// 需要在pubspec.yaml增加该模块</span>\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-comment">/// <span class="markdown">[prefix]是显示在时间之前的一个字符串</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">展示当前时间字符串</span></span>\n  <span class="hljs-built_in">String</span> currentTimeStr;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    <span class="hljs-keyword">this</span>.currentTimeStr = getCurrentTime();\n  }\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// 返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime() {\n    <span class="hljs-built_in">DateTime</span> now = <span class="hljs-built_in">DateTime</span>.now();\n    <span class="hljs-keyword">var</span> formatter = DateFormat(<span class="hljs-string">\'yy-MM-dd hh:mm:ss\'</span>);\n    <span class="hljs-keyword">return</span> formatter.format(now);\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<h4 data-nodeid="110888">步骤四：定时 Timer 实现 state 定时更新</h4>\n<p data-nodeid="110889">定义并实现一个定时刷新的函数 refreshTimeStr ，在定时函数中使用 Timer 定时使用 setState 来更新 state，并在 initState 中执行该函数 ，代码如下。</p>\n<pre class="lang-dart" data-nodeid="110890"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:async\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:intl/intl.dart\'</span>; <span class="hljs-comment">// 需要在pubspec.yaml增加该模块</span>\n<span class="hljs-comment">/// <span class="markdown">APP 首页入口</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 本模块函数，加载状态类组件HomePageState</span></span>\n<span class="hljs-comment">/// <span class="markdown">[prefix]是显示在时间之前的一个字符串</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageState();\n}\n<span class="hljs-comment">/// <span class="markdown">首页有状态组件类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 主要是获取当前时间，并动态展示当前时间</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePage</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">展示当前时间字符串</span></span>\n  <span class="hljs-built_in">String</span> currentTimeStr;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    <span class="hljs-keyword">this</span>.currentTimeStr = getCurrentTime();\n    refreshTimeStr();\n  }\n  <span class="hljs-comment">/// <span class="markdown">更新当前时间字符串 [currentTimeStr]</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// 每 500ms 更新一次，使用 Timer</span></span>\n  <span class="hljs-keyword">void</span> refreshTimeStr() {\n    <span class="hljs-keyword">const</span> period = <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">500</span>);\n    <span class="hljs-comment">// 定时更新当前时间的 currentTimeStr 字符串</span>\n    Timer.periodic(period, (timer) {\n      setState(() {\n        <span class="hljs-keyword">this</span>.currentTimeStr = getCurrentTime();\n      });\n    });\n  }\n  <span class="hljs-comment">/// <span class="markdown">获取当前时间戳</span></span>\n  <span class="hljs-comment">///\n  <span class="markdown">/// 返回一个字符串类型的前缀信息：时间戳</span></span>\n  <span class="hljs-built_in">String</span> getCurrentTime() {\n    <span class="hljs-built_in">DateTime</span> now = <span class="hljs-built_in">DateTime</span>.now();\n    <span class="hljs-keyword">var</span> formatter = DateFormat(<span class="hljs-string">\'yy-MM-dd hh:mm:ss\'</span>);\n    <span class="hljs-keyword">return</span> formatter.format(now);\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<h4 data-nodeid="110891">步骤五：build 中显示组件内容</h4>\n<p data-nodeid="110892">build 中展示当前时间的 state 值，以及一个前缀信息。由于前缀是一个无状态变量，因此我们尽量将该变量放在 StatefulWidget 类中。这里在 build 中使用了一个新的布局组件 Column ，目前你暂时可以不关注这个组件，只需要了解其是布局组件即可，代码如下。</p>\n<pre data-nodeid="110893"><code>import \'dart:async\';\nimport \'package:flutter/material.dart\';\nimport \'package:intl/intl.dart\'; // 需要在 pubspec.yaml 增加该模块\n/// App 首页入口\n///\n/// 本模块函数，加载状态类组件 HomePageState\n/// [prefix]是显示在时间之前的一个字符串\nclass HomePage extends StatefulWidget {\n  /// 当前时间显示的前缀信息\n  final String prefix = \'当前时间\';\n  @override\n  createState() =&gt; HomePageState();\n}\n/// 首页有状态组件类\n///\n/// 主要是获取当前时间，并动态展示当前时间\nclass HomePageState extends State&lt;HomePage&gt; {\n  /// 展示当前时间字符串\n  String currentTimeStr;\n  @override\n  void initState() {\n    super.initState();\n    this.currentTimeStr = getCurrentTime();\n    refreshTimeStr();\n  }\n  /// 更新当前时间字符串 [currentTimeStr]\n  ///\n  /// 每 500ms 更新一次，使用 Timer\n  void refreshTimeStr() {\n    const period = Duration(milliseconds: 500);\n    // 定时更新当前时间的 currentTimeStr 字符串\n    Timer.periodic(period, (timer) {\n      setState(() {\n        this.currentTimeStr = getCurrentTime();\n      });\n    });\n  }\n  /// 获取当前时间戳\n  ///\n  /// 返回一个字符串类型的前缀信息：时间戳\n  String getCurrentTime() {\n    DateTime now = DateTime.now();\n    var formatter = DateFormat(\'yy-MM-dd hh:mm:ss\');\n    return formatter.format(now);\n  }\n  /// 有状态类返回组件信息\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: &lt;Widget&gt;[Text(widget.prefix), Text(this.currentTimeStr)],\n    );\n  }\n}\n</code></pre>\n<h4 data-nodeid="110894">步骤六：main.dart 中加载 HomPage 组件</h4>\n<p data-nodeid="110895">最后我们需要在 main.dart 中应用该组件，代码如下。</p>\n<pre class="lang-dart" data-nodeid="110896"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/home_page.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">App 核心入口文件</span></span>\n<span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());\n<span class="hljs-comment">/// <span class="markdown">MyApp 核心入口界面</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> MaterialApp(\n        title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字</span>\n        theme: ThemeData(\n          primarySwatch: Colors.blue, <span class="hljs-comment">// APP 主题</span>\n        ),\n        home: Scaffold(\n            appBar: AppBar(\n              title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n            ),\n            body: Column(\n              children: &lt;Widget&gt;[\n                HomePage(),\n              ],\n            )\n        ));\n  }\n}\n</code></pre>\n<h4 data-nodeid="110897">步骤七：代码美化和规范检查，并运行程序</h4>\n<p data-nodeid="110898">现在我们将代码实现完成了，需要使用我们 04 课时的知识来进行美化代码和检查代码是否规范，我们可以将美化和代码规范检查的两个命令写出一个 shell 脚本，每次只需要运行这个 shell 脚本（ format_check.sh ）检查即可，代码如下。</p>\n<pre class="lang-powershell" data-nodeid="110899"><code data-language="powershell"><span class="hljs-comment"># 代码美化</span>\ndartfmt <span class="hljs-literal">-w</span> -<span class="hljs-literal">-fix</span> lib/\n<span class="hljs-comment"># 代码规范检查</span>\ndartanalyzer lib\n</code></pre>\n<p data-nodeid="110900">接下来，每次运行前执行该脚本检查。</p>\n<pre class="lang-powershell" data-nodeid="110901"><code data-language="powershell">sh format_check.sh\n</code></pre>\n<p data-nodeid="110902">检查后，如果有问题则修复，没有问题，再选择手机模拟器运行该项目，既可以看到如下图 2 动态效果了。</p>\n<p data-nodeid="110903"><img src="https://s0.lgstatic.com/i/image/M00/26/D4/CgqCHl7zAWyAf3hFAAt1uKBbpwY045.gif" alt="20200610_140500-2.gif" data-nodeid="111063"><br>\n图 2 增加动态时间显示</p>\n<h3 data-nodeid="110904">总结</h3>\n<p data-nodeid="110905">本课时主要介绍了组件中的有状态组件和无状态组件，关于有状态组件则介绍了其各个生命周期函数的执行场景以及实际触发的应用场景。最后再通过有状态组件优化我们之前的时间展示的小功能。学完本课时后，你需要掌握如何实现有状态组件，并了解有状态组件中各个生命周期函数被触发的时机。</p>\n<p data-nodeid="110906">以上就是本课时的主要内容，下一课时介绍有状态组件和无状态组件应用场景，以及如何区分使用有状态组件和无状态组件。</p>\n<p data-nodeid="110907"><a href="https://github.com/love-flutter/flutter-column" data-nodeid="111071">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '06 | 有/无状态组件：如何巧妙地应用 Flutter 有/无状态组件',
            id: 38,
            content:
              '<h3 data-nodeid="14704" class="">无/有状态组件</h3>\n<p data-nodeid="14705">由于无状态组件在执行过程中只有一个 build 阶段，在执行期间只会执行一个 build 函数，没有其他生命周期函数，因此在执行速度和效率方面比有状态组件更好。所以在设计组件时，不要任何组件都使用有状态组件进行开发，要根据实际分析情况使用。</p>\n<h4 data-nodeid="14706">Flutter 中基础组件介绍</h4>\n<p data-nodeid="14707">Flutter 内部包含一些基础的无状态组件，在组件设计的时候，需要对基础组件有一定认识。本课时所使用的 Flutter 基础组件（这里我只简单介绍本课时所使用的组件，更多组件请参考<a href="https://flutterchina.club/widgets/" data-nodeid="14821">官网文档</a>）包括：</p>\n<ul data-nodeid="14708">\n<li data-nodeid="14709">\n<p data-nodeid="14710">Text，文本显示组件，里面包含了文本类相关的样式以及排版相关的配置信息；</p>\n</li>\n<li data-nodeid="14711">\n<p data-nodeid="14712">Image，图片显示组件，里面包含了图片的来源设置，以及图片的配置；</p>\n</li>\n<li data-nodeid="14713">\n<p data-nodeid="14714">Icon，Icon 库，里面是 Flutter 原生支持的一些小的 icon ；</p>\n</li>\n<li data-nodeid="14715">\n<p data-nodeid="14716">FlatButton，包含点击动作的组件；</p>\n</li>\n<li data-nodeid="14717">\n<p data-nodeid="14718">Row，布局组件，在水平方向上依次排列组件；</p>\n</li>\n<li data-nodeid="14719">\n<p data-nodeid="14720">Column，布局组件，在垂直方向上依次排列组件；</p>\n</li>\n<li data-nodeid="14721">\n<p data-nodeid="14722">Container，布局组件，容器组件，这点有点类似于前端中的 body ；</p>\n</li>\n<li data-nodeid="14723">\n<p data-nodeid="14724">Expanded，可以按比例“扩伸” Row、Column 和 Flex 子组件所占用的空间 ，这点就是前端所介绍的 flex 布局设计；</p>\n</li>\n<li data-nodeid="14725">\n<p data-nodeid="14726">Padding，可填充空白区域组件，这点和前端的 padding 功能基本一致；</p>\n</li>\n<li data-nodeid="14727">\n<p data-nodeid="14728">ClipRRect，圆角组件，可以让子组件有圆形边角。</p>\n</li>\n</ul>\n<p data-nodeid="14729">以上组件的具体使用以及参数配置，在<a href="https://flutterchina.club/widgets/" data-nodeid="14836">官网</a>中有具体说明。</p>\n<h4 data-nodeid="14730">组件组合要点</h4>\n<p data-nodeid="14731">Flutter 功能的开发，可以总结为将基础组件组合并赋予一些交互行为的过程，因此需要掌握组件组合的一些要点。</p>\n<p data-nodeid="14732">由于动态组件和静态组件的特点，因此在组合的时候要非常注意，动态组件下的子组件如果过多，则在组件更新的时候，会导致其子组件的全部更新，从而引发性能问题。因此在组件组合的时候需要有一些避免的规则来参考，下面这几点是我自己整理的一套原则。</p>\n<ol data-nodeid="14733">\n<li data-nodeid="14734">\n<p data-nodeid="14735">尽可能减少动态组件下的静态组件；</p>\n</li>\n<li data-nodeid="14736">\n<p data-nodeid="14737">数据来源相同的部分组合为同一组件；</p>\n</li>\n<li data-nodeid="14738">\n<p data-nodeid="14739">使用行或者列作为合并的条件；</p>\n</li>\n<li data-nodeid="14740">\n<p data-nodeid="14741">功能相同的部分，转化为基础组件；</p>\n</li>\n<li data-nodeid="14742">\n<p data-nodeid="14743">合并后根节点的为 Container。</p>\n</li>\n</ol>\n<h3 data-nodeid="14744">组件设计</h3>\n<p data-nodeid="14745">当 UI 提供一个交互过来以后，我们要用一套标准的流程来设计组件，减少主观上不合理的设计，接下来主要介绍下我整理的那一套原则。</p>\n<p data-nodeid="14746">例如我们现在需要设计一个图 1 的主界面，其次可以进行点赞操作，点赞完成后数字增加 1 。</p>\n<p data-nodeid="14747"><img src="https://s0.lgstatic.com/i/image/M00/26/C9/Ciqc1F7zAciAV3kHAAsOqdx9yX8344.png" alt="image (10).png" data-nodeid="14851"><br>\n图 1 Two You 的首页推荐界面</p>\n<h4 data-nodeid="14748">界面分析</h4>\n<p data-nodeid="14749">将设计方案分为以下几个过程：</p>\n<ol data-nodeid="14750">\n<li data-nodeid="14751">\n<p data-nodeid="14752">标记所有界面元素（ Flutter 基础组件），按照数字进行标记，请注意明显相似部分不需要标记；</p>\n</li>\n<li data-nodeid="14753">\n<p data-nodeid="14754">记录相应数字对应的组件名称，并命名展示数据的参数名；</p>\n</li>\n<li data-nodeid="14755">\n<p data-nodeid="14756">标记需要交互和数据变化的数据；</p>\n</li>\n<li data-nodeid="14757">\n<p data-nodeid="14758">将数字和数据合成一个最小组件，并标记组件是有或无状态组件；</p>\n</li>\n<li data-nodeid="14759">\n<p data-nodeid="14760">将第 4 步中的最小组件进行合并，组件组合规则，请参照上面介绍到的“组件组合要点”；</p>\n</li>\n<li data-nodeid="14761">\n<p data-nodeid="14762">完成组件合并后，绘制一张组件图，再次分析动态组件下的静态组件是否合理，如果能拆分尽量拆分。</p>\n</li>\n</ol>\n<p data-nodeid="14763">按照这 6 个步骤我们就可以实现一个界面的组件分析，接下来我们按照图 1 中的界面以及这 6 个步骤实践组件设计。</p>\n<h4 data-nodeid="14764">实践设计</h4>\n<p data-nodeid="14765">第一步：<strong data-nodeid="14869">标记界面元素</strong>，标记效果如图 2 所示：</p>\n<p data-nodeid="14766"><img src="https://s0.lgstatic.com/i/image/M00/26/C9/Ciqc1F7zAdOAel6TAAtwHZn7wQw909.png" alt="image (11).png" data-nodeid="14872"><br>\n图 2 组件标记</p>\n<p data-nodeid="14767">第二步：记录<strong data-nodeid="14884">组件名称以及组件数据</strong>，以及<strong data-nodeid="14885">标记动态数据</strong>，我们使用下面的表格 1 来处理，并且将每个小组件命名好。</p>\n<p data-nodeid="14768"><img src="https://s0.lgstatic.com/i/image/M00/26/C9/Ciqc1F7zAemAA3hwAACRl_hUd40759.png" alt="image (12).png" data-nodeid="14888"><br>\n表格 1 组件标记结果</p>\n<p data-nodeid="14769">第三步：<strong data-nodeid="14896">组件合并</strong>，主要是将功能一致的组件进行合并，上面的组件中，5 和 6 属于头像信息合并为一个最小组件，7 和 8 为帖子信息合并，9 和 10 为点赞信息合并。</p>\n<p data-nodeid="14770" class="">第四部：<strong data-nodeid="14902">创建组件树</strong>，1 由于是单独的一列，因此我们单独一个组件。2 和 3 以及 4 为同一行组件，因此可以合并为一个 Row 组件。然后 2 和 3 垂直排列，组合为一个 Column 组件。5、6、7、8、9、10 都在同一行，因此合并为一个组件。2、3、4、5、6、7、8、9、10 由于存在重复部分，因此合并为一个大的 Row 组件。根据上面的结论，我们绘制组件树如图 3 所示。</p>\n<p data-nodeid="16073"><img src="https://s0.lgstatic.com/i/image/M00/31/5D/CgqCHl8MPo6AfA-wAACs_VZfuQw592.png" alt="5.png" data-nodeid="16076"><br>\n图 3 组件树</p>\n\n\n\n\n<p data-nodeid="14772">图 3 中的黄色背景的表示动态组件，由于 9 和 10 组成的是最小组件，因此将 9 和 10 作为一个动态组件。所有的叶子节点上都是我们第一步所标记的基础组件，完成后看是否满足我们的设计规则。可以看到动态组件只有一个，在右下角的 Row 中，而该动态组件下只有最小的组件组合，因此是满足我们的设计要求。但为了减少动态组件 10 因状态改变而影响的范围，我们可以将 5、6、7、8 合 并为一个新的组件，将 9 和 10 单独作为一个组件，如图 4 所示。</p>\n<p data-nodeid="17717"><img src="https://s0.lgstatic.com/i/image/M00/31/5D/CgqCHl8MPp2AZhKfAADFimfXDyg939.png" alt="6.png" data-nodeid="17720"><br>\n图 4 优化后的组件设计图</p>\n\n\n\n\n<p data-nodeid="14774">这样就完成了组件的分析和设计，按照这种方式，我们再实现其中的组件代码，完成界面效果。接下来我们将组件进行命名，将表格 1 根据上图的设计重新修改下，如表格 2 。</p>\n<p data-nodeid="14775"><img src="https://s0.lgstatic.com/i/image/M00/26/C9/Ciqc1F7zAgaAJ59xAABi3IF6Ycw572.png" alt="image (15).png" data-nodeid="14917"><br>\n表格 2 最终组件设计结构</p>\n<p data-nodeid="14776">接下来我们就使用代码去实现这部分功能。</p>\n<h3 data-nodeid="14777">综合实践</h3>\n<p data-nodeid="14778">根据表格 2 的设计结构，我们先将目录层级结构，以及相应目录下的文件创建好。因为在表格中，组件都已经命名好了，所以创建就比较简单，如图 5 所示的目录结构。图 5 中的 struct 用来做数据结构描述，类似 TypeScript 中的 interface 作用，避免因为数据结构问题导致的异常。</p>\n<p data-nodeid="14779"><img src="https://s0.lgstatic.com/i/image/M00/26/C9/Ciqc1F7zAg2AAeVzAACV_ulkeyM179.png" alt="image (16).png" data-nodeid="14925"><br>\n图 5 组件目录结构</p>\n<p data-nodeid="14780">接下来我先从底层组件依次实现，其次将组件的数据都作为参数传递进来即可。下面的代码，我只介绍核心部分，其他代码大家可以参考 Github 中的 06 课时源码。</p>\n<h4 data-nodeid="14781">基础组件</h4>\n<p data-nodeid="14782">下面我们主要看几个核心的组件实现。</p>\n<p data-nodeid="14783"><strong data-nodeid="14938">article_like_bar</strong></p>\n<p data-nodeid="14784">该组件包括点赞数动态变量的声明以及点赞行为（点赞行为中触发的逻辑是，增加点赞数 state 的值）两部分内容，具体代码实现如下：</p>\n<pre class="lang-dart" data-nodeid="14785"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">帖子文章的赞组件</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 包括点赞组件 icon ，以及组件点击效果</span></span>\n<span class="hljs-comment">/// <span class="markdown">需要外部参数[likeNum],点赞数量</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleLikeBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">外部传入参数</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> likeNum;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> ArticleLikeBar({Key key, <span class="hljs-keyword">this</span>.likeNum}) : <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; ArticleLikeBarState();\n}\n<span class="hljs-comment">/// <span class="markdown">帖子d文章的赞组件的状态管理类</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 内部包括组件的点赞效果，点击后触发数字更新操作</span></span>\n<span class="hljs-comment">/// <span class="markdown">[likeNum] 为状态组件可变数据</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleLikeBarState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">ArticleLikeBar</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">状态 state</span></span>\n  <span class="hljs-built_in">int</span> likeNum;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    likeNum ??= widget.likeNum;\n  }\n  <span class="hljs-comment">/// <span class="markdown">点赞动作效果，点击后[likeNum]加1</span></span>\n  <span class="hljs-keyword">void</span> like() {\n    setState(() {\n      likeNum = ++likeNum;\n    });\n  }\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Row(\n      children: &lt;Widget&gt;[\n        Icon(Icons.thumb_up, color: Colors.grey, size: <span class="hljs-number">18</span>),\n        Padding(padding: EdgeInsets.only(left: <span class="hljs-number">10</span>)),\n        FlatButton(\n          child: Text(<span class="hljs-string">\'<span class="hljs-subst">$likeNum</span>\'</span>),\n          onPressed: () =&gt; like(),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="14786">学到本课时，除了 build 中的部分代码比较陌生，其他部分的代码应该是非常熟悉的，因此这里简单介绍了 build 中的逻辑。build 中使用了 Row 布局组件，然后包含了三个最基础组件：Icon、Padding 和 FlatButton ，而 FlatButton 中又包含了基础组件 Text ，总结下 build 主要是完成界面组件组合以及增加组件交互行为这两方面的逻辑。</p>\n<h4 data-nodeid="14787">二级组件</h4>\n<p data-nodeid="14788">上面介绍了一个一级组件的代码，我们再来看一个二级组件 article_card 的代码实现，在表格 2 中，可以看到其需要引入三个一级组件，因此在头部需要引入代码如下：</p>\n<pre class="lang-dart" data-nodeid="14789"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/article_summary_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/user_info_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_bottom_bar.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_like_bar.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_summary.dart\'</span>;\n</code></pre>\n<p data-nodeid="14790">第 1 行是 Flutter 基础组件，第 3 和 4 行是我们上面介绍的数据结构描述类库，第 6、7 和 8 行 则是三个一级组件的库。</p>\n<p data-nodeid="14791">因为 article_card 是一个静态组件，所以只需要继承 StatelessWidget 。接下来实现 build 方法，由于子组件需要用户信息和帖子信息，所以该组件包含两个参数。</p>\n<pre class="lang-dart" data-nodeid="14792"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">此为帖子描述类，包括了帖子UI中的所有元素</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">传入的用户信息</span></span>\n  <span class="hljs-keyword">final</span> UserInfoStruct userInfo;\n  <span class="hljs-comment">/// <span class="markdown">传入的帖子信息</span></span>\n  <span class="hljs-keyword">final</span> ArticleSummaryStruct articleInfo;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> ArticleCard({Key key, <span class="hljs-keyword">this</span>.userInfo, <span class="hljs-keyword">this</span>.articleInfo})\n      : <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<p data-nodeid="14793">上面代码中的第 3 到 10 行是定义无状态类的参数以及构造函数，接下来我们看看 build 函数的实现，代码如下：</p>\n<pre class="lang-dart" data-nodeid="14794"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-keyword">return</span> Column(\n    children: &lt;Widget&gt;[\n      ArticleSummary(\n          title: articleInfo.title,\n          summary: articleInfo.summary,\n          articleImage: articleInfo.articleImage),\n      Row(\n        children: &lt;Widget&gt;[\n          ArticleBottomBar(\n              nickname: userInfo.nickname,\n              headerImage: userInfo.headerImage,\n              commentNum: articleInfo.commentNum),\n          ArticleLikeBar(likeNum: articleInfo.likeNum),\n        ],\n      ),\n    ],\n  );\n}\n</code></pre>\n<p data-nodeid="14795">UI 稿中包含两部分内容展示，第一部分是帖子的概要信息，第二部分是帖子的相关作者以及点赞评论信息，因此可以使用垂直组件 Column ，竖着排列这两部分内容。由于在状态栏这一行中又包含有作者信息和评论点赞信息，因此使用 Row 组件包裹两个一级组件 ArticleBottomBar 和 ArticleLikeBar 。这样就完成了该组件无状态类组件的设计，我们看下整个代码实现。</p>\n<pre class="lang-dart" data-nodeid="14796"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/article_summary_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/user_info_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_bottom_bar.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_like_bar.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_summary.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">此为帖子描述类，包括了帖子UI中的所有元素</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">传入的用户信息</span></span>\n  <span class="hljs-keyword">final</span> UserInfoStruct userInfo;\n  <span class="hljs-comment">/// <span class="markdown">传入的帖子信息</span></span>\n  <span class="hljs-keyword">final</span> ArticleSummaryStruct articleInfo;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> ArticleCard({Key key, <span class="hljs-keyword">this</span>.userInfo, <span class="hljs-keyword">this</span>.articleInfo})\n      : <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Column(\n      children: &lt;Widget&gt;[\n        ArticleSummary(\n            title: articleInfo.title,\n            summary: articleInfo.summary,\n            articleImage: articleInfo.articleImage),\n        Row(\n          children: &lt;Widget&gt;[\n            ArticleBottomBar(\n                nickname: userInfo.nickname,\n                headerImage: userInfo.headerImage,\n                commentNum: articleInfo.commentNum),\n            ArticleLikeBar(likeNum: articleInfo.likeNum),\n          ],\n        ),\n      ],\n    );\n  }\n}\n</code></pre>\n<h4 data-nodeid="14797">页面组件</h4>\n<p data-nodeid="14798">其他组件的开发方式按照上面一个无状态组件和一个有状态组件的方式开发即可，最后再看下页面组件 home_page.dart ，因为这是一个静态组件页面，所以相对较为简单，代码如下：</p>\n<pre class="lang-dart" data-nodeid="14799"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/article_summary_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/user_info_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/common/banner_info.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_card.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">首页列表信息</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 展示banner和帖子信息</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">banner 地址信息</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> bannerImage =\n      <span class="hljs-string">\'https://img.089t.com/content/20200227/osbbw9upeelfqnxnwt0glcht.jpg\'</span>;\n  <span class="hljs-comment">/// <span class="markdown">帖子标题</span></span>\n  <span class="hljs-keyword">final</span> UserInfoStruct userInfo = UserInfoStruct(<span class="hljs-string">\'flutter\'</span>,\n      <span class="hljs-string">\'https://i.pinimg.com/originals/1f/00/27/1f0027a3a80f470bcfa5de596507f9f4.png\'</span>);\n  <span class="hljs-comment">/// <span class="markdown">帖子概要描述信息</span></span>\n  <span class="hljs-keyword">final</span> ArticleSummaryStruct articleInfo = ArticleSummaryStruct(\n      <span class="hljs-string">\'你好，交个朋友\'</span>,\n      <span class="hljs-string">\'我是一个小可爱\'</span>,\n      <span class="hljs-string">\'https://i.pinimg.com/originals/e0/64/4b/e0644bd2f13db50d0ef6a4df5a756fd9.png\'</span>,\n      <span class="hljs-number">20</span>,\n      <span class="hljs-number">30</span>);\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Container(\n      child: Column(\n        children: &lt;Widget&gt;[\n          BannerInfo(bannerImage: bannerImage),\n          ArticleCard(\n            userInfo: userInfo,\n            articleInfo: articleInfo,\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>\n<ul data-nodeid="14800">\n<li data-nodeid="14801">\n<p data-nodeid="14802">import 库，import 库包括 Flutter 基础库，两个数据结构类定义库，以及 banner 组件和 articile_card 库；</p>\n</li>\n<li data-nodeid="14803">\n<p data-nodeid="14804">初始化几个本次测试需要的数据，banner 数据、userInfo 数据和 article 内容数据；</p>\n</li>\n<li data-nodeid="14805">\n<p data-nodeid="14806">build 返回组件内容，使用 Column 垂直排列 banner 组件和 article 组件。</p>\n</li>\n</ul>\n<p data-nodeid="14807">以上就实现了该组件的所有功能点，首先还是运行代码检查工具，使用下面的运行命令。</p>\n<pre class="lang-plain" data-nodeid="14808"><code data-language="plain">sh format_check.sh\n</code></pre>\n<p data-nodeid="14809">确认代码无误后，再打开手机模拟器，运行程序，即可看到图 6 的界面效果。</p>\n<p data-nodeid="14810"><img src="https://s0.lgstatic.com/i/image/M00/26/CA/Ciqc1F7zAi6AIamAAAnwMrGReX8255.png" alt="image (17).png" data-nodeid="14964"><br>\n图 6 应用运行效果</p>\n<h3 data-nodeid="14811">总结</h3>\n<p data-nodeid="14812">本课时介绍了有无状态组件的一些特点以及在组件设计选择的时候需要注意的规则，接下来实践了组件设计的方法。学完本课时你应该掌握界面的组件设计思想，并根据组件设计实现具体的交互界面。</p>\n<p data-nodeid="14813">以上就是本课时的所有内容，下一课时我将介绍 Flutter 中有状态组件的状态管理，学完本课时以及下一课时，你将可以掌握复杂的交互界面开发技巧。</p>\n<p data-nodeid="14814" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="14972">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '07 | 状态管理：Flutter 状态管理及对比选型',
            id: 39,
            content:
              '<p data-nodeid="25201" class="">上一课时我详细介绍了有/无状态组件的应用设计，但是在设计过程中，还缺乏一个对状态管理的考虑。本课时介绍状态管理设计的必要性，以及一些常见的状态管理技术对比，最后再着重通过 Provider 来优化前一课时中的例子。</p>\n<h3 data-nodeid="25202">状态管理场景</h3>\n<p data-nodeid="25203">上一课时的例子中，只涉及一个有状态的组件 article_like_bar ，接下来我们需要实现另外一个详情页面，并且在详情页面中也需要一个点赞功能，具体的界面效果可以参考动图 1 （为了界面更好，我在上一课时的基础上增加了一些样式）。</p>\n<p data-nodeid="25204"><img src="https://s0.lgstatic.com/i/image/M00/2A/89/CgqCHl78dduAVpypABtxqF5qwAA906.gif" alt="20200620_110314.gif" data-nodeid="25335"><br>\n图 1 增加二级点赞详情页面效果</p>\n<p data-nodeid="25205">在上面的动图例子中，你是否发现了一个问题？第一个页面的点赞数与第二个页面的点赞数并不同步。在实际项目开发过中，需求方希望二级详情页面的点赞数能与第一个页面的点赞数同步。</p>\n<p data-nodeid="25206">如果不引入新的技术方案，能想到的办法就是将该状态进行提升，放到其共同的父节点上，然后将父节点设计为有状态组件，并提供修改状态的方法给到子组件。可以用图 2 来表示。</p>\n<p data-nodeid="25207"><img src="https://s0.lgstatic.com/i/image/M00/2A/7D/Ciqc1F78dfGARKuUAACYOe66MlY026.png" alt="Drawing 1.png" data-nodeid="25342"></p>\n<p data-nodeid="25208">图 2 状态提升共享方式</p>\n<p data-nodeid="25209">上面的方式是可以做到这点，但是你有没有发现，只因为一个点赞行为，就需要将两个页面的所有组件（静态组件和动图组件）进行重新 build ，成本实在太高，这也违背了我们上一课时的组件设计原则（尽可能减少动态组件下的静态组件）。为了更好地解决这个问题，我们就需要引入一些状态管理的方法，下面就介绍一些常见的技术方案，同时做一个对比。</p>\n<h3 data-nodeid="25210">状态选型对比</h3>\n<p data-nodeid="25211">状态管理技术不少于 10 种，但是为了高效，我只介绍其中比较核心的三个，第一个是原生所使用的 InheritedWidget ；第二个是相对前端同学比较熟悉的 Redux 技术；最后一个则是我们推荐使用的技术 Provider 。</p>\n<h4 data-nodeid="25212">InheritedWidget</h4>\n<p data-nodeid="25213">InheritedWidget 核心原理和状态提升原理一致，将 likeNum 提升到根节点，但不需要一层层地将变量传递下去，只需要在根节点声明即可。</p>\n<p data-nodeid="25214">现在我们有一个页面，页面下有两个组件，两个组件都需要用同一个名字，并且第二个组件的名字可以点击切换随机名字，而切换以后需要及时更新第一个组件中的名字。页面效果如图 3 所示。</p>\n<p data-nodeid="25215"><img src="https://s0.lgstatic.com/i/image/M00/2A/89/CgqCHl78diqALC0dAACKe0B0HjU731.png" alt="Drawing 3.png" data-nodeid="25352"><br>\n图 3 多组件状态共享效果</p>\n<p data-nodeid="25216">按照上面介绍的例子以及上一课时的知识点，画一个简单的组件树，并且附带上需要的状态属性，如图 4 所示。</p>\n<p data-nodeid="25217"><img src="https://s0.lgstatic.com/i/image/M00/2A/7D/Ciqc1F78djSAUVqwAACHGNkmeCM922.png" alt="Drawing 4.png" data-nodeid="25358"><br>\n图 4 InheritedWidget 组件设计</p>\n<ul data-nodeid="25218">\n<li data-nodeid="25219">\n<p data-nodeid="25220">首先创建一个根结点为一个有状态组件 name_game；</p>\n</li>\n<li data-nodeid="25221">\n<p data-nodeid="25222">name_game 为一个有状态类，状态属性为 name，并带有 changName 的状态修改方法；</p>\n</li>\n<li data-nodeid="25223">\n<p data-nodeid="25224">创建一个状态管理类组件 NameInheritedWidget ；</p>\n</li>\n<li data-nodeid="25225">\n<p data-nodeid="25226">创建 NameInheritedWidget 的三个子组件，分别为 welcome（显示欢迎 name ）、random_name（显示 name ，并且有点击切换随机 name 操作）和 other_widgets 。</p>\n</li>\n</ul>\n<p data-nodeid="25227"><strong data-nodeid="25379">对于上面的结构，肯定有很多同学比较疑惑，other_widgets 并没有使用这个 name 状态，为什么要在 NameInheritedWidget 下呢</strong>？</p>\n<p data-nodeid="25228">带着这样的疑惑，我们先来看下 name_game 核心代码（为了在专栏中更简洁，我省去了部分代码，完整代码大家可以参考文章下的 github 代码地址）。</p>\n<pre class="lang-dart" data-nodeid="25229"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">随机名字游戏组件状态管理类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameGameState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">NameGame</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">name 状态</span></span>\n  <span class="hljs-built_in">String</span> name;\n  <span class="hljs-comment">/// <span class="markdown">构造函数参数，避免父组件状态变化，而引起的子组件的重 build 操作</span></span>\n  Widget child;\n  <span class="hljs-comment">/// <span class="markdown">修改当前名字</span></span>\n  <span class="hljs-keyword">void</span> changeName() {\n    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; nameList = [<span class="hljs-string">\'flutter one\'</span>, <span class="hljs-string">\'flutter two\'</span>, <span class="hljs-string">\'flutter three\'</span>];\n    <span class="hljs-built_in">int</span> pos = Random().nextInt(<span class="hljs-number">3</span>);\n    setState(() {\n      name = nameList[pos];\n    });\n  }\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    setState(() {\n      name = <span class="hljs-string">\'test flutter\'</span>;\n    });\n    <span class="hljs-keyword">super</span>.initState();\n  }\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  NameGameState()\n  {\n    child = Column (\n        children: &lt;Widget&gt;[\n          Welcome(),\n          RandomName(),\n          TestOther(),\n        ]\n    );\n  }\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Column(\n      children: &lt;Widget&gt;[\n        NameInheritedWidget(\n            child: child,\n            onNameChange: changeName,\n            name: name\n        ),\n      ],\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25230">上面代码中，定义状态属性 name ，并创建了可以修改 state 的 changeName 方法。接下来在 build 中使用 NameInheritedWidget 这个组件（该组件可以理解为前端所说的高阶组件，也就是通过将组件作为参数传递进该组件，并返回一个新的组件的功能组件），这个组件包裹了两个需要状态 name 的组件（ Welcome 和 RandomName ）以及一个不需要状态的 TestOther。</p>\n<p data-nodeid="25231">上面代码中还有一个比较特殊的地方，就是将 child 作为了 state ，在构造函数中进行了定义，并将该组件的所有子组件都包含在了 child 中。具体什么原因，大家可以继续往下学习。</p>\n<p data-nodeid="25232">接下来我们看一下 NameInheritedWidget 的实现逻辑，代码如下：</p>\n<pre class="lang-dart" data-nodeid="25233"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">定义一个name共享父组件</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameInheritedWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">共享状态</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;\n  <span class="hljs-comment">/// <span class="markdown">修改共享状态方法</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Function</span> onNameChange;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  NameInheritedWidget({\n    Key key,\n    <span class="hljs-meta">@required</span> Widget child,\n    <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.name,\n    <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.onNameChange,\n  }) : <span class="hljs-keyword">super</span>(key: key, child: child);\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-built_in">bool</span> updateShouldNotify(NameInheritedWidget old) =&gt;\n      name != old.name;\n}\n</code></pre>\n<p data-nodeid="25234">主要是接受两个参数， name 和 onNameChange 方法，并且有一个判断函数 updateShouldNotify 。前面两个参数不用介绍，关键在于 updateShouldNotify ，这个判断函数的作用就是上面大家的疑惑点。<br>\n如果将 TestOther 不作为该子组件，那么根据我们之前了解到的知识点，由于 setState 会触发父组件 NameGame 的更新，而子组件会因为父组件的更新，则会引发执行 build 操作。</p>\n<p data-nodeid="25235">如果 TestOther 是 NameInheritedWidget 的子组件，那么在执行 setState 后，NameInheritedWidget 会判断状态是否有状态变化，还会判断子组件是否有依赖该 name 状态，从而就保证了两点：</p>\n<ol data-nodeid="25236">\n<li data-nodeid="25237">\n<p data-nodeid="25238">状态变化时，如果未使用该状态子组件，则不会发生 build；</p>\n</li>\n<li data-nodeid="25239">\n<p data-nodeid="25240">使用了该状态组件，如果组件的状态没有发生变化，也不会发生 build。</p>\n</li>\n</ol>\n<p data-nodeid="25241">这两点就非常好地保护了我们刚开始提到的问题，因为有状态父组件的更新，而导致全部子节点的 build 操作。<strong data-nodeid="25397">这里要非常注意，需要使用 NameGameState 方法来封装组件，如果该子组件直接写在 build 中的 child 方法中，就无法利用 NameInheritedWidget 优点，这点大家要特别注意</strong>。</p>\n<p data-nodeid="25242">最后我们再来看下子组件如何利用 name 和 onNameChange 这两个值，我们可以看下 RandomName 组件，代码如下：</p>\n<pre class="lang-dart" data-nodeid="25243"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/inherited_widget/name_inherited_widget.dart\'</span>;\n\n<span class="hljs-comment">/// <span class="markdown">随机展示人名</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name = (\n        context.inheritFromWidgetOfExactType(NameInheritedWidget)\n        <span class="hljs-keyword">as</span> NameInheritedWidget).name;\n    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Function</span> changeName = (\n        context.inheritFromWidgetOfExactType(NameInheritedWidget)\n        <span class="hljs-keyword">as</span> NameInheritedWidget).onNameChange;\n    <span class="hljs-keyword">return</span> FlatButton(\n      child: Text(name),\n      onPressed: () =&gt; changeName(),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25244">上面代码中可以看到，是通过以下方式来获得 InheritedWidget 对象中的方法和属性。</p>\n<pre class="lang-dart" data-nodeid="25245"><code data-language="dart">context.inheritFromWidgetOfExactType(NameInheritedWidget) <span class="hljs-keyword">as</span> NameInheritedWidget)\n</code></pre>\n<p data-nodeid="25246">总结下 InheritedWidget 实现状态管理的要点：</p>\n<ol data-nodeid="26093">\n<li data-nodeid="26094">\n<p data-nodeid="26095">状态提升，将需要共享的状态提升到共同且最近的一个父节点，并使用 InheritedWidget 来管理；</p>\n</li>\n<li data-nodeid="26096">\n<p data-nodeid="26097">该父节点上，将所有子节点作为该节点状态管理类的一个构造函数参数，并且传递给 InheritedWidget；</p>\n</li>\n<li data-nodeid="26098">\n<p data-nodeid="26099" class="">子节点通过 inheritFromWidgetOfExactType 的方法来获取状态管理类 InheritedWidget 中的属性以及方法。</p>\n</li>\n</ol>\n\n\n<h4 data-nodeid="25254">Redux</h4>\n<p data-nodeid="25255">由于 Redux 在前端是一个比较常用的状态管理技术解决方案，因此这里简单介绍一下，不过在 Flutter 中 ，Redux 并非第一选择。Redux 核心思想是单向数据流架构，将所有的状态存储在 store 中，所有数据改变都是通过 Action ，然后 Action 触发 store 存储，store 变化触发所有应用该状态的组件的 build 操作。为了实现效果，我们也同样使用上面的例子，步骤如下：</p>\n<ol data-nodeid="25256">\n<li data-nodeid="25257">\n<p data-nodeid="25258">因为是第三方库，因此需要在 pubspec.yaml 增加依赖；</p>\n</li>\n<li data-nodeid="25259">\n<p data-nodeid="25260">实现 state 管理中心；</p>\n</li>\n<li data-nodeid="25261">\n<p data-nodeid="25262">创建相应的 Action ，触发状态变化；</p>\n</li>\n<li data-nodeid="25263">\n<p data-nodeid="25264">创建相应的 reduce；</p>\n</li>\n<li data-nodeid="25265">\n<p data-nodeid="25266">将状态添加到 store 中，并放在 APP 最顶层。</p>\n</li>\n</ol>\n<p data-nodeid="25267">接下来我们一步步实现代码逻辑。</p>\n<p data-nodeid="25268">这里单独创建一个目录 states ，用于状态管理，其次在 states 目录中创建 name_state.dart ，并实现其中的代码如下，创建相应的 state 以及 Action。</p>\n<pre class="lang-dart" data-nodeid="25269"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:math\'</span>;\n<span class="hljs-comment">/// <span class="markdown">name 状态管理类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameStates</span> </span>{\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> _name;\n  <span class="hljs-comment">/// <span class="markdown">getter 方法获取name</span></span>\n  <span class="hljs-keyword">get</span> name =&gt; _name;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  NameStates(<span class="hljs-keyword">this</span>._name);\n  <span class="hljs-comment">/// <span class="markdown">初始设置</span></span>\n  NameStates.initState() : _name = <span class="hljs-string">\'test flutter 1\'</span>;\n}\n<span class="hljs-comment">/// <span class="markdown">定义 name state 对应的状态修改 action</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// [NameActions.changeName] 为修改当前 name</span></span>\n<span class="hljs-keyword">enum</span> NameActions {\n  <span class="hljs-comment">/// <span class="markdown">修改 name 的 state</span></span>\n  changeName\n}\n</code></pre>\n<p data-nodeid="25270">实现对应的 Action 方法。</p>\n<pre class="lang-dart" data-nodeid="25271"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">修改当前name，随机选取一个</span></span>\nNameStates changeName() {\n  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; nameList = [<span class="hljs-string">\'flutter one\'</span>, <span class="hljs-string">\'flutter two\'</span>, <span class="hljs-string">\'flutter three\'</span>];\n  <span class="hljs-built_in">int</span> pos = Random().nextInt(<span class="hljs-number">3</span>);\n  <span class="hljs-keyword">return</span> NameStates(nameList[pos]);\n}\n</code></pre>\n<p data-nodeid="25272">在 reducer 中增加对应 Action 的判断。</p>\n<pre class="lang-dart" data-nodeid="25273"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">reducer 方法，触发组件更新</span></span>\nNameStates reducer(NameStates state, action){\n  <span class="hljs-keyword">if</span> (action == NameActions.changeName) {\n    <span class="hljs-keyword">return</span> changeName();\n  }\n  <span class="hljs-keyword">return</span> state;\n}\n</code></pre>\n<p data-nodeid="25274">上面就完成了整个 state 类管理，这点和前端的 reducer 实现完全一致。接下来我们看下，在 APP 底层创建的代码。</p>\n<pre class="lang-dart" data-nodeid="25275"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_redux/flutter_redux.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:redux/redux.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/pages/name_game.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/states/name_states.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">APP 核心入口文件</span></span>\n<span class="hljs-keyword">void</span> main() {\n  <span class="hljs-keyword">final</span> store =\n  Store&lt;NameStates&gt;(reducer, initialState: NameStates.initState());\n  runApp(MyApp(store));\n}\n<span class="hljs-comment">/// <span class="markdown">MyApp 核心入口界面</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">初始</span></span>\n  <span class="hljs-keyword">final</span> Store&lt;NameStates&gt; store;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  MyApp(<span class="hljs-keyword">this</span>.store);\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> StoreProvider&lt;NameStates&gt;(\n      store: store,\n      child: MaterialApp(\n          title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字</span>\n          debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>,\n          theme: ThemeData(\n            primarySwatch: Colors.blue, <span class="hljs-comment">// APP 主题</span>\n          ),\n          home: Scaffold(\n              appBar: AppBar(\n                title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n              ),\n              body: Center(\n                <span class="hljs-comment">//child: HomePage(),</span>\n                child: NameGame(store: store),\n              ))),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25276">在 main 函数中创建 store 对象并执行初始化，然后在具体需要使用 store 的方法中使用如下代码规则：</p>\n<pre class="lang-dart" data-nodeid="25277"><code data-language="dart">    <span class="hljs-keyword">return</span> StoreProvider&lt;NameStates&gt;(\n      store: store,\n      child: (具体的组件，可以直接使用 store 变量),\n    )\n</code></pre>\n<p data-nodeid="25278">子组件如果需要使用 store ，也需要在子组件中声明 store 变量作为组件参数，我们看下 RandomName 组件内的使用和实现。</p>\n<pre class="lang-dart" data-nodeid="25279"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_redux/flutter_redux.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:redux/redux.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/states/name_states.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">随机展示人名</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">store</span></span>\n  <span class="hljs-keyword">final</span> Store store;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  RandomName({Key key, <span class="hljs-keyword">this</span>.store}) : <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'random name build\'</span>);\n    <span class="hljs-keyword">return</span> StoreConnector&lt;NameStates,<span class="hljs-built_in">String</span>&gt;(\n      converter: (store) =&gt; store.state.name.toString(),\n      builder: (context, name) {\n        <span class="hljs-keyword">return</span> StoreConnector&lt;NameStates,VoidCallback&gt;(\n          converter: (store) {\n            <span class="hljs-keyword">return</span> () =&gt; store.dispatch(NameActions.changeName);\n          },\n          builder: (context, callback) {\n            <span class="hljs-keyword">return</span> FlatButton(\n              child: Text(name),\n              onPressed: () =&gt; callback(),\n            );\n          }\n        );\n      },\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25280">这种方式就需要层层传递这个 store ，从而会显得代码非常臃肿，特别是上面代码中的 19 行和 22 行。你会发现，如果需要的 Action 越多，StoreConnector 的层级就越深，你就会陷入深深的代码嵌套中。</p>\n<p data-nodeid="25281">当然使用 redux ，并不会因为父组件的更新而导致子组件的 build 问题，其他部分详细的代码，大家可参考 github 源码。</p>\n<h4 data-nodeid="25282">Provider</h4>\n<p data-nodeid="27281" class="">最后我们来看下官方推荐的技术方案 Provider ，开发过程比较简单，分为三步：</p>\n\n\n<ol data-nodeid="25284">\n<li data-nodeid="25285">\n<p data-nodeid="25286">创建状态管理类 name_model ，创建对应的状态 name 以及其修改 name 的方法 changeName；</p>\n</li>\n<li data-nodeid="25287">\n<p data-nodeid="25288">在 name_game 中增加 provider 的支持，并将相应需要共享的组件使用 provider 进行封装，监听数据变化；</p>\n</li>\n<li data-nodeid="25289">\n<p data-nodeid="25290">在子组件中获取 provider 的 name 数据以及 changeName 方法，在相应的点击部分触发 changeName 事件。</p>\n</li>\n</ol>\n<p data-nodeid="25291">在使用 Provider 来实现状态管理，我们需要创建一个 model 文件夹，放入对应的状态类 name_model ，代码实现如下：</p>\n<pre class="lang-dart" data-nodeid="25292"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:math\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">name状态管理模块</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">声明私有变量</span></span>\n  <span class="hljs-built_in">String</span> _name = <span class="hljs-string">\'test flutter\'</span>;\n  <span class="hljs-comment">/// <span class="markdown">设置get方法</span></span>\n  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> value =&gt; _name;\n  <span class="hljs-comment">/// <span class="markdown">修改当前name，随机选取一个</span></span>\n  <span class="hljs-keyword">void</span> changeName() {\n    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; nameList = [<span class="hljs-string">\'flutter one\'</span>, <span class="hljs-string">\'flutter two\'</span>, <span class="hljs-string">\'flutter three\'</span>];\n    <span class="hljs-built_in">int</span> pos = Random().nextInt(<span class="hljs-number">3</span>);\n    <span class="hljs-keyword">if</span>(_name != nameList[pos]) {\n      _name = nameList[pos];\n      notifyListeners();\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="25293">在第 6 行代码中，使用了一个 Dart 的 with 关键词，这个用法是表示 NameModel 可以直接调用 ChangeNotifier 的方法，比如第 15 行的代码就是调用了 ChangeNotifier 类中的方法。上面代码中，在 changeName 中设置完状态属性 _name 以后，通过 ChangeNotifier 通知监听方。为了性能优化，在第 18 到第 21 行进行了判断，避免属性未改变而触发 build 操作。接下来看一下，在 name_game 中是如何监听数据变化，代码实现如下：</p>\n<pre class="lang-dart" data-nodeid="25294"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/name_model.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/name_game/random_name.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/name_game/test_other.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/name_game/welcome.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">测试随机名字游戏组件</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameGame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">设置状态 name</span></span>\n  <span class="hljs-keyword">final</span> name = NameModel();\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Column(\n      children: &lt;Widget&gt;[\n        Provider&lt;<span class="hljs-built_in">String</span>&gt;.value(\n          child: ChangeNotifierProvider.value(\n            value: name,\n            child: Column(\n              children: &lt;Widget&gt;[\n                Welcome(),\n                RandomName(),\n              ],\n            ),\n          ),\n        ),\n        TestOther(),\n      ],\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25295">上述代码中，第 13 行获取状态属性 name ，在 build 逻辑中使用 Provider.value 来封装需要共享的组件，String 为 name 相应的字段类型。并且使用 ChangeNotifierProvider 来接受监听数据变化，当数据发生变化时则触发子组件的 build 。</p>\n<p data-nodeid="25296">最后我们再来看其中的一个子组件 RandomName ，在 RandomName 中展示 name 字段，并且有一个按钮触发 changeName 操作，代码实现如下。</p>\n<pre class="lang-dart" data-nodeid="25297"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/name_model.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">随机展示人名</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">final</span> _name = Provider.of&lt;NameModel&gt;(context);\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'random name build\'</span>);\n    <span class="hljs-keyword">return</span> FlatButton(\n      child: Text(_name.value),\n      onPressed: () =&gt; _name.changeName(),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25298">第 11 行通过 Provider.of(context) 方式，获得根节点 NameModel 的句柄，然后通过 NameModel 的 value 获得状态 name 的值，其次使用 _name.changeName 执行 NameModel 的方法，触发 name 状态值的修改，从而再通过 ChangeNotifier 通知到两个组件 welcome 和 random_name 。</p>\n<p data-nodeid="25299">以上就完成了整个 Provider 的实现逻辑，相对其他两种技术方案，则更简洁一些。</p>\n<h4 data-nodeid="25300">三者的对比</h4>\n<p data-nodeid="25301">上面三种技术方案，在同页面组件共享都没有任何问题，在性能方面也都解决了组件更新避免全局子组件的更新问题。但是 InheritedWidget 在多页面间数据共享比较麻烦（因为需要一个共同的父节点，对于多个页面来说没有共同的父节点这个概念），这点对于 Redux 和 Provider 则较为简单。其次由于 Redux 容易陷入无限的深度嵌套，因此也不建议使用。所以本专栏推荐使用 Provider 技术方案，使用方式较为简单，其次也不会带来其他负面的影响。</p>\n<p data-nodeid="25302">本课时一开始就介绍了关于多页面内容共享引起的问题，从而思考状态管理的技术方案，那么通过技术对比，我们选择了 Provider ，接下来我使用 Provider 来完善上一课时中的例子。</p>\n<h4 data-nodeid="25303">创建 like_num_model</h4>\n<pre class="lang-dart" data-nodeid="25304"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">name状态管理模块</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeNumModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">声明私有变量</span></span>\n  <span class="hljs-built_in">int</span> _likeNum = <span class="hljs-number">0</span>;\n  <span class="hljs-comment">/// <span class="markdown">设置get方法</span></span>\n  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> value =&gt; _likeNum;\n  <span class="hljs-comment">/// <span class="markdown">修改当前name，随机选取一个</span></span>\n  <span class="hljs-keyword">void</span> like() {\n    _likeNum++;\n    notifyListeners();\n  }\n}\n</code></pre>\n<p data-nodeid="25305">由于每次都会自增，因此在 like 函数中无须判断是否 likeNum 状态有变化，只要自增了 likeNum 状态后通知监听方即可。</p>\n<h4 data-nodeid="25306">main 函数创建监听组件</h4>\n<p data-nodeid="25307">由于涉及两个页面，并不是两个组件，因此这里需要将状态提升到 main 函数中，mian 组件的实现如下：</p>\n<pre class="lang-dart" data-nodeid="25308"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/like_num_model.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/pages/home_page.dart\'</span>;\n\n<span class="hljs-comment">/// <span class="markdown">APP 核心入口文件</span></span>\n<span class="hljs-keyword">void</span> main() {\n  runApp(MyApp());\n}\n<span class="hljs-comment">/// <span class="markdown">MyApp 核心入口界面</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">创建 like model</span></span>\n  <span class="hljs-keyword">final</span> likeNumModel = LikeNumModel();\n  <span class="hljs-comment">// This widget is the root of your application.</span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Provider&lt;<span class="hljs-built_in">int</span>&gt;.value(\n        child: ChangeNotifierProvider.value(\n          value: likeNumModel,\n            child: MaterialApp(\n                title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字</span>\n                debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>,\n                theme: ThemeData(\n                  primarySwatch: Colors.blue, <span class="hljs-comment">// APP 主题</span>\n                ),\n                home: Scaffold(\n                    appBar: AppBar(\n                      title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n                    ),\n                    body: Center(\n                      child: HomePage(),\n                    ))),\n      ),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25309">上述代码第 16 行，创建了状态管理类的对象，并通过 Provider.value 和 ChangeNotifierProvider.value 来封装组件 HomePage ，由于 ArticlePage 也是在页面组件中的 MaterialApp 组件下，因此都可以通过 context 获取 likeNumModel 句柄。</p>\n<h4 data-nodeid="25310">使用 likeNumModel</h4>\n<p data-nodeid="25311">使用 Provider 的好处就在于，不使用的部分完全不需要修改，只需要在使用该状态的地方修改即可。由于 likeNumModel 只在 article_detail_like 和 article_like_bar 中使用，因此修改这两个组件即可。</p>\n<p data-nodeid="25312">article_like_bar 代码如下：</p>\n<pre class="lang-dart" data-nodeid="25313"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/like_num_model.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/styles/text_syles.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">帖子文章的赞组件</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 包括点赞组件 icon ，以及组件点击效果</span></span>\n<span class="hljs-comment">/// <span class="markdown">需要外部参数[likeNum],点赞数量</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleLikeBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">final</span> likeNumModel = Provider.of&lt;LikeNumModel&gt;(context);\n    <span class="hljs-keyword">return</span> Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: &lt;Widget&gt;[\n        FlatButton(\n          child: Row(\n            children: &lt;Widget&gt;[\n              Icon(Icons.thumb_up, color: Colors.grey, size: <span class="hljs-number">18</span>),\n              Padding(padding: EdgeInsets.only(left: <span class="hljs-number">10</span>)),\n              Text(\n                <span class="hljs-string">\'<span class="hljs-subst">${likeModel.value}</span>\'</span>,\n                style: TextStyles.commonStyle(),\n              ),\n            ],\n          ),\n          onPressed: () =&gt; likeNumModel.like(),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25314">在第 15 行获取操作句柄，然后在第 26 行获取属性 likeNum ， 在第 31 行执行 likeNumModel 执行 like 操作。</p>\n<p data-nodeid="25315">article_detail_like 代码如下：</p>\n<pre class="lang-dart" data-nodeid="25316"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/like_num_model.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/styles/text_syles.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">帖子详情页的赞组件</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 包括点赞组件 icon ，以及组件点击效果</span></span>\n<span class="hljs-comment">/// <span class="markdown">需要外部参数[likeNum],点赞数量</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleDetailLike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">有状态类返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">final</span> likeNumModel = Provider.of&lt;LikeNumModel&gt;(context);\n    <span class="hljs-keyword">return</span> Column(\n      crossAxisAlignment: CrossAxisAlignment.center,\n      children: &lt;Widget&gt;[\n        FlatButton(\n          child: Icon(Icons.thumb_up, color: Colors.grey, size: <span class="hljs-number">40</span>),\n          onPressed: () =&gt; likeNumModel.like(),\n        ),\n        Text(\n          <span class="hljs-string">\'<span class="hljs-subst">${likeNumModel.value}</span>\'</span>,\n          style: TextStyles.commonStyle(),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="25317">同样上面的第 15 行获取 likeNumModel 操作句柄，然后在第 22 行执行 like 操作，在第 25 行显示点赞数量。</p>\n<p data-nodeid="25318">接下来我们运行下项目，可以看到效果如图 5 所示。</p>\n<p data-nodeid="25319"><img src="https://s0.lgstatic.com/i/image/M00/2A/7E/Ciqc1F78dpSARI7HACF3LNRp7LA326.gif" alt="20200620_213558.gif" data-nodeid="25486"><br>\n图 5 多页面状态点赞同步效果</p>\n<h3 data-nodeid="25320">总结</h3>\n<p data-nodeid="25321">以上就是本课时的所有内容，学完本课时你需要掌握使用状态管理的场景，常见的状态管理有哪些。本课时的核心是需要你掌握 Provider 的状态管理技术方案。</p>\n<p data-nodeid="25322">至此，我已经将组件的设计基本介绍完毕，接下来我将介绍组件的单元测试，以及完善组件功能。如果你有疑问，可以在下方留言。</p>\n<p data-nodeid="25323" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="25494">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '08 | 单元测试：Flutter 应用单元测试，提升代码质量',
            id: 310,
            content:
              '<p data-nodeid="669" class="">之前已经讲解了 Flutter 所有基础的知识点，本课时介绍如何保证组件代码的质量，以此来确保我们在代码开发过程中或者在重构过程中的代码质量。</p>\n<h3 data-nodeid="670">单元测试</h3>\n<p data-nodeid="671">单元测试的概念是针对程序中最小单位来进行校验的工作，在 Flutter 中最小的单位是组件。由于我们扩展了一些模块比如 Model（Provider）、Struct（数据结构部分），因此这里也需要介绍下这两部分的单元测试。</p>\n<h4 data-nodeid="672">目录结构</h4>\n<p data-nodeid="673">为了保持一致性，我们在 test 单元测试目录，创建与项目结构目录一致的结构，如图 1 所示。</p>\n<p data-nodeid="674"><img src="https://s0.lgstatic.com/i/image/M00/2B/C9/Ciqc1F7_AHGAJ8__AABUPoaGi10666.png" alt="image (9).png" data-nodeid="735"><br>\n图 1 单元测试目录结构</p>\n<p data-nodeid="675">单元测试目录结构下的测试文件命名也是按照原组件命名方式，但是需要在组件命名后面增加 test 后缀。例如，我们需要对 article_comments.dart 文件进行单元测试，根据规则将其命名为 article_comments_test.dart。</p>\n<h4 data-nodeid="676">前期准备</h4>\n<p data-nodeid="677">首先我们需要在 pubspec.yaml 中增加相应的 flutter_test 第三库，一般项目初始化后，会自动在 dev_dependencies 中引入，最后执行 flutter pub get 更新本地第三库即可。目录结构目前还是需要手动创建，在下一课时，我会在脚手架中自动化创建。</p>\n<h3 data-nodeid="678">Struct 的单元测试</h3>\n<p data-nodeid="679">Struct 的目的是保证数据结构的安全，避免因为动态数据结构而引发客户端的 Crash 问题，因此做好数据结构的单元测试非常必要。Struct 的结构比较简单，只有一个构造函数，在构造函数中存在必须和可选参数，单元测试部分主要是验证这个构造函数即可。</p>\n<p data-nodeid="680">在上一课时中，我们创建了三个 Struct ，这里着重介绍较为复杂的 comment_info_struct.dart 的测试用例写法，代码如下。</p>\n<pre class="lang-dart" data-nodeid="681"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_test/flutter_test.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/comment_info_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/user_info_struct.dart\'</span>;\n<span class="hljs-keyword">void</span> main() {\n  <span class="hljs-keyword">final</span> UserInfoStruct userInfo = UserInfoStruct(<span class="hljs-string">\'test\'</span>, <span class="hljs-string">\'http://test.com\'</span>);\n  test(<span class="hljs-string">\'test-userinfo\'</span>, () {\n    <span class="hljs-keyword">final</span> CommentInfoStruct commentInfo =\n      CommentInfoStruct(userInfo, <span class="hljs-string">\'comment test\'</span>);\n    expect(commentInfo.comment == <span class="hljs-string">\'comment test\'</span>, <span class="hljs-keyword">true</span>);\n    expect(commentInfo.userInfo.nickname == <span class="hljs-string">\'test\'</span>, <span class="hljs-keyword">true</span>);\n    expect(commentInfo.userInfo.headerImage, <span class="hljs-string">\'http://test.com\'</span>);\n  });\n}\n</code></pre>\n<p data-nodeid="682">第 1 行代码引入 flutter_test 第三方库，第 3 和 4 行引入本次测试需要的 struct 结构库。测试文件的所有测试逻辑都在 main 函数中。在第 7 行中使用 UserInfoStruct 创建 userInfo ，Flutter 中的类以及库测试都是以 test 函数为测试方法，test 包含两个参数，一个是测试的描述，另外一个是测试的核心逻辑。</p>\n<p data-nodeid="683">测试的核心逻辑中有一个 expect 方法，该方法可以在代码前使用一个条件判断语句，例如等于、大于、小于等等，而第二个参数可以是任何数据。如果 expect 的前后两个值相等，则测试用例通过，如果不相等则不通过。</p>\n<p data-nodeid="684">代码完成以后，我们在根目录执行下面的命令。</p>\n<pre class="lang-plain" data-nodeid="685"><code data-language="plain">flutter test\n</code></pre>\n<p data-nodeid="686">执行完成后，就可以看到以下结果，这表明测试用例已全部通过。</p>\n<pre class="lang-plain" data-nodeid="687"><code data-language="plain">00:04 +1: All tests passed!\n</code></pre>\n<h3 data-nodeid="688">Model 的单元测试</h3>\n<p data-nodeid="689">Model 的测试和 Struct 基本一样，不过在 Model 中有较多方法，因此需要增加一些类方法的测试。这里我们使用 like_num_model.dart 作为测试文件，在 test 目录下的 model 文件夹中新增测试文件 like_num_model_test.dart ，并在实现如下测试代码。</p>\n<pre class="lang-dart" data-nodeid="690"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_test/flutter_test.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/like_num_model.dart\'</span>;\n<span class="hljs-keyword">void</span> main() {\n  <span class="hljs-keyword">final</span> LikeNumModel likeNumModel = LikeNumModel();\n  test(<span class="hljs-string">\'test like model value\'</span>, () {\n    expect(likeNumModel.value, <span class="hljs-number">0</span>);\n  });\n  test(<span class="hljs-string">\'test like model like method\'</span>, () {\n    likeNumModel.like();\n    expect(likeNumModel.value, <span class="hljs-number">1</span>);\n    likeNumModel.like();\n    expect(likeNumModel.value, <span class="hljs-number">2</span>);\n  });\n}\n</code></pre>\n<p data-nodeid="691">代码中第 1 行和第 3 行都是引入相应的库以及测试库文件，其次以 main 为测试入口，在 main 中调用 LikeNumModel 初始化并获得操作句柄，然后分为两部分，一部分测试状态属性，另一部分测试相应状态属性变更的类方法。</p>\n<h3 data-nodeid="692">组件的单元测试</h3>\n<p data-nodeid="693">上面两部分测试代码逻辑较为简单，真正的核心是组件的单元测试。组件测试使用的方法是 testWidgets ，需要将组件放入到 MaterialApp 中，然后在 MaterialApp 中去 find 相应组件中的元素，接下来我们看一个比较简单的无状态组件的测试 。</p>\n<h4 data-nodeid="694">无状态组件</h4>\n<p data-nodeid="695">学习无状态组件的单元测试，我们选择上一课时中 article_detail 文件下的 article_content.dart 组件作为例子。在 test/article_detail 文件夹中创建 article_content_test.dart 文件，代码实现如下。</p>\n<pre class="lang-dart" data-nodeid="696"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_test/flutter_test.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/article_detail/article_content.dart\'</span>;\n<span class="hljs-keyword">void</span> main() {\n  testWidgets(<span class="hljs-string">\'test article content\'</span>, (WidgetTester tester) <span class="hljs-keyword">async</span> {\n    <span class="hljs-keyword">final</span> Widget testWidgets = ArticleContent(content: <span class="hljs-string">\'test content\'</span>);\n    <span class="hljs-keyword">await</span> tester.pumpWidget(\n        <span class="hljs-keyword">new</span> MaterialApp(\n            home: testWidgets\n        )\n    );\n    expect(find.text(<span class="hljs-string">\'test content\'</span>), findsOneWidget);\n    expect(find.byWidget(testWidgets), findsOneWidget);\n  });\n}\n</code></pre>\n<ul data-nodeid="697">\n<li data-nodeid="698">\n<p data-nodeid="699">代码的前 2 行引入相应的组件库和测试库，第 4 行引入需要被测试的组件 article_content ；</p>\n</li>\n<li data-nodeid="700">\n<p data-nodeid="701">在 main 函数中使用 testWidgets 来测试组件，testWidgets 也有两个参数，第一个是测试描述，第二个是一个执行函数，函数会自带一个组件测试对象 tester ；</p>\n</li>\n<li data-nodeid="702">\n<p data-nodeid="703">在测试过程中需要将被测试的组件插入到 MaterialApp ，因此这里需要使用到tester.pumpWidget 方法，代码在第 9 行中体现；因为这是一个异步方法，因此需要函数使用 async ，并且这里需要使用 await 来等待执行完成；</p>\n</li>\n<li data-nodeid="704">\n<p data-nodeid="705">使用 expect 来查询组件，findsOneWidget 来判断是否找到相应的组件。</p>\n</li>\n</ul>\n<p data-nodeid="706">以上就是无状态组件的测试方法，由于上面的 article_content 内部只有一个 text 组件，因此单元测试比较简单。无状态组件可以验证组件是否存在，并且可以判断组件中的元素是否按照参数传入的值显示。</p>\n<h4 data-nodeid="707">有状态组件</h4>\n<p data-nodeid="708">有状态组件在组件测试部分与无状态组件一样，这里主要是介绍在组件触发更新后，如何保证界面显示正常与否。这里我们使用上一课时的 article_detail_like 作为测试例子。因为组件状态管理需要使用 Provider ，因此需要引入该模块。</p>\n<pre class="lang-dart" data-nodeid="709"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_test/flutter_test.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/model/like_num_model.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/article_detail/article_detail_like.dart\'</span>;\n</code></pre>\n<p data-nodeid="710">接下来在 main 函数初始化状态模块 like_num_model，代码如下。</p>\n<pre class="lang-dart" data-nodeid="711"><code data-language="dart"><span class="hljs-keyword">void</span> main() {\n  <span class="hljs-keyword">final</span> LikeNumModel likeNumModel = LikeNumModel();\n}\n</code></pre>\n<p data-nodeid="712">然后我们增加单纯的静态组件测试，这部分和无状态组件部分完全一致，代码如下。</p>\n<pre class="lang-dart" data-nodeid="713"><code data-language="dart">testWidgets(<span class="hljs-string">\'test article like widget\'</span>, (WidgetTester tester) <span class="hljs-keyword">async</span> {\n  <span class="hljs-keyword">final</span> Widget testWidgets = ArticleDetailLike();\n  <span class="hljs-keyword">await</span> tester.pumpWidget(\n      <span class="hljs-keyword">new</span> Provider&lt;<span class="hljs-built_in">int</span>&gt;.value(\n          child: ChangeNotifierProvider.value(\n            value: likeNumModel,\n            child: MaterialApp(\n                home: testWidgets\n            ),\n          )\n      )\n  );\n  expect(find.byType(FlatButton), findsOneWidget);\n  expect(find.byIcon(Icons.thumb_up), findsOneWidget);\n  expect(find.text(<span class="hljs-string">\'0\'</span>), findsOneWidget);\n});\n</code></pre>\n<p data-nodeid="714">与无状态组件测试唯一不同的是，我们需要使用 Provider 将 MaterialApp 封装起来。在代码中的第 13 行找 FlatButton 组件，第 14 行寻找 thumb_up icon ，第 15 行获取组件中的 Text 组件，并判断初始值为 0 。</p>\n<p data-nodeid="715">接下来我们看下比较复杂的事件触发更新的测试部分逻辑。在这个例子的单元测试中，我们需要触发按钮点击操作，并且进行 rebuild 后，重新校验组件的正确性，代码如下。</p>\n<pre class="lang-dart" data-nodeid="716"><code data-language="dart">testWidgets(<span class="hljs-string">\'test article like widget when like action\'</span>, (WidgetTester tester) <span class="hljs-keyword">async</span> {\n  <span class="hljs-keyword">final</span> Widget testWidgets = ArticleDetailLike();\n  <span class="hljs-keyword">await</span> tester.pumpWidget(\n      <span class="hljs-keyword">new</span> Provider&lt;<span class="hljs-built_in">int</span>&gt;.value(\n          child: ChangeNotifierProvider.value(\n            value: likeNumModel,\n            child: MaterialApp(\n                home: testWidgets\n            ),\n          )\n      )\n  );\n  <span class="hljs-keyword">await</span> tester.tap(find.byType(FlatButton));\n  <span class="hljs-keyword">await</span> Future.microtask(tester.pump);\n  expect(find.text(<span class="hljs-string">\'1\'</span>), findsOneWidget);\n});\n</code></pre>\n<p data-nodeid="717">代码中的第 13 行就是找到 FlatButton 并且触发其点击操作，使用的是 tester.tap 方法，在触发后需要等待组件重新更新，因此需要使用 Future.microtask 来触发等待更新完成，完成后再校验组件中的点赞数是否更新，在上面的 17 行中使用 expect 再次判断。</p>\n<h3 data-nodeid="718">综合实践</h3>\n<p data-nodeid="719">以上就囊括了所有的单元测试的写法，由于断言 find 的方法还存在其他比较多的用法，这里就不复制过来，具体详细的内容，大家可以前往<a href="https://api.flutter.dev/flutter/flutter_test/CommonFinders-class.html" data-nodeid="821">官方文档</a>去查询。</p>\n<p data-nodeid="720">接下来大家需要将上一课时的所有的组件使用本课时的知识点，覆盖到所有的单元测试，写完以后大家可以对比或者参考我们 github 上的源码。</p>\n<p data-nodeid="721">这里也补充下，因为涉及图片组件，为了避免图片组件在测试加载过程中的异常问题，这里需要使用第三方库 image_test_utils ，下面是一个使用该组件的例子。</p>\n<pre class="lang-dart" data-nodeid="722"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_test/flutter_test.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:image_test_utils/image_test_utils.dart\'</span>;\n\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/util/struct/article_summary_struct.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you/widgets/home_page/article_summary.dart\'</span>;\n\n<span class="hljs-keyword">void</span> main() {\n&nbsp; <span class="hljs-comment">/// <span class="markdown">帖子概要描述信息</span></span>\n&nbsp; <span class="hljs-keyword">final</span> ArticleSummaryStruct articleInfo = ArticleSummaryStruct(\n&nbsp; &nbsp; &nbsp; <span class="hljs-string">\'你好，交个朋友\'</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-string">\'我是一个小可爱，很长的一个测试看看效果，会换行吗\'</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-string">\'https://i.pinimg.com/originals/e0/64/4b/e0644bd2f13db50d0ef6a4df5a756fd9.png\'</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-number">20</span>,\n&nbsp; &nbsp; &nbsp; <span class="hljs-number">30</span>);\n\n&nbsp; testWidgets(<span class="hljs-string">\'test article summary\'</span>, (WidgetTester tester) <span class="hljs-keyword">async</span> {\n&nbsp; &nbsp; provideMockedNetworkImages(() <span class="hljs-keyword">async</span> {\n&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">final</span> Widget testWidgets = ArticleSummary(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: articleInfo.title,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summary: articleInfo.summary,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; articleImage: articleInfo.articleImage\n&nbsp; &nbsp; &nbsp; );\n&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">await</span> tester.pumpWidget(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">new</span> MaterialApp(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; home: testWidgets\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; );\n\n&nbsp; &nbsp; &nbsp; expect(find.text(<span class="hljs-string">\'你好，交个朋友\'</span>), findsOneWidget);\n&nbsp; &nbsp; &nbsp; expect(find.text(<span class="hljs-string">\'我是一个小可爱，很长的一个测试看看效果，会换行吗\'</span>), findsOneWidget);\n\n&nbsp; &nbsp; &nbsp; expect(find.byWidget(testWidgets), findsOneWidget);\n&nbsp; &nbsp; });\n&nbsp; });\n}\n</code></pre>\n<p data-nodeid="723">主要看代码的第 22 行，需要将整个测试代码使用 provideMockedNetworkImages 函数来执行，这样就不会出现异常情况了。</p>\n<h3 data-nodeid="724">总结</h3>\n<p data-nodeid="725">以上就是本课时的所有内容，学完本课时你需要掌握 Struct、Model、无状态和有状态组件的单元测试写法。</p>\n<p data-nodeid="726">下一课时我将把我们基础部分的所有基础知识汇总会一个脚手架，规范和统一基础模块。谢谢。</p>\n<p data-nodeid="727" class="te-preview-highlight"><a href="https://github.com/love-flutter/flutter-column" data-nodeid="835">点击此链接查看本课时源码</a></p>',
          },
        ],
      },
      {
        sectionName: '第二部分：项目实战',
        sectionId: 2,
        courseList: [
          {
            theme: '09 | 项目脚手架：一个命令构建 Flutter 项目',
            id: 311,
            content:
              '<p data-nodeid="39710" class="">在基础功能部分，我已经讲解了从基础到规范的应用，接下来我们进入项目实战部分。本课时将介绍项目基础框架，并且应用脚手架功能实现轻松的初始化项目。</p>\n\n\n<h3 data-nodeid="39019">项目基础框架</h3>\n<p data-nodeid="39020">先看项目基础框架，我们将项目基础框架分为三个部分：核心代码部分、基础工具以及单元测试。</p>\n<h4 data-nodeid="39021">核心代码</h4>\n<p data-nodeid="40622">核心代码主要是在 lib 目录下，我们将 lib 下的各个功能进行了整理，可以用图 1 来表示各个模块之间的关系。</p>\n<p data-nodeid="40623" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/C3/Ciqc1F8Flb-AGmmvAADAcKsYMc8004.png" alt="image.png" data-nodeid="40627"><br>\n图 1 lib 核心目录结构</p>\n\n\n\n\n<ul data-nodeid="39025">\n<li data-nodeid="39026">\n<p data-nodeid="39027">入口文件，main.dart 核心入口文件；</p>\n</li>\n<li data-nodeid="39028">\n<p data-nodeid="39029">pages 作为具体的页面结构，可以通过 main.dart 直接加载，大部分还是通过 router.dart 进行跳转，pages 可以按照业务功能划分文件夹；</p>\n</li>\n<li data-nodeid="39030">\n<p data-nodeid="39031">pages 下是各个组件组建而成，组件部分可以按照通用、基础和业务来划分；</p>\n</li>\n<li data-nodeid="39032">\n<p data-nodeid="39033">组件中包含了样式、交互和数据三个部分，因此分别需要 styles 和 model 文件夹；</p>\n</li>\n<li data-nodeid="39034">\n<p data-nodeid="39035">model 大部分数据来自服务端，因此需要一个 api 文件夹来与服务端交互；</p>\n</li>\n<li data-nodeid="39036">\n<p data-nodeid="39037">类型校验部分贯穿整个项目，在 pages 、widgets 、 model 和 api 中都可能会被应用到。</p>\n</li>\n</ul>\n<p data-nodeid="39038">按照上面的划分，唯一需要注意的是，各个目录下的二级目录需要根据你们自身的业务功能去设计。因为业务模块不一定是一个页面，在项目初期就应该按照业务模块规划好目录结构，后期维护成本会降低很多，同时提升可扩展性。</p>\n<p data-nodeid="41538">例如 pages 需要三个页面，一个是首页内容，一个是用户个人信息页面，另外一个则是用户信息修改页面，那么我们可以按照表格 1 这样命名文件以及类。</p>\n<p data-nodeid="42794" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/C3/Ciqc1F8FldOAPQ-gAABVfTIEj5I407.png" alt="image (1).png" data-nodeid="42801"><br>\n表格 1 pages 业务划分目录结构</p>\n\n\n\n\n\n\n\n<p data-nodeid="43562">widgets 下则与 pages 目录结构保持一致即可，model 、api 以及 struct 则需要根据的服务端协议的业务功能来定义目录结构。使用上面的目录方式，我们创建出了如图 2 所示的一个结构，提供大家参考。</p>\n<p data-nodeid="43563" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/CF/CgqCHl8FleuAcV39AABWvTrY5U8584.png" alt="image2.png" data-nodeid="43567"><br>\n图 2 项目目录结构示例</p>\n\n\n\n\n<h4 data-nodeid="39069">基础工具</h4>\n<p data-nodeid="39070">按照我们前面课时所设计的一些基础规范，这里需要两个基础的工具 dartfmt 和 dartanalyzer。将这两个工具整合在一起，一个为 shell 脚本和一个为 bat 脚本，整合后的文件叫作 format_check.sh 和 format_check.bat，里面包含以下代码。</p>\n<p data-nodeid="39071">format_check.sh，该脚本主要适用于 Mac 系统和 Linux 系统。</p>\n<pre class="lang-shell" data-nodeid="39072"><code data-language="shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>\n<span class="hljs-meta">#</span><span class="bash"> 代码美化</span>\ndartfmt -w --fix lib/\n<span class="hljs-meta">#</span><span class="bash"> 代码规范检查</span>\ndartanalyzer lib\n<span class="hljs-meta">#</span><span class="bash"> 单元测试通过</span>\nflutter test\n</code></pre>\n<p data-nodeid="39073">format_check.bat，该脚本主要适用于 Windows 系统。</p>\n<pre class="lang-sql" data-nodeid="50655"><code data-language="sql">dartfmt -w <span class="hljs-comment">--fix lib/</span>\ndartanalyzer lib\nflutter test\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="51038">在项目开发阶段只需要通过该命令来运行，就可以确保我们的一些基础规范是满足的，其他逻辑部分还是需要各个团队自身的 Code Review。</p>\n<h4 data-nodeid="51039">单元测试</h4>\n\n\n<p data-nodeid="51609">为了保证代码的健壮性，还需要生成对应的单元测试目录。针对上面的 lib 结构，我们生成对应的目录结构即可，唯一需要去掉的就是 styles 目录，例如，初始化的时候，我们对应生成下图 3 的目录层级结构。</p>\n<p data-nodeid="51610" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/C3/Ciqc1F8Flg2AZvgFAABbTxGj0PU912.png" alt="image (2).png" data-nodeid="51618"><br>\n图 3 单元测试目录结构</p>\n\n\n\n\n<p data-nodeid="39080">以上部分就是整个项目框架的基础结构，接下来我们将这个基础的项目结构做成一个框架模版，使用脚手架的方式统一来创建和运行。</p>\n<h3 data-nodeid="39081">脚手架应用</h3>\n<p data-nodeid="39082">为了能够更好地体验，我们可以封装好这些一样的功能，开发出一个脚手架方式。前端同学会比较熟悉，将大部分初始化或者脚本化的功能统一封装成一个脚手架，通过脚手架执行项目的初始化。</p>\n<h4 data-nodeid="39083">环境要求</h4>\n<p data-nodeid="39084">这里需要使用到 Node.js 和 npm 环境，如果是前端开发，应该已具备。如果是非前端开发或者未安装相应 Node.js 和 npm 环境的可以前往<a href="https://nodejs.org/en/download/" data-nodeid="39188">官网下载安装</a>最新的版本即可。</p>\n<h4 data-nodeid="39085">flutter-pro-cli</h4>\n<p data-nodeid="39086">flutter-pro-cli，该工具可以轻松帮你完成项目框架结构的初始化，在安装完成上面的运行环境后，在命令运行窗口，运行下面的命令。</p>\n<pre class="lang-sql" data-nodeid="56703"><code data-language="sql">npm <span class="hljs-keyword">install</span> -g flutter-pro-cli\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="39088">安装完成后，运行如下命令查看具体包含的功能。</p>\n<pre class="lang-sql" data-nodeid="57094"><code data-language="sql">flutter-pro-cli -h\n</code></pre>\n\n<p data-nodeid="39090">可以看到如下的窗口提示信息。</p>\n<pre class="lang-sql" data-nodeid="57485"><code data-language="sql">Usage: flutter-pro-cli [options] [command]\nOptions:\n&nbsp; -h, <span class="hljs-comment">--help&nbsp; &nbsp; &nbsp; display help for command</span>\nCommands:\n&nbsp; init|i&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Generates new flutter project\n&nbsp; <span class="hljs-keyword">check</span>|c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">Check</span> the <span class="hljs-keyword">project</span> lib <span class="hljs-keyword">format</span>\n&nbsp; run|r [<span class="hljs-keyword">check</span>]&nbsp; &nbsp;<span class="hljs-keyword">Check</span> the <span class="hljs-keyword">project</span> lib <span class="hljs-keyword">format</span> <span class="hljs-keyword">and</span> run\n&nbsp; <span class="hljs-keyword">sync</span>-<span class="hljs-keyword">test</span>|st&nbsp; &nbsp; Generates <span class="hljs-keyword">new</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">path</span> base <span class="hljs-keyword">on</span> lib <span class="hljs-keyword">path</span>\n&nbsp; <span class="hljs-keyword">help</span> [command]&nbsp; display <span class="hljs-keyword">help</span> <span class="hljs-keyword">for</span> command\n</code></pre>\n\n<ul data-nodeid="39092">\n<li data-nodeid="39093">\n<p data-nodeid="39094"><strong data-nodeid="39204">init</strong>，该操作会初始化好目录结构，包含 lib 和 test 目录下，其次会生成一个比较简单的 main.dart 和 router.dart 文件，并将我们需要的 check_format.sh 、 check_format.bat 以及 analysis_options.yaml 这三个文件放在项目根目录下。</p>\n</li>\n<li data-nodeid="39095">\n<p data-nodeid="39096"><strong data-nodeid="39213">check</strong>，该操作执行  check_format.sh 或者 check_format.bat 文件来美化代码结构，并检查当前项目的代码是否符合我们规范。</p>\n</li>\n<li data-nodeid="39097">\n<p data-nodeid="39098"><strong data-nodeid="39220">run</strong>，启动运行项目，可以带 check 参数执行 check_format.sh 先校验是否符合规范，符合则启动，否则不启动项目。这里的 run 要注意，需要优先打开手机模拟器，不然无法启动。</p>\n</li>\n<li data-nodeid="39099">\n<p data-nodeid="39100"><strong data-nodeid="39225">sync-test</strong>，同步测试代码结构，为了减少大家写单元测试的时间，脚手架提供了方法，可以读取你项目代码文件，并且添加了一个最基础的测试，其他部分则需要自己补充。</p>\n</li>\n</ul>\n<p data-nodeid="39101">我在实际项目开发过程中发现写测试用例确实挺麻烦，为了节省时间，可以针对性生成一些基础的测试代码用例，例如上面的 sync-test 会为我们创建好相应的目录结构，以及相应的测试代码文件。</p>\n<h4 data-nodeid="39102">脚手架实现</h4>\n<p data-nodeid="39103">脚手架使用的是 Node.js 来实现的，大家可以参考 <a href="https://github.com/love-flutter/flutter-pro-cli" data-nodeid="39231">gtihub 源码</a>，并在这基础上进行协同开发。由于使用的是 Node.js 来实现，这里就不过多介绍其实现原理，如果大家有兴趣可以进一步在 github 进行交流，希望共同完善这个脚手架。</p>\n<h3 data-nodeid="39104">实战初始化</h3>\n<p data-nodeid="39105">现在我们使用以上脚手架来初始化一个 Flutter 项目。首先第一步是创建项目 two you friend ，需要在 Android Studio 中创建好 Flutter 项目，项目创建完成后，在项目根目录打开命令行窗口，执行以下命令进行初始化。</p>\n<pre class="lang-sql" data-nodeid="57876"><code data-language="sql">flutter-pro-cli init\n</code></pre>\n\n<p data-nodeid="39107">执行完该初始化成功后，打开手机模拟器运行下面的命令检查代码规范，并且启动项目。</p>\n<pre class="lang-sql" data-nodeid="58267"><code data-language="sql">flutter-pro-cli run <span class="hljs-keyword">check</span>\n</code></pre>\n\n<p data-nodeid="39109">为了尝试自动化生成测试代码，我们可以在项目中的 lib/pages/home_page/ 目录下创建一个 index.dart 。然后再运行下面的命令。</p>\n<pre class="lang-sql" data-nodeid="58658"><code data-language="sql">flutter-pro-cli st\n</code></pre>\n\n<p data-nodeid="39111">运行完后，在相应的 test/pages/home_page 目录下你将看到 index_test.dart 文件，里面将包含下面的测试代码。</p>\n<pre class="lang-dart" data-nodeid="39112"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_test/flutter_test.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/home_page/index.dart\'</span>;\n<span class="hljs-comment">// @todo</span>\n<span class="hljs-keyword">void</span> main() {\n  testWidgets(<span class="hljs-string">\'test two_you_friend/pages/home_page/index.dart\'</span>, (WidgetTester tester) <span class="hljs-keyword">async</span> {\n     <span class="hljs-keyword">final</span> Widget testWidgets = HomePageIndex();\n      <span class="hljs-keyword">await</span> tester.pumpWidget(\n          <span class="hljs-keyword">new</span> MaterialApp(\n              home: testWidgets\n          )\n      );\n      expect(find.byWidget(testWidgets), findsOneWidget);\n  });\n}\n</code></pre>\n<p data-nodeid="39113">以上就完成了一个项目的初始化，比较简单的三个步骤。后期开发过程中可以使用 run 和 st 命令来提升研发效率。</p>\n<h3 data-nodeid="39114">总结</h3>\n<p data-nodeid="59049">以上就是本课时的主要内容，本课时通过工具化的方式来初始化项目，学完本课时你需要掌握 Flutter 项目基础结构，需要了解 flutter-pro-cli 的一个简单应用，最后希望你使用本课时的工具（或者手动的方式）创建一个 two you friend 项目，后面的课时我会逐步在该项目基础上完善功能。</p>',
          },
          {
            theme: '10 | 路由设计：Flutter 中是如何实现 Scheme 跳转的',
            id: 312,
            content:
              '<p data-nodeid="35621" class="">上一课时我们已经创建好了项目的基础框架结构，其中有一个 router.dart 文件，该文件的作用是实现 App 内的一个路由管理和跳转。本课时是基于该功能模块，着重介绍如何实现 App 内外的路由跳转。</p>\n<h3 data-nodeid="35622">Scheme</h3>\n<p data-nodeid="35623">在介绍路由跳转实现之前，我们先来了解下 Scheme 的概念，Scheme 是一种 App 内跳转协议，通过 Scheme 协议在 APP 内实现一些页面的互相跳转。一般可以使用以下格式协议。</p>\n<pre class="lang-java" data-nodeid="35624"><code data-language="java">[scheme]:<span class="hljs-comment">//[host]/[path]?[query]</span>\n</code></pre>\n<p data-nodeid="35625">这种格式不仅可以使用在 App 内部实现可跳转，还可以适用于外部拉起 App 指定页面的功能。内部跳转类似于前端的页面路由，只不过前端的页面路由是直接用链接来处理，在 App 中是无法像前端一样能够使用链接实现路由管理。外部跳转则需要分别从 Android 和 iOS 来介绍，其中主要的不同点是一些平台配置，下面我们先来看看内部如何实现路由跳转。</p>\n<h3 data-nodeid="35626">内部跳转</h3>\n<p data-nodeid="35627">按照上面的协议规则，我们将 Scheme 设置为项目 App 名字 tyfApp ，由于是 App 跳转 host 可以不设置，path 为具体的 pages 页面，query 则为 pages 需要的参数，举例如下。</p>\n<pre class="lang-java" data-nodeid="35628"><code data-language="java">tyfapp:<span class="hljs-comment">//userPageIndex?userId=1001</span>\n</code></pre>\n<h4 data-nodeid="35629">基础版本</h4>\n<p data-nodeid="35630">根据这个规则，实现 router.dart 逻辑。首先需要 import 相应的 pages 页面，例如这里我们需要两个页面的跳转和一个 Web 页面。</p>\n<pre class="lang-dart" data-nodeid="35631"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/common/web_view_page.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/home_page/index.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/pages/user_page/index.dart\'</span>;\n</code></pre>\n<p data-nodeid="35632">web_view_page.dart 使用第三方库，在遇到 http 或者 https 的协议时，使用该页面去打开，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="35633"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter_webview_plugin/flutter_webview_plugin.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">通用跳转逻辑</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonWebViewPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">url 地址</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> url;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  CommonWebViewPage({Key key, <span class="hljs-keyword">this</span>.url}) : <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> WebviewScaffold(\n      url: url,\n      appBar: AppBar(\n        backgroundColor: Colors.blue,\n      ),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="35634">使用第三方库 flutter_webview_plugin 来打开具体的网页地址，该组件一个是 url 具体的网址，一个是 appBar 包含 title 和主题信息。如果非网页地址，并符合页面规范的协议时，我们需要解析出跳转的页面以及页面需要的参数。</p>\n<pre class="lang-dart" data-nodeid="35635"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">解析跳转的url，并且分析其内部参数</span></span>\n<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; _parseUrl(<span class="hljs-built_in">String</span> url) {\n  <span class="hljs-keyword">if</span>(url.startsWith(appScheme)) {\n    url = url.substring(<span class="hljs-number">9</span>);\n  }\n  <span class="hljs-built_in">int</span> placeIndex = url.indexOf(<span class="hljs-string">\'?\'</span>);\n  <span class="hljs-keyword">if</span>(url == <span class="hljs-string">\'\'</span> || url == <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">return</span> {<span class="hljs-string">\'action\'</span>: <span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'params\'</span>: <span class="hljs-keyword">null</span>};\n  }\n  <span class="hljs-keyword">if</span> (placeIndex &lt; <span class="hljs-number">0</span>) {\n    <span class="hljs-keyword">return</span> {<span class="hljs-string">\'action\'</span>: url, <span class="hljs-string">\'params\'</span>: <span class="hljs-keyword">null</span>};\n  }\n  <span class="hljs-built_in">String</span> action = url.substring(<span class="hljs-number">0</span>, placeIndex);\n  <span class="hljs-built_in">String</span> paramStr = url.substring(placeIndex + <span class="hljs-number">1</span>);\n  <span class="hljs-keyword">if</span> (paramStr == <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">return</span> {<span class="hljs-string">\'action\'</span>: action, <span class="hljs-string">\'params\'</span>: <span class="hljs-keyword">null</span>};\n  }\n  <span class="hljs-built_in">Map</span> params = {};\n  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; paramsStrArr = paramStr.split(<span class="hljs-string">\'&amp;\'</span>);\n  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> singleParamsStr <span class="hljs-keyword">in</span> paramsStrArr) {\n    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; singleParamsArr = singleParamsStr.split(<span class="hljs-string">\'=\'</span>);\n    params[singleParamsArr[<span class="hljs-number">0</span>]] = singleParamsArr[<span class="hljs-number">1</span>];\n  }\n  <span class="hljs-keyword">return</span> {<span class="hljs-string">\'action\'</span>: action, <span class="hljs-string">\'params\'</span>: params};\n}\n</code></pre>\n<p data-nodeid="35636">上面这段代码和前端解析 url 的代码逻辑完全一致，使用 ? 来分割 path 和参数两部分，再使用 &amp; 来获取参数的 key 和 value。解析出 path 和页面参数后，我们需要根据具体的 path 来跳转到相应的组件页面，并将解析出来的页面参数带入到组件中，代码如下。</p>\n<pre class="lang-dart" data-nodeid="35637"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">根据url处理获得需要跳转的action页面以及需要携带的参数</span></span>\nWidget _getPage(<span class="hljs-built_in">String</span> url, <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; urlParseRet) {\n  <span class="hljs-keyword">if</span> (url.startsWith(<span class="hljs-string">\'https://\'</span>) || url.startsWith(<span class="hljs-string">\'http://\'</span>)) {\n    <span class="hljs-keyword">return</span> CommonWebViewPage(url: url);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(url.startsWith(appScheme)) {\n    <span class="hljs-comment">// 判断是否解析出 path action，并且能否在路由配置中找到</span>\n    <span class="hljs-built_in">String</span> pathAction = urlParseRet[<span class="hljs-string">\'action\'</span>].toString();\n    <span class="hljs-keyword">switch</span> (pathAction) {\n      <span class="hljs-keyword">case</span> <span class="hljs-string">"homepage"</span>: {\n        <span class="hljs-keyword">return</span> _buildPage(HomePageIndex());\n      }\n      <span class="hljs-keyword">case</span> <span class="hljs-string">"userpage"</span>: {\n        <span class="hljs-comment">// 必要性检查，如果没有参数则不做任何处理</span>\n        <span class="hljs-keyword">if</span>(urlParseRet[<span class="hljs-string">\'params\'</span>][<span class="hljs-string">\'user_id\'</span>].toString() == <span class="hljs-keyword">null</span>) {\n          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n        }\n        <span class="hljs-keyword">return</span> _buildPage(\n            UserPageIndex(\n                userId: urlParseRet[<span class="hljs-string">\'params\'</span>][<span class="hljs-string">\'user_id\'</span>].toString()\n            )\n        );\n      }\n      <span class="hljs-keyword">default</span>: {\n        <span class="hljs-keyword">return</span> _buildPage(HomePageIndex());\n      }\n    }\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n}\n</code></pre>\n<p data-nodeid="35638">首先就是判断是否以 http 和 https 开头，如果是则使用网页打开，如果不是则继续判断是否符合 App Scheme 信息，符合则解析出相应的 path 和参数信息，并且根据 path 调用对应的页面组件，打开相应的页面信息。如果匹配不到或者不符合 App Scheme 则不做任何处理。</p>\n<p data-nodeid="35639">最后为该 Router 类添加一个可外部调用的函数，执行页面跳转，代码如下。</p>\n<pre class="lang-dart" data-nodeid="35640"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">执行页面跳转</span></span>\n<span class="hljs-keyword">void</span> push(BuildContext context, <span class="hljs-built_in">String</span> url) {\n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; urlParseRet = _parseUrl(url);\n  <span class="hljs-comment">// 不同页面，则跳转</span>\n  Navigator.push(context, MaterialPageRoute(builder: (context) {\n    <span class="hljs-keyword">return</span> _getPage(url, urlParseRet);\n  }));\n}\n</code></pre>\n<p data-nodeid="35641">上面逻辑会存在一些问题，主要问题是没有考虑到当前页面，无论什么情况下都会打开一个新的页面，这样会很耗费机器资源，接下来我就介绍下如何优化这块逻辑。</p>\n<h4 data-nodeid="35642">进阶版本</h4>\n<p data-nodeid="35643">进阶版本的目的是判断当前是否有打开页面，如果打开了页面则替换和刷新旧页面，如果没有则打开新的页面。分为以下两点来分析：</p>\n<ol data-nodeid="35644">\n<li data-nodeid="35645">\n<p data-nodeid="35646">了解页面标识，具体打开的页面路由名称；</p>\n</li>\n<li data-nodeid="35647">\n<p data-nodeid="35648">判断当前打开的页面，如果已经打开则更新，未打开则新建窗口；</p>\n</li>\n</ol>\n<p data-nodeid="35649">首先，我们需要使用到 Flutter 路由注册功能，我们需要修改 main.dart 中的代码，在 build MaterialApp 组件中增加两个函数，代码如下：</p>\n<pre class="lang-dart" data-nodeid="35650"><code data-language="dart"><span class="hljs-keyword">return</span> MaterialApp(\n    title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字</span>\n    debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>,\n    theme: ThemeData(\n      primarySwatch: Colors.blue, <span class="hljs-comment">// APP 主题</span>\n    ),\n    routes: Router().registerRouter(),\n    home: Scaffold(\n        appBar: AppBar(\n          title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n        ),\n        body: Center(\n          child: Entrance(),\n        )));\n</code></pre>\n<p data-nodeid="35651">上面代码中的第 7 行是注册路由名字，我们看下 Router 中的实现。</p>\n<pre class="lang-dart" data-nodeid="35652"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">注册路由事件</span></span>\n<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Widget <span class="hljs-built_in">Function</span>(BuildContext)&gt; registerRouter () {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-string">\'homepage\'</span> : (context) =&gt; _buildPage(HomePageIndex()),\n    <span class="hljs-string">\'userpage\'</span> : (context) =&gt; _buildPage(UserPageIndex())\n  };\n}\n</code></pre>\n<p data-nodeid="35653">按照这个方式注册其他的页面信息即可，接下来我们着重看下 push 的方法。</p>\n<pre class="lang-dart" data-nodeid="35654"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">执行页面跳转</span></span>\n<span class="hljs-keyword">void</span> push(BuildContext context, <span class="hljs-built_in">String</span> url) {\n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; urlParseRet = _parseUrl(url);\n  Navigator.pushNamedAndRemoveUntil(\n      context,\n      urlParseRet[<span class="hljs-string">\'action\'</span>].toString(), (route) {\n            <span class="hljs-keyword">if</span>(route.settings.name ==\n                urlParseRet[<span class="hljs-string">\'action\'</span>].toString()) {\n              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n            }\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n          }, arguments: urlParseRet[<span class="hljs-string">\'params\'</span>]);\n  }\n}\n</code></pre>\n<p data-nodeid="35655">在原来的基础上我们修改了方法，使用到了 pushNamedAndRemoveUntil 方法，并且在第二个回调参数中判断是否为当前页面，如果是则返回 false，否则返回 true。这种方式有个缺点就是在具体的 pages 页面中不能直接通过构造函数去获取参数，必须使用下面的方式。</p>\n<pre class="lang-dart" data-nodeid="35656"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-built_in">Map</span> dataInfo = JsonConfig.objectToMap(\n      ModalRoute.of(context).settings.arguments\n  );\n  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement build</span>\n  <span class="hljs-keyword">return</span> Text(<span class="hljs-string">\'I am use page <span class="hljs-subst">${dataInfo[<span class="hljs-string">\'userId\'</span>]}</span>\'</span>);\n}\n</code></pre>\n<p data-nodeid="35657">获取的方式是第 3 到 5 行，这段逻辑还必须在 build 中，存在一定缺陷，现阶段还没有找到其他的解决方案，后续有解决方案再通过源码进行更新。</p>\n<p data-nodeid="35658">以上就是整个 router.dart 的实现逻辑，这样就可以在 APP 内的页面实现跳转，接下来我们看看如何在 App 外也能使用这个 Scheme，拉起 App。</p>\n<h3 data-nodeid="35659">外部跳转</h3>\n<p data-nodeid="35660">该功能的实现，需要使用 <a href="https://pub.dev/packages/uni_links" data-nodeid="35754">uni_links</a> 第三方库来协助完成外部页面的 Scheme，在 pubspec.yaml 中增加依赖，然后更新本地库文件。由于 Android 和 iOS 在配置上会有点区别，因此这里分别来介绍。</p>\n<h4 data-nodeid="35661">Android 流程</h4>\n<p data-nodeid="35662">在项目中找到这个路径下的文件</p>\n<pre class="lang-java" data-nodeid="35663"><code data-language="java">android/app/src/main/AndroidManifest.xml\n</code></pre>\n<p data-nodeid="35664">在配置的 application 下的 activity 内增加如下配置：</p>\n<pre class="lang-xml" data-nodeid="35665"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.VIEW"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.BROWSABLE"</span>/&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>\n        <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"tyfapp"</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>\n</code></pre>\n<p data-nodeid="35666">第 6 行代码就是声明这个 App 的 Scheme 的协议。</p>\n<h4 data-nodeid="35667">iOS 流程</h4>\n<p data-nodeid="35668">在项目中找到这个路径下的文件</p>\n<pre class="lang-java" data-nodeid="35669"><code data-language="java">ios/Runner/info.plist\n</code></pre>\n<p data-nodeid="35670">在 dict 内增加下面的配置：</p>\n<pre class="lang-xml" data-nodeid="35671"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>CFBundleURLTypes<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>CFBundleTypeRole<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Editor<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>CFBundleURLName<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Two You<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>CFBundleURLSchemes<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>tyfapp<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>\n</code></pre>\n<p data-nodeid="35672">其中的第 9 行声明 App 的 Scheme。<br>\n以上就完成了基础的配置，接下来我们就使用 uni_links 来实现 Scheme 的监听。</p>\n<h4 data-nodeid="35673">Uni_links 实现外部跳转</h4>\n<p data-nodeid="35674">首先我们在 pages 目录下新建一个主入口文件 entrance.dart ，该文件需要设计为一个有状态类组件。在组件中最关键的是监听获取到打开 App 的链接地址，实现的方式如下代码。</p>\n<pre class="lang-dart" data-nodeid="35675"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">使用[String]链接实现</span></span>\nFuture&lt;<span class="hljs-keyword">void</span>&gt; initPlatformStateForStringUniLinks() <span class="hljs-keyword">async</span> {\n  <span class="hljs-built_in">String</span> initialLink;\n  <span class="hljs-comment">// Platform messages may fail, so we use a try/catch PlatformException.</span>\n  <span class="hljs-keyword">try</span> {\n    initialLink = <span class="hljs-keyword">await</span> getInitialLink();\n    <span class="hljs-keyword">if</span> (initialLink != <span class="hljs-keyword">null</span>) {\n      <span class="hljs-comment">//  跳转到指定页面</span>\n      router.push(context, initialLink);\n    }\n  } <span class="hljs-keyword">on</span> PlatformException {\n    initialLink = <span class="hljs-string">\'Failed to get initial link.\'</span>;\n  } <span class="hljs-keyword">on</span> FormatException {\n    initialLink = <span class="hljs-string">\'Failed to parse the initial link as Uri.\'</span>;\n  }\n  <span class="hljs-comment">// Attach a listener to the links stream</span>\n  _sub = getLinksStream().listen((<span class="hljs-built_in">String</span> link) {\n    <span class="hljs-keyword">if</span> (!mounted || link == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;\n    <span class="hljs-comment">//  跳转到指定页面</span>\n    router.push(context, link);\n  }, onError: (<span class="hljs-built_in">Object</span> err) {\n    <span class="hljs-keyword">if</span> (!mounted) <span class="hljs-keyword">return</span>;\n  });\n</code></pre>\n<p data-nodeid="35676">其中第 6 行是处理在外部直接拉起 App 的业务逻辑，第 17 行则表示当前 App 处于打开状态，监听外部拉起事件，监听变化后处理相应的跳转逻辑。由于组件中有一个监听事件，为了避免组件被销毁后还在监听，因此需要在组件销毁阶段移除监听事件，代码如下：</p>\n<pre class="lang-dart" data-nodeid="35677"><code data-language="dart"><span class="hljs-meta">@override</span>\n<span class="hljs-keyword">void</span> dispose() {\n  <span class="hljs-keyword">super</span>.dispose();\n  <span class="hljs-keyword">if</span> (_sub != <span class="hljs-keyword">null</span>) _sub.cancel();\n}\n</code></pre>\n<p data-nodeid="35678">为了验证效果，使用了一个 <a href="https://love-flutter.github.io/test-page/index.html" data-nodeid="35776">github 上创建的测试页面</a>。接下来我们运行下程序，然后在手机模拟器中打开测试页面，可以看到如图 1 所示的效果。</p>\n<p data-nodeid="35679"><img src="https://s0.lgstatic.com/i/image/M00/2F/E1/Ciqc1F8IDbaAIpJ7AESu3z7EomU793.gif" alt="1.gif" data-nodeid="35780"></p>\n<div data-nodeid="35680"><p style="text-align:center">图 1 Scheme 实现运行效果</p></div>\n<p data-nodeid="35681">以上就实现了 Scheme 可以直接在内外部使用的跳转逻辑。不过 Scheme 在 App 外部存在一些体验方面的问题，比如：</p>\n<ul data-nodeid="35682">\n<li data-nodeid="35683">\n<p data-nodeid="35684">当需要被拉起的 App 没有被安装时，这个链接就不会生效；</p>\n</li>\n<li data-nodeid="35685">\n<p data-nodeid="35686">在大部分 App 内 Scheme 是被禁用的，因此在用户体验的时候会非常差；</p>\n</li>\n<li data-nodeid="35687">\n<p data-nodeid="35688">注册的 Scheme 相同导致冲突；</p>\n</li>\n</ul>\n<p data-nodeid="35689">为了解决上述问题，Andorid 和 iOS 都提供了一套解决方案，在 Android 叫作 App link / Deep links ，在 iOS 叫作 Universal Links / Custom URL schemes。解决的方案就是在未安装 App 时可提供网页跳转，其次可以使用 https 和 http 域名链接的方式来进一步提升唯一性。</p>\n<p data-nodeid="35690"><strong data-nodeid="35789">App link / Deep links</strong></p>\n<p data-nodeid="35691">应用链接仅适用于 https 方案，并且需要指定的主机以及托管文件 assetlinks.json，该配置文件可参考如下：</p>\n<pre class="lang-json" data-nodeid="35692"><code data-language="json">[{\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"relation"</span>: [<span class="hljs-string">"delegate_permission/common.handle_all_urls"</span>],\n&nbsp; &nbsp; &nbsp; <span class="hljs-attr">"target"</span>: {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"namespace"</span>: <span class="hljs-string">"android_app"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"package_name"</span>: <span class="hljs-string">"com.example"</span>,\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">"sha256_cert_fingerprints"</span>:\n&nbsp; &nbsp; &nbsp; &nbsp; [<span class="hljs-string">"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"</span>]\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }]\n</code></pre>\n<ul data-nodeid="35693">\n<li data-nodeid="35694">\n<p data-nodeid="35695">package_name，在应用的 build.gradle 文件中声明的应用 ID；</p>\n</li>\n<li data-nodeid="35696">\n<p data-nodeid="35697">sha256_cert_fingerprints：应用签名证书的 SHA256 指纹，你可以利用 Java 密钥工具。</p>\n</li>\n</ul>\n<p data-nodeid="35698">配置好该文件后，同样是修改下面路径下的文件。</p>\n<pre class="lang-java" data-nodeid="35699"><code data-language="java">android/app/src/main/AndroidManifest.xml\n</code></pre>\n<p data-nodeid="35700">在配置的 application 下的 activity 内增加如下配置：</p>\n<pre class="lang-xml" data-nodeid="35701"><code data-language="xml"><span class="hljs-comment">&lt;!-- App Links --&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:autoVerify</span>=<span class="hljs-string">"true"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.VIEW"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.BROWSABLE"</span> /&gt;</span>\n        <span class="hljs-comment">&lt;!-- Accepts URIs that begin with https://YOUR_HOST --&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">data</span>\n          <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"https"</span>\n          <span class="hljs-attr">android:host</span>=<span class="hljs-string">"[YOUR_HOST]"</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>\n</code></pre>\n<p data-nodeid="35702">具体的过程，你可以在线上项目开发过程中尝试应用。</p>\n<p data-nodeid="35703"><strong data-nodeid="35805">Universal Links / Custom URL schemes</strong></p>\n<p data-nodeid="35704">该方法也是需要一个主机域名来启动应用，因此需要服务的一个在线配置，例如：<a href="https://www.example.test" data-nodeid="35809">https://www.example.test</a>/apple-app-site-association 获取 apple-app-site-association 的配置文件如下。</p>\n<pre class="lang-java" data-nodeid="35705"><code data-language="java">{\n    <span class="hljs-string">"applinks"</span>: {\n        <span class="hljs-string">"apps"</span>: [],\n        <span class="hljs-string">"details"</span>: [\n            {\n                <span class="hljs-string">"appID"</span>: <span class="hljs-string">"8LX3M43WHV.me.gexiao.me"</span>,\n                <span class="hljs-string">"paths"</span>: [ <span class="hljs-string">"/*"</span> ]\n            }\n        ]\n    }\n}\n</code></pre>\n<p data-nodeid="35706">同样我们需要修改下面路径的文件。</p>\n<pre class="lang-java" data-nodeid="35707"><code data-language="java">ios/Runner/info.plist\n</code></pre>\n<p data-nodeid="35708">在 dict 内增加下面的配置：</p>\n<pre class="lang-xml" data-nodeid="35709"><code data-language="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>com.apple.developer.associated-domains<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>applinks:[YOUR_HOST]<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>\n <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>\n</code></pre>\n<p data-nodeid="35710">以上就是外部跳转的实现方案，实现外部跳转的 App Links 和 Universal Link 功能，由于需要域名部署，我这里就没有实际应用，具体你可以在项目开发中尝试。</p>\n<h3 data-nodeid="35711">总结</h3>\n<p data-nodeid="35712">本课时介绍了在 Flutter 中路由跳转以及外部 Scheme 启动 App 的方法，最后简单介绍了 App Links 和 Universal Link 的知识点。学完本课时你需要掌握开发 Flutter 路由跳转基础技巧，并且能够应用 uni_links 库实现外部 Scheme 启动 App 功能。</p>\n<p data-nodeid="38825">下一课时我将介绍 Flutter 中各种导航栏的设计，我会在本课时的基础上增加导航栏功能，其次我也会实现首页和个人页面的代码逻辑。</p>\n<p data-nodeid="51691" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="51694">点击链接，查看本课时源码。</a></p>',
          },
          {
            theme: '11 | 多样式导航栏：掌握所有 Flutter 导航栏的设计',
            id: 313,
            content:
              '<p data-nodeid="47173" class="">本课时将介绍一些比较通用的导航栏功能，并应用上一课时的知识来实现导航栏跳转对应页面的功能。</p>\n<h3 data-nodeid="47174">导航栏样式效果</h3>\n<p data-nodeid="47175">目前较为常见三种导航栏功能：底部导航栏、顶部导航栏和侧边导航栏。为了更好的界面效果，我在导航栏基础上增加了搜索功能模块的实现，完善了整个界面交互效果。我们先来看看这三种导航栏+搜索功能的运行效果。</p>\n<p data-nodeid="47176"><img src="https://s0.lgstatic.com/i/image/M00/32/E7/CgqCHl8O3yKAXVpIAAr_4vHP8yw482.gif" alt="11.gif" data-nodeid="47241"><br>\n图 1 底部导航栏+搜索栏</p>\n<p data-nodeid="47177"><img src="https://s0.lgstatic.com/i/image/M00/32/E7/CgqCHl8O3y6ANmY5ABTLVrhmzuE224.gif" alt="22.gif" data-nodeid="47246"><br>\n图 2 顶部导航栏+搜索栏</p>\n<p data-nodeid="47178"><img src="https://s0.lgstatic.com/i/image/M00/32/DC/Ciqc1F8O3z-ARRi7ABZtQ8SwZzo652.gif" alt="33.gif" data-nodeid="47251"><br>\n图 3 侧边栏+搜索栏+底部导航栏</p>\n<p data-nodeid="47179"><img src="https://s0.lgstatic.com/i/image/M00/32/E7/CgqCHl8O30yAND7IABhCW3e0Ytk015.gif" alt="44.gif" data-nodeid="47256"><br>\n图 4 侧边栏+搜索栏+顶部导航栏</p>\n<p data-nodeid="47180">上面就是本课时所需要实现的全部导航栏功能，接下来我们就逐个介绍下如何实现该功能。</p>\n<h3 data-nodeid="47181">导航栏实现</h3>\n<p data-nodeid="47182">导航栏功能会涉及 Flutter 中几个核心点，我们使用如下表格的方式来说明，后续内容遇到相应的知识点后，可以直接对照表格 1 。</p>\n<p data-nodeid="47183"><img src="https://s0.lgstatic.com/i/image/M00/32/AC/Ciqc1F8Os9eAcJO5AAB1aFqjuhE322.png" alt="image (5).png" data-nodeid="47264"></p>\n<div data-nodeid="47184"><p style="text-align:center">图 1 底部导航栏+搜索栏</p></div>\n<p data-nodeid="47185">可以看到上述导航栏都是 Scaffold 的一个属性，这就类似于一个架子，架子提供了很多模块。如果我们需要某些模块，只需要按照模块的格式插入数据，就可以实现相应功能。这个控件的一些参数应用具体如下。</p>\n<pre class="lang-dart" data-nodeid="47186"><code data-language="dart"><span class="hljs-keyword">const</span> Scaffold({\n  Key key,\n  <span class="hljs-keyword">this</span>.appBar, <span class="hljs-comment">// 应用栏，显示在顶部，包括其中的搜索框</span>\n  <span class="hljs-keyword">this</span>.body, <span class="hljs-comment">// 页面的主题显示内容</span>\n  <span class="hljs-keyword">this</span>.floatingActionButton, <span class="hljs-comment">// 设置显示在上层区域的按钮，默认位置位于右下角</span>\n  <span class="hljs-keyword">this</span>.floatingActionButtonLocation, <span class="hljs-comment">// 设置floatingActionButton的位置</span>\n  <span class="hljs-keyword">this</span>.floatingActionButtonAnimator, <span class="hljs-comment">// floatingActionButton动画</span>\n  <span class="hljs-keyword">this</span>.persistentFooterButtons, <span class="hljs-comment">// 在底部导航栏之上的一组操作按钮</span>\n  <span class="hljs-keyword">this</span>.drawer, <span class="hljs-comment">// 左侧导航栏</span>\n  <span class="hljs-keyword">this</span>.endDrawer, <span class="hljs-comment">// 右侧导航栏</span>\n  <span class="hljs-keyword">this</span>.bottomNavigationBar, <span class="hljs-comment">// 底部导航栏</span>\n  <span class="hljs-keyword">this</span>.bottomSheet, <span class="hljs-comment">// 底部可隐藏导航栏</span>\n  <span class="hljs-keyword">this</span>.backgroundColor, <span class="hljs-comment">// 内容区域颜色</span>\n  <span class="hljs-keyword">this</span>.resizeToAvoidBottomPadding, <span class="hljs-comment">// 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。</span>\n  <span class="hljs-keyword">this</span>.resizeToAvoidBottomInset, <span class="hljs-comment">//键盘弹出时是否重新绘制，以避免输入框被遮挡</span>\n  <span class="hljs-keyword">this</span>.primary = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 是否计算手机顶部状态栏的高度</span>\n  <span class="hljs-keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start, <span class="hljs-comment">// 拖动的处理</span>\n  <span class="hljs-keyword">this</span>.extendBody = <span class="hljs-keyword">false</span>, <span class="hljs-comment">// 是否延伸body至底部</span>\n  <span class="hljs-keyword">this</span>.extendBodyBehindAppBar = <span class="hljs-keyword">false</span>, <span class="hljs-comment">// 是否延伸body至顶部</span>\n  <span class="hljs-keyword">this</span>.drawerScrimColor, <span class="hljs-comment">// 抽屉遮罩层背景色</span>\n  <span class="hljs-keyword">this</span>.drawerEdgeDragWidth, <span class="hljs-comment">// 滑动拉出抽屉的生效距离</span>\n  <span class="hljs-keyword">this</span>.drawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 确定是否可以通过拖动手势打开Scaffold.drawer, 默认情况下，拖动手势处于启用状态</span>\n  <span class="hljs-keyword">this</span>.endDrawerEnableOpenDragGesture = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 确定是否可以使用拖动手势打开Scaffold.endDrawer，默认情况下，拖动手势处于启用状态。</span>\n})\n</code></pre>\n<h4 data-nodeid="47187">1. 底部导航栏</h4>\n<p data-nodeid="47188">根据控件 Scaffold 的说明，其中涉及 bottomNavigationBar 这个属性名，在表格 1 中有说明到该属性对应的是一个 BottomNavigationBar 组件，该组件的属性也比较多，如下所示。</p>\n<pre class="lang-dart" data-nodeid="47189"><code data-language="dart">BottomNavigationBar({\n  Key key,\n  <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.items, <span class="hljs-comment">// 数组，对应于BottomNavigationBarItem这个组件为菜单栏的每一项，其中包含四个属性icon、title、activeIcon和backgroundColor</span>\n  <span class="hljs-keyword">this</span>.onTap, <span class="hljs-comment">// 点击触发逻辑，一般用来触发页面的跳转更新</span>\n  <span class="hljs-keyword">this</span>.currentIndex = <span class="hljs-number">0</span>, <span class="hljs-comment">// 当前所在的 items 数组中的位置</span>\n  <span class="hljs-keyword">this</span>.elevation = <span class="hljs-number">8.0</span>, <span class="hljs-comment">// 设置阴影效果值</span>\n  BottomNavigationBarType type, <span class="hljs-comment">// fixed(固定位置)和shifting(浮动效果)</span>\n  Color fixedColor, <span class="hljs-comment">// 代表选中时候的颜色，不能和selectedItemColor一起使用</span>\n  <span class="hljs-keyword">this</span>.backgroundColor, <span class="hljs-comment">// 背景颜色</span>\n  <span class="hljs-keyword">this</span>.iconSize = <span class="hljs-number">24.0</span>, <span class="hljs-comment">// icon 大小</span>\n  Color selectedItemColor, <span class="hljs-comment">// 代表选中的颜色，不能和selectedItemColor一起使用</span>\n  <span class="hljs-keyword">this</span>.unselectedItemColor, <span class="hljs-comment">// 未选中时颜色</span>\n  <span class="hljs-keyword">this</span>.selectedIconTheme = <span class="hljs-keyword">const</span> IconThemeData(), <span class="hljs-comment">// 当前选中的BottomNavigationBarItem.icon中图标的大小，不透明度和颜色</span>\n  <span class="hljs-keyword">this</span>.unselectedIconTheme = <span class="hljs-keyword">const</span> IconThemeData(), <span class="hljs-comment">// 当前未选中的BottomNavigationBarItem.icon中图标的大小，不透明度和颜色</span>\n  <span class="hljs-keyword">this</span>.selectedFontSize = <span class="hljs-number">14.0</span>, <span class="hljs-comment">// 选中的字体大小</span>\n  <span class="hljs-keyword">this</span>.unselectedFontSize = <span class="hljs-number">12.0</span>, <span class="hljs-comment">// 未选中字体大小</span>\n  <span class="hljs-keyword">this</span>.selectedLabelStyle, <span class="hljs-comment">// 选中字体样式</span>\n  <span class="hljs-keyword">this</span>.unselectedLabelStyle, <span class="hljs-comment">// 未选中字体样式</span>\n  <span class="hljs-keyword">this</span>.showSelectedLabels = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 是否开启选中的样式</span>\n  <span class="hljs-built_in">bool</span> showUnselectedLabels, <span class="hljs-comment">// 是否开启未选中的样式</span>\n})\n</code></pre>\n<p data-nodeid="47190">介绍完一些基础属性以后，我们来尝试实现顶部导航栏功能。基于上一课时我们实现的两个页面功能，现在我们需要使用导航栏的方式来支持页面跳转。底部导航栏需要一个状态属性 indexValue 来控制导航栏显示位置，我们看下具体在 Scaffold 中的代码逻辑。</p>\n<pre class="lang-dart" data-nodeid="47191"><code data-language="dart"><span class="hljs-keyword">return</span> Scaffold(\n  appBar: AppBar(\n    title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n  ),\n  body: Stack(\n    children: &lt;Widget&gt;[\n      _getPagesWidget(<span class="hljs-number">0</span>),\n      _getPagesWidget(<span class="hljs-number">1</span>),\n      _getPagesWidget(<span class="hljs-number">2</span>)\n    ],\n  ),\n  bottomNavigationBar: BottomNavigationBar(\n    items: [\n      BottomNavigationBarItem(\n        icon: Icon(Icons.people),\n        title: Text(<span class="hljs-string">\'推荐\'</span>),\n        activeIcon: Icon(Icons.people_outline),\n      ),\n      BottomNavigationBarItem(\n        icon: Icon(Icons.favorite),\n        title: Text(<span class="hljs-string">\'关注\'</span>),\n        activeIcon: Icon(Icons.favorite_border),\n      ),\n      BottomNavigationBarItem(\n        icon: Icon(Icons.person),\n        title: Text(<span class="hljs-string">\'我\'</span>),\n        activeIcon: Icon(Icons.person_outline),\n      ),\n    ],\n    iconSize: <span class="hljs-number">24</span>,\n    currentIndex: _indexNum,\n    <span class="hljs-comment">/// <span class="markdown">选中后，底部BottomNavigationBar内容的颜色(选中时，默认为主题色)</span></span>\n    <span class="hljs-comment">/// <span class="markdown">（仅当type: BottomNavigationBarType.fixed,时生效）</span></span>\n    fixedColor: Colors.lightBlueAccent,\n    type: BottomNavigationBarType.fixed,\n    onTap: (<span class="hljs-built_in">int</span> index) {\n      <span class="hljs-comment">///<span class="markdown">这里根据点击的index来显示，非index的page均隐藏</span></span>\n      <span class="hljs-keyword">if</span>(_indexNum != index){\n        setState(() {\n          _indexNum = index;\n        });\n      }\n    },\n  ),\n);\n</code></pre>\n<p data-nodeid="47192">上面代码中，第 5 - 10 行是获取具体的页面信息，并且在 _getPagesWidget 里会判断当前 index 的值，判断当前索引 _indexNum 与 index 是否相同，相同则显示页面，不相同则页面隐藏，具体 _getPagesWidget 代码实现逻辑如下：</p>\n<pre class="lang-dart" data-nodeid="47193"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取页面组件</span></span>\nWidget _getPagesWidget(<span class="hljs-built_in">int</span> index) {\n  <span class="hljs-built_in">List</span>&lt;Widget&gt; widgetList = [\n    router.getPageByRouter(<span class="hljs-string">\'homepage\'</span>),\n    Icon(Icons.directions_transit),\n    router.getPageByRouter(<span class="hljs-string">\'userpage\'</span>)\n  ];\n  <span class="hljs-keyword">return</span> Offstage(\n    offstage: _indexNum != index,\n    child: TickerMode(\n      enabled: _indexNum == index,\n      child: widgetList[index],\n    ),\n  );\n}\n</code></pre>\n<p data-nodeid="47194">上面代码中又使用到了 router 的一个新方法，该方法组件是获取对应 router 名称的组件页面信息，具体代码在 router 中实现，可以参考 github 源码，没有特殊性。</p>\n<p data-nodeid="47195">Scaffold 中代码的第 12 行开始实现底部导航栏逻辑，其中使用到了 BottomNavigationBar 控件，配置控件中的 items 属性，该属性注意是导航栏具体每一项数据，iconSize、currentIndex、fixedColor、type 和 onTap，onTap 主要是来切换页面，触发 setState ，然后重新 build 页面结构。</p>\n<p data-nodeid="47196">以上就完成了导航栏的设计，运行完以后，就可以正常进行页面切换操作。但是这里存在一些问题，比如在我们上一课时提到的外部拉起 APP 功能，如果拉起的是首页，我们不应该再去 push 一个新的页面，而是打开首页并且根据具体的页面跳转到具体的 tab 下，因此这里需要将 router 中的 push 进行修改。</p>\n<p data-nodeid="47197">我们将原来的 push 改为 open，并且对代码做了修改，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="47198"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">执行页面跳转</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 需要特别注意以下逻辑</span></span>\n<span class="hljs-comment">/// <span class="markdown">-1 不在首页，则执行跳转</span></span>\n<span class="hljs-comment">/// <span class="markdown">大于 -1 则为首页，需要在首页进行 tab 切换，而不是进行跳转</span></span>\n<span class="hljs-built_in">int</span> open(BuildContext context, <span class="hljs-built_in">String</span> url) {\n  <span class="hljs-comment">// 非entrance入口标识</span>\n  <span class="hljs-built_in">int</span> notEntrancePageIndex = <span class="hljs-number">-1</span>;\n  <span class="hljs-keyword">if</span> (url.startsWith(<span class="hljs-string">\'https://\'</span>) || url.startsWith(<span class="hljs-string">\'http://\'</span>)) {\n    <span class="hljs-comment">// 打开网页</span>\n    Navigator.push(context, MaterialPageRoute(builder: (context) {\n      <span class="hljs-keyword">return</span> CommonWebViewPage(url: url);\n    }));\n    <span class="hljs-keyword">return</span> notEntrancePageIndex;\n  }\n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; urlParseRet = _parseUrl(url);\n  <span class="hljs-built_in">int</span> entranceIndex = routerMapping[urlParseRet[<span class="hljs-string">\'action\'</span>]].entranceIndex;\n  <span class="hljs-keyword">if</span> (entranceIndex &gt; notEntrancePageIndex) {\n    <span class="hljs-comment">// 判断为首页，返回切换的tab信息</span>\n    <span class="hljs-keyword">return</span> entranceIndex;\n  }\n  Navigator.pushNamedAndRemoveUntil(context, urlParseRet[<span class="hljs-string">\'action\'</span>].toString(),\n      (route) {\n    <span class="hljs-keyword">if</span> (route.settings.name == urlParseRet[<span class="hljs-string">\'action\'</span>].toString()) {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n  }, arguments: urlParseRet[<span class="hljs-string">\'params\'</span>]);\n  <span class="hljs-comment">// 执行跳转，非首页</span>\n  <span class="hljs-keyword">return</span> notEntrancePageIndex;\n}\n</code></pre>\n<p data-nodeid="47199">上面代码与我们之前唯一的不同在于，判断是否在 entrance 页面，如果是则返回相应 tab 的 index，而不是直接进行跳转。如果不是则进行跳转，并返回一个 -1 notEntrancePageIndex。因为返回不一样，因此在 entrance.dart 中也需要对返回的信息做一定的处理，处理部分代码如下。</p>\n<pre class="lang-dart" data-nodeid="47200"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">跳转页面</span></span>\n<span class="hljs-keyword">void</span> redirect(<span class="hljs-built_in">String</span> link) {\n  <span class="hljs-keyword">if</span> (link == <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">return</span>;\n  }\n  <span class="hljs-built_in">int</span> indexNum = router.open(context, link);\n  <span class="hljs-keyword">if</span> (indexNum &gt; <span class="hljs-number">-1</span> &amp;&amp; _indexNum != indexNum) {\n    setState(() {\n      _indexNum = indexNum;\n    });\n  }\n}\n</code></pre>\n<p data-nodeid="47201">代码主要是判断是否返回非 -1 以及两个 index 不相等，这时候就使用 setState 来切换导航栏 tab。</p>\n<h4 data-nodeid="47202">2. 顶部导航栏</h4>\n<p data-nodeid="47203">在表格 1 中我们看到顶部导航栏，需要控件 Scaffold 属性 appBar ，在 appBar 中设置 bottom 就可以实现顶部导航栏功能。接下来看下 bottom 的设置方法，代码如下：</p>\n<pre class="lang-dart" data-nodeid="47204"><code data-language="dart"><span class="hljs-keyword">return</span> Scaffold(\n  appBar: AppBar(\n    title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n    bottom: TabBar(\n      controller: _controller,\n      tabs: &lt;Widget&gt;[\n        Tab(\n          icon: Icon(Icons.view_list),\n          text: <span class="hljs-string">\'推荐\'</span>,\n        ),\n        Tab(\n          icon: Icon(Icons.favorite),\n          text: <span class="hljs-string">\'关注\'</span>,\n        ),\n        Tab(\n          icon: Icon(Icons.person),\n          text: <span class="hljs-string">\'我\'</span>,\n        ),\n      ],\n    ),\n  ),\n  body: TabBarView(\n    controller: _controller,\n    children: [\n      router.getPageByRouter(<span class="hljs-string">\'homepage\'</span>),\n      Icon(Icons.directions_transit),\n      router.getPageByRouter(<span class="hljs-string">\'userpage\'</span>)\n    ],\n  ),\n);\n</code></pre>\n<p data-nodeid="47205">在上面代码中的第 4 到第 21 行是在设置 bottom 的 TabBar 组件。在 TabBar 中，包含了一个控制导航栏的 controller 和具体导航栏的配置信息的 Tabs。在代码第 22 行到第 29 行也是在配置各个 tab 对应的页面内容组件，这里也是通过 controller 来控制显示，具体 controller 控制部分代码如下。</p>\n<pre class="lang-dart" data-nodeid="47206"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">跳转页面</span></span>\n<span class="hljs-keyword">void</span> redirect(<span class="hljs-built_in">String</span> link) {\n  <span class="hljs-keyword">if</span> (link == <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">return</span>;\n  }\n  <span class="hljs-built_in">int</span> indexNum = router.open(context, link);\n  <span class="hljs-keyword">if</span> (indexNum &gt; <span class="hljs-number">-1</span> &amp;&amp; _controller.index != indexNum) {\n    _controller.animateTo(indexNum);\n  }\n}\n</code></pre>\n<p data-nodeid="47207">顶部导航栏的跳转逻辑部分和底部导航栏相似，这里是使用状态变量 _controller 的 animateTo 方法来处理 tab 的切换。其他部分代码改动和底部导航栏都基本一致，具体代码参考 github 源码。</p>\n<h4 data-nodeid="47208">3. 侧边导航栏</h4>\n<p data-nodeid="47209">侧边栏在表格 1 中，可以看到使用的是 Scaffold 的 drawer 属性。该属性需要一个 Drawer 对象，因此我们在 Widgets 目录中创建一个 menu 目录，并新增 draw.dart 文件，具体代码如下。</p>\n<pre class="lang-dart" data-nodeid="47210"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/router.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">左侧菜单</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuDraw</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">外部跳转</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Function</span> redirect;\n  <span class="hljs-comment">/// <span class="markdown">默认构造函数</span></span>\n  <span class="hljs-keyword">const</span> MenuDraw(<span class="hljs-keyword">this</span>.redirect);\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Drawer(\n        child: MediaQuery.removePadding(\n          context: context,\n          child: ListView(\n            children: &lt;Widget&gt;[\n              ListTile(\n                leading: Icon(Icons.view_list),\n                title: Text(<span class="hljs-string">\'推荐\'</span>),\n                onTap: () {\n                  Navigator.pop(context);\n                  redirect(<span class="hljs-string">\'tyfapp://homepage\'</span>);\n                },\n              ),\n              ListTile(\n                leading: Icon(Icons.favorite),\n                title: Text(<span class="hljs-string">\'关注\'</span>),\n                onTap: () {\n                  Navigator.pop(context);\n                  Router().open(context, <span class="hljs-string">\'http://www.qq.com\'</span>);\n                },\n              ),\n              ListTile(\n                leading: Icon(Icons.person),\n                title: Text(<span class="hljs-string">\'我\'</span>),\n                onTap: () {\n                  Navigator.pop(context);\n                  redirect(<span class="hljs-string">\'tyfapp://userpage\'</span>);\n                },\n              ),\n            ],\n          ),\n        ),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="47211">前 4 行是导入相应的库，创建 MenuDraw 类，类包含 redirect 方法，该方法就是 entrance 中声明的 tab 导航栏切换的方法，如果非 entrance 的切换则需要使用到 router 跳转，类似上面代码中的第 33 行 。</p>\n<p data-nodeid="47212">代码的第 19 行到第 44 行则为相应的左侧导航栏的配置，onTap 为导航栏的跳转逻辑，在点击相应的 Tap 以后，需要使用 Navigator.pop(context) 来关闭左侧导航栏。</p>\n<p data-nodeid="47213">实现完成该 MenuDraw 类后，我们需要在控件 Scaffold 中增加 drawer 属性，代码如下。</p>\n<pre class="lang-dart" data-nodeid="47214"><code data-language="dart"><span class="hljs-keyword">return</span> Scaffold(\n  appBar: AppBar(\n    title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n  ),\n  drawer: MenuDraw(redirect),\n  ...\n);\n</code></pre>\n<p data-nodeid="47215">上面代码的第 5 行就是新增 drawer 左侧导航栏。</p>\n<h4 data-nodeid="47216">4. 搜索功能</h4>\n<p data-nodeid="47217">为了让功能更完善，我们需要增加一个右侧搜索功能，这里就涉及表格 1 中 AppBar 的 actions 属性，我们可以在 AppBar 中增加如下代码：</p>\n<pre class="lang-dart" data-nodeid="47218"><code data-language="dart">AppBar(\n  title: Text(<span class="hljs-string">\'Two You\'</span>), <span class="hljs-comment">// 页面名字</span>\n  actions: &lt;Widget&gt;[\n    IconButton(\n      icon: Icon(Icons.search),\n      onPressed: () {\n        showSearch(\n            context: context,\n            delegate: SearchPageCustomDelegate()\n        );\n      },\n    ),\n  ],\n)\n</code></pre>\n<p data-nodeid="47219">在 actions 中可以添加一组功能按钮，由于这里我们只需要搜索功能按钮，因此在 actions 属性中添加一个 IconButton 即可。IconButton 中需要展示一个搜索 icon ，并且点击以后前往搜索页面。</p>\n<p data-nodeid="47220">接下来我们就需要实现 SearchPageCustomDelegate 的页面逻辑，新增 search_page 页面，并在 search_page 下新建 custom_delegate.dart 文件，接下来实现该文件代码。</p>\n<p data-nodeid="47221">这个类需要继承 SearchDelegate ，然后必须包含四个方法的实现逻辑，代码如下。</p>\n<pre class="lang-dart" data-nodeid="47222"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">搜索框</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchPageCustomDelegate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SearchDelegate</span> </span>{\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-built_in">List</span>&lt;Widget&gt; buildActions(BuildContext context) {\n  }\n  <span class="hljs-meta">@override</span>\n  Widget buildLeading(BuildContext context) {\n  }\n  <span class="hljs-meta">@override</span>\n  Widget buildResults(BuildContext context) {\n  }\n  <span class="hljs-meta">@override</span>\n  Widget buildSuggestions(BuildContext context) {\n  }\n}\n</code></pre>\n<p data-nodeid="47223">buildActions 为右侧的图标按钮，一般我们可以显示一个清除搜索框内容的功能，我们可以使用如下代码来实现。</p>\n<pre class="lang-dart" data-nodeid="47224"><code data-language="dart"><span class="hljs-keyword">return</span> [\n  IconButton(\n    tooltip: <span class="hljs-string">\'Clear\'</span>,\n    icon: <span class="hljs-keyword">const</span> Icon(Icons.clear),\n    onPressed: () {\n      query = <span class="hljs-string">\'\'</span>;\n      showSuggestions(context);\n    },\n  )\n];\n</code></pre>\n<p data-nodeid="47225">buildLeading 为左侧的按钮一般来触发返回操作，代码实现如下：</p>\n<pre class="lang-dart" data-nodeid="47226"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget buildLeading(BuildContext context) {\n  <span class="hljs-keyword">return</span> IconButton(\n    tooltip: <span class="hljs-string">\'Back\'</span>,\n    icon: AnimatedIcon(\n      icon: AnimatedIcons.menu_arrow,\n      progress: transitionAnimation,\n    ),\n    onPressed: () {\n      close(context, <span class="hljs-keyword">null</span>);\n    },\n  );\n}\n</code></pre>\n<p data-nodeid="47227">关闭当前页面使用 close(context, null) 即可实现。</p>\n<p data-nodeid="47228">buildResults 为搜索结果显示列表，buildSuggestions 为搜索提示列表，在这里我们返回一个空 ListView() 就行。</p>\n<p data-nodeid="47229">在上面基础上，我们需要修改默认的搜索框的提示，并且需要匹配当前主题的颜色字体等，需要做以下两部分逻辑。</p>\n<pre class="lang-dart" data-nodeid="47230"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">修改提示框内容</span></span>\n<span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> searchFieldLabel =&gt; <span class="hljs-string">\'用户、帖子\'</span>;\n<span class="hljs-meta">@override</span>\nThemeData appBarTheme(BuildContext context) {\n  <span class="hljs-keyword">final</span> ThemeData theme = Theme.of(context);\n  <span class="hljs-keyword">return</span> theme.copyWith(\n      inputDecorationTheme: InputDecorationTheme(),\n      primaryColor: theme.primaryColor,\n      primaryIconTheme: theme.primaryIconTheme,\n      primaryColorBrightness: theme.primaryColorBrightness,\n      primaryTextTheme: theme.primaryTextTheme\n  );\n}\n</code></pre>\n<p data-nodeid="50691" class="">上面代码中第 2 行是修改默认搜索框提示，第 5 至第 17 行则是匹配当前应用主题。完整代码可<a href="https://github.com/love-flutter/flutter-column" data-nodeid="50695">参考 github 源码。</a></p>\n\n<h3 data-nodeid="47232">总结</h3>\n<p data-nodeid="47233" class="">本课时介绍了控件 Scaffold 的一些基础用法，着重介绍了其中三个比较常用的属性 bottomNavigationBar、appBar 和 drawer，同时使用这些属性完成了我们顶部导航栏、底部导航栏、侧边导航栏和搜索功能的实现。学完本课时你需要掌握这些基础的导航栏设计的使用方法，其次了解控件 Scaffold 的其他属性的用法。</p>\n<p data-nodeid="50385" class="">本课时实现了 App 的基础结构，下一课时我将从内容展示的多样式来实现具体的 App 页面内容。</p>\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="47235" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="47324">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '12 | 列表样式：实践 Flutter 中内容多样式展示方式',
            id: 314,
            content:
              '<p data-nodeid="17459" class="">本课时，我将在导航栏基础上，设计一个 APP 首页推荐列表，以此来讲解 Flutter 中内容多样式的展示方式。</p>\n<p data-nodeid="17460">列表的多样式包含内容+缩略图、图片九宫格以及单图信息流。接下来我将逐一讲解这三种类型的设计和实现原理。</p>\n<h3 data-nodeid="17461">前期准备</h3>\n<p data-nodeid="17462">本课时中的列表多样式会涉及 Flutter 控件 ListView ，该控件包含了多个构造函数，比如：默认构造函数、builder、separated 和 custom。</p>\n<h4 data-nodeid="17463">ListView</h4>\n<p data-nodeid="17464">ListView 下四种构造函数的使用场景都不相同，比如：</p>\n<ul data-nodeid="17465">\n<li data-nodeid="17466">\n<p data-nodeid="17467">ListView 默认构造函数，适用于有限的小列表内容展示，一次性创建所有项目；</p>\n</li>\n<li data-nodeid="17468">\n<p data-nodeid="17469">ListView.builder 构造函数用于处理包含大量数据的列表，其次它会在列表项滚动到屏幕上时创建该列表项；</p>\n</li>\n<li data-nodeid="17470">\n<p data-nodeid="17471">ListView.separated 相比 ListView.builder 多了一个分隔符，其次更适用于固定项列表；</p>\n</li>\n<li data-nodeid="17472">\n<p data-nodeid="17473">ListView.custom 可以自定义列表结构，使用场景不多，但是 ListView.builder 与 ListView.separated 都是基于 ListView.custom 来实现的。</p>\n</li>\n</ul>\n<p data-nodeid="17689" class="">本课时因为是一个固定有限的列表，更适用于 ListView.separated ，因此本课时基于 ListView.separated 来讲解，这里我介绍下该控件的参数列表。</p>\n\n<pre class="lang-dart" data-nodeid="17475"><code data-language="dart">ListView.separated({\n  Key key,\n  Axis scrollDirection = Axis.vertical, <span class="hljs-comment">// 滑动方向，垂直</span>\n  <span class="hljs-built_in">bool</span> reverse = <span class="hljs-keyword">false</span>, <span class="hljs-comment">// 是否倒序</span>\n  ScrollController controller, <span class="hljs-comment">// 控制滚动和监听滚动事件变化</span>\n  <span class="hljs-built_in">bool</span> primary, <span class="hljs-comment">// false内容不足不滚动，true一直可滚动</span>\n  ScrollPhysics physics, <span class="hljs-comment">// 列表滚动方式设置</span>\n  <span class="hljs-built_in">bool</span> shrinkWrap = <span class="hljs-keyword">false</span>, <span class="hljs-comment">// item高度适配</span>\n  EdgeInsetsGeometry padding, <span class="hljs-comment">// padding设置</span>\n  <span class="hljs-meta">@required</span> IndexedWidgetBuilder itemBuilder, <span class="hljs-comment">// 设置列表内容</span>\n  <span class="hljs-meta">@required</span> IndexedWidgetBuilder separatorBuilder, <span class="hljs-comment">// 设置分割内容</span>\n  <span class="hljs-meta">@required</span> <span class="hljs-built_in">int</span> itemCount, <span class="hljs-comment">// 总数量</span>\n  <span class="hljs-built_in">bool</span> addAutomaticKeepAlives = <span class="hljs-keyword">true</span>,  <span class="hljs-comment">// 该属性表示是否将列表项（子组件）包裹在AutomaticKeepAlive&nbsp;组件中，主要是为了避免被垃圾回收</span>\n  <span class="hljs-built_in">bool</span> addRepaintBoundaries = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 该属性表示是否将列表项（子组件）包裹在addRepaintBoundaries&nbsp;组件中，为了避免重绘</span>\n  <span class="hljs-built_in">bool</span> addSemanticIndexes = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 该属性表示是否将列表项（子组件）包裹在addSemanticIndexes&nbsp;组件中，用来提供无障碍语义</span>\n  <span class="hljs-built_in">double</span> cacheExtent, <span class="hljs-comment">// 设置预加载区域</span>\n})\n</code></pre>\n<p data-nodeid="17476">根据以上的配置信息，我们设置了一个比较通用的配置，如下。</p>\n<pre class="lang-dart" data-nodeid="17477"><code data-language="dart">ListView.separated(\n  scrollDirection: Axis.vertical,\n  shrinkWrap: <span class="hljs-keyword">true</span>,\n  itemCount: contentList.length,\n  itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) {\n    <span class="hljs-keyword">return</span> (Widget);\n  },\n  separatorBuilder: (context, index) {\n    <span class="hljs-keyword">return</span> Divider(\n      height: <span class="hljs-number">.5</span>,\n      <span class="hljs-comment">//indent: 75,</span>\n      color: Color(<span class="hljs-number">0xFFDDDDDD</span>),\n    );\n  },\n)\n</code></pre>\n<p data-nodeid="17478">上面代码配置中，scrollDirection 设置为垂直滚动，shrinkWrap 设置为高度适配，separatorBuilder 使用灰色线条分割每列数据。</p>\n<p data-nodeid="17479">以上就是 ListView 控件的一些基本知识，介绍完基本的知识点后，我们还需要做一些编码方面的前期准备。由于该交友 APP，在列表展示的是推荐帖子，因此需要使用到相应的帖子内容相关的数据结构。根据交友 APP 的数据需要，我们设计交友帖子对应的数据结构模块 Struct 、相应获取推荐帖子内容的 API 接口以及需要状态共享的 Model。</p>\n<h4 data-nodeid="17480">Struct</h4>\n<p data-nodeid="17481">首页推荐的交友帖子数据，涉及三个具体内容：用户信息部分、交友帖子数据、帖子的评论信息。因此需要创建好三个对应的 Struct 文件。</p>\n<p data-nodeid="17482">1.user_info.dart，对应为 StructUserInfo 类，其数据结果如下。</p>\n<pre class="lang-dart" data-nodeid="17483"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">用户信息</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// {</span></span>\n<span class="hljs-comment">///   <span class="markdown">"nickname" : "string",</span></span>\n<span class="hljs-comment">///   <span class="markdown">"headerUrl" : "string",</span></span>\n<span class="hljs-comment">///   <span class="markdown">"uid" : "string"</span></span>\n<span class="hljs-comment">/// <span class="markdown">}</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StructUserInfo</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">标题</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> nickName;\n  <span class="hljs-comment">/// <span class="markdown">简要</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> headerUrl;\n  <span class="hljs-comment">/// <span class="markdown">主要内容</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> uid;\n  <span class="hljs-comment">/// <span class="markdown">默认构造函数</span></span>\n  <span class="hljs-keyword">const</span> StructUserInfo(\n      <span class="hljs-keyword">this</span>.uid,\n      <span class="hljs-keyword">this</span>.nickName,\n      <span class="hljs-keyword">this</span>.headerUrl\n      );\n}\n</code></pre>\n<p data-nodeid="17484">2.content_detail.dart，对应为 StructContentDetail 类，其数据结构比较长，我们这里只是给个 JSON 的例子，代码如下。</p>\n<pre class="lang-json" data-nodeid="17485"><code data-language="json">{\n   <span class="hljs-attr">"id"</span> : <span class="hljs-string">"string"</span>,\n   <span class="hljs-attr">"title"</span> : <span class="hljs-string">"string"</span>,\n   <span class="hljs-attr">"summary"</span> : <span class="hljs-string">"string"</span>,\n   <span class="hljs-attr">"detailInfo"</span> : <span class="hljs-string">"string"</span>,\n   <span class="hljs-attr">"uid"</span> : <span class="hljs-string">"string"</span>,\n   <span class="hljs-attr">"userInfo"</span> : <span class="hljs-string">"StructUserInfo"</span>,\n   <span class="hljs-attr">"articleImage"</span> : <span class="hljs-string">"string"</span>,\n   <span class="hljs-attr">"likeNum"</span> : <span class="hljs-string">"int"</span>,\n   <span class="hljs-attr">"commentNum"</span> : <span class="hljs-string">"int"</span>\n}\n</code></pre>\n<p data-nodeid="17486">3.comment_info.dart，对应为 StructCommentInfo 类，代码如下。</p>\n<pre class="lang-dart" data-nodeid="17487"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/user_info.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">用户信息</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// {</span></span>\n<span class="hljs-comment">///   <span class="markdown">"userInfo" : "StructUserInfo",</span></span>\n<span class="hljs-comment">///   <span class="markdown">"comment" : "string"</span></span>\n<span class="hljs-comment">/// <span class="markdown">}</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StructCommentInfo</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">用户的昵称</span></span>\n  <span class="hljs-keyword">final</span> StructUserInfo userInfo;\n  <span class="hljs-comment">/// <span class="markdown">用户头像信息</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> comment;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> StructCommentInfo(<span class="hljs-keyword">this</span>.userInfo, <span class="hljs-keyword">this</span>.comment);\n}\n</code></pre>\n<h4 data-nodeid="17488">API</h4>\n<p data-nodeid="17489">有了以上基础的数据结构后，我们再来开发对应具体的 API，通过 API 部分拉取具体的首页推荐的帖子列表。在 API 文件夹中创建一个 content 文件夹，并且在 content 文件夹中创建 index.dart API 文件类，在该类中创建三个方法（这里使用的是假数据，未真正的调用服务端）。</p>\n<p data-nodeid="17490">1.getOneById，根据内容 ID 拉取内容详情</p>\n<pre class="lang-dart" data-nodeid="17491"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">根据内容id拉取内容详情</span></span>\nStructContentDetail getOneById(<span class="hljs-built_in">String</span> id) {\n   StructContentDetail detailInfo = StructContentDetail(\n      <span class="hljs-string">\'1001\'</span>,\n      <span class="hljs-string">\'hello test\'</span>,\n      <span class="hljs-string">\'summary\'</span>,\n      <span class="hljs-string">\'detail info <span class="hljs-subst">${id}</span>\'</span>,\n      <span class="hljs-string">\'1001\'</span>,\n      <span class="hljs-number">1</span>,\n      <span class="hljs-number">2</span>,\n      <span class="hljs-string">\'https://i.pinimg.com/originals/e0/64/4b/e0644bd2f13db50d0ef6a4df5a756fd9.png\'</span>\n   );\n   StructUserInfo userInfo = ApiUserInfoIndex.getOneById(detailInfo.uid);\n   <span class="hljs-keyword">return</span> StructContentDetail(\n       detailInfo.uid, detailInfo.title,\n       detailInfo.summary, detailInfo.detailInfo,\n       detailInfo.uid, detailInfo.likeNum,detailInfo.commentNum,\n       detailInfo.articleImage, userInfo: userInfo\n   );\n}\n</code></pre>\n<p data-nodeid="17492">上面代码获取到初始的单条内容，然后基于用户信息的 API 补全用户信息部分，返回 StructContentDetail 数据结构。</p>\n<p data-nodeid="17493">2.getRecommendList，获取首页推荐的内容列表</p>\n<pre class="lang-dart" data-nodeid="17494"><code data-language="dart"><span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; getRecommendList() {\n  <span class="hljs-keyword">return</span> [\n   StructContentDetail(...),\n   StructContentDetail(...),\n  ]\n}\n</code></pre>\n<p data-nodeid="18151">这部分代码就比较简单，获取具体的推荐内容列表，并返回 List<code data-backticks="1" data-nodeid="18154">&lt;StructContentDetail&gt;</code> 列表数据。</p>\n<p data-nodeid="18152">3.getFollowList，获取关注人的内容列表</p>\n\n<p data-nodeid="17496">这部分和 getRecommendList 方法实现完全一样，其中拉取的只是关注人的帖子列表。</p>\n<h4 data-nodeid="17497">Model</h4>\n<p data-nodeid="17498">这里只涉及我们第 07 课时所演示例子的知识点——应用 Provider 来实现状态管理。实现原理一样，唯一不同点是这里需要保存多个帖子的点赞数量，因此需要将这个状态变量设计为一个 Map，其次需要将 get 方法进行修改，使用帖子 id 作为键名。下面为部分代码，其他部分代码请查看 github 源码。</p>\n<pre class="lang-dart" data-nodeid="17499"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">name状态管理模块</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeNumModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">声明私有变量</span></span>\n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">int</span>&gt; _likeInfo;\n  <span class="hljs-comment">/// <span class="markdown">设置get方法</span></span>\n  <span class="hljs-built_in">int</span> getLikeNum(<span class="hljs-built_in">String</span> articleId, [<span class="hljs-built_in">int</span> likeNum = <span class="hljs-number">0</span>]) {\n    <span class="hljs-keyword">if</span>(_likeInfo == <span class="hljs-keyword">null</span>){\n      _likeInfo = {};\n    }\n    <span class="hljs-keyword">if</span>(articleId == <span class="hljs-keyword">null</span>){\n      <span class="hljs-keyword">return</span> likeNum;\n    }\n    <span class="hljs-keyword">if</span>(_likeInfo[articleId] == <span class="hljs-keyword">null</span>) {\n      _likeInfo[articleId] = likeNum;\n    }\n\n    <span class="hljs-keyword">return</span> _likeInfo[articleId];\n  }\n}\n</code></pre>\n<p data-nodeid="17500">接下来我们就具体看下这三种列表样式的实现原理。</p>\n<h3 data-nodeid="17501">内容+缩略图</h3>\n<p data-nodeid="17502">这种样式的列表内容较为常见，每一条信息包含帖子的标题和简要信息，右侧为一个缩略图，底部栏为头像、点赞和评论相关内容，具体效果截图如下图 1。</p>\n<p data-nodeid="17503"><img src="https://s0.lgstatic.com/i/image/M00/33/F0/CgqCHl8RIO-AVjCIAANJnR6nMPc935.png" alt="图片1.png" data-nodeid="17609"></p>\n<h4 data-nodeid="17504">组件设计</h4>\n<p data-nodeid="17505">按照我们 06 课时的知识点，我们需要将界面的组件进行拆解分析，由于这部分我们在 06 课时也分析过，因此这里比较快速地分析出下面的一个组件树，如图 2 所示。</p>\n<p data-nodeid="17506"><img src="https://s0.lgstatic.com/i/image/M00/33/F0/CgqCHl8RIPyAE8_gAALBPW0-Bj0112.png" alt="图片2.png" data-nodeid="17614"></p>\n<h4 data-nodeid="17507">实现原理</h4>\n<p data-nodeid="17508">组件部分的实现逻辑，我们在 06 课时已经详细介绍过，这里就不一一细讲。接下来我们主要说下列表部分的实现，核心代码在 home_page/index.dart 中，首先还是 import 对应需要的库和组件库。</p>\n<pre class="lang-dart" data-nodeid="17509"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/api/content/index.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/home_page/article_card.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/content_detail.dart\'</span>;\n</code></pre>\n<p data-nodeid="17510">其中的 API 为我们拉取内容的接口， article_card 为我们每条展示的内容的组件， content_detail 则为 Struct 类。</p>\n<p data-nodeid="17511">为了后续动态内容的需要，这里将该类设计为一个有状态类。</p>\n<pre class="lang-dart" data-nodeid="17512"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">首页</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageIndex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> HomePageIndex({Key, key});\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageIndexState();\n}\n<span class="hljs-comment">/// <span class="markdown">具体的state类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageIndexState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePageIndex</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">首页推荐帖子列表</span></span>\n  <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; contentList;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    <span class="hljs-comment">// 拉取推荐内容</span>\n    setState(() {\n      contentList = ApiContentIndex().getRecommendList();\n    });\n  }\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<p data-nodeid="17513">上面代码中的第 20 行就是通过 API 去拉取具体的推荐内容列表，并使用 setState 来触发界面更新。接下来再看下 build 逻辑，在列表展示部分，我们需要使用到 ListView.separated 控件，下面看下这部分的核心代码。</p>\n<pre class="lang-dart" data-nodeid="17514"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-keyword">return</span> ListView.separated(\n    scrollDirection: Axis.vertical,\n    shrinkWrap: <span class="hljs-keyword">true</span>,\n    itemCount: contentList.length,\n    itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) {\n      <span class="hljs-keyword">return</span> ArticleCard(articleInfo: <span class="hljs-keyword">this</span>.contentList[position]);\n    },\n    separatorBuilder: (context, index) {\n      <span class="hljs-keyword">return</span> Divider(\n        height: <span class="hljs-number">.5</span>,\n        <span class="hljs-comment">//indent: 75,</span>\n        color: Color(<span class="hljs-number">0xFFDDDDDD</span>),\n      );\n    },\n  );\n}\n</code></pre>\n<p data-nodeid="17515">其他部分与我们一开始介绍的 ListView.separated 标准部分相同，唯一不同的就是在 itemBuilder 做了组件的插入，这里针对每个数组元素所进行的操作，都是返回一个 article_card 组件。</p>\n<p data-nodeid="17516">以上就完成了一个内容+缩略图组件的设计，接下来我们看下大图列表的设计。</p>\n<h3 data-nodeid="17517">大图列表</h3>\n<p data-nodeid="17518">大图列表是一个大小图穿插的功能，可以分为三个一行插入，奇数行显示大小图组合，偶数行显示三小图组合。其中在大小图组合中，大图位置随机为第一个或者最后一个，具体效果如图 3 所示。</p>\n<p data-nodeid="17519"><img src="https://s0.lgstatic.com/i/image/M00/33/E5/Ciqc1F8RIRaAUc1mAAfclNZgPPA347.png" alt="图片3.png" data-nodeid="17634"></p>\n<h4 data-nodeid="17520">组件设计</h4>\n<p data-nodeid="17521">根据上面的规则，我们将三个图片分为一组，则存在 2 种组件组合规则，如图 4 所示的左右图的两个组合规则。图 4 左边为三小图并列组合规则，图 4 右侧为大小图组合规则，其次这部分还可能出现两种情况，第一种是第一个为大图，第二种是最后一个为大图，也就是“大小小”和“小小大”组件组合规则。</p>\n<p data-nodeid="17522"><img src="https://s0.lgstatic.com/i/image/M00/33/E5/Ciqc1F8RISOAdHsLAAHLoId25k8599.png" alt="图片4.png" data-nodeid="17639"></p>\n<h4 data-nodeid="17523">实现原理</h4>\n<p data-nodeid="17524">我们创建 home_page/img_flow.dart 来表示这个大图列表组件的页面。然后为这个页面增加一个跳转入口，修改 11 课时中的左侧菜单栏文件 draw.dart ，将菜单名称修改为图片流，并且跳转到 tyfapp://imgflow 这个地址（这里需要去 router 中注册 imgflow 路由，注册方法如下代码的第 10 行）。</p>\n<pre class="lang-dart" data-nodeid="17525"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">路由配置信息</span></span>\n<span class="hljs-comment">/// <span class="markdown">widget 为组件</span></span>\n<span class="hljs-comment">/// <span class="markdown">entranceIndex 为首页位置，如果非首页则为-1</span></span>\n<span class="hljs-comment">/// <span class="markdown">params 为组件需要的参数数组</span></span>\n<span class="hljs-keyword">const</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, StructRouter&gt; routerMapping = {\n  <span class="hljs-string">\'homepage\'</span>: StructRouter(HomePageIndex(), <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>),\n  <span class="hljs-string">\'userpage\'</span>: StructRouter(UserPageIndex(), <span class="hljs-number">2</span>, [<span class="hljs-string">\'userId\'</span>]),\n  <span class="hljs-string">\'contentpage\'</span>: StructRouter(ArticleDetailIndex(), <span class="hljs-number">-1</span>, [<span class="hljs-string">\'articleId\'</span>]),\n  <span class="hljs-string">\'default\'</span>: StructRouter(HomePageIndex(), <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>),\n  <span class="hljs-string">\'imgflow\'</span>: StructRouter(HomePageImgFlow(), <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>),\n  <span class="hljs-string">\'singlepage\'</span>: StructRouter(HomePageSingle(), <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>)\n};\n</code></pre>\n<p data-nodeid="17526">接下来实现 HomePageImgFlow 这个类，首先还是导入相应的组件库、 Struct 以及 API 接口，代码如下：</p>\n<pre class="lang-dart" data-nodeid="17527"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/api/content/index.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/content_detail.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/home_page/img_card.dart\'</span>;\n</code></pre>\n<p data-nodeid="17528">然后开始创建有状态类 HomePageImgFlow ，并在 initState 中拉取接口数据。</p>\n<pre class="lang-dart" data-nodeid="17529"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">九宫格首页</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageImgFlow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> HomePageImgFlow({Key, key});\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageImgFlowState();\n}\n<span class="hljs-comment">/// <span class="markdown">具体的state类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageImgFlowState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePageImgFlow</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">首页推荐帖子列表</span></span>\n  <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; contentList;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    <span class="hljs-comment">// 拉取推荐内容</span>\n    setState(() {\n      contentList = ApiContentIndex().getRecommendList();\n    });\n  }\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<p data-nodeid="17530">上面代码和第一部分内容+缩略图的实现原理基本一致，在 build 方法中，除了 itemBuilder 逻辑不一样，其他实现均一样，所以我们主要看下 itemBuilder 代码。</p>\n<pre class="lang-dart" data-nodeid="17531"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; tmpList = [];\n  <span class="hljs-keyword">return</span> ListView.separated(\n    scrollDirection: Axis.vertical,\n    shrinkWrap: <span class="hljs-keyword">true</span>,\n    itemCount: contentList.length,\n    itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) {\n      <span class="hljs-keyword">if</span> (position % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {\n        <span class="hljs-comment">// 起始位置初始赋值</span>\n        tmpList = [<span class="hljs-keyword">this</span>.contentList[position]];\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 非初始则插入列表</span>\n        tmpList.add(<span class="hljs-keyword">this</span>.contentList[position]);\n      }\n      <span class="hljs-comment">// 判断数据插入时机，如果最后一组或者满足三个一组则插入</span>\n      <span class="hljs-keyword">if</span> (position == contentList.length - <span class="hljs-number">1</span> || (position + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {\n        <span class="hljs-keyword">return</span> ImgCard(\n            position: position,\n            articleInfoList: tmpList,\n            <span class="hljs-comment">// 确认是否为最后数据，最后数据无须处理大小图问题</span>\n            isLast: position == contentList.length - <span class="hljs-number">1</span>);\n      }\n      <span class="hljs-keyword">return</span> Container();\n    },\n    separatorBuilder: (context, index) {\n      <span class="hljs-keyword">return</span> Divider(\n        height: <span class="hljs-number">.1</span>,\n        <span class="hljs-comment">//indent: 75,</span>\n        color: Color(<span class="hljs-number">0xFFDDDDDD</span>),\n      );\n    },\n  );\n}\n</code></pre>\n<p data-nodeid="17532">上面代码第 3 行，初始化定义了一个临时数组，该数组用来保存临时需要插入的列表，代码的第 10 行判断是否为 3 的倍数位置，例如第 0 、3 、6，对于这些位置需要将 tmpList 重新赋值，如果非这些位置，则往 tmpList 插入。</p>\n<p data-nodeid="17533">代码第 19 行则判断 tmpList 是否满足 3 个，或者是否为最后一组，如果满足两个条件的任意一个则返回 ImgCard 组件，如果不是则返回一个空元素控件。</p>\n<p data-nodeid="17534">接下来我们来看下 ImgCard 中的 build 代码。</p>\n<pre class="lang-dart" data-nodeid="17535"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-keyword">if</span> (isLast) {\n    <span class="hljs-keyword">return</span> withSmallPic(context);\n  }\n  <span class="hljs-keyword">if</span> ((position + <span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">3</span>) {\n    <span class="hljs-keyword">return</span> withBigPic(context);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> withSmallPic(context);\n  }\n}\n</code></pre>\n<p data-nodeid="17536">上面代码中的第 3 行是判断是否为最后一组，最后一组则使用小图模式，如果是奇数组则使用大图模式，是偶数组则使用小图模式。小图模式的实现比较简单，使用 flex 布局，并列显示三个即可。这里我们看下实现大图模式的代码。</p>\n<pre class="lang-dart" data-nodeid="17537"><code data-language="dart"><span class="hljs-keyword">return</span> Row(\n  children: &lt;Widget&gt;[\n    Expanded(\n      flex: <span class="hljs-number">6</span>,\n      child: getFlatImg(context, articleInfoList[<span class="hljs-number">0</span>], <span class="hljs-number">200</span>),\n    ),\n    Expanded(\n      flex: <span class="hljs-number">3</span>,\n      child: Column(\n        children: &lt;Widget&gt;[\n          getFlatImg(context, articleInfoList[<span class="hljs-number">1</span>]),\n          Padding(padding: EdgeInsets.only(top: <span class="hljs-number">2</span>)),\n          getFlatImg(context, articleInfoList[<span class="hljs-number">2</span>]),\n        ],\n      ),\n    ),\n  ],\n);\n</code></pre>\n<p data-nodeid="17538">这个组件布局也是使用 flex 来实现，大图占 6 小图占 3，其次小图使用 Column 控件来列表显示。<br>\n以上就完成了大图列表的实现方式，接下来我们再看下单信息流模式。</p>\n<h3 data-nodeid="17539">单信息流</h3>\n<p data-nodeid="17540">单信息流模式有点类似于目前比较流行的短视频应用，在这里我们用简单的方式来介绍下实现原理。单信息流模式使用图片作为背景，右侧为头像、评论和点赞信息，最底部显示帖子的标题和摘要部分，效果如图 5 所示。</p>\n<p data-nodeid="17541"><img src="https://s0.lgstatic.com/i/image/M00/33/E5/Ciqc1F8RIUWAJaWRAAQ7AhPuYYY687.png" alt="图片5.png" data-nodeid="17660"></p>\n<h4 data-nodeid="17542">组件设计</h4>\n<p data-nodeid="17543">根据图 5 的效果图，我们按照 06 课时的知识点，绘制出图 6 的一个组件树。</p>\n<p data-nodeid="17544"><img src="https://s0.lgstatic.com/i/image/M00/33/E5/Ciqc1F8RIVKAZyj1AAJ_M5lRbOU489.png" alt="图片6.png" data-nodeid="17665"></p>\n<p data-nodeid="17545">完成组件设计后，我们再根据组件树创建相应组件，以及实现相应组件代码。</p>\n<h4 data-nodeid="17546">实现原理</h4>\n<p data-nodeid="17547">我们创建 home_page/single.dart 来表示这个单信息流组件的页面，然后修改最开始的左侧菜单栏文件 draw.dart ，再修改第二个菜单为单图片信息，并且跳转到 tyfapp://singlepage 这个地址（这里需要去 router 中注册 singlepage 路由，具体注册的代码部分，在上面大图列表中已经说明）。</p>\n<p data-nodeid="17548">接下来实现 HomePageSingle 这个类，首先还是导入相应的组件库、 Struct 以及 API 接口，代码如下：</p>\n<pre class="lang-dart" data-nodeid="17549"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/api/content/index.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/home_page/single_bottom_summary.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/home_page/single_like_bar.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/home_page/single_right_bar.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/content_detail.dart\'</span>;\n</code></pre>\n<p data-nodeid="17550">接下来创建有状态类组件，并且在 initState 中获取接口数据，并初始化赋值。</p>\n<pre class="lang-dart" data-nodeid="17551"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">单个内容首页</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageSingle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> HomePageSingle({Key, key});\n  <span class="hljs-meta">@override</span>\n  createState() =&gt; HomePageSingleState();\n}\n<span class="hljs-comment">/// <span class="markdown">具体的state类</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePageSingleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">HomePageSingle</span>&gt; </span>{\n  <span class="hljs-comment">/// <span class="markdown">index position</span></span>\n  <span class="hljs-built_in">int</span> indexPos;\n  <span class="hljs-comment">/// <span class="markdown">首页推荐帖子列表</span></span>\n  <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; contentList;\n  <span class="hljs-meta">@override</span>\n  <span class="hljs-keyword">void</span> initState() {\n    <span class="hljs-keyword">super</span>.initState();\n    indexPos = <span class="hljs-number">0</span>;\n    <span class="hljs-comment">// 拉取推荐内容</span>\n    setState(() {\n      contentList = ApiContentIndex().getRecommendList();\n    });\n  }\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n</code></pre>\n<p data-nodeid="17552">代码中的 indexPos 代表当前展示的内容位置，我们主要看下 build 逻辑的代码。</p>\n<pre class="lang-dart" data-nodeid="17553"><code data-language="dart"><span class="hljs-keyword">return</span> Container(\n  height: MediaQuery.of(context).size.height,\n  width: MediaQuery.of(context).size.width,\n  decoration: BoxDecoration(\n      image: DecorationImage(\n          image: NetworkImage(contentList[indexPos].articleImage),\n          fit: BoxFit.contain)),\n  child: Column(\n    crossAxisAlignment: CrossAxisAlignment.end,\n    children: &lt;Widget&gt;[\n      SingleRightBar(\n          nickname: contentList[indexPos].userInfo.nickName,\n          headerImage: contentList[indexPos].userInfo.headerUrl,\n          commentNum: contentList[indexPos].commentNum),\n      SingleLikeBar(\n          articleId: contentList[indexPos].id,\n          likeNum: contentList[indexPos].likeNum),\n      SingleBottomSummary(\n        articleId: contentList[indexPos].id,\n        title: contentList[indexPos].title,\n        summary: contentList[indexPos].summary,\n      ),\n    ],\n  ),\n);\n</code></pre>\n<p data-nodeid="17554">代码中的第 4 行就是为了设置背景图片，代码第 11 到第 22 行就是加载我们图 6 中的三个组件。三个组件中我们就只看 single_like_bar 组件的实现，其他两个组件实现原理较为简单，这个组件由于涉及状态管理，因此稍微复杂一些，所以着重说明下。接下来我们看下具体的逻辑实现过程。</p>\n<p data-nodeid="17555">第一步导入相应的组件库和第三方库。</p>\n<pre class="lang-dart" data-nodeid="17556"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/model/like_num_model.dart\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/styles/text_syles.dart\'</span>;\n</code></pre>\n<p data-nodeid="17557">第二步创建 SingleLikeBar 并且定义其初始化需要的参数，代码如下。</p>\n<pre class="lang-dart" data-nodeid="17558"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">帖子文章的赞组件</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// 包括点赞组件 icon ，以及组件点击效果</span></span>\n<span class="hljs-comment">/// <span class="markdown">需要外部参数[likeNum],点赞数量</span></span>\n<span class="hljs-comment">/// <span class="markdown">[articleId] 帖子的内容</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLikeBar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">帖子id</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> articleId;\n  <span class="hljs-comment">/// <span class="markdown">like num</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> likeNum;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> SingleLikeBar({Key key, <span class="hljs-keyword">this</span>.articleId, <span class="hljs-keyword">this</span>.likeNum})\n      : <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-comment">/// <span class="markdown">返回组件信息</span></span>\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n  }\n}\n</code></pre>\n<p data-nodeid="17559">最后看一下 build 逻辑的代码实现，基本和原来没有太大区别，只是在 Icon 和 Text 展示上从 Row 控件修改为 Column 控件。</p>\n<pre class="lang-dart" data-nodeid="17560"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">返回组件信息</span></span>\n<span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-keyword">final</span> likeNumModel = Provider.of&lt;LikeNumModel&gt;(context);\n  <span class="hljs-keyword">return</span> Container(\n    width: <span class="hljs-number">50</span>,\n    child: FlatButton(\n      padding: EdgeInsets.only(top: <span class="hljs-number">10</span>),\n      child: Column(\n        children: &lt;Widget&gt;[\n          Icon(Icons.thumb_up, color: Colors.grey, size: <span class="hljs-number">36</span>),\n          Padding(padding: EdgeInsets.only(top: <span class="hljs-number">2</span>)),\n          Text(\n            <span class="hljs-string">\'<span class="hljs-subst">${likeNumModel.getLikeNum(articleId, likeNum)}</span>\'</span>,\n            style: TextStyles.commonStyle(),\n          ),\n        ],\n      ),\n      onPressed: () =&gt; likeNumModel.like(articleId),\n    ),\n  );\n}\n</code></pre>\n<p data-nodeid="17561">上述代码是 07 课时已经详细介绍过的部分，其中没有太大的区别，这里需要介绍下 Container 的目的是限制 FlatButton 的大小，避免 FlatButton 产生一些 margin 引起布局问题。以上就完成了单信息流组件的一个设计。</p>\n<h3 data-nodeid="17562">总结</h3>\n<p data-nodeid="17563">以上就是本课时的所有内容，学完本课时，你要掌握 ListView.separated 的应用，并且了解 ListView 其他构造函数的使用。你要熟练应用 ListView.separated 实现三种内容展示的样式实现方法，并且能进一步熟悉界面效果转化组件设计的实践方法。</p>\n<p data-nodeid="17564">本课时已经完成了首页推荐内容，但是还缺乏内容的更新机制，下一课时我将介绍下拉刷新当前数据以及上拉更新列表数据的功能。谢谢。</p>\n<p data-nodeid="17565" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="17688">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '13 | 刷新加载：下拉刷新上拉加载，在 Flutter 中的实现',
            id: 315,
            content:
              '<p data-nodeid="29698" class="">你好，欢迎来到第 13 课时，上一课时我们实现了多种列表样式，但是缺乏下拉刷新和上拉加载更多的功能，本课时就来完善这部分的功能。实现下拉刷新和上拉加载更多，需要应用到 RefreshIndicator 组件 ，接下来我们就先了解这个组件的一些作用。</p>\n<h3 data-nodeid="29699">RefreshIndicator</h3>\n<p data-nodeid="29700">该组件主要的作用是在下拉时实现刷新，具体看下组件参数的一些作用。</p>\n<pre class="lang-dart" data-nodeid="29701"><code data-language="dart">RefreshIndicator({\n  Key key,\n  <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.child, <span class="hljs-comment">// 子组件，需要更新的组件列表</span>\n  <span class="hljs-keyword">this</span>.displacement = <span class="hljs-number">40.0</span>, <span class="hljs-comment">// 刷新指示器离顶部的位置</span>\n  <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.onRefresh, <span class="hljs-comment">// 下拉触发函数，该函数必须是 Future&lt;void&gt;</span>\n  <span class="hljs-keyword">this</span>.color, <span class="hljs-comment">// 设置指示器的颜色</span>\n  <span class="hljs-keyword">this</span>.backgroundColor, <span class="hljs-comment">// 设置指示器的颜色</span>\n  <span class="hljs-keyword">this</span>.notificationPredicate = defaultScrollNotificationPredicate, <span class="hljs-comment">// 检查组件是否需要监听下拉事件</span>\n  <span class="hljs-keyword">this</span>.semanticsLabel, <span class="hljs-comment">// 设置指示器的一个标签名字</span>\n  <span class="hljs-keyword">this</span>.semanticsValue, <span class="hljs-comment">// 加载进度，一般使用百分比</span>\n  <span class="hljs-keyword">this</span>.strokeWidth = <span class="hljs-number">2.0</span> <span class="hljs-comment">// 指示器的像素大小，默认 2.0</span>\n})\n</code></pre>\n<p data-nodeid="29702">了解完 RefreshIndicator 组件，我们再来看下本课时所要实现的一个效果，如图 1 动画所示。</p>\n<p data-nodeid="29703"><img src="https://s0.lgstatic.com/i/image/M00/36/B5/CgqCHl8X9e6AN6lyAH6AtsDFbHo367.gif" alt="20200711_155132.gif" data-nodeid="29791"><br>\n图 1 下拉刷新上拉加载效果</p>\n<p data-nodeid="29704">图 1 中的效果包含了下拉刷新，上拉滑动翻页，在翻页到最后一页时，给了一定的提示信息。接下来我们就实现这个功能。</p>\n<h3 data-nodeid="29705">实现原理</h3>\n<p data-nodeid="29706">前面我介绍到了下拉刷新功能，使用到的是 RefreshIndicator 组件。而上拉加载更多，使用的是上课时 ListView.separated 中的 controller 属性，通过监听上拉动作，来判断是否需要执行下一页翻页。</p>\n<p data-nodeid="29707">那么在实现代码前，我们还是需要做一些前期的准备。因为现在涉及了翻页，因此 API 返回的数据结构不仅仅是数据列表了，需要加上翻页相关的一些参数，具体我们来看下实现方案。</p>\n<h4 data-nodeid="29708">API 增加返回结构</h4>\n<p data-nodeid="29709">API 的数据结构调整为下面的一个 JSON 格式。</p>\n<pre class="lang-json" data-nodeid="29710"><code data-language="json">{\n   <span class="hljs-attr">"ret"</span> : <span class="hljs-number">0</span>, \n   <span class="hljs-attr">"message"</span> : <span class="hljs-string">"success"</span>, \n   <span class="hljs-attr">"hasMore"</span> : <span class="hljs-literal">true</span>,\n   <span class="hljs-attr">"lastId"</span> : <span class="hljs-literal">null</span>,\n}\n</code></pre>\n<ul data-nodeid="29711">\n<li data-nodeid="29712">\n<p data-nodeid="29713">ret，表示返回的状态码，0 表示成功。</p>\n</li>\n<li data-nodeid="29714">\n<p data-nodeid="29715">message，返回的提示信息。</p>\n</li>\n<li data-nodeid="29716">\n<p data-nodeid="29717">hasMore，表示是否还有更多，或者说下一页。</p>\n</li>\n<li data-nodeid="29718">\n<p data-nodeid="29719">lastId，翻页标识。</p>\n</li>\n</ul>\n<p data-nodeid="29720">根据如上的结构，我们需要去 Struct 中新建一个 api_ret_info.dart 用来保存所有相关的 api 返回结构，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="29721"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/content_detail.dart\'</span>;\n<span class="hljs-comment">/// <span class="markdown">api 拉取content list返回结构</span></span>\n<span class="hljs-comment">///\n<span class="markdown">/// {</span></span>\n<span class="hljs-comment">///   <span class="markdown">"ret" : 0,</span></span>\n<span class="hljs-comment">///   <span class="markdown">"message" : "success",</span></span>\n<span class="hljs-comment">///   <span class="markdown">"hasMore" : true,</span></span>\n<span class="hljs-comment">///   <span class="markdown">"lastId" : null,</span></span>\n<span class="hljs-comment">/// <span class="markdown">}</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StructApiContentListRetInfo</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">用户的昵称</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> ret;\n  <span class="hljs-comment">/// <span class="markdown">用户头像信息</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> message;\n  <span class="hljs-comment">/// <span class="markdown">是否还有更多</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> hasMore;\n  <span class="hljs-comment">/// <span class="markdown">最后一个id</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> lastId;\n  <span class="hljs-comment">/// <span class="markdown">具体的content list</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; data;\n  <span class="hljs-comment">/// <span class="markdown">构造函数</span></span>\n  <span class="hljs-keyword">const</span> StructApiContentListRetInfo(\n      <span class="hljs-keyword">this</span>.ret, <span class="hljs-keyword">this</span>.message, <span class="hljs-keyword">this</span>.hasMore, <span class="hljs-keyword">this</span>.lastId, <span class="hljs-keyword">this</span>.data\n      );\n}\n</code></pre>\n<p data-nodeid="29722">上面代码已经是一个比较常见的 Struct 结构。完成 Struct 代码后，我们再来修改 API 文件，将接口返回的类型从原来的 List 修改为 StructApiContentListRetInfo ，其次在函数中增加参数，用来判断是否为下一页，具体代码实现如下：</p>\n<pre class="lang-dart" data-nodeid="29723"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">拉取用户内容推荐帖子列表</span></span>\nStructApiContentListRetInfo getRecommendList([lastId = <span class="hljs-keyword">null</span>]) {\n  <span class="hljs-keyword">if</span>(lastId != <span class="hljs-keyword">null</span>) {\n    <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; dataList = [\n      StructContentDetail(),\n      ...\n    ];\n    <span class="hljs-keyword">return</span> StructApiContentListRetInfo(\n      <span class="hljs-number">0</span>,\n      <span class="hljs-string">\'success\'</span>,\n      <span class="hljs-keyword">false</span>,\n      <span class="hljs-string">\'2001\'</span>,\n      dataList\n    );\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; dataList =  [\n      StructContentDetail()，\n      ...\n    ];\n    <span class="hljs-keyword">return</span> StructApiContentListRetInfo(\n        <span class="hljs-number">0</span>,\n        <span class="hljs-string">\'success\'</span>,\n        <span class="hljs-keyword">true</span>,\n        <span class="hljs-string">\'1010\'</span>,\n        dataList\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="29724">代码第 2 行修改了 API 接口返回的数据类型为 StructApiContentListRetInfo 。代码第 3 行，判断是否为下一页，如果是则返回下一页的数据，如果不是则返回第一页数据。最后返回的数据结构都是使用 StructApiContentListRetInfo 进行封装处理。</p>\n<p data-nodeid="29725">完成上面前期准备后，我们再来修改核心主页面的一个逻辑处理，分为下拉刷新和上拉加载更多两部分。Two You APP 的首页会以内容+缩略图的展示方式，本课时也只从这部分来介绍。</p>\n<h4 data-nodeid="29726">新增状态</h4>\n<p data-nodeid="29727">为了实现该功能，我们需要新增以下几个状态变量：</p>\n<pre class="lang-dart" data-nodeid="29728"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">首页推荐贴子列表</span></span>\n<span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; contentList;\n<span class="hljs-comment">/// <span class="markdown">列表事件监听</span></span>\nScrollController scrollController = ScrollController();\n<span class="hljs-comment">/// <span class="markdown">是否存在下一页</span></span>\n<span class="hljs-built_in">bool</span> hasMore;\n<span class="hljs-comment">/// <span class="markdown">页面是否正在加载</span></span>\n<span class="hljs-built_in">bool</span> isLoading;\n<span class="hljs-comment">/// <span class="markdown">最后一个数据 ID</span></span>\n<span class="hljs-built_in">String</span> lastId;\n</code></pre>\n<ul data-nodeid="29729">\n<li data-nodeid="29730">\n<p data-nodeid="29731">contentList，我们已经介绍过，是保存当前需要的列表元素；</p>\n</li>\n<li data-nodeid="29732">\n<p data-nodeid="29733">scrollController，用来监听列表事件，主要是判断上拉加载更多功能；</p>\n</li>\n<li data-nodeid="29734">\n<p data-nodeid="29735">hasMore，标记是否还存在下一页；</p>\n</li>\n<li data-nodeid="29736">\n<p data-nodeid="29737">isLoading，用于标识页面是否正在加载中；</p>\n</li>\n<li data-nodeid="29738">\n<p data-nodeid="29739">lastId，记录最后一条数据的 ID，用于翻页。</p>\n</li>\n</ul>\n<h4 data-nodeid="29740">首次加载和下拉刷新</h4>\n<p data-nodeid="29741">首次加载和下拉刷新本质上是一样的作用，因此我们将两个功能合并为一个函数 setFirstPage ，先来看下这个函数的实现。</p>\n<pre class="lang-dart" data-nodeid="29742"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">处理首次拉取和刷新数据获取动作</span></span>\n<span class="hljs-keyword">void</span> setFirstPage() {\n  StructApiContentListRetInfo retInfo =\n    ApiContentIndex().getRecommendList();\n  setState(() {\n    contentList = retInfo.data;\n    hasMore = retInfo.hasMore;\n    isLoading = <span class="hljs-keyword">false</span>;\n    lastId = retInfo.lastId;\n  });\n}\n</code></pre>\n<p data-nodeid="29743">在上述代码中，首先获取 API 返回数据，然后将返回的数据初始化相应的状态属性。实现完 setFirstPage ，我们再补充调用该函数的两个逻辑，initState 和 onRefresh ，代码如下：</p>\n<pre class="lang-dart" data-nodeid="29744"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">处理刷新操作</span></span>\nFuture onRefresh() {\n  <span class="hljs-keyword">return</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>), () {\n    setFirstPage();\n  });\n}\n<span class="hljs-meta">@override</span>\n<span class="hljs-keyword">void</span> initState() {\n  <span class="hljs-keyword">super</span>.initState();\n  <span class="hljs-comment">/// <span class="markdown">拉取首页接口数据</span></span>\n  setFirstPage();\n}\n</code></pre>\n<p data-nodeid="29745">完成以上两部分后，我们使用刚刚介绍的 RefreshIndicator 来实现下拉刷新，修改 build 逻辑，代码如下：</p>\n<pre class="lang-dart" data-nodeid="29746"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-keyword">return</span> RefreshIndicator(\n    onRefresh: onRefresh, <span class="hljs-comment">// 调用刷新事件</span>\n    child: ListView.separated(\n      scrollDirection: Axis.vertical,\n      shrinkWrap: <span class="hljs-keyword">true</span>,\n      itemCount: contentList.length,\n      itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) {\n        <span class="hljs-keyword">return</span> ArticleCard(articleInfo: contentList[position]);\n      },\n      separatorBuilder: (context, index) {\n        <span class="hljs-keyword">return</span> Divider(\n          height: <span class="hljs-number">.5</span>,\n          <span class="hljs-comment">//indent: 75,</span>\n          color: Color(<span class="hljs-number">0xFFDDDDDD</span>),\n        );\n      },\n    ),\n  );\n}\n</code></pre>\n<p data-nodeid="29747">在上面代码的第 3 行，使用到了 RefreshIndicator 组件，在第 4 行设置 onRefresh 调用 onRefresh 函数，这样就完成了下拉刷新功能。</p>\n<h4 data-nodeid="29748">上拉加载更多</h4>\n<p data-nodeid="29749">上拉加载更多使用到 ListView.separated 的 controller 属性功能，在 initState 中，我们首先要设置该滑动的监听事件，代码如下：</p>\n<pre class="lang-dart" data-nodeid="29750"><code data-language="dart"><span class="hljs-meta">@override</span>\n<span class="hljs-keyword">void</span> initState() {\n  <span class="hljs-keyword">super</span>.initState();\n  <span class="hljs-comment">/// <span class="markdown">拉取首页接口数据</span></span>\n  setFirstPage();\n  <span class="hljs-comment">/// <span class="markdown">监听上滑事件，活动加载更多</span></span>\n  <span class="hljs-keyword">this</span>.scrollController.addListener(() {\n    <span class="hljs-keyword">if</span>(!hasMore){\n      <span class="hljs-keyword">return</span>;\n    }\n    <span class="hljs-keyword">if</span> (\n    !isLoading &amp;&amp;\n        scrollController.position.pixels &gt;=\n            scrollController.position.maxScrollExtent\n    ) {\n      isLoading = <span class="hljs-keyword">true</span>;\n      loadMoreData();\n    }\n  });\n}\n</code></pre>\n<p data-nodeid="29751">上述代码的第 8 行到第 22 行，先判断是否还有更多内容，如果没有则下拉不处理任何事件，如果有更多内容，并且界面内容没有在加载中，则处理内容加载。第 13 行中的 isLoading 目的就是避免上一次内容未加载完，又继续请求触发。第 14 行作用是判断当前滚动位置是否大于等于最大滚动长度，大于则表示需要加载更多。触发加载时，首选需要将 isLoading 修改为 true，这里可以不用 setState ，避免因为使用 setState 而引发 build 逻辑。最后调用 loadMoreData 方法，我们来看下该方法的实现。</p>\n<pre class="lang-dart" data-nodeid="29752"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">加载下一页</span></span>\n<span class="hljs-keyword">void</span> loadMoreData() {\n  StructApiContentListRetInfo retInfo =\n    ApiContentIndex().getRecommendList(lastId);\n  <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; newList = retInfo.data;\n  setState(() {\n    isLoading = <span class="hljs-keyword">false</span>;\n    hasMore = retInfo.hasMore;\n    contentList.addAll(newList);\n  });\n}\n</code></pre>\n<p data-nodeid="29753">代码第 4 到第 6 行还是拉取 API 接口数据，获取到接口返回后，再使用 setState 来更新状态变量 contentList ，从而触发界面 build 。</p>\n<p data-nodeid="29754">以上就完成了下拉刷新和上拉加载更多，但是这里还存在一些问题，比如在网络较慢的情况下，如何处理一些加载动作，或者在接口出错的情况下，如何友好地提示用户。下面我们就来完成这部分的一个简单优化。</p>\n<h3 data-nodeid="29755">功能优化</h3>\n<p data-nodeid="31738" class="">在 App 运行中，都没办法 100% 保证正确性，因此需要考虑到，在接口访问较慢或者接口报错的情况下，我们需要友好地提示用户。这里我们可以在接口报错或者其他异常时，显示通用报错组件。在接口请求较慢，或者加载到最后一页时，可以设计一个通用的 loading 组件来优化这部分体验。接下来我们就来实现这两个通用的组件。</p>\n\n\n\n\n\n\n\n<h4 data-nodeid="29757">增加错误处理</h4>\n<p data-nodeid="29758">首先我们需要创建一个比较通用的错误提示组件，该组件因为是一个通用组件，所以在 widgets/common 文件夹下创建 error.dart 。创建该组件的一些外部参数，代码如下：</p>\n<pre class="lang-dart" data-nodeid="29759"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">具体的错误码</span></span>\n<span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> errorCode;\n<span class="hljs-comment">/// <span class="markdown">可点击的回调函数</span></span>\n<span class="hljs-keyword">final</span> <span class="hljs-built_in">Function</span> action;\n<span class="hljs-comment">/// <span class="markdown">默认构造函数</span></span>\n<span class="hljs-keyword">const</span> CommonError({Key key, <span class="hljs-keyword">this</span>.errorCode, <span class="hljs-keyword">this</span>.action})\n    :<span class="hljs-keyword">super</span>(key: key);\n<span class="hljs-comment">/// <span class="markdown">返回提示信息</span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> errorMapping = {\n  <span class="hljs-string">\'server_error\'</span> : <span class="hljs-string">\'服务器响应错误\'</span>,\n  <span class="hljs-string">\'error\'</span> : <span class="hljs-string">\'系统异常\'</span>,\n  <span class="hljs-string">\'default\'</span> : <span class="hljs-string">\'服务异常\'</span>\n};\n</code></pre>\n<p data-nodeid="29760">主要看下 build 逻辑，build 中包含两部分，第一部分是解析页面跳转的数据，代码如下：</p>\n<pre class="lang-dart" data-nodeid="29761"><code data-language="dart"><span class="hljs-built_in">String</span> newErrorCode = errorCode;\n<span class="hljs-built_in">Function</span> newAction = action;\n<span class="hljs-comment">// 获取来自接口 router 跳转参数</span>\n<span class="hljs-keyword">if</span> (ModalRoute.of(context).settings.arguments != <span class="hljs-keyword">null</span>) {\n  <span class="hljs-built_in">Map</span> dataInfo =\n  JsonConfig.objectToMap(ModalRoute.of(context).settings.arguments);\n  <span class="hljs-keyword">if</span>(dataInfo[<span class="hljs-string">\'errorCode\'</span>] != <span class="hljs-keyword">null</span>) {\n    newErrorCode = dataInfo[<span class="hljs-string">\'errorCode\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>;\n  }\n  <span class="hljs-keyword">if</span>(dataInfo[<span class="hljs-string">\'action\'</span>] != <span class="hljs-keyword">null</span>) {\n    newAction = dataInfo[<span class="hljs-string">\'action\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">Function</span>;\n  }\n}\n<span class="hljs-comment">// 判断是否存在，不存在使用默认提示</span>\n<span class="hljs-keyword">if</span>(errorMapping[newErrorCode] == <span class="hljs-keyword">null</span>) {\n  newErrorCode = <span class="hljs-string">\'default\'</span>;\n}\n</code></pre>\n<p data-nodeid="29762">上述代码中的第 4 到 13 行主要是为了处理有些来自 router 跳转的参数，router 跳转的参数是通过 ModalRoute.of(context).settings.arguments 方法来获取，这点在第 10 课时已经讲解过。第 15 行则是避免没有匹配到任何错误提示，给一个默认数据。</p>\n<p data-nodeid="29763">以上是参数处理部分，接下来我们看下组件部分代码。</p>\n<pre class="lang-dart" data-nodeid="29764"><code data-language="dart"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Scaffold(\n  body: Container(\n    alignment: Alignment.center,\n    child: Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: &lt;Widget&gt;[\n        Text(<span class="hljs-string">\'<span class="hljs-subst">${errorMapping[newErrorCode]}</span>\'</span>),\n        RaisedButton(\n          color: Colors.lightBlueAccent,\n          highlightColor: Colors.lightBlueAccent[<span class="hljs-number">700</span>],\n          colorBrightness: Brightness.dark,\n          splashColor: Colors.lightBlueAccent,\n          child: Icon(Icons.refresh),\n          shape:RoundedRectangleBorder(\n              borderRadius: BorderRadius.circular(<span class="hljs-number">20.0</span>)\n          ),\n          onPressed: () {\n            <span class="hljs-keyword">if</span>(newAction != <span class="hljs-keyword">null</span>) {\n              newAction(); <span class="hljs-comment">// 处理重试</span>\n            }\n          },\n        ),\n      ],\n    ),\n  ),\n);\n</code></pre>\n<p data-nodeid="29765">上面代码使用了按钮组件 RaisedButton ，这和我们之前所使用的 FaltButton 功能相似，都是一个操作按钮，点击触发效果的功能。不过两者在界面上有一定区别，前者是凸起的按钮，后者是扁平的按钮。为了能够让用户手动重试，我们按钮增加了 onPressed 属性，该属性在点击后会触发 newAction 函数的执行。</p>\n<p data-nodeid="29766">接下来我们看下主页面是如何来调用的。首先在接口失败后，需要将一个状态变量 error 设置为 true ，其次在 build 前进行该字段的判断，当为 true 时，则显示错误页面，具体代码如下。</p>\n<pre class="lang-dart" data-nodeid="29767"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">处理首次拉取和刷新数据获取动作</span></span>\n<span class="hljs-keyword">void</span> setFirstPage() {\n  StructApiContentListRetInfo retInfo =\n  ApiContentIndex().getRecommendList();\n  setState(() {\n    <span class="hljs-keyword">if</span>(retInfo.ret != <span class="hljs-number">0</span>){ <span class="hljs-comment">// 判断返回是否正确</span>\n      error = <span class="hljs-keyword">true</span>;\n      <span class="hljs-keyword">return</span>;\n    }\n    error = <span class="hljs-keyword">false</span>;\n    contentList = retInfo.data;\n    hasMore = retInfo.hasMore;\n    isLoading = <span class="hljs-keyword">false</span>;\n    lastId = retInfo.lastId;\n  });\n}\n</code></pre>\n<p data-nodeid="29768">上述代码和前面介绍的 setFirstPage 的共同点是对接口进行了返回判断，报错则直接设置 error 状态即可。</p>\n<pre class="lang-dart" data-nodeid="29769"><code data-language="dart"><span class="hljs-meta">@override</span>\nWidget build(BuildContext context) {\n  <span class="hljs-keyword">if</span>(error){\n    <span class="hljs-keyword">return</span> CommonError(action: <span class="hljs-keyword">this</span>.setFirstPage);\n  }\n</code></pre>\n<p data-nodeid="29770">build 部分代码我们只看前三行即可，当接口报错，则直接返回错误组件，并且传入重试函数<br>\nsetFirstPage 。以上就完成了对错误的体验优化，这部分也可以使用弹窗提示模式。</p>\n<h4 data-nodeid="29771">增加 loading 效果</h4>\n<p data-nodeid="29772">这里和上面错误处理一样，我们先还是创建一个通用的 loading 组件。在 widgets/common 下创建 loading.dart 文件。loading 组件会有三种状态：加载中、上拉加载提示、加载完成。将以上三种状态分别设计为三个小组件，我们主要看下核心组件的代码：</p>\n<pre class="lang-dart" data-nodeid="29773"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">自行展示，load more还是已加载完成</span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonLoadingButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-comment">/// <span class="markdown">加载状态</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> loadingState;\n  <span class="hljs-comment">/// <span class="markdown">是否有更多</span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> hasMore;\n  <span class="hljs-comment">/// <span class="markdown">默认构造函数</span></span>\n  <span class="hljs-keyword">const</span> CommonLoadingButton({Key key, <span class="hljs-keyword">this</span>.loadingState, <span class="hljs-keyword">this</span>.hasMore}) :\n        <span class="hljs-keyword">super</span>(key: key);\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.hasMore) {\n      <span class="hljs-keyword">return</span> NoMore();\n    }\n    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.loadingState) {\n      <span class="hljs-keyword">return</span> Loading();\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">return</span> LoadingStatic();\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="29774">上述代码第 14 行判断是否存在更多，没有则显示 NoMore 组件，再根据 loadingState 判断是显示加载中还是显示上拉加载提示。</p>\n<p data-nodeid="29775">最后我们再来看下在 build 逻辑中是如何应用该组件的，代码如下：</p>\n<pre class="lang-dart" data-nodeid="29776"><code data-language="dart">Widget build(BuildContext context) {\n  <span class="hljs-keyword">if</span>(error){\n    <span class="hljs-keyword">return</span> CommonError(action: <span class="hljs-keyword">this</span>.setFirstPage);\n  }\n  <span class="hljs-keyword">return</span> RefreshIndicator(\n    onRefresh: onRefresh, <span class="hljs-comment">// 调用刷新事件</span>\n    child: ListView.separated(\n      scrollDirection: Axis.vertical,\n      controller: scrollController,\n      shrinkWrap: <span class="hljs-keyword">true</span>,\n      itemCount: contentList.length + <span class="hljs-number">1</span>,\n      itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) {\n        <span class="hljs-keyword">if</span>(position &lt; <span class="hljs-keyword">this</span>.contentList.length) {\n          <span class="hljs-keyword">return</span> ArticleCard(articleInfo: contentList[position]);\n        }\n        <span class="hljs-keyword">return</span> CommonLoadingButton(\n            loadingState: isLoading, hasMore: hasMore\n        );\n      },\n      separatorBuilder: (context, index) {\n        <span class="hljs-keyword">return</span> Divider(\n          height: <span class="hljs-number">.5</span>,\n          <span class="hljs-comment">//indent: 75,</span>\n          color: Color(<span class="hljs-number">0xFFDDDDDD</span>),\n        );\n      },\n    ),\n  );\n}\n</code></pre>\n<p data-nodeid="29777">上述代码中的第 11 行，需要将原来的列表数量增加一个，主要是预留给 loading 组件，其次在第 13 行判断是否大于当前列表元素，小于则 build 贴子组件，大于等于则显示 loading 组件。</p>\n<p data-nodeid="29778">以上就完成了错误处理和 loading 效果的优化，这两个功能也是通用组件，后续也会被使用到其他页面逻辑中。</p>\n<h3 data-nodeid="29779">总结</h3>\n<p data-nodeid="34564" class="">本课时介绍了刷新组件 RefreshIndicator 的一些基础属性，其次实践开发了下拉刷新和上拉加载更多功能，最后在页面基础上增加了一些优化体验的功能。学完本课时要掌握下拉刷新和上拉加载的知识，并且能够实践应用，其次需要了解通用组件的设计方法。</p>\n\n<p data-nodeid="34878" class="">下一课时我们将在 App 基础上完成个人页面，并且在个人页面增加红点提醒功能，丰富 App 整体功能。</p>\n\n\n\n\n\n\n\n\n\n<p data-nodeid="29782" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="29853">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '14 | 红点组件：如何将红点设计做成 Flutter 组件',
            id: 316,
            content:
              '<p data-nodeid="65937" class="">上一课时我们完善了首页推荐功能，本课时将完善个人页面。个人页面涉及红点组件的知识点，因此本课时在完善个人页面的同时，会着重介绍下该功能的实现。</p>\n<h3 data-nodeid="65938">实现效果</h3>\n<p data-nodeid="65939">我们先来看下本课时要完成的一个界面效果，如图 1 动画所示。</p>\n<p data-nodeid="65940"><img src="https://s0.lgstatic.com/i/image/M00/37/AD/Ciqc1F8aewCAIDGrAAocYK2ZqIo350.gif" alt="20200712_160246.gif" data-nodeid="66015"><br>\n图 1 本课时目标效果</p>\n<p data-nodeid="65941">首先在最底部导航栏增加了消息未读数提示，当有新的未读消息时候，会有红点提示。个人界面展示了个人信息以及个人相关的操作栏（我的好友、我的消息和系统设置）。</p>\n<p data-nodeid="65942">接下来我们来看下实现该效果需要做哪些前期准备工作。</p>\n<h3 data-nodeid="65943">前期准备</h3>\n<p data-nodeid="65944">基于图 1 的效果，我们首先要实现个人页面。个人页面是一个新页面，对于新页面我们按照第 7 课时的知识去设计页面。由于新增了红点功能，首先在 App 启动时 ，需要一个新的接口拉取服务器未读消息数，然后新增 API 来拉取该数据。其次这个数据状态，需要在多个组件中共享，因此要新增 Model 来管理该状态 。</p>\n<h4 data-nodeid="65945">组件设计</h4>\n<p data-nodeid="65946">根据图 2 的界面效果，我们将页面拆分图 3 组件树。</p>\n<p data-nodeid="65947"><img src="https://s0.lgstatic.com/i/image/M00/37/B9/CgqCHl8aeySAO1UTAAIF-lgAvBA674.png" alt="image (9).png" data-nodeid="66026"><br>\n图 2 个人页面效果</p>\n<p data-nodeid="65948"><img src="https://s0.lgstatic.com/i/image/M00/37/AD/Ciqc1F8aezCAA5btAACFxGz_UhM158.png" alt="image (10).png" data-nodeid="66031"><br>\n图 3 个人页面组件树设计</p>\n<p data-nodeid="65949">图 3 组件树中， 左侧为最上面的头像和昵称，右侧为功能列表 。由于是一个有限的列表，因此可以使用 ListView 来封装组件。具体代码编写部分和之前所介绍的没有太大区别，详细代码可<a href="https://github.com/love-flutter/flutter-column" data-nodeid="66037">前往 github 参考</a>。</p>\n<p data-nodeid="65950">个人页面开发完成后，我们再来看下红点功能所涉及的 API 和 Model 功能部分。由于用户信息和红点未读消息，都需要状态共享，因此需要创建两个 Model 类 。 这两个 Model 类的代码逻辑基本一致，下面只介绍与红点未读消息有关的部分。</p>\n<h4 data-nodeid="65951">API</h4>\n<p data-nodeid="65952">在 App 启动时就需要拉取未读消息数，因此需要一个接口来获取未读消息内容 。在 api/user_info 目录下创建 message.dart 来管理消息接口 ，实现该 ApiUserInfoMessage 类，代码如下：</p>\n<pre class="lang-dart" data-nodeid="65953"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取用户消息相关 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiUserInfoMessage</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">获取自己的个人信息 </span></span>\n  <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> getUnReadMessageNum() { \n    <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>; \n  } \n}\n</code></pre>\n<p data-nodeid="65954">上面就是这个 API 的功能，里面包含一个 getUnReadMessageNum 方法，这里模拟返回一个假数据 18 个未读消息。</p>\n<h4 data-nodeid="65955">Model</h4>\n<p data-nodeid="65956">由于未读消息会被应用在底部导航栏和个人页面两个组件页面，因此需要使用 Provider 来做状态管理，在 model 下创建 new_message_model.dart ，并实现下面代码：</p>\n<pre class="lang-dart" data-nodeid="65957"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">name状态管理模块 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewMessageModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">系统未读新消息数 </span></span>\n  <span class="hljs-built_in">int</span> newMessageNum; \n  <span class="hljs-comment">/// <span class="markdown">构造函数 </span></span>\n  NewMessageModel({<span class="hljs-keyword">this</span>.newMessageNum}); \n  <span class="hljs-comment">/// <span class="markdown">获取未读消息 </span></span>\n  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> value =&gt; newMessageNum; \n  <span class="hljs-comment">/// <span class="markdown">设置已经阅读消息 </span></span>\n  <span class="hljs-keyword">void</span> readNewMessage() { \n    <span class="hljs-keyword">if</span>(newMessageNum == <span class="hljs-number">0</span>) { \n      <span class="hljs-keyword">return</span>; \n    } \n    newMessageNum = <span class="hljs-number">0</span>; \n    notifyListeners(); \n  } \n}\n</code></pre>\n<p data-nodeid="66512" class="">第 6 行是声明一个未读消息字段，保存未读消息数量。第 9 行是构造函数，第 12 行是设置一个 get 方法，第 14 行是设置已读状态，也可以在此调用服务端，将服务端未读状态清零，同时将本地的未读消息数清零。在写 Model 代码要特别注意，比如上面的第 16 行，目的就是避免没必要的 rebuild，当已经没有未读消息，则不需要处理任何行为。</p>\n\n\n<p data-nodeid="65959">在完成 API 和 Model 部分代码后，接下来修改入口文件 main.dart，在该入口文件中要多增加一个状态管理模块。</p>\n<h4 data-nodeid="65960">Main.dart</h4>\n<p data-nodeid="65961">由于需求的改变，现在需要多个共享状态类，课时之前只有一个状态 like_num_model，现在需要新增一个 new_message_model 状态，这里就需要使用到 MultiProvider，避免嵌套多层。需要将 main.dart build 方法修改为下面逻辑：</p>\n<pre class="lang-dart" data-nodeid="65962"><code data-language="dart"><span class="hljs-meta">@override</span> \nWidget build(BuildContext context) { \n  <span class="hljs-keyword">return</span> _getProviders( \n    context, \n    MaterialApp( \n        title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字 </span>\n        debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>, \n        theme: ThemeData( \n          primarySwatch: Colors.blue, <span class="hljs-comment">// APP 主题 </span>\n        ), \n        routes: Router().registerRouter(), \n        home: Entrance()), \n  ); \n}\n</code></pre>\n<p data-nodeid="65963">为了保持代码的整洁，新增了一个 _getProviders 方法，然后将状态管理相关的逻辑放入 _getProviders 中，其他组件相关的逻辑还是在 build 中，具体在看下 _getProviders 中的代码逻辑：</p>\n<pre class="lang-dart" data-nodeid="65964"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">部分数据需要获取初始值 </span></span>\nWidget _getProviders(BuildContext context, Widget child) { \n  StructUserInfo myUserInfo = ApiUserInfoIndex.getSelfUserInfo(); \n  <span class="hljs-keyword">if</span>(myUserInfo == <span class="hljs-keyword">null</span>){ \n    <span class="hljs-keyword">return</span> CommonError(); \n  } \n  <span class="hljs-built_in">int</span> unReadMessageNum = ApiUserInfoMessage.getUnReadMessageNum(); \n  <span class="hljs-keyword">return</span> MultiProvider( \n    providers: [ \n      ChangeNotifierProvider(create: (context) =&gt; LikeNumModel()), \n      ChangeNotifierProvider( \n          create: (context) =&gt; UserInfoModel( \n            myUserInfo: myUserInfo \n          ) \n      ), \n      ChangeNotifierProvider( \n          create: (context) =&gt; NewMessageModel( \n              newMessageNum: unReadMessageNum \n          ) \n      ), \n    ], \n    child: child, \n  ); \n}\n</code></pre>\n<p data-nodeid="65965">代码第 3 到 7 行是从服务端调用未读消息接口，并获得用户信息和用户未读消息数 。第 9 行使用 MultiProvider 来封装所有需要状态管理的代码，其中每一个状态管理的格式按照下面的方式：</p>\n<pre class="lang-dart" data-nodeid="65966"><code data-language="dart">ChangeNotifierProvider(create: (context) =&gt; LikeNumModel()),\n</code></pre>\n<p data-nodeid="65967">LikeNumModel 为 Model 类，可以为类增加初始赋值，比如上面的 UserInfoModel 和 NewMessageModel。</p>\n<p data-nodeid="65968">通过以上方法，我们就将用户信息和未读消息两个状态进行了组件共享，接下来我们看下如何设计红点组件。</p>\n<h3 data-nodeid="65969">红点组件</h3>\n<p data-nodeid="65970">在 App 中红点和消息提醒是非常常见的应用，因此需要将该功能，设计为一个基础通用组件。在 Flutter 中是提供了一个比较通用的库 <a href="https://pub.dev/packages/badges" data-nodeid="66077">badges</a>。如果你觉得不太适用也可以自己来封装，本课时主要是基于这个组件库实现一个二次封装应用，先来具体看下二次封装的红点组件实现部分。</p>\n<h4 data-nodeid="65971">组件实现</h4>\n<p data-nodeid="65972">根据自身的业务，我们可以设计为两种， 一个是只显示红点，另一个是显示具体未读消息数的，先看下只显示红点的部分。</p>\n<pre class="lang-dart" data-nodeid="65973"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:badges/badges.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">通用红点逻辑 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonRedMessage</span>  </span>{ \n  <span class="hljs-comment">/// <span class="markdown">只展示红点，不展示具体消息数 </span></span>\n  <span class="hljs-keyword">static</span> Widget showRedWidget(Widget needRedWidget, <span class="hljs-built_in">int</span> newMessageNum) { \n    <span class="hljs-keyword">if</span>(newMessageNum &lt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// 小于 1 的消息则无须设置 </span>\n      <span class="hljs-keyword">return</span> needRedWidget; \n    } \n    <span class="hljs-keyword">return</span> _getBadge(needRedWidget, <span class="hljs-string">\'\'</span>); \n  } \n\n  <span class="hljs-comment">/// <span class="markdown">获取 badge 组件 </span></span>\n  <span class="hljs-keyword">static</span> Widget _getBadge(Widget needRedWidget, <span class="hljs-built_in">String</span> msgTips) { \n    <span class="hljs-keyword">return</span> Badge( \n      alignment: Alignment.bottomLeft, \n      position: BadgePosition.topRight(), \n      toAnimate: <span class="hljs-keyword">false</span>, \n      badgeContent: Text( \n        <span class="hljs-string">\'<span class="hljs-subst">$msgTips</span>\'</span>, \n        style: TextStyle( \n          color: Colors.white, \n          fontSize: <span class="hljs-number">10.0</span>, \n          letterSpacing: <span class="hljs-number">1</span>, \n          wordSpacing: <span class="hljs-number">2</span>, \n          height: <span class="hljs-number">1</span>, \n        ), \n      ), \n      child: needRedWidget, \n    ); \n  } \n}\n</code></pre>\n<p data-nodeid="66896" class="">代码第 7 行的方法 showRedWidget 就是只显示红点提醒，其调用的是 _getBadge 方法，该方法主要是应用 Badge 第三方组件，上面代码中的五个参数的作用分别是：</p>\n\n<ul data-nodeid="65975">\n<li data-nodeid="65976">\n<p data-nodeid="65977">alignment，child 组件的展示方式，这里是底部靠左；</p>\n</li>\n<li data-nodeid="65978">\n<p data-nodeid="65979">position，红点或者未读消息数的位置，这里是右上角；</p>\n</li>\n<li data-nodeid="65980">\n<p data-nodeid="65981">toAnimate，表示动画，这里直接去掉，感觉效果不太好，也没有必要；</p>\n</li>\n<li data-nodeid="65982">\n<p data-nodeid="65983">badgeContent，则是红点的样式内容，需要 Text 组件；</p>\n</li>\n<li data-nodeid="65984">\n<p data-nodeid="65985">child，就是需要展示红点的组件。</p>\n</li>\n</ul>\n<p data-nodeid="65986">未读消息也是使用到 _getBadge 方法，但这里传入的是具体的消息数，而不是一个空字符，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="65987"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">展示消息提醒 </span></span>\n<span class="hljs-keyword">static</span> Widget showRedNumWidget(Widget needRedWidget, <span class="hljs-built_in">int</span> newMessageNum) { \n  <span class="hljs-keyword">if</span>(newMessageNum &lt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// 小于1的消息则无须设置 </span>\n    <span class="hljs-keyword">return</span> needRedWidget; \n  } \n  <span class="hljs-comment">// 消息数大于99时，则只显示一个红点即可 </span>\n  <span class="hljs-built_in">String</span> msgTips = newMessageNum &gt; <span class="hljs-number">99</span> ? <span class="hljs-string">\'99+\'</span> : <span class="hljs-string">\'<span class="hljs-subst">$newMessageNum</span>\'</span>; \n  <span class="hljs-keyword">return</span> _getBadge(needRedWidget, msgTips); \n}\n</code></pre>\n<p data-nodeid="65988">考虑到未读消息数小于 1 不用展示，其次为了避免消息未读数量过大导致 UI 问题，这里在第 7 行代码也加了判断，具体还是根据业务场景来配置。完成基础组件后，我们再来看下该组件的应用部分。</p>\n<h4 data-nodeid="65989">组件应用</h4>\n<p data-nodeid="65990">组件的应用包含在两部分，一部分是底部导航栏，另外一部分是个人页的“我的消息”按钮。我们先来看下底部导航栏部分，这部分代码在 pages/entrance.dart 中，我们只看修改的部分。</p>\n<pre class="lang-dart" data-nodeid="65991"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取页面内容部分 </span></span>\nWidget _getScaffold(BuildContext context) { \n  <span class="hljs-keyword">final</span> newMessageModel = Provider.of&lt;NewMessageModel&gt;(context);\n</code></pre>\n<p data-nodeid="65992">首先需要通过 Provider 获得 NewMessageModel 的操作句柄。</p>\n<pre class="lang-dart" data-nodeid="65993"><code data-language="dart">BottomNavigationBarItem( \n  icon: CommonRedMessage.showRedWidget( \n      Icon(Icons.person), \n      newMessageModel.value \n  ), \n  title: Text(<span class="hljs-string">\'我\'</span>), \n  activeIcon: CommonRedMessage.showRedWidget( \n      Icon(Icons.person_outline), \n      newMessageModel.value \n  ), \n),\n</code></pre>\n<p data-nodeid="65994">修改底部导航栏的“我”，将其中的 icon 使用红点组件封装，代码在第 2 到 5 行，这里封装在 icon 上界面效果是最好的 ， 这样就在底部导航栏增加了未读消息红点提醒 。</p>\n<p data-nodeid="65995">为了演示红点和消息数两种场景，在导航上使用红点来演示效果，个人页面则演示展示具体未读消息数量。再来看下个人页面的代码部分，这部分逻辑在 widgets/user_page/button_list.dart 中。</p>\n<pre class="lang-dart" data-nodeid="65996"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">个人页面的功能列表 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPageButtonList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{ \n  <span class="hljs-meta">@override</span> \n  Widget build(BuildContext context) { \n    <span class="hljs-keyword">final</span> newMessageModel = Provider.of&lt;NewMessageModel&gt;(context); \n    <span class="hljs-keyword">return</span> ListView( \n      children: &lt;Widget&gt;[ \n        ListTile( \n          leading: Icon(Icons.person_pin), \n          title: Text(<span class="hljs-string">\'我的好友\'</span>), \n          onTap: () {}, \n        ), \n        ListTile( \n          leading: CommonRedMessage.showRedNumWidget( \n            Icon(Icons.email), \n            newMessageModel.value \n          ), \n          title: Text(<span class="hljs-string">\'我的消息\'</span>), \n          onTap: () {}, \n        ), \n        ListTile( \n          leading: Icon(Icons.settings), \n          title: Text(<span class="hljs-string">\'系统设置\'</span>), \n          onTap: () {}, \n        ) \n      ], \n    ); \n  } \n}\n</code></pre>\n<p data-nodeid="65997">以上代码中的第 18 行到 21 行，就是将 icon 封装在了红点组件内。未读消息展示已经介绍了，那么我们再来看下如何消除消息红点和未读消息。</p>\n<h4 data-nodeid="65998">消除红点</h4>\n<p data-nodeid="65999">在 new_messsage_model 状态管理类中，有一个 readNewMessage 方法，该方法就是将未读消息设置为 0 ， 然后通知数据监听方，这里我们将点击行为在个人页面的“我的消息”来触发，将 widgets/user_page/button_list.dart 修改为下面的部分：</p>\n<pre class="lang-dart" data-nodeid="66000"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/model/new_message_model.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/common/red_message.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">个人页面的功能列表 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPageButtonList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{ \n  <span class="hljs-meta">@override</span> \n  Widget build(BuildContext context) { \n    <span class="hljs-keyword">final</span> newMessageModel = Provider.of&lt;NewMessageModel&gt;(context); \n    <span class="hljs-keyword">return</span> ListView( \n      children: &lt;Widget&gt;[ \n        ListTile( \n          leading: Icon(Icons.person_pin), \n          title: Text(<span class="hljs-string">\'我的好友\'</span>), \n          onTap: () {}, \n        ), \n        ListTile( \n          leading: CommonRedMessage.showRedNumWidget( \n            Icon(Icons.email), \n            newMessageModel.value \n          ), \n          title: Text(<span class="hljs-string">\'我的消息\'</span>), \n          onTap: () { \n            newMessageModel.readNewMessage(); \n          }, \n        ), \n        ListTile( \n          leading: Icon(Icons.settings), \n          title: Text(<span class="hljs-string">\'系统设置\'</span>), \n          onTap: () {}, \n        ) \n      ], \n    ); \n  } \n}\n</code></pre>\n<p data-nodeid="66001">上面代码中的第 28 行就是点击触发消息消除，接下来我们运行看下效果，如图 4 的动效所示。</p>\n<p data-nodeid="66002"><img src="https://s0.lgstatic.com/i/image/M00/37/AE/Ciqc1F8ae4WASR5LAAocYK2ZqIo031.gif" alt="20200712_160246 (1).gif" data-nodeid="66118"><br>\n图 4 红点效果图</p>\n<p data-nodeid="66003">以上就实现了红点组件的设计，并应用红点组件完善了 Two You Friend 的个人页面功能。</p>\n<h3 data-nodeid="66004">总结</h3>\n<p data-nodeid="66005">本课时在实现 App 个人页面的过程中，着重介绍了红点组件的设计和应用，同时介绍到了 Provider 多状态管理的方法。学习完本课时后，你要熟练应用红点组件，并且掌握其业务组件设计的方法，其次需要掌握 Provider 的多状态管理方法 。</p>\n<p data-nodeid="66006">在本课时之前，所有的 API 接口都是一个假接口数据，下一课时我们将介绍如何进行网络请求，来完善 API 部分功能。谢谢大家。</p>\n<p data-nodeid="66007" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="66127">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '15 | 服务通信：Flutter 中常见的网络协议',
            id: 317,
            content:
              '<p data-nodeid="4995" class="">上一课时之前，我们的接口都是在代码中模拟假数据，并没有从服务端获取数据，但是在实际开发中，必须与服务端进行交互。本课时主要介绍在 Flutter 中常见的网络传输协议序列化方式，并对其中比较常用的协议进行简单实践，最后再通过 JSON 协议来完善本课时的 api 部分的代码。</p>\n<h3 data-nodeid="4996">常见的 APP 网络传输协议序列化方式</h3>\n<p data-nodeid="4997">常见的传输协议有三种：XML 、JSON 和 Protocol Buffer。我们先来对比下这三种协议，我会分别从 Flutter 中的实现、序列化后的数据长度、Flutter 中反序列化性能三个方面来讲解。我先将本课时中的一段基础的数据格式用来做效果演示，测试数据如下：</p>\n<pre class="lang-coffeescript" data-nodeid="4998"><code data-language="coffeescript">nickName = <span class="hljs-string">\'test-pb\'</span>; \nuid = <span class="hljs-string">\'3001\'</span>; \nheaderUrl = <span class="hljs-string">\'http://image.biaobaiju.com/uploads/20180211/00/1518279967-IAnVyPiRLK.jpg\'</span>;\n</code></pre>\n<p data-nodeid="4999">上面的是用户信息接口，接下来我们使用这三种方式来实现这个接口。</p>\n<h4 data-nodeid="5000">XML</h4>\n<p data-nodeid="5001">XML 指可扩展标记语言（eXtensible Markup Language）是一种通用的重量级数据交换格式，以文本结构存储。</p>\n<p data-nodeid="5002">在 Flutter 中有一个解析 XML 的第三方库 <a href="https://pub.dev/packages/xml2json" data-nodeid="5095">xml2json</a>，将服务端的 XML 解析为 JSON 格式，因为是第三方库，因此需要在 pubspec.yaml 中增加该库的依赖，然后更新本地库。接下来我们实现具体的代码，在 lib 目录下新建 api_xml ，然后在目录下创建 api_xml/user_info/index.dart 。创建完成后，我们来实现 user_info/index.dart 的逻辑。</p>\n<p data-nodeid="5003">首先需要增加第三方库的引用。</p>\n<pre class="lang-dart" data-nodeid="5004"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:convert\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/user_info.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:xml2json/xml2json.dart\'</span>;\n</code></pre>\n<p data-nodeid="5005">接下来实现 ApiXmlUserInfoIndex 类中的 getSelfUserInfo 方法，后续 getSelfUserInfo 会是一个异步网络请求方法，因此将返回类型修改为 Future<code data-backticks="1" data-nodeid="5107">&lt;StructUserInfo&gt;</code>，具体实现逻辑如下：</p>\n<pre class="lang-dart" data-nodeid="5006"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取自己的个人信息 </span></span>\n<span class="hljs-keyword">static</span> Future&lt;StructUserInfo&gt; getSelfUserInfo() <span class="hljs-keyword">async</span>{ \n  <span class="hljs-comment">// 模拟xml假数据 </span>\n  <span class="hljs-keyword">final</span> userInfoXml = <span class="hljs-string">\'\'\'&lt;?xml version="1.0"?&gt; \n  &lt;userInfo&gt; \n    &lt;nickName&gt;test&lt;/nickName&gt; \n    &lt;uid&gt;3001&lt;/uid&gt; \n    &lt;headerUrl&gt;http://image.biaobaiju.com/uploads/20180211/00/1518279967-IAnVyPiRLK.jpg&lt;/headerUrl&gt; \n  &lt;/userInfo&gt;\'\'\'</span>; \n\n  <span class="hljs-comment">// 记录当前时间 </span>\n  <span class="hljs-built_in">int</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch; \n  Xml2Json xml2json = Xml2Json(); \n  xml2json.parse(userInfoXml); \n  <span class="hljs-comment">// 转化xml数据 </span>\n  <span class="hljs-keyword">final</span> userInfoStr = xml2json.toGData(); \n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'xml length\'</span>); \n  <span class="hljs-built_in">print</span>(userInfoStr.length); \n\n  <span class="hljs-built_in">int</span> jsonStartTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch; \n  <span class="hljs-keyword">final</span> userInfo = json.decode(userInfoStr); \n  <span class="hljs-comment">// 打印解析json时间 </span>\n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'json decode time\'</span>); \n  <span class="hljs-built_in">print</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch - jsonStartTime); \n\n  <span class="hljs-comment">// 打印整体解析时间 </span>\n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'xml decode time\'</span>); \n  <span class="hljs-built_in">print</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch - currentTime); \n  <span class="hljs-keyword">return</span> StructUserInfo( \n      userInfo[<span class="hljs-string">\'userInfo\'</span>][<span class="hljs-string">\'uid\'</span>][<span class="hljs-string">\'\\$t\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>, \n      userInfo[<span class="hljs-string">\'userInfo\'</span>][<span class="hljs-string">\'nickName\'</span>][<span class="hljs-string">\'\\$t\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>, \n      userInfo[<span class="hljs-string">\'userInfo\'</span>][<span class="hljs-string">\'headerUrl\'</span>][<span class="hljs-string">\'\\$t\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span> \n  ); \n}\n</code></pre>\n<p data-nodeid="5007">上述代码首先在第 4 行模拟一个 XML 数据，在第 12 行记录开始解析时间，第 28 行打印整体 XML 解析时间，在第 24 行打印 JSON 的解析时间。XML 的解析过程是先将 XML 转化为一个 JSON 字符串，然后再通过 convert 转化为 JSON。在 main.dart 中引入该文件，并调用 getSelfUserInfo 方法，可以看到如下的打印信息。</p>\n<pre class="lang-plain" data-nodeid="5008"><code data-language="plain">flutter: xml length \nflutter: 180 \nflutter: json decode time \nflutter: 200 \nflutter: xml decode time \nflutter: 2000\n</code></pre>\n<p data-nodeid="5009">从解析过程来看，XML 的解析性能肯定是比较差的，因为最终还是需要将 XML 转化为 JSON 来处理，接下来我们看下 JSON 的解析实现方式。</p>\n<h4 data-nodeid="5010">JSON</h4>\n<p data-nodeid="5011">JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。 易于人阅读和编写，同时也易于机器解析和生成。 它是基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。</p>\n<p data-nodeid="5012">在 Flutter 中，JSON 解析有专门的 dart 原生库支持——dart:convert。同样我们去实现 XML 例子中的 user_info/index.dart，我们以 api/user_info/index.dart 为例子来实现，在原来代码基础上，我们增加打印解析时间和 JSON 长度，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="5013"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取自己的个人信息 </span></span>\n  <span class="hljs-keyword">static</span> Future&lt;StructUserInfo&gt; getSelfUserInfo() <span class="hljs-keyword">async</span>{ \n    <span class="hljs-built_in">String</span> jsonStr = <span class="hljs-string">\'{"nickName":"test","uid":"3001","headerUrl":"http://image.biaobaiju.com/uploads/20180211/00/1518279967-IAnVyPiRLK.jpg"}\'</span>; \n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'json length\'</span>); \n    <span class="hljs-built_in">print</span>(jsonStr.length); \n    <span class="hljs-built_in">int</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch; \n    <span class="hljs-keyword">final</span> jsonInfo = json.decode(jsonStr) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;; \n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'json parse time\'</span>); \n    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch - currentTime); \n    <span class="hljs-keyword">return</span> StructUserInfo.fromJson(jsonInfo); \n  }\n</code></pre>\n<p data-nodeid="5014">上面代码较 XML 简单一些，第 3 行创建假数据，然后在第 7 行进行解析。在代码第 5 行，打印 JSON 长度，第 9 行打印具体的解析时间，在 main.dart 执行该函数，可以看到如下打印数据。</p>\n<pre class="lang-java" data-nodeid="5015"><code data-language="java">flutter: json length \nflutter: <span class="hljs-number">119</span> \nflutter: json parse time \nflutter: <span class="hljs-number">420</span>\n</code></pre>\n<p data-nodeid="5016">与 XML 对比，从解析时间和传递数据长度来看，都是较优的，接下来我们看下 Protocol Buffer 的实现、相关解析时长和具体的数据长度。</p>\n<h4 data-nodeid="5017">Protocol Buffer</h4>\n<p data-nodeid="5018">Protocol Buffer 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式，可用于通信协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>\n<p data-nodeid="5019">在 Flutter 中应用 Protocol Buffer 需要下面几个过程。</p>\n<p data-nodeid="5020">1.<strong data-nodeid="5128">安装 Protocol Buffer 工具</strong>，在 Mac 应用如下命令。</p>\n<pre class="lang-js" data-nodeid="5021"><code data-language="js">brew install protobuf\n</code></pre>\n<p data-nodeid="5022">如果是在 Windows 或者 Linux 上，则前往（ <a href="https://github.com/protocolbuffers/protobuf/releases?after=v3.5.0" data-nodeid="5132">https://github.com/protocolbuffers/protobuf/releases?after=v3.5.0</a>）解压安装即可。</p>\n<p data-nodeid="5023">2.<strong data-nodeid="5141">安装 protoc_plugin 插件</strong>，在 Mac 或者 Linux 应用如下命令安装。</p>\n<pre class="lang-plain" data-nodeid="5024"><code data-language="plain">pub global activate protoc_plugin\n</code></pre>\n<p data-nodeid="5025">如果在 Windows 上没有这个支持，你在 Windows 上只能通过虚拟机的方式。</p>\n<p data-nodeid="5026">3.<strong data-nodeid="5150">在 lib 同级目录下创建 protos</strong> 用来存放所需要的 Protocol Buffer 文件，这里我们创建了一个 user_info.proto ，然后添加下面的代码：</p>\n<pre class="lang-java" data-nodeid="5027"><code data-language="java">syntax = <span class="hljs-string">"proto3"</span>; \noption java_package = <span class="hljs-string">"pro.two_you_friend"</span>; \nmessage UserInfoRsp { \n    string nickName = <span class="hljs-number">1</span>; \n    string headerUrl = <span class="hljs-number">2</span>; \n    string uid = <span class="hljs-number">3</span>; \n}\n</code></pre>\n<p data-nodeid="5028">上面的代码就是创建一个 Protocol Buffer 协议，该协议数据结构就是一个 UserInfo 的结构，具体关于 Protocol Buffer 的协议，可以<a href="https://developers.google.com/protocol-buffers/docs/proto3" data-nodeid="5154">参考官网</a>。</p>\n<p data-nodeid="5029">4.创建完成 Protocol Buffer 协议后，我们再<strong data-nodeid="5161">将 Protocol Buffer 文件转化为 Dart 文件</strong>，在项目根目录，也就是 lib 同级目录，运行下面命令。</p>\n<pre class="lang-shell" data-nodeid="5030"><code data-language="shell">protoc --dart_out=./lib ./protos/* --plugin=protoc-gen-dart=$HOME/.pub-cache/bin/protoc-gen-dart\n</code></pre>\n<p data-nodeid="5031">其中 dart_out 就是转化后的 dart 文件存放路径，会默认带上原有 protos 目录。--plugin 就是需要使用到的插件，这里的路径就是第二步安装的插件位置。</p>\n<p data-nodeid="5032">5.运行成功后，<strong data-nodeid="5170">会在 lib 目录下创建 protos 目录</strong>，并生成如图 1 的目录结构；</p>\n<p data-nodeid="5033"><img src="https://s0.lgstatic.com/i/image/M00/3A/39/Ciqc1F8hN7qARIvYAACMRuwnLuo133.png" alt="image (14).png" data-nodeid="5173"></p>\n<div data-nodeid="5034"><p style="text-align:center">图 1 生成的 Protocol Buffer 目录结构</p></div>\n<p data-nodeid="5035">生成完成以后，这时候是会提示报错的，因为在 user_info.pb.dart 中引用了 package:protobuf/protobuf.dart 这个库。接下来我们就需要去修改 pubspec.yaml ，添加 Protocol Buffer（ protobuf: ^1.0.1 ）第三方库的依赖，添加完成后更新本地库。</p>\n<p data-nodeid="5036">以上就完成了整个 Protocol Buffer 的创建到转化，接下来我们看下如何在 Flutter 应用，同样和 XML 以及 JSON 一样，我们继续在 lib 目录下新建一个 api_pb 文件夹，用来存放 Protocol Buffer 相关的 API 协议，这里为了演示，只创建 api_pb/user_info/index.dart 。接下来我们看下具体的代码逻辑。</p>\n<p data-nodeid="5037">先引入相应的库文件，其中第 2 行就是相应的 Protocol Buffer 文件。</p>\n<pre class="lang-dart" data-nodeid="5038"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/user_info.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/protos/user_info.pb.dart\'</span>;\n</code></pre>\n<p data-nodeid="5039">接下来我们看下 ApiPbUserInfoIndex 类中创建 Protocol Buffer 的代码部分，这部分逻辑放在 createUserInfo 函数中，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="5040"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">生成二进制内容，测试文件 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; createUserInfo() { \n  UserInfoRsp userInfoRsp = UserInfoRsp(); \n  userInfoRsp.nickName = <span class="hljs-string">\'test\'</span>; \n  userInfoRsp.uid = <span class="hljs-string">\'3001\'</span>; \n  userInfoRsp.headerUrl = <span class="hljs-string">\'http://image.biaobaiju.com/uploads/20180211/00/1518279967-IAnVyPiRLK.jpg\'</span>; \n  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; retInfo = userInfoRsp.writeToBuffer(); \n  <span class="hljs-keyword">return</span> retInfo; \n}\n</code></pre>\n<p data-nodeid="5041">代码的第 2 行就是创建 Protocol Buffer 中的 Message 类，也就是我们的 UserInfo 数据结构，然后根据其数据结构，设置具体的字段值，最后调用 writeToBuffer 转化为二进制数据。</p>\n<p data-nodeid="5042">应用上面生成的二进制数据，我们再来实现 getSelfUserInfo 方法，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="5043"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取自己的个人信息 </span></span>\n<span class="hljs-keyword">static</span> Future&lt;StructUserInfo&gt; getSelfUserInfo() <span class="hljs-keyword">async</span>{ \n  <span class="hljs-comment">// 该数据涞源createUserInfo函数 </span>\n  <span class="hljs-built_in">int</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch; \n  UserInfoRsp userInfoRsp = UserInfoRsp.fromBuffer( \n      [ \n        <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">116</span>, <span class="hljs-number">101</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">18</span>, <span class="hljs-number">72</span>, <span class="hljs-number">104</span>, <span class="hljs-number">116</span>, \n        <span class="hljs-number">116</span>, <span class="hljs-number">112</span>, <span class="hljs-number">58</span>, <span class="hljs-number">47</span>, <span class="hljs-number">47</span>, <span class="hljs-number">105</span>, <span class="hljs-number">109</span>, <span class="hljs-number">97</span>, <span class="hljs-number">103</span>, <span class="hljs-number">101</span>, \n        <span class="hljs-number">46</span>, <span class="hljs-number">98</span>, <span class="hljs-number">105</span>, <span class="hljs-number">97</span>, <span class="hljs-number">111</span>, <span class="hljs-number">98</span>, <span class="hljs-number">97</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">117</span>, \n        <span class="hljs-number">46</span>, <span class="hljs-number">99</span>, <span class="hljs-number">111</span>, <span class="hljs-number">109</span>, <span class="hljs-number">47</span>, <span class="hljs-number">117</span>, <span class="hljs-number">112</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>, <span class="hljs-number">97</span>, \n        <span class="hljs-number">100</span>, <span class="hljs-number">115</span>, <span class="hljs-number">47</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">56</span>, <span class="hljs-number">48</span>, <span class="hljs-number">50</span>, <span class="hljs-number">49</span>, <span class="hljs-number">49</span>, \n        <span class="hljs-number">47</span>, <span class="hljs-number">48</span>, <span class="hljs-number">48</span>, <span class="hljs-number">47</span>, <span class="hljs-number">49</span>, <span class="hljs-number">53</span>, <span class="hljs-number">49</span>, <span class="hljs-number">56</span>, <span class="hljs-number">50</span>, <span class="hljs-number">55</span>, <span class="hljs-number">57</span>, \n        <span class="hljs-number">57</span>, <span class="hljs-number">54</span>, <span class="hljs-number">55</span>, <span class="hljs-number">45</span>, <span class="hljs-number">73</span>, <span class="hljs-number">65</span>, <span class="hljs-number">110</span>, <span class="hljs-number">86</span>, <span class="hljs-number">121</span>, <span class="hljs-number">80</span>, \n        <span class="hljs-number">105</span>, <span class="hljs-number">82</span>, <span class="hljs-number">76</span>, <span class="hljs-number">75</span>, <span class="hljs-number">46</span>, <span class="hljs-number">106</span>, <span class="hljs-number">112</span>, <span class="hljs-number">103</span>, <span class="hljs-number">26</span>, \n        <span class="hljs-number">4</span>, <span class="hljs-number">51</span>, <span class="hljs-number">48</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span> \n      ] \n  ); \n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'pb length\'</span>); \n  <span class="hljs-built_in">print</span>(userInfoRsp.toString().length); \n  <span class="hljs-built_in">int</span> dfTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DateTime</span>.now().microsecondsSinceEpoch - currentTime; \n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'pb decode time\'</span>); \n  <span class="hljs-built_in">print</span>(dfTime); \n  <span class="hljs-keyword">return</span> StructUserInfo( \n    userInfoRsp.uid, \n    userInfoRsp.nickName, \n    userInfoRsp.headerUrl \n  ); \n}\n</code></pre>\n<p data-nodeid="5044">代码第 5 行是应用 createUserInfo 生成的二进制数据，利用该二进制数据调用 fromBuffer 转化为 Protocol Buffer 对象，返回的对象可以直接获取到 StructUserInfo 的相应字段： uid、nickName 和 headerUrl，具体代码在第 25 到第 28行。第 18 行打印字符串长度，第 23 行打印反序列化时间。运行上面的代码，可以看到如下打印数据：</p>\n<pre class="lang-java" data-nodeid="5045"><code data-language="java">flutter: pb length \nflutter: <span class="hljs-number">109</span> \nflutter: pb decode time \nflutter: <span class="hljs-number">383</span>\n</code></pre>\n<p data-nodeid="5046">长度和解析时长相对 JSON 协议又减少了一些，因此在带宽和解析性能方面都是优于 JSON 和 XML。由于本课时中还没有实现服务端代码，我们只能借助第三方 Mock 平台来实现网络调用，因此这里会以 JSON 协议为参考来实践本课时的 api 层代码逻辑。在实际应用中，我更倾向大家使用 Protocol Buffer 。</p>\n<p data-nodeid="5047">以上就是三种协议在 Flutter 中的应用尝试和对比，基于数据长度和解析性能对比（由于跑的数据总量不够大，因此单次运行会存在样本误差），XML 是最差的，JSON 相对较好，Protocol Buffer 是最优的，不过可读性最差，具体对比看下表格 1。</p>\n<p data-nodeid="5048"><img src="https://s0.lgstatic.com/i/image/M00/3A/45/CgqCHl8hN_CAHkTmAABBGfUbGT4406.png" alt="image (15).png" data-nodeid="5193"></p>\n<div data-nodeid="5049"><p style="text-align:center">表格 1 整体数据对比情况</p></div>\n<h3 data-nodeid="5050">代码实践</h3>\n<p data-nodeid="5242" class="te-preview-highlight">介绍完常见的网络传输协议序列化方式，接下来就使用 JSON 的传输协议来完善我们 api 逻辑。这里会应用到一个第三方的 Mock 平台。主要是 Mock 以下几个接口协议，如图 2 所示的结构列表。</p>\n\n<p data-nodeid="5052"><img src="https://s0.lgstatic.com/i/image/M00/3A/3A/Ciqc1F8hOAmAc5eCAAH87tkUVJM571.png" alt="image (16).png" data-nodeid="5198"></p>\n<div data-nodeid="5053"><p style="text-align:center">图 2 Mock 协议列表</p></div>\n<p data-nodeid="5054">有了具体协议 Mock 协议后，我们再来实现 Flutter 中的代码。首先我们需要创建一个通用的网络请求的类，这个类我们存放在 util/tools 目录下，命名为 call_server.dart 。Flutter 中的网络协议需要使用到 <a href="https://pub.dev/packages/dio" data-nodeid="5204">dio</a> 这个第三方库，同样还是需要在 pubspec.yaml 增加依赖，然后更新本地库文件。接下来我们看下 call_server.dart 的代码实现。</p>\n<h4 data-nodeid="5055">通用网络请求类实现</h4>\n<p data-nodeid="5056">该通用网络请求类，文件存放在源码中的 lib/util/tools/call_server.dart ，接下来我们看下它的实现逻辑。</p>\n<p data-nodeid="5057">首先还是引入相应的库文件</p>\n<pre class="lang-dart" data-nodeid="5058"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'dart:convert\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:dio/dio.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/tools/json_config.dart\'</span>;\n</code></pre>\n<p data-nodeid="5059">第 1 个库是数据转化类的原生库，第 2 个库是网络请求库，第 3 个库是我们自己实现的一个工具库，该库的作用是读取一个 JSON 配置文件。</p>\n<p data-nodeid="5060">接下来我们实现 CallServer 类，在类中新增一个 get 方法，这里需要注意因为 dio 网络请求是一个异步方法，因此这里需要将 get 设计为一个 async 的方法，并返回的是一个 Future 类型，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="5061"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">统一调用API接口 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallServer</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">get 方法 </span></span>\n  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt; <span class="hljs-keyword">get</span> \n  } \n}\n</code></pre>\n<p data-nodeid="5062">因为网络请求异步返回的是一个 JSON 协议，因此需要设置返回的数据结构为 Map&lt;String, dynamic&gt; 。接下来我们看下具体的函数代码逻辑。</p>\n<pre class="lang-dart" data-nodeid="5063"><code data-language="dart"><span class="hljs-comment">// 根据类型，获取api具体信息 </span>\n<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; apis = <span class="hljs-keyword">await</span> JsonConfig.getConfig(<span class="hljs-string">\'api\'</span>); \n<span class="hljs-keyword">if</span>(apis == <span class="hljs-keyword">null</span>) { \n  <span class="hljs-keyword">return</span> {<span class="hljs-string">"ret"</span> : <span class="hljs-keyword">false</span>}; \n} \n<span class="hljs-built_in">String</span> callApi = apis[apiName][<span class="hljs-string">\'apiUrl\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>; \n<span class="hljs-comment">// 处理异常情况 </span>\n<span class="hljs-keyword">if</span>(callApi == <span class="hljs-keyword">null</span>) { \n  <span class="hljs-keyword">return</span> {<span class="hljs-string">"ret"</span> : <span class="hljs-keyword">false</span>}; \n} \n<span class="hljs-comment">// 处理参数替换 </span>\n<span class="hljs-keyword">if</span>(params != <span class="hljs-keyword">null</span>) { \n  params.forEach((k, v) =&gt; callApi = callApi.replaceAll(<span class="hljs-string">\'{<span class="hljs-subst">$k</span>}\'</span>, <span class="hljs-string">\'<span class="hljs-subst">$v</span>\'</span>)); \n} \n<span class="hljs-comment">// 调用服务端接口获取返回数据 </span>\n<span class="hljs-keyword">try</span> { \n  Response response = <span class="hljs-keyword">await</span> Dio().<span class="hljs-keyword">get</span>( \n      callApi, \n      options: Options(responseType: ResponseType.json) \n  ); \n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; retInfo = \n    json.decode(response.toString()) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;; \n  <span class="hljs-keyword">return</span> retInfo; \n} <span class="hljs-keyword">catch</span> (e) { \n  <span class="hljs-keyword">return</span> {<span class="hljs-string">"ret"</span> : <span class="hljs-keyword">false</span>}; \n}\n</code></pre>\n<p data-nodeid="5064">第 2 行读取配置文件中的 api.json 数据（配置文件需要在 pubspec.yaml 中引入，具体查看源码中的第 55 和第 56 行），该 api.json 的部分数据如下：</p>\n<pre class="lang-json" data-nodeid="5065"><code data-language="json">{ \n  <span class="hljs-attr">"recommendList"</span> : { \n    <span class="hljs-attr">"method"</span> : <span class="hljs-string">"get"</span>, \n    <span class="hljs-attr">"apiUrl"</span> : <span class="hljs-string">"https://www.fastmock.site/mock/978685eaf6950d1e2f0790f85cfdacaa/cgi-bin/recommend_list"</span>, \n    <span class="hljs-attr">"params"</span> : <span class="hljs-literal">null</span> \n  } \n}\n</code></pre>\n<p data-nodeid="5066">其中 JSON 部分就包括了协议名称，以及协议的请求方式和协议的 URL 以及具体的参数。<br>\n在 get 方法中，获取到 api.json 数据后，再根据协议名称，获取到协议的 URL 。接下来经过一定的数据判断和参数处理，应用 dio 模块发起 get 网络请求。最后再使用 convert 库，将结构转化为 JSON 数据结构，并返回给到调用方。</p>\n<h4 data-nodeid="5067">ApiContentIndex 实现</h4>\n<p data-nodeid="5068">通用网络请求实现后，我们再看下具体的接口调用方的实现逻辑。接下来我们修改 ApiContentIndex 中的 getRecommendList 的代码，将原来的假数据转化为网络请求。因为是异步方法，因此还是需要使用 Future 和 async ，函数代码如下：</p>\n<pre class="lang-dart" data-nodeid="5069"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/api_ret_info.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/content_detail.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/tools/call_server.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">获取内容详情接口 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiContentIndex</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">拉取用户内容推荐帖子列表 </span></span>\n  Future&lt;StructApiContentListRetInfo&gt; getRecommendList([lastId = <span class="hljs-keyword">null</span>]) <span class="hljs-keyword">async</span> { \n\n  } \n}\n</code></pre>\n<p data-nodeid="5070">代码第一部分还是引入相应的库，第二部分创建 ApiContentIndex 类，并创建 getRecommendList 函数，该函数异步返回 StructApiContentListRetInfo 数据结构，支持可选参数 lastId ，有 lastId 则拉取下一页，没有则拉取首页内容。接下来看下 getRecommendList 函数的具体逻辑，代码如下。</p>\n<pre class="lang-dart" data-nodeid="5071"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">拉取用户内容推荐帖子列表 </span></span>\nFuture&lt;StructApiContentListRetInfo&gt; getRecommendList([lastId = <span class="hljs-keyword">null</span>]) <span class="hljs-keyword">async</span> { \n  <span class="hljs-keyword">if</span> (lastId != <span class="hljs-keyword">null</span>) { \n    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; retJson = \n      <span class="hljs-keyword">await</span> CallServer.<span class="hljs-keyword">get</span>(<span class="hljs-string">\'recommendListNext\'</span>, {lastId: lastId}); \n    <span class="hljs-keyword">return</span> StructApiContentListRetInfo.fromJson(retJson); \n  } <span class="hljs-keyword">else</span> { \n    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; retJson = \n    <span class="hljs-keyword">await</span> CallServer.<span class="hljs-keyword">get</span>(<span class="hljs-string">\'recommendList\'</span>); \n    <span class="hljs-keyword">return</span> StructApiContentListRetInfo.fromJson(retJson); \n  } \n}\n</code></pre>\n<p data-nodeid="5072">以上代码就比较简洁了，先根据 lastId 判断拉取首页还是拉取下一页，如果拉取首页，则调用 recommendList 协议，如果拉取下一页，则调用 recommendListNext 协议。使用 CallServer.get 方法与服务端交互，得到返回数据结构后，调用 StructApiContentListRetInfo.fromJson 转化为 StructApiContentListRetInfo 数据结构，这样就实现了具体的 API 协议，最后我们再来看下在页面中调用 api 的使用方法。</p>\n<h4 data-nodeid="5073">HomePageIndex</h4>\n<p data-nodeid="5074">因为 ApiContentIndex 协议是在 HomePageIndex 这个类中调用，我们就来看下这块的处理逻辑，相同部分我们就不过多介绍。</p>\n<pre class="lang-dart" data-nodeid="5075"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">处理首次拉取和刷新数据获取动作 </span></span>\n<span class="hljs-keyword">void</span> setFirstPage() { \n  ApiContentIndex().getRecommendList().then((retInfo){ \n    <span class="hljs-keyword">if</span> (retInfo.ret != <span class="hljs-number">0</span>) { \n      <span class="hljs-comment">// 判断返回是否正确 </span>\n      error = <span class="hljs-keyword">true</span>; \n      <span class="hljs-keyword">return</span>; \n    } \n    setState(() { \n      error = <span class="hljs-keyword">false</span>; \n      contentList = retInfo.data; \n      hasMore = retInfo.hasMore; \n      isLoading = <span class="hljs-keyword">false</span>; \n      lastId = retInfo.lastId; \n    }); \n  }); \n}\n</code></pre>\n<p data-nodeid="5076">在 setFirstPage 中调用类 ApiContentIndex 中的异步方法 getRecommendList ，在 getRecommendList 回调中成功获取数据后使用 setState 更新页面状态。由于网络请求有时间延迟，因此在页面刚加载时，需要使用 loading 组件，需要更改原来的 build 方法，修改部分如下：</p>\n<pre class="lang-dart" data-nodeid="5077"><code data-language="dart"><span class="hljs-keyword">if</span> (error) { \n  <span class="hljs-keyword">return</span> CommonError(action: <span class="hljs-keyword">this</span>.setFirstPage); \n} \n<span class="hljs-keyword">if</span>(contentList == <span class="hljs-keyword">null</span>){ \n  <span class="hljs-keyword">return</span> Loading(); \n}\n</code></pre>\n<p data-nodeid="5078">主要是第 4 行，增加了对数据的判断，如果为空则显示 loading 组件内容，具体效果如下图 3 所示。</p>\n<p data-nodeid="5079"><img src="https://s0.lgstatic.com/i/image/M00/3A/45/CgqCHl8hOHuANKsHACSrYreWeyI011.gif" alt="20200717_233752.gif" data-nodeid="5234"></p>\n<div data-nodeid="5080"><p style="text-align:center">图 3 网络请求 loading 效果</p></div>\n<p data-nodeid="5081">以上就完成了 ApiContentIndex 部分的 getRecommendList 逻辑，其他代码逻辑基本相似，具体大家可以参考 github 上的源码。</p>\n<h3 data-nodeid="5082">总结</h3>\n<p data-nodeid="5083">本课时介绍了 APP 常用的三种网络传输协议序列化方式，其次介绍了 Flutter 与服务端的网络通信方法，并且通过传输协议与服务端进行交互获取数据。学完本课时后要着重掌握 JSON 和 Protocol Buffer 的使用方法，其次掌握网络请求库 CallServer 的实现原理。</p>\n<p data-nodeid="5084">下一课时我们将整理我们在 Two You APP 研发过程中所涉及的布局逻辑，介绍在 Flutter 中常见的一些布局原理和思想，并用此理论来完善我们 APP 内的“客人态页面” 的功能。</p>\n<p data-nodeid="5085" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="5241">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '16 | 布局设计：如何将 Flutter 布局设计沉淀为理论规范',
            id: 318,
            content:
              '<p data-nodeid="2282" class="">前面课时只介绍了组件设计，并没有过多涉及布局的讲解，可能你了解一些布局组件，比如 Container、Row、Column、Padding、Center 等，但是对于如何从 UI 稿到组件再到布局，却没有非常清晰的思路。本课时就从我的角度来分析，如何进行组件的布局。</p>\n<h3 data-nodeid="2283">常见布局组件</h3>\n<p data-nodeid="2284">在 Flutter 中可以分为 Single-child layout widgets 和 Multi-child layout widgets ，使用中文来解释就是单个子元素的布局组件和多个子元素的布局组件。</p>\n<h4 data-nodeid="2285">Single-child</h4>\n<p data-nodeid="2286">常见单个子组件的有 Align、Padding、 Expanded 和 Container 。</p>\n<ul data-nodeid="2287">\n<li data-nodeid="2288">\n<p data-nodeid="2289">Align 比较好理解，Align 组件的位置左、右、上、下、左上、右下、左下、右上，这两者一般配合 Container 来使用。</p>\n</li>\n<li data-nodeid="2290">\n<p data-nodeid="2291">Padding 是一个可以设置上下和左右填充的组件，在布局设计中也非常常见。</p>\n</li>\n<li data-nodeid="2292">\n<p data-nodeid="2293">Expanded 是一个可伸缩的容器，可以根据子组件的大小进行动态伸缩，这个需要配合 Row 组件的 flex 布局使用，其次也可以作为动态列表的父组件，避免列表超出界面，引起布局问题。</p>\n</li>\n<li data-nodeid="2294">\n<p data-nodeid="2295">Container 是比较常用的，类似一个容器，可以设置容器的大小，然后将子元素包裹在容器中，该组件在超出容器后，会容易引起布局问题。</p>\n</li>\n</ul>\n<h4 data-nodeid="2296">Multi-child</h4>\n<p data-nodeid="2297">常见的多个子组件有 Row、Column 和 Stack。</p>\n<ul data-nodeid="2298">\n<li data-nodeid="2299">\n<p data-nodeid="2300">Row 是横排展示子组件。</p>\n</li>\n<li data-nodeid="2301">\n<p data-nodeid="2302">Column 是竖排展示子组件。</p>\n</li>\n<li data-nodeid="2303">\n<p data-nodeid="2304">Stack 是层叠展示子组件。</p>\n</li>\n</ul>\n<p data-nodeid="2305">以上具体每个组件的参数配置，大家可以在<a href="https://flutter.cn/docs/development/ui/widgets/layout" data-nodeid="2394">官网</a>查到，官网还有一些不常用的，但也比较实用的布局组件，这里就不详细列出了。</p>\n<h3 data-nodeid="2306">布局思想</h3>\n<p data-nodeid="2307">将布局的思想总结为八个字：<strong data-nodeid="2402">竖、横、高、宽、上、下、左、右。</strong> 也就是一个页面出来以后，按照这八个字的先后去分析页面的布局。那么我们具体来看下，八个字中会涉及哪些布局组件的应用。</p>\n<h4 data-nodeid="2308">竖和横</h4>\n<p data-nodeid="2309">根据设计好的组件树，从上往下分析，遇到块状不同内容组，则设计为一个 Column 的子元素。例如图 2 的一个界面，从上往下分析，我们可以得到 6 个 Column 布局组件的子组件（这里为了演示效果，我们把组件也设计为 6 个部分）。</p>\n<p data-nodeid="2310"><img src="https://s0.lgstatic.com/i/image/M00/3B/70/CgqCHl8j_LCAP9HUAAHcncNZZmY563.png" alt="Drawing 0.png" data-nodeid="2407"></p>\n<div data-nodeid="2311"><p style="text-align:center">图 1 帖子详情页</p></div>\n<p data-nodeid="2312">分析完成以后，我们再来看下每一行组件中所涉及的子组件。行子组件一般也是基于：Container、Row、Center 等布局组件来实现的，根据图 1 的效果，我们来分析：</p>\n<ul data-nodeid="2313">\n<li data-nodeid="2314">\n<p data-nodeid="2315">第一部分是居中的文章标题，可以使用 Center 组件；</p>\n</li>\n<li data-nodeid="2316">\n<p data-nodeid="2317">第二部分是一条横线，可以使用 Divider 来绘制一条分割直线；</p>\n</li>\n<li data-nodeid="2318">\n<p data-nodeid="2319">第三部分是用户信息，因为横着是有两个组件，所以使用 Row；</p>\n</li>\n<li data-nodeid="2320">\n<p data-nodeid="2321">第四部分是文章内容，这里使用 Container 包裹一个 Text 组件；</p>\n</li>\n<li data-nodeid="2322">\n<p data-nodeid="2323">第五部分是文章图片，这里也使用 Container 包裹一个 Image 组件；</p>\n</li>\n<li data-nodeid="2324">\n<p data-nodeid="2325">第六部分是一个组件，这个组件内部竖看也是两个组件，因此需要使用 Column 组件。</p>\n</li>\n</ul>\n<p data-nodeid="2326">根据以上规则我们就可以设计出一个 pages 的页面了，代码如下：</p>\n<pre class="lang-dart" data-nodeid="2327"><code data-language="dart"><span class="hljs-keyword">return</span> Column( \n  children: &lt;Widget&gt;[ \n    ArticleDetailTitle(title: contentDetail.title), \n    Divider(), \n    ArticleDetailUserInfoBar(userInfo: contentDetail.userInfo), \n    ArticleDetailContent(content: contentDetail.detailInfo), \n    ArticleDetailImg(articleImage: contentDetail.articleImage), \n    ArticleDetailLike(articleId: id, likeNum: contentDetail.likeNum) \n  ], \n);\n</code></pre>\n<h4 data-nodeid="2328">高和宽</h4>\n<p data-nodeid="2329">接下来我们分析好每个组件所占用的高和宽，这部分可以在组件的 Container 属性中设置，有些组件也自带高和宽属性。例如上面的 Divider 组件我们就需要设置高和宽，代码如下：</p>\n<pre class="lang-dart" data-nodeid="2330"><code data-language="dart"><span class="hljs-keyword">return</span> Column( \n  children: &lt;Widget&gt;[ \n    ArticleDetailTitle(title: contentDetail.title), \n    Divider( \n        height: <span class="hljs-number">1</span>, \n        color: Colors.lightBlueAccent, \n        indent: <span class="hljs-number">75</span>, \n        endIndent: <span class="hljs-number">75</span> \n    ), \n    ArticleDetailUserInfoBar(userInfo: contentDetail.userInfo), \n    ArticleDetailContent(content: contentDetail.detailInfo), \n    ArticleDetailImg(articleImage: contentDetail.articleImage), \n    ArticleDetailLike(articleId: id, likeNum: contentDetail.likeNum), \n    ArticleDetailComments(commentList: []) \n  ], \n);\n</code></pre>\n<p data-nodeid="2331">上面代码的第 5 行就是设置高，第 7 和第 8 行就是设置其宽度。</p>\n<h4 data-nodeid="2332">上和下</h4>\n<p data-nodeid="2333">设置完每个组件的高和宽后，我们再从上往下看。根据组件树，这里主要看 Column 组件下的所有子组件之间是否需要设置上下，如果需要则应用 Padding 来实现。为了效果，我们在 ArticleDetailContent 和 ArticleDetailUserInfoBar 之间增加一个 Padding 效果，代码如下：</p>\n<pre class="lang-dart" data-nodeid="2334"><code data-language="dart"><span class="hljs-keyword">return</span> Column( \n  children: &lt;Widget&gt;[ \n    ArticleDetailTitle(title: contentDetail.title), \n    Divider( \n        height: <span class="hljs-number">1</span>, \n        color: Colors.lightBlueAccent, \n        indent: <span class="hljs-number">75</span>, \n        endIndent: <span class="hljs-number">75</span> \n    ), \n    ArticleDetailUserInfoBar(userInfo: contentDetail.userInfo), \n    Padding(padding: EdgeInsets.only(top: <span class="hljs-number">2</span>)), \n    ArticleDetailContent(content: contentDetail.detailInfo), \n    ArticleDetailImg(articleImage: contentDetail.articleImage), \n    ArticleDetailLike(articleId: id, likeNum: contentDetail.likeNum), \n    ArticleDetailComments(commentList: []) \n  ], \n);\n</code></pre>\n<h4 data-nodeid="2335">左和右</h4>\n<p data-nodeid="2336">整体设置完成后，我们再来看下组件左右的间隔设置。这里主要看 Row 组件下的所有子组件，检查是否需要 Padding 属性。其次判断 Row 子组件是否需要设置左右占比，如果需要则使用到 flex 布局中的 Expanded 组件。比如上面组件中的 ArticleDetailUserInfoBar 需要左右布局设计，因此根据规则我们看下 ArticleDetailUserInfoBar 的代码逻辑。具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="2337"><code data-language="dart"><span class="hljs-meta">@override</span> \nWidget build(BuildContext context) { \n  <span class="hljs-keyword">return</span> Container( \n    color: Colors.white, \n    padding: EdgeInsets.all(<span class="hljs-number">8</span>), \n    child: Row( \n      mainAxisAlignment: MainAxisAlignment.spaceBetween, \n      children: &lt;Widget&gt;[ \n        Expanded( \n          flex: <span class="hljs-number">4</span>, \n          child: Row(), \n        Expanded( \n          flex: <span class="hljs-number">1</span>, \n          child: Row(), \n      ], \n    ), \n  ); \n}\n</code></pre>\n<p data-nodeid="2338">上面的代码中可以看到该组件使用 Container 包裹，其次使用了 Row 组件，假设我们 UI 稿中的图 3 部分是左右 4 : 1 布局，因此在代码中第 10 行设置前面组件为 4 ，第 13 行设置后面组件为 1。</p>\n<p data-nodeid="2339">这样就完成了外部组件的设计，以上 6 个组件就可以写一部分伪代码去实现了。外部组件设计完成后，我们开始通过 8 个过程来进行子组件布局设计，对于其中的 8 个过程，并不是每个组件都需要，因此越到根节点布局设计过程会越少。</p>\n<p data-nodeid="2340">根据以上设计原则，我们就实现了帖子详情部分的布局设计。具体代码实现在 github 源码中的 pages/article_detail/index.dart 中。接下来我将用上面的原则来设计我们 Two You Friend App 的“客人态主页”页面。</p>\n<h3 data-nodeid="2341">实践应用</h3>\n<p data-nodeid="3076" class="">我们先来看下我们需要实现的效果，如图 2 所示。<br>\n<img src="https://s0.lgstatic.com/i/image/M00/3B/66/Ciqc1F8kAQiAQlZeAAyBiY_2das872.png" alt="2.png" data-nodeid="3082"></p>\n<div data-nodeid="3077"><p style="text-align:center">图 2 客人态页面</p></div>\n\n\n\n\n\n\n<p data-nodeid="4086" class="">根据图 2 的界面我们还是先绘制一个组件树，如图 3 所示。<br>\n<img src="https://s0.lgstatic.com/i/image/M00/3B/72/CgqCHl8kARSAEVsNAAnCRb3Xg8U183.png" alt="3.png" data-nodeid="4092"></p>\n<div data-nodeid="4087"><p style="text-align:center">图 3 客人态组件树设计</p></div>\n\n\n\n\n\n\n<p data-nodeid="2348">接下来，我们在图 3 的基础上，应用布局设计的 8 个过程，一步步来优化这个组件树。</p>\n<h4 data-nodeid="2349">竖和横</h4>\n<p data-nodeid="2350">竖着来看四个组件分别为 guest 的 Column 子组件，因此需要标记为 Column。然后再横着看每个子组件：</p>\n<ul data-nodeid="2351">\n<li data-nodeid="2352">\n<p data-nodeid="2353">guest_header，包含两部分左边为 user_info 组件（其中又包含 Image 和 Text），右边为 Icon 组件；</p>\n</li>\n<li data-nodeid="2354">\n<p data-nodeid="2355">Divider，是一条分割线；</p>\n</li>\n<li data-nodeid="2356">\n<p data-nodeid="2357">guest_bar，包含了三个并列的组件，分别是 Icon、Icon 和 Text；</p>\n</li>\n<li data-nodeid="2358">\n<p data-nodeid="2359">content_list，这个应用 article_card 子组件即可，该组件已经在前面介绍过具体设计。</p>\n</li>\n</ul>\n<p data-nodeid="2360">分析完后，我们将会得到图 4 组件树。</p>\n<p data-nodeid="2361"><img src="https://s0.lgstatic.com/i/image/M00/3B/70/CgqCHl8j_UCAYzQpAAC8p58g-Ys713.png" alt="Drawing 3.png" data-nodeid="2453"></p>\n<div data-nodeid="2362"><p style="text-align:center">图 4 组件树+布局设计</p></div>\n<p data-nodeid="2363">从图 4 我们可以看到，在组件与组件之间增加了布局组件的应用 Column 、Row 和 Expanded。</p>\n<h4 data-nodeid="2364">高和宽</h4>\n<p data-nodeid="2365">上面组件中，有两个组件是需要设置的，一个是 Divider ，一个是 content_list 。后者需要设置的目的是，因为列表组件超出会引起布局异常。因此 content_list 是需要使用 Expanded 来包裹，这部分可以不体现在界面中。</p>\n<h4 data-nodeid="2366">上和下</h4>\n<p data-nodeid="2367">由于图 2 这里就没有需要设置上下的间隔，因此组件图也不需要修改。这里主要看每个 Column 组件下的子节点。</p>\n<h4 data-nodeid="2368">左和右</h4>\n<p data-nodeid="2369">根据这个规则，我们看下每个 Row 组件下的子节点之间是否需要设置 Padding 。根据 UI 稿分析，我们可以了解到 user_info 和 guest_bar 组件的子组件都需要设置左右填充，因此在图 2 基础上，我们增加 Padding 布局设计，并重新绘制组件图，可以最终得到图 5 的一个组件+布局的设计结果。</p>\n<p data-nodeid="2370"><img src="https://s0.lgstatic.com/i/image/M00/3B/70/CgqCHl8j_YeAGTGoAADPvQkoceM879.png" alt="Drawing 5.png" data-nodeid="2471"></p>\n<div data-nodeid="2371"><p style="text-align:center">图 5 组件树+布局设计结果</p></div>\n<p data-nodeid="2372">在将组件树和布局设计完成后，我们再去进行组件的代码编写，这部分代码大家可以前往 github 的源码的 pages/user_page/guest.dart 文件中查看，具体的代码比较相似，这里就不过多介绍了。</p>\n<h3 data-nodeid="2373">总结</h3>\n<p data-nodeid="2374">本课时介绍了几个常用的布局组件和布局设计的思想（8 个过程），最后通过实现“客人态主页“来实践组件树+布局的设计思想。相关页面的知识点就介绍完了，接下来我会在源码中更新其他界面内容，对于比较核心的一些知识点我们还会在 18 课时中介绍，其他重复知识点，就不再介绍了。</p>\n<p data-nodeid="2375">下一课时我们将带着现有的 Two You Friend App 代码，教大家如何打包 Android 和 iOS 发布包。</p>\n<p data-nodeid="2376" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="2480">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '17 | 打包发布：Flutter 应用，你离线上运营只差最后一步',
            id: 319,
            content:
              '<p data-nodeid="46003" class="">本课时主要介绍如何将 Two You App 项目，打包成 apk 和 ipa 文件。在打包前，我们首先需要将 App 的名称和图标进行修改，其次增加一些功能授权，确保我们打包后的文件安装是可用的。</p>\n\n\n<h3 data-nodeid="45165">基础配置</h3>\n<p data-nodeid="45166">在打包之前我们需要修改 App 的名字和图标，Android 和 iOS 的修改方式有点不同，我们先来看下在 Android 中的修改方式。</p>\n<h4 data-nodeid="45167">Android</h4>\n<p data-nodeid="45168">我们打开项目路径下的 android/app/src/main/AndroidMainfest.xml 文件，在该文件中找到下面两个字段：</p>\n<ul data-nodeid="45169">\n<li data-nodeid="45170">\n<p data-nodeid="45171">android:label，为应用展示在手机中的名字，这里我们修改为 Two You；</p>\n</li>\n<li data-nodeid="45172">\n<p data-nodeid="45173">android:icon，为应用展示在手机中的图标，可以修改图片的名字，具体图标文件存储在 android/app/src/main/res 中。</p>\n</li>\n</ul>\n<p data-nodeid="45174">其次需要增加网络访问权限，在 manifest（application 配置下面）中增加下面四行配置：</p>\n<pre class="lang-xml" data-nodeid="45175"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span> \n<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /&gt;</span> \n<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span> \n<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span> \n</code></pre>\n<p data-nodeid="45176">这样就将打包所需要的配置信息处理完了，接下来我们看下 iOS 的配置。</p>\n<h4 data-nodeid="45177">iOS</h4>\n<p data-nodeid="45178">我们打开项目路径下的 ios/Runner/info.plist 文件，在文件中找到 CFBundleName 的 key，然后修改该 key 对应的值，修改为下面的配置：</p>\n<pre class="lang-js" data-nodeid="48789"><code data-language="js">&lt;key&gt;CFBundleName&lt;/key&gt;  \n<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Two You<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span> \n</code></pre>\n\n\n\n\n\n<p data-nodeid="49346">图标的配置在 ios/Runner/Assets.xcassets/AppIcon.appiconset/Content.json 文件中，具体需要根据不同的机型做不同的配置。</p>\n<p data-nodeid="50480" class="">请注意，如果需要申请其他权限，例如本地存储都需要在 AndroidMainfest.xml 和 info.plist 中增加相应的配置，不然可能会导致异常或者 Crash。具体权限配置查询，<a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html" data-nodeid="50484">Android 请参考这里</a>，<a href="https://pub.dev/packages/flutter_permissions" data-nodeid="50488">iOS 请参考这里</a>。</p>\n\n\n\n<p data-nodeid="45181">如上配置修改完成后，我们可以在虚拟机上重新构建 App，构建完成后你可以在虚拟机上看到图标和名称的效果，接下来我们开始介绍打包过程。</p>\n<h3 data-nodeid="45182">打包发布</h3>\n<p data-nodeid="45183">打包发布过程在官网都有比较详细的说明文档，不过这里我还是会针对过程中的每一步进行阐述，减少你在打包发布过程中的问题。由于目前没有私人的苹果开发者账号，因此这里只说明 Android 中的打包问题，iOS 部分会详细介绍下流程。</p>\n<h4 data-nodeid="45184">Android</h4>\n<p data-nodeid="45185">按照如下步骤，一步步操作。在每个步骤中，我会详细说明需要注意的细节点，请认真阅读每个过程，以免出现一些不必要的问题。</p>\n<p data-nodeid="56997" class="">1.<strong data-nodeid="57010">keytool 是否安装</strong>。一般情况下，如果安装了 Android Studio ，keytool 是会默认安装，如果你安装了 Java ，在 Java 的 bin 目录也可以找到该工具，没有安装 Java 的话可以前往 <a href="https://java.com/en/download/help/download_options.xml" data-nodeid="57008">这里安装 Java</a>；</p>\n<p data-nodeid="57572" class="">2.<strong data-nodeid="57579">创建 keystore</strong>，有了 keytool 工具后，运行如下命令：</p>\n<pre class="lang-java" data-nodeid="57573"><code data-language="java">keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize <span class="hljs-number">2048</span> -validity <span class="hljs-number">10000</span> -alias key \n</code></pre>\n\n\n\n\n\n\n\n\n<p data-nodeid="45192">其中 genkey 是生成一个密钥对，keystore 是密钥库的名称（可以根据你自己的实际情况修改），keyalg 是加密算法，keysize 是大小，validity 为有效期天数，alias 为别名。在上面的配置信息中， alias 的 key 是比较关键的，如果大家需要修改需要记住该 alias。<br>\n输入该命令后，需要你填写各种信息，其中涉及一个密码比较关键（请记住该密码），其他的信息按照你的想法输入就行。执行完成后会提示下面的信息，代表成功创建。</p>\n<pre class="lang-js" data-nodeid="54731"><code data-language="js">[正在存储/Users/xxx/key.jks] \n</code></pre>\n\n\n\n\n<p data-nodeid="45194">这里请记住该 keystore 的目录地址。</p>\n<p data-nodeid="56433" class="">3.<strong data-nodeid="56440">引用 keystore 生成 key.properties</strong>，在项目的 android 目录下创建一个 key.properties 文件，该文件包含如下配置信息：</p>\n<pre class="lang-js" data-nodeid="61464"><code data-language="js">storePassword=刚才输入的密码 \nkeyPassword=刚才输入的密码 \nkeyAlias=刚才设置的别名 \nstoreFile=生成的 keystore 文件地址路径 \n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="45199">这四个数据一定要配置正确，不然会在打包时会报错，报错会提示相应的数据错误。</p>\n<p data-nodeid="62582" class="">4.<strong data-nodeid="62589">配置签名</strong>，具体需要打开 android/app/build.gradle 该文件，在该文件中找到下面信息</p>\n<pre class="lang-java" data-nodeid="63142"><code data-language="java">android { \n</code></pre>\n\n\n\n\n\n<p data-nodeid="45204">修改为下面的配置，主要是增加了对 key.properties 文件引入。</p>\n<pre class="lang-java" data-nodeid="63695"><code data-language="java">def keystorePropertiesFile = rootProject.file(<span class="hljs-string">"key.properties"</span>) \ndef keystoreProperties = <span class="hljs-keyword">new</span> Properties() \nkeystoreProperties.load(<span class="hljs-keyword">new</span> FileInputStream(keystorePropertiesFile)) \nandroid { \n</code></pre>\n\n<p data-nodeid="45206">然后找到下面配置。</p>\n<pre class="lang-java" data-nodeid="64248"><code data-language="java">buildTypes { \n    release { \n        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add your own signing config for the release build. </span>\n        <span class="hljs-comment">// Signing with the debug keys for now, so `flutter run --release` works. </span>\n        signingConfig signingConfigs.debug \n    } \n} \n</code></pre>\n\n<p data-nodeid="45208">替换为下面这份配置。</p>\n<pre class="lang-java" data-nodeid="64801"><code data-language="java">signingConfigs { \n    release { \n        keyAlias keystoreProperties[<span class="hljs-string">\'keyAlias\'</span>] \n        keyPassword keystoreProperties[<span class="hljs-string">\'keyPassword\'</span>] \n        <span class="hljs-function">storeFile <span class="hljs-title">file</span><span class="hljs-params">(keystoreProperties[<span class="hljs-string">\'storeFile\'</span>])</span> \n        storePassword keystoreProperties[\'storePassword\'] \n    } \n} \nbuildTypes </span>{ \n    release { \n        signingConfig signingConfigs.<span class="hljs-function">release \n        minifyEnabled <span class="hljs-keyword">true</span> \n        useProguard <span class="hljs-keyword">true</span> \n        proguardFiles <span class="hljs-title">getDefaultProguardFile</span><span class="hljs-params">(<span class="hljs-string">\'proguard-android.txt\'</span>)</span>, \'proguard-rules.pro\' \n    } \n} \n</span></code></pre>\n\n<p data-nodeid="65915" class="">5.<strong data-nodeid="65922">混淆代码包</strong>，这点类似于前端所说的 JS 压缩，主要是缩减代码，并达到不可阅读的目的。完成混淆功能，需要创建 lib/android/app/proguard-rule 文件，具体可以按照如下的方式配置：</p>\n<pre class="lang-dart" data-nodeid="70330"><code data-language="dart">#Flutter Wrapper \n-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">flutter</span>.<span class="hljs-title">app</span>.** </span>{ *; } \n-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">flutter</span>.<span class="hljs-title">plugin</span>.**  </span>{ *; } \n-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">flutter</span>.<span class="hljs-title">util</span>.**  </span>{ *; } \n-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">flutter</span>.<span class="hljs-title">view</span>.**  </span>{ *; } \n-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">flutter</span>.**  </span>{ *; } \n-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">flutter</span>.<span class="hljs-title">plugins</span>.**  </span>{ *; } \n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="71160">上述配置只混淆了 Flutter 引擎库，其他的库或者项目中的库也可以使用这种方式，具体的配置规则大家可以搜索 Proguard 的常用规则。</p>\n<p data-nodeid="71161">增加需要混淆压缩的配置文件后，需要在 lib/android/app/build.gradle 中打开混淆压缩的逻辑，在 android 中增加下面一段配置。</p>\n\n\n\n<pre class="lang-java" data-nodeid="71714"><code data-language="java">buildTypes { \n        release { \n            signingConfig signingConfigs.<span class="hljs-function">release \n            minifyEnabled <span class="hljs-keyword">true</span> \n            useProguard <span class="hljs-keyword">true</span> \n            proguardFiles <span class="hljs-title">getDefaultProguardFile</span><span class="hljs-params">(<span class="hljs-string">\'proguard-android.txt\'</span>)</span>, \'proguard-rules.pro\' \n        } \n    } \n</span></code></pre>\n\n<p data-nodeid="72265">其中 minifyEnabled 和 useProguard 配合使用都为 true 才会开启压缩混淆，如果只是 minifyEnabled 为 true 只会打开压缩，并不会混淆。</p>\n<p data-nodeid="72266">以上完成后，我们在项目根目录，运行下面命令启动打包 apk。</p>\n\n<pre class="lang-java" data-nodeid="72819"><code data-language="java">flutter build apk \n</code></pre>\n\n<p data-nodeid="73370">执行成功后，会提示具体 apk 保存的位置，然后将该 apk 发送到 Android 手机，就可以在手机上看到我们的具体效果了。</p>\n<p data-nodeid="73371"><strong data-nodeid="73377">可能出现的问题</strong>（后续有出现其他的，可以评论，我会尽量帮大家解答，解答完成后再更新到这里）：</p>\n\n<p data-nodeid="74479" class="">1.<strong data-nodeid="74492">Execution failed for task \':flutter_webview_plugin:verifyReleaseResources\'. &gt; A failure occurred while executing com.android.build.gradle.internal.tasks.Workers$ActionFacade.</strong></p>\n\n<p data-nodeid="45222">原因：我们使用了一个 flutter_webview_plugin: ^0.3.0+2 的包，会导致在打包的时候无法找到。</p>\n<p data-nodeid="45223">解决：你先将这个包的版本修改为 flutter_webview_plugin: ^0.3.0 这个，其次删掉 pubspec.lock 文件，依次等待执行下面几个命令即可：</p>\n<pre class="lang-java" data-nodeid="73928"><code data-language="java">flutter clean \nflutter pub get \n</code></pre>\n\n<p data-nodeid="75596" class="">2.<strong data-nodeid="75601">在虚拟机上运行正常，在实体机上运行出现各种奇怪问题，比如一打开直接黑屏。</strong></p>\n\n\n<p data-nodeid="45228">原因：实体机上各种权限都是需要申请，比如说网络权限、相机权限等，如果没有申请会导致网络请求失败超时。我们 App 中首次需要等待用户信息返回数据，因此可能会导致的就是黑屏。</p>\n<p data-nodeid="45229">解决：对于黑屏，上面已经说明了需要增加网络授权。关于这类问题的话，你可以使用排除法，例如只展示一个简单 Text 组件，看下打包后是否正常，然后慢慢地增加组件。经过这个过程，你会发现到具体的问题原因。还有一种方法就是外接设备进行调试。</p>\n<p data-nodeid="45230">其他问题欢迎大家评论补充，接下来我们看下 iOS 的打包过程。</p>\n<h4 data-nodeid="45231">iOS</h4>\n<p data-nodeid="45232">完成 iOS 的打包和发布，需要几个先决条件：</p>\n<ol data-nodeid="45233">\n<li data-nodeid="45234">\n<p data-nodeid="45235">Xcode，如果你是非 Mac 系统，需要先安装虚拟机，然后安装 Mac 系统，具体的流程你可以去搜索安装；</p>\n</li>\n<li data-nodeid="45236">\n<p data-nodeid="45237">苹果开发者账户，这个需要下载苹果的开发者 App，然后在 App 上认证支付，认证完成后创建项目，并设置一个 Bundle Id。</p>\n</li>\n</ol>\n<p data-nodeid="45238">接下来我们看下具体的打包步骤：</p>\n<p data-nodeid="79508" class="">1.<strong data-nodeid="79522">打开 Xcode</strong>，并打开 Flutter 中的 ios 目录；<br>\n2.打开后，<strong data-nodeid="79523">点击左侧项目的 Runner</strong>，然后选择右侧的 Singing &amp; Capabilites，修改 Bundle Id 为对应在苹果开发者中创建的项目 Bundle Id，接下来选择 Team，登录开发者账户，自动查询相应的项目信息，如图 1 截图指引所示；</p>\n\n\n<p data-nodeid="77830"><img src="https://s0.lgstatic.com/i/image/M00/3D/C7/Ciqc1F8qoliAHwU5AALSnCYSZPg629.png" alt="image (7).png" data-nodeid="77838"></p>\n<div data-nodeid="78391" class=""><p style="text-align:center">图 1 Xcode 配置指引</p> </div>\n\n\n\n\n\n\n<p data-nodeid="80624" class="">3.回到项目根目录中运行下面命令并<strong data-nodeid="80631">执行 Flutter 的命令创建 relase 版本</strong>；</p>\n<pre class="lang-plain" data-nodeid="80625"><code data-language="plain">flutter build ios \n</code></pre>\n\n\n\n\n<p data-nodeid="81739" class="">4.在 Xcode 中，**配置应用程序版本并构建一个可测试的 App 版本，**步骤如下。</p>\n\n<ul data-nodeid="82819">\n<li data-nodeid="82820">\n<p data-nodeid="82821">首先选择 Product &gt; Scheme &gt; Runner，然后选择 Product &gt; Destination &gt; Generic iOS Device。</p>\n</li>\n<li data-nodeid="82822">\n<p data-nodeid="82823"><strong data-nodeid="82830">选中左侧的 Runner</strong>，并打开右侧的 General ，然后配置 Identity 中的版本号 Version 和 Build，如图 2 所示。</p>\n</li>\n</ul>\n<p data-nodeid="83949"><img src="https://s0.lgstatic.com/i/image/M00/3D/D3/CgqCHl8qopOARENrAAaU0YGW44c040.png" alt="image (8).png" data-nodeid="83957"></p>\n<div data-nodeid="83950" class=""><p style="text-align:center">图 2 配置指引</p> </div>\n<p></p>\n\n\n\n\n\n\n\n<ul data-nodeid="45260">\n<li data-nodeid="45261">\n<p data-nodeid="45262"><strong data-nodeid="45424">选择 Product &gt; Archive 以生成构建文件。</strong></p>\n</li>\n<li data-nodeid="45263">\n<p data-nodeid="45264">在 Xcode Organizer 窗口的边栏中，选择 iOS 应用程序，然后<strong data-nodeid="45429">选中刚刚构建的文件。</strong></p>\n</li>\n<li data-nodeid="45265">\n<p data-nodeid="45266">点击 Validate… 按钮，然后 <strong data-nodeid="45435">Upload to App Store</strong>，然后你就可以在开发者官网中查看构建情况。</p>\n</li>\n</ul>\n<p data-nodeid="45267">以上就完成了构建过程，构建成功后会有相应的邮件提醒，然后就可以发布到 TestFlight 进行安装测试了。如果你还需要发布到 App Store，则按照苹果的审核要求提交审核即可。</p>\n<h3 data-nodeid="45268">总结</h3>\n<p data-nodeid="45269">本课时着重介绍了如何打包发布我们的 App，其中大部分都是实践操作，只要你根据步骤去实践即可。学完本课时你需要掌握 Android 和 iOS 两个平台的打包发布流程。</p>\n<p data-nodeid="45270">下一课时，我将完善我们 App 的整体代码逻辑，其中包括：我的消息、系统设置、搜索等功能。我会通过演示界面效果和绘制组件树来介绍整体代码逻辑，对于其中特殊的点会进一步说明。谢谢。</p>\n<p data-nodeid="45271"><a href="https://github.com/love-flutter/flutter-column" data-nodeid="45442">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '18 | 项目实战：实践 Flutter 交友功能',
            id: 320,
            content:
              '<p data-nodeid="115274" class="">本课时我会和大家一起来完善 App 的其他功能，其中包括：我的好友、我的消息、系统设置和搜索功能。按照我们之前课时所学的技术点，我们可以通过绘制组件树+布局来实现，在实现过程中也会介绍一些新的知识点，接下来我们就分别看下这几个功能的实现过程。</p>\n\n\n\n<h3 data-nodeid="113888">我的好友</h3>\n<p data-nodeid="116364">我们首先看下要实现的效果图，如图 1 所示。</p>\n<p data-nodeid="128276"><img src="https://s0.lgstatic.com/i/image/M00/3E/A7/Ciqc1F8tC1OAa6iOAABaIAPOiu0051.png" alt="Drawing 0.png" data-nodeid="128280"></p>\n<div data-nodeid="133974" class=""><p style="text-align:center">图 1 我的好友效果图</p> </div>\n\n\n\n\n\n\n\n<p data-nodeid="117994">根据图 1 的效果图，我们绘制出组件树+布局，如图 2 所示。</p>\n<p data-nodeid="128761"><img src="https://s0.lgstatic.com/i/image/M00/3E/A7/Ciqc1F8tC3SAJma7AACIdJvSfFY733.png" alt="Drawing 2.png" data-nodeid="128765"></p>\n<div data-nodeid="134443" class=""><p style="text-align:center">图 2 组件树</p> </div>\n\n\n\n\n\n\n\n<p data-nodeid="113897">图 2 很清晰地分析出了界面所转化的组件树，由于这里都不涉及动态组件，因此将 Text 和 Image 作为一个 card 组件即可。代码实现逻辑和我们之前介绍的推荐页面和关注页面基本一样，接下来我们看下“我的消息”的实现。</p>\n<h3 data-nodeid="113898">我的消息</h3>\n<p data-nodeid="119060">我们先来看下“我的消息”要实现的界面效果，如图 3 所示。</p>\n<p data-nodeid="129244"><img src="https://s0.lgstatic.com/i/image/M00/3E/B2/CgqCHl8tC4CAKYbEAACBTQQFajM318.png" alt="Drawing 4.png" data-nodeid="129248"></p>\n<div data-nodeid="133505" class=""><p style="text-align:center">图 3 我的消息界面效果</p> </div>\n\n\n\n\n\n\n\n<p data-nodeid="120110">根据图 3 的效果图，我们绘制出组件树+布局，如图 4 所示。</p>\n<p data-nodeid="129725"><img src="https://s0.lgstatic.com/i/image/M00/3E/B2/CgqCHl8tC4iAA2RQAAGgiSh8hy0630.png" alt="Drawing 6.png" data-nodeid="129729"></p>\n<div data-nodeid="133036" class=""><p style="text-align:center">图 4 我的消息组件树+布局</p> </div>\n\n\n\n\n\n\n\n<p data-nodeid="113907">图 4 就非常清晰地描述了我们整个 UI 构造：</p>\n<ul data-nodeid="113908">\n<li data-nodeid="113909">\n<p data-nodeid="113910">图 4 中的 Row-Expanded-1 和 Row-Expanded-5 代表的是使用 flex 布局，左右屏幕占比 1 比 5；</p>\n</li>\n<li data-nodeid="113911">\n<p data-nodeid="113912">图 4 中的 first_line 代表的是图 3 右侧的用户昵称和时间一行；</p>\n</li>\n<li data-nodeid="113913">\n<p data-nodeid="113914">图 4 中的 spaceBetween 是 Row 的 mainAxisAlignment 属性，代表的是两端对齐，具体这部分代码如下。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="113915"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取右侧的首行 </span></span>\nWidget _getFirstLine() { \n  <span class="hljs-keyword">return</span>  Row( \n    mainAxisAlignment: MainAxisAlignment.spaceBetween, \n    children: &lt;Widget&gt;[ \n      Text( \n        userMessage.userInfo.nickName, \n        style: TextStyles.commonStyle(<span class="hljs-number">0.8</span>, Colors.black), \n      ), \n      _getMessageTimeSection(userMessage.messageTime), \n    ], \n  ); \n} \n</code></pre>\n<p data-nodeid="113916">由于这里也没有涉及组件的复用和动态组件，因此这里也建议将整个组件内容设计为一个组件叫作 message_card。为了代码维护性，可以使用类函数来封装小组件，为后续重构抽象为通用组件做准备，例如这里我们将 first_line 设计为一个类函数，如上代码中的 _getFirstLine 函数。</p>\n<h3 data-nodeid="113917">系统设置</h3>\n<p data-nodeid="121144">接下来我们来看下“系统设置”这部分界面效果，如图 5 所示。</p>\n<p data-nodeid="130204"><img src="https://s0.lgstatic.com/i/image/M00/3E/A7/Ciqc1F8tC5mAb80WAABCUd3CwUc272.png" alt="Drawing 8.png" data-nodeid="130208"></p>\n<div data-nodeid="132567" class=""><p style="text-align:center">图 5 系统设置的效果</p> </div>\n\n\n\n\n\n\n\n<p data-nodeid="113922">看到图 5 的效果后，其实组件设计可能不是关键。这里涉及两个新的知识点：</p>\n<ul data-nodeid="113923">\n<li data-nodeid="113924">\n<p data-nodeid="113925">在 Flutter 上怎么处理表单数据；</p>\n</li>\n<li data-nodeid="113926">\n<p data-nodeid="113927">怎么保存系统设置的数据。</p>\n</li>\n</ul>\n<p data-nodeid="113928">这里具体的组件树+布局就不绘制了，我们可以将实现过程分为四部分：第三方库引入、通用文件存储、model 应用和组件应用。</p>\n<h4 data-nodeid="113929">第三方库</h4>\n<p data-nodeid="122732" class="">这里我们需要使用到 Flutter 本地存储功能，Flutter 本地存储功能包含三种：<a href="https://pub.dev/packages/shared_preferences" data-nodeid="122738">shared_preferences</a>、<a href="https://pub.dev/packages/path_provider" data-nodeid="122744">path_provider</a> 文件存储以及 <a href="https://pub.dev/packages/sqflite" data-nodeid="122748">sqflite</a>。这里只介绍 path_provider 文件存储的实现，其他两个大家参照官网的介绍尝试即可。使用该 path_provider  库需要在 pubspec.yaml 中增加库引入，然后更新本地库。</p>\n\n\n\n<h4 data-nodeid="113931">通用文件存储</h4>\n<p data-nodeid="123266" class="">接下来我们基于 path_provider 实现一个通用的文件内容存储，<a href="https://github.com/love-flutter/flutter-column" data-nodeid="123272">代码在 github 源码中</a>的 util/tools/local_storage.dart 中。这里我们主要需要实现两个方法，一个是文件储存内容，一个文件读取内容。</p>\n\n<ul data-nodeid="113933">\n<li data-nodeid="113934">\n<p data-nodeid="113935">文件存储</p>\n</li>\n</ul>\n<p data-nodeid="113936">我们先来看下文件存储的逻辑，如下代码：</p>\n<pre class="lang-dart" data-nodeid="113937"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">将数据保存到文件中 </span></span>\n<span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; save(<span class="hljs-built_in">String</span> content, <span class="hljs-built_in">String</span> filePath) <span class="hljs-keyword">async</span> { \n  <span class="hljs-keyword">final</span> directory = <span class="hljs-keyword">await</span> getApplicationDocumentsDirectory(); \n  File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">\'<span class="hljs-subst">${directory.path}</span>/<span class="hljs-subst">$filePath</span>\'</span>); \n  file.writeAsString(content); \n} \n</code></pre>\n<p data-nodeid="113938">因为是异步获取文件存储路径，因此 save 方法也需要作为异步逻辑，由于无须等待处理结果，因此返回 void。上面代码中使用了 path_provider 的 getApplicationDocumentsDirectory 的方法获取文件存储目录，使用 dart:io 获取具体文件的操作句柄，最后将内容写入文件，接下来我们看下读取的过程。</p>\n<ul data-nodeid="113939">\n<li data-nodeid="113940">\n<p data-nodeid="113941">文件读取</p>\n</li>\n</ul>\n<p data-nodeid="113942">读取的过程和写的代码相似，首先是找到文件并获取文件操作句柄，然后再使用文件句柄读取文件具体内容，代码如下：</p>\n<pre class="lang-dart" data-nodeid="113943"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取文件数据内容 </span></span>\n<span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span>(<span class="hljs-built_in">String</span> filePath) <span class="hljs-keyword">async</span> { \n  <span class="hljs-keyword">try</span> { \n    <span class="hljs-keyword">final</span> directory = <span class="hljs-keyword">await</span> getApplicationDocumentsDirectory(); \n    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">\'<span class="hljs-subst">${directory.path}</span>/<span class="hljs-subst">$filePath</span>\'</span>); \n    <span class="hljs-built_in">bool</span> exist = <span class="hljs-keyword">await</span> file.exists(); \n    <span class="hljs-keyword">if</span>(!exist){ <span class="hljs-comment">// 判断是否存在文件 </span>\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>; \n    } \n    <span class="hljs-keyword">return</span> file.readAsString(); \n  } <span class="hljs-keyword">catch</span>(e) { \n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>; \n  } \n} \n</code></pre>\n<p data-nodeid="113944">上面代码增加了一个异常处理，避免读取失败返回错误数据，因此如果这里判断异常，则返回空字符串。在 catch 逻辑中是需要增加上报来监控告警的，后续我们再来介绍这部分内容。</p>\n<h4 data-nodeid="113945">model 应用</h4>\n<p data-nodeid="113946">因为系统配置是一个全局状态，需要在多个页面使用，所以我们需要将系统数据保存在 model 中，因此我们在 model 创建</p>\n<p data-nodeid="113947">system_config_model.dart 文件。在实现逻辑中，需要先调用 LocalStorage 来获取初始配置，代码如下：</p>\n<pre class="lang-dart" data-nodeid="113948"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">构造函数 </span></span>\nSystemConfigModel.init(){ \n  LocalStorage.<span class="hljs-keyword">get</span>(<span class="hljs-string">\'tyfapp.system.config\'</span>).then((configStr){ \n    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; configInfo = {}; \n    <span class="hljs-keyword">if</span>(configStr == <span class="hljs-keyword">null</span> || configStr == <span class="hljs-string">\'\'</span>) { <span class="hljs-comment">// 判断合法性 </span>\n      configInfo = { \n        <span class="hljs-string">"accessMessage"</span> : <span class="hljs-keyword">true</span>, \n        <span class="hljs-string">"tipsDetail"</span> : <span class="hljs-keyword">true</span>, \n        <span class="hljs-string">"soundReminder"</span> : <span class="hljs-keyword">true</span>, \n        <span class="hljs-string">"vibrationReminder"</span> : <span class="hljs-keyword">true</span> \n      }; \n    } <span class="hljs-keyword">else</span> { \n      <span class="hljs-keyword">try</span> { <span class="hljs-comment">// 尝试 json 解析，解析失败直接返回 </span>\n        configInfo = \n        json.decode(configStr) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;; \n      } <span class="hljs-keyword">catch</span>(e){ \n        <span class="hljs-keyword">return</span>; \n      } \n    } \n    systemConfig = StructSystemConfig.fromJson(configInfo); \n  }); \n} \n</code></pre>\n<p data-nodeid="113949">上面代码 init 为构造函数，其中第 3 行是异步读取文件，获取到文件后存储在共享状态变量 systemConfig 中。为了异常考虑，如果没有获取到文件内容，则将共享状态变量默认设置打开状态，也就是 true 值。有了初始化部分，再修改 main.dart 增加一个新的状态共享，部分如下代码：</p>\n<pre class="lang-dart" data-nodeid="113950"><code data-language="dart"><span class="hljs-comment">// 初始化共享状态对象 </span>\nLikeNumModel likeNumModel = LikeNumModel(); \nNewMessageModel newMessageNum = NewMessageModel(newMessageNum: <span class="hljs-number">0</span>); \n<span class="hljs-comment">// 异步数据处理 </span>\nApiUserInfoMessage.getUnReadMessageNum(newMessageNum); \n<span class="hljs-comment">// 异步获取系统配置 </span>\nSystemConfigModel systemConfigModel = SystemConfigModel.init(); \n<span class="hljs-keyword">return</span> MultiProvider( \n  providers: [ \n    ChangeNotifierProvider(create: (context) =&gt; likeNumModel), \n    ChangeNotifierProvider( \n        create: (context) =&gt; UserInfoModel(myUserInfo: myUserInfo)), \n    ChangeNotifierProvider(create: (context) =&gt; newMessageNum), \n    ChangeNotifierProvider(create: (context) =&gt; systemConfigModel), \n  ], \n  child: child, \n); \n</code></pre>\n<p data-nodeid="113951">上面代码的第 7 行就是增加了系统变量的初始化，第 15 行就是增加到状态共享中。接下来我们完善下 system_config_model.dart 代码，为其增加 get 和 save 方法，代码如下：</p>\n<pre class="lang-dart" data-nodeid="113952"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">转化为StructSystemConfig结构 </span></span>\nStructSystemConfig <span class="hljs-keyword">get</span>() { \n  <span class="hljs-keyword">return</span> systemConfig; \n} \n<span class="hljs-comment">/// <span class="markdown">转化为StructSystemConfig结构 </span></span>\n<span class="hljs-built_in">bool</span> getSwitchItem(<span class="hljs-built_in">String</span> switchItem) { \n  <span class="hljs-keyword">if</span>(systemConfig == <span class="hljs-keyword">null</span>) { \n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; \n  } \n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; systemConfigJson = \n  StructSystemConfig.toJson(systemConfig); \n  <span class="hljs-keyword">try</span>{ \n    <span class="hljs-keyword">return</span> systemConfigJson[switchItem] <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool</span>; \n  }<span class="hljs-keyword">catch</span>(e){ \n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; \n  } \n} \n</code></pre>\n<p data-nodeid="113953">代码的第 2 到第 18 行中的两个方法 get 和 getSwitchItem ，其作用都是获取系统配置，前者是获取所有配置，后者是获取具体的某个配置。我们继续看下配置保存的两个方法，代码如下。</p>\n<pre class="lang-dart" data-nodeid="113954"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">保存单个数据 </span></span>\n<span class="hljs-keyword">void</span> saveOne(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">bool</span> value) { \n  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; systemConfigJson = \n    StructSystemConfig.toJson(systemConfig); \n  <span class="hljs-keyword">if</span>(systemConfigJson[key] == value) { \n    <span class="hljs-keyword">return</span>; \n  } \n  systemConfigJson[key] = value; \n  systemConfig = StructSystemConfig.fromJson(systemConfigJson); \n  <span class="hljs-built_in">print</span>(systemConfigJson); \n  LocalStorage.save(json.encode(systemConfigJson), <span class="hljs-string">\'tyfapp.system.config\'</span>); \n  notifyListeners(); \n} \n\n<span class="hljs-comment">/// <span class="markdown">整体数据保存 </span></span>\n<span class="hljs-keyword">void</span> save(StructSystemConfig newSystemConfig) { \n  <span class="hljs-keyword">if</span>( \n  systemConfig.accessMessage == newSystemConfig.accessMessage &amp;&amp; \n      systemConfig.tipsDetail == newSystemConfig.tipsDetail &amp;&amp; \n      systemConfig.soundReminder == newSystemConfig.soundReminder &amp;&amp; \n      systemConfig.vibrationReminder == newSystemConfig.vibrationReminder \n  ) { \n    <span class="hljs-keyword">return</span>; \n  } \n  systemConfig = newSystemConfig; \n  LocalStorage.save( \n      json.encode(StructSystemConfig.toJson(systemConfig)), \n      <span class="hljs-string">\'tyfapp.system.config\'</span> \n  ); \n  notifyListeners( \n</code></pre>\n<p data-nodeid="113955">代码 save 和 saveOne，分别对应保存整个系统配置数据和保存单个系统配置数据。在两者实现逻辑中，首先都做了前期数据校验判断，避免不必要的 build 操作。在 save 代码逻辑中，需要将数据存储到本地，通过调用 LocaStorage.save 来实现。</p>\n<h4 data-nodeid="113956">组件应用</h4>\n<p data-nodeid="113957">组件应用部分较为简单，我们先看下 pages/system_page/index.dart 的逻辑，如下：</p>\n<pre class="lang-dart" data-nodeid="113958"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/model/system_config_model.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/widgets/system_page/switch_card.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/struct/system_config.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">首页 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemConfigPageIndex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">构造函数 </span></span>\n  <span class="hljs-keyword">const</span> SystemConfigPageIndex(); \n  <span class="hljs-meta">@override</span> \n  Widget build(BuildContext context) { \n    <span class="hljs-keyword">final</span> systemConfigModel = Provider.of&lt;SystemConfigModel&gt;(context); \n    StructSystemConfig systemConfig = systemConfigModel.<span class="hljs-keyword">get</span>(); \n    <span class="hljs-keyword">return</span> Container( \n      padding: EdgeInsets.all(<span class="hljs-number">8</span>), \n      child: Column( \n        children: &lt;Widget&gt;[ \n          SystemPageSwitchCard(itemDesc: <span class="hljs-string">\'新消息提醒\'</span>, switchItem: <span class="hljs-string">\'accessMessage\'</span>), \n          SystemPageSwitchCard(itemDesc: <span class="hljs-string">\'通知显示详情\'</span>, switchItem: <span class="hljs-string">\'tipsDetail\'</span>), \n          SystemPageSwitchCard(itemDesc: <span class="hljs-string">\'声音\'</span>, switchItem: <span class="hljs-string">\'soundReminder\'</span>), \n          SystemPageSwitchCard(itemDesc: <span class="hljs-string">\'振动\'</span>, switchItem: <span class="hljs-string">\'vibrationReminder\'</span>) \n         ], \n      ), \n    ); \n  } \n} \n</code></pre>\n<p data-nodeid="113959">主要逻辑在 build 中，build 中使用了 widgets/system_page/switch_card.dart ，我们看下这个子组件的实现，代码如下：</p>\n<pre class="lang-dart" data-nodeid="113960"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:provider/provider.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/model/system_config_model.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/styles/text_syles.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">单个系统配置 </span></span>\n<span class="hljs-comment">/// \n<span class="markdown">/// [title]为帖子详情内容 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemPageSwitchCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">传入的帖子标题 </span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> switchItem; \n  <span class="hljs-comment">/// <span class="markdown">消息提醒文字 </span></span>\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> itemDesc; \n  <span class="hljs-comment">/// <span class="markdown">构造函数 </span></span>\n  <span class="hljs-keyword">const</span> SystemPageSwitchCard( \n      {Key key, <span class="hljs-keyword">this</span>.itemDesc, <span class="hljs-keyword">this</span>.switchItem} \n      ) : <span class="hljs-keyword">super</span>(key: key); \n  <span class="hljs-meta">@override</span> \n  Widget build(BuildContext context) { \n    <span class="hljs-comment">// 获取操作句柄 </span>\n    <span class="hljs-keyword">final</span> systemConfigModel = Provider.of&lt;SystemConfigModel&gt;(context); \n    <span class="hljs-keyword">return</span> Row( \n      mainAxisAlignment: MainAxisAlignment.spaceBetween, \n      children: &lt;Widget&gt;[ \n        Text( \n          itemDesc, \n          style: TextStyles.commonStyle(<span class="hljs-number">1</span>, Colors.black), \n        ), \n        Switch( <span class="hljs-comment">// 选择 </span>\n            value: systemConfigModel.getSwitchItem(switchItem), \n            activeTrackColor: Colors.lightBlueAccent, \n            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, \n            onChanged: (newValue) { <span class="hljs-comment">// 触发状态变化 </span>\n              systemConfigModel.saveOne( \n                  switchItem, \n                  !systemConfigModel.getSwitchItem(switchItem) \n              ); \n            } \n        ), \n      ], \n    ); \n  } \n} \n</code></pre>\n<p data-nodeid="123788">代码第 34 行使用了 Switch 这个组件，该组件的 value 是通过 systemConfigModel 状态共享类获取，在点击切换时触发状态改变，并调用 systemConfigModel 中的 saveOne 触发依赖组件状态变化。</p>\n<p data-nodeid="123789">以上就实现了系统设置的功能，相对其他组件的实现，这部分逻辑较为复杂，涉及了 Flutter 的本地存储 以及 Provider 的应用技术点。</p>\n\n<h3 data-nodeid="113962">搜索</h3>\n<p data-nodeid="124796">最后我们来看下搜索功能，前面我们已经实现了一个基本的搜索功能，但是其中的接口部分没有补齐，我们先来看下实际的效果，如图 6 所示。</p>\n<p data-nodeid="130681"><img src="https://s0.lgstatic.com/i/image/M00/3E/B2/CgqCHl8tC9yAB1kXAAC_xNdvVn4559.png" alt="Drawing 10.png" data-nodeid="130685"></p>\n<div data-nodeid="132098" class=""><p style="text-align:center">图 6 搜索提示和搜索结果效果</p> </div>\n\n\n\n\n\n\n\n<h4 data-nodeid="113967">组件树+布局</h4>\n<p data-nodeid="125786">根据图 6 的页面效果，我们来绘制组件树+布局，搜索提示就是一个列表，这里就不绘制了，搜索结果稍微复杂一些，主要看下这部分，绘制结果如图 7 所示。</p>\n<p data-nodeid="131156"><img src="https://s0.lgstatic.com/i/image/M00/3E/B3/CgqCHl8tC-aAConRAADrcMIRoXM555.png" alt="Drawing 13.png" data-nodeid="131160"></p>\n<div data-nodeid="131629" class=""><p style="text-align:center">图 7 搜索结果页面组件树+布局设计</p> </div>\n\n\n\n\n\n\n\n<p data-nodeid="113972">这个组件树的设计，包含了我们布局设计思想中的 8 个过程，竖横、高宽、上下和左右，具体细节就不再赘述。接下来我们看下这两部分逻辑的实现：搜索提示和搜索结果。</p>\n<h4 data-nodeid="113973">搜索提示</h4>\n<p data-nodeid="113974">搜索提示较为简单，主要逻辑是从服务端拉取搜索提示接口，并返回一个 ListView 列表结果。具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="113975"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取 suggest list组件列表 </span></span>\nFuture&lt;Widget&gt; _getSuggestList() <span class="hljs-keyword">async</span>{ \n  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; suggests = <span class="hljs-keyword">await</span> ApiSearchIndex.suggest(query); \n  <span class="hljs-keyword">if</span>(suggests == <span class="hljs-keyword">null</span> || suggests.length &lt; <span class="hljs-number">1</span>){ <span class="hljs-comment">// 异常处理 </span>\n    <span class="hljs-keyword">return</span> Container(); \n  } \n  <span class="hljs-comment">// 保留前 5 个搜索 </span>\n  <span class="hljs-built_in">int</span> subLen = suggests.length &gt; <span class="hljs-number">5</span> ? <span class="hljs-number">5</span> : suggests.length; \n  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; subSuggests = suggests.sublist(<span class="hljs-number">0</span>, subLen); \n  <span class="hljs-keyword">return</span> ListView.builder( \n      scrollDirection: Axis.vertical, \n      shrinkWrap: <span class="hljs-keyword">true</span>, \n      itemCount: subSuggests.length, \n      itemBuilder: (context,index){ \n        <span class="hljs-keyword">return</span>  ListTile( \n            title: RichText( \n                text: TextSpan( \n                  <span class="hljs-comment">// 获取搜索框内输入的字符串，设置它的颜色并加粗 </span>\n                    text: subSuggests[index], \n                    style: TextStyles.commonStyle() \n                ) \n            ), \n            onTap: () { \n              query = subSuggests[index]; \n              showResults(context); \n            }, \n        ); \n      } \n  ); \n} \n</code></pre>\n<p data-nodeid="113976">代码中，首先使用 query 关键词获取用户输入，通过 ApiSearchIndex.suggest 方法获取服务端搜索提示结果，接下来做一些数据校验，最后根据搜索提示 build 出相应的组件。其中的第 26 行至第 28 行代码的作用是，通过点击搜索提示触发搜索行为，第 27 行替换搜索提示内容，第 28 行执行搜索并获取搜索结果。</p>\n<h4 data-nodeid="113977">搜索结果</h4>\n<p data-nodeid="113978">根据图 7 的绘制结果，我们了解到这里需要设计两个组件，组件一是展示搜索到的用户列表内容，组件二是展示搜索到的帖子列表内容。我们这里就使用两个组件函数来实现，主要看下用户部分（帖子部分逻辑相似）。</p>\n<pre class="lang-dart" data-nodeid="113979"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取用户搜索结果组件 </span></span>\nWidget _getUserListWidget(<span class="hljs-built_in">List</span>&lt;StructUserInfo&gt; userList) { \n  <span class="hljs-keyword">if</span>(userList == <span class="hljs-keyword">null</span> || userList.length &lt; <span class="hljs-number">1</span>){ \n    <span class="hljs-keyword">return</span> Container(); \n  } \n  <span class="hljs-built_in">int</span> subLen = userList.length &gt; <span class="hljs-number">5</span> ? <span class="hljs-number">5</span> : userList.length; \n  <span class="hljs-built_in">List</span>&lt;StructUserInfo&gt; subUserList = userList.sublist(<span class="hljs-number">0</span>, subLen); \n  <span class="hljs-keyword">return</span> ListView.builder( \n      scrollDirection: Axis.vertical, \n      shrinkWrap: <span class="hljs-keyword">true</span>, \n      itemCount: subUserList.length + <span class="hljs-number">1</span>, \n      itemBuilder: (context,index) { \n        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>){ \n          <span class="hljs-keyword">return</span> Row( \n            children: &lt;Widget&gt;[ \n              Padding(padding: EdgeInsets.only(left: <span class="hljs-number">10</span>)), \n              Text( \n                <span class="hljs-string">\'用户\'</span>, \n                style: TextStyles.commonStyle(<span class="hljs-number">0.9</span>), \n              ), \n            ], \n          ); \n        } \n        <span class="hljs-keyword">return</span> UserPageCard(userInfo: subUserList[index - <span class="hljs-number">1</span>]); \n      }); \n} \n</code></pre>\n<p data-nodeid="126284">以上组件代码的实现与我们之前所学习的知识点，没有太大的差异性。核心知识点是应用 ListView.builder 组件，来显示 seaction_name （也就是上面的 Text 组件）和搜索结果中的用户列表（上面的 UserPageCard 组件）。</p>\n<p data-nodeid="127785" class="">以上就完成了搜索部分的逻辑，具体代码<a href="https://github.com/love-flutter/flutter-column" data-nodeid="127793">查看 github 中的 pages/search_page/custom_delegate.dart 文件。</a></p>\n\n\n\n\n<h3 data-nodeid="113981">总结</h3>\n<p data-nodeid="113982">本课时带领大家实践开发了四个核心页面（我的好友、我的消息、系统设置和搜索）。学完本课时你需要进一步掌握组件树+布局的设计思想，同时掌握 Flutter 本地存储的技术点，进一步巩固 Flutter 编码风格。学完本课时之后，我建议你自行去实现“我的消息”中的私信功能和评论相关的部分（后续会在 github 上提供源码）。</p>\n<p data-nodeid="113983">本课时之前，我们对 App 的安全并没有关注太多，可以说完全放任。下一课时我们将通过工具化的方式来上报异常，保证我们 App 的质量，提前发现并解决问题。</p>\n<p data-nodeid="113984"><a href="https://github.com/love-flutter/flutter-column" data-nodeid="114163">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '19 | 安全保障：Flutter 工具化实现线上安全与稳定',
            id: 321,
            content:
              '<p data-nodeid="605" class="">本课时将实现一个通用的 Flutter 异常上报模块，为线上运营提供上报与监控安全保障，其次借助 Sentry 平台实现异常告警和管理功能。我们先来看下 App 的线上安全包括哪些点。</p>\n<h3 data-nodeid="606">线上安全运营</h3>\n<p data-nodeid="6114" class="">在上线每个客户端版本时，我们都要有一个 crash 标准，由于客户端发布后是无法回滚的，因此在发布时需要使用数据来辅助判断，这里就需要使用 crash 率来辅助判断是否需要进一步灰度更多用户。要做到这点，就需要将客户端异常的报错问题，上报到平台。Android 和 iOS 都有类似的功能模块，在 <a href="https://flutter.cn/docs/cookbook/maintenance/error-reporting" data-nodeid="6118">Flutter 官网</a>也介绍了相应的理论方法，大家可以前往官网进行了解。写这篇专栏的目的是希望将该功能作为通用模块，并且实践该过程。</p>\n\n\n\n\n<p data-nodeid="608">接下来我们就看看，如何利用官网的理论知识，将该功能封装为一个通用的异常上报模块。</p>\n<h3 data-nodeid="609">通用上报模块</h3>\n<p data-nodeid="610">根据官网的文档，我们将该过程分为三个步骤：</p>\n<ol data-nodeid="611">\n<li data-nodeid="612">\n<p data-nodeid="613">修改 main.dart 中的 main 函数；</p>\n</li>\n<li data-nodeid="614">\n<p data-nodeid="615">异常捕获；</p>\n</li>\n<li data-nodeid="616">\n<p data-nodeid="617">捕获内容上报。</p>\n</li>\n</ol>\n<p data-nodeid="618">接下来我们就分别看看三个过程中的实现原理。</p>\n<h4 data-nodeid="619">第一步：修改 main.dart 中 main 函数</h4>\n<p data-nodeid="620">在我们之前项目代码逻辑的 main 函数中，都是使用下面的代码方式来启动运行 Flutter 项目。</p>\n<pre class="lang-dart" data-nodeid="4911"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">App 核心入口文件 </span></span>\n<span class="hljs-keyword">void</span> main() { \n  runApp(MyApp()); \n}\n</code></pre>\n\n\n\n\n<p data-nodeid="622">由于需要 catch 异常，因此我们将 runApp 执行放到异常捕获模块中去执行，修改如下的方式。</p>\n<pre class="lang-dart" data-nodeid="3723"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:two_you_friend/util/tools/app_sentry.dart\'</span>; \n<span class="hljs-comment">/// <span class="markdown">App 核心入口文件 </span></span>\n<span class="hljs-keyword">void</span> main() { \n  AppSentry.runWithCatchError(MyApp()); \n}\n</code></pre>\n\n\n\n\n<p data-nodeid="624">这里引入了通用异常捕获模块，后续你在项目中，也可以直接使用该模块实现上报，接下来我们来看下 AppSentry 的实现异常捕获逻辑。</p>\n<h4 data-nodeid="625">第二步：异常捕获</h4>\n<p data-nodeid="626">该功能的实现会应用到 FlutterError 和 runZonedGuarded 两个知识点。</p>\n<p data-nodeid="627">在 Flutter 中可以通过 FlutterError 来捕获到运行期间的错误，包括构建期间、布局期间和绘制期间。</p>\n<p data-nodeid="628">runZonedGuarded 则是使用 Zone.fork 创建一片新的区域去运行代码逻辑，也就是 runApp，当遇到错误时会执行其回调函数 onError，其次如果在项目使用了 Zone.current.handleUncaughtError 也会将错误抛出执行 onError 逻辑，具体我们看下代码，如下：</p>\n<pre class="lang-dart" data-nodeid="629"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">catch 组件异常 </span></span>\n<span class="hljs-comment">/// \n<span class="markdown">/// 开发模式下，本地打印，上线时则调用 sentry 平台 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> runWithCatchError(Widget appMain) { \n  <span class="hljs-comment">// 捕获并上报 Flutter 异常 </span>\n  FlutterError.onError = (FlutterErrorDetails details) <span class="hljs-keyword">async</span> { \n    <span class="hljs-keyword">if</span> (!inProduction) { \n      FlutterError.dumpErrorToConsole(details); \n    } <span class="hljs-keyword">else</span> { \n      Zone.current.handleUncaughtError(details.exception, details.stack); \n    } \n  }; \n  runZonedGuarded&lt;Future&lt;<span class="hljs-built_in">Null</span>&gt;&gt;(() <span class="hljs-keyword">async</span> { \n    runApp(appMain); \n  }, (error, stackTrace) <span class="hljs-keyword">async</span> { \n    <span class="hljs-keyword">await</span> _reportError(error, stackTrace); \n  }); \n}\n</code></pre>\n<p data-nodeid="630">FlutterError.onError 来捕获异常，这里会判断是否在正式环境，如果是则在本地打印错误日志，如果不是则去执行 runZonedGuarded onError 逻辑。在 runZonedGuarded 代码中执行 runApp，遇到异常时则调用 _reportError 实现错误上报，接下来我们就看下 _reportError 的实现部分。</p>\n<h4 data-nodeid="631">第三步：异常上报</h4>\n<p data-nodeid="632">上面已经获取到了客户端的具体异常信息，接下来我们利用 Sentry 平台将异常信息进行上报。应用 Sentry 平台前，需要去申请接入，具体接入方法在本课时的“Sentry 平台”中介绍，成功接入 Sentry 平台后，会提供一个 dsn。这里我们需要将其配置在该文件中，如下代码。因为 Sentry 是一个第三方库，因此需要在 pubspec.yaml 增加库依赖，并更新本地库。</p>\n<pre class="lang-dart" data-nodeid="633"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">创建 SentryClient 用于将异常日志上报给 sentry 平台 </span></span>\n<span class="hljs-keyword">final</span> SentryClient _sentry = SentryClient( \n  dsn: <span class="hljs-string">\'https://f886adfd35e64062b01feb5e9a8723f6@o425523.ingest.sentry.io/5362342\'</span>, \n); \n<span class="hljs-comment">/// <span class="markdown">判断当前环境类型 </span></span>\n<span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span> inProduction = <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">"dart.vm.product"</span>);\n</code></pre>\n<p data-nodeid="634">_sentry 就是利用 Sentry 第三方库创建的上报句柄，dsn 则是我们测试的上报标识，请大家测试时自己前往申请，不然无法看到自己的异常上报内容。上述代码中 inProduction 是用来获取是否为正式环境的逻辑。接下来我们看下上报逻辑，代码如下：</p>\n<pre class="lang-dart" data-nodeid="635"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">上报异常的函数 </span></span>\n<span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; _reportError(<span class="hljs-built_in">dynamic</span> error, <span class="hljs-built_in">dynamic</span> stackTrace) <span class="hljs-keyword">async</span> { \n  <span class="hljs-keyword">if</span> (!inProduction) { <span class="hljs-comment">// 判断是否为正式环境 </span>\n    <span class="hljs-built_in">print</span>(stackTrace); \n  } \n  <span class="hljs-comment">// sentry 上报 </span>\n  <span class="hljs-keyword">final</span> SentryResponse response = <span class="hljs-keyword">await</span> _sentry.captureException( \n    exception: error, \n    stackTrace: stackTrace, \n  ); \n  <span class="hljs-keyword">if</span> (response.isSuccessful) { \n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'Success! Event ID: <span class="hljs-subst">${response.eventId}</span>\'</span>); \n  } <span class="hljs-keyword">else</span> { \n    <span class="hljs-built_in">print</span>(<span class="hljs-string">\'Failed to report to Sentry.io: <span class="hljs-subst">${response.error}</span>\'</span>); \n  } \n}\n</code></pre>\n<p data-nodeid="636">首先还是判断是否为正式环境，如果不是则直接打印，也可以应用下面的代码打印本地日志。如果是正式环境，则使用 _sentry.captureException 来上报异常，最后打印是否执行成功，后面一段是可以去掉的，主要是为了在真机调试时候查看。</p>\n<pre class="lang-dart" data-nodeid="637"><code data-language="dart">FlutterError.dumpErrorToConsole(FlutterErrorDetails(exception: error));\n</code></pre>\n<p data-nodeid="638">以上就完成了通用上报工具的代码，接下来我们来教大家如何注册 Sentry 并创建项目获得 dsn。</p>\n<h3 data-nodeid="639">Sentry 平台</h3>\n<p data-nodeid="640">我们来看下具体的创建步骤：</p>\n<p data-nodeid="641">1.创建注册账户， <a href="https://sentry.io/signup/" data-nodeid="706">前往官网</a>，具体请按照你自己的信息填写，注册完成后，直接登录；<br>\n2.创建项目，这个过程如果没有分组会让填写分组，按要求填写即可；<br>\n3.上报测试，里面会有各种 SDK 的例子，唯独是没有 Flutter 的，你可以不关注，直接进入项目中或者进入个人页面，可以看到如图 1 的界面。</p>\n<p data-nodeid="642"><img src="https://s0.lgstatic.com/i/image/M00/40/BC/Ciqc1F8zjOiAZrLtAAUYl4LuWZQ819.png" alt="image.png" data-nodeid="714"></p>\n<div data-nodeid="643"><p style="text-align:center">图 1 Sentry 平台</p></div>\n<p data-nodeid="644">4.按照图 2 的方法可以看到我们需要的 dsn，如果是新注册的，可以点击图 2 中的 Setup Sentry 快速找到；</p>\n<p data-nodeid="645"><img src="https://s0.lgstatic.com/i/image/M00/40/BC/Ciqc1F8zjPmADPTqAAZbn--G0NI800.png" alt="image (1).png" data-nodeid="718"></p>\n<div data-nodeid="646"><p style="text-align:center">图 2 dsn 查询指引</p></div>\n<p data-nodeid="647">5.替换项目代码中的 dsn。</p>\n<p data-nodeid="648">经过以上 5 个步骤就可以完成项目的接入，接下来我们就验证下上报是否正常。</p>\n<h3 data-nodeid="649">上报测试</h3>\n<p data-nodeid="650">为了验证该功能，我们需要特意去修改正常的代码改为异常。这里我们将左侧菜单“图片流”中的代码做如下修改：</p>\n<pre class="lang-dart" data-nodeid="651"><code data-language="dart">Widget build(BuildContext context) { \n  <span class="hljs-keyword">if</span> (contentList == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 判断是否为空 </span>\n    <span class="hljs-keyword">return</span> Loading(); \n  } \n  <span class="hljs-built_in">List</span>&lt;StructContentDetail&gt; tmpList = []; \n  <span class="hljs-keyword">return</span> ListView.separated( \n    scrollDirection: Axis.vertical, \n    shrinkWrap: <span class="hljs-keyword">true</span>, \n    itemCount: contentList.length + <span class="hljs-number">1</span>, <span class="hljs-comment">// 增加异常 </span>\n    ......\n</code></pre>\n<p data-nodeid="652">上面只是 pages/home_page/img_flow.dart 部分代码，其中代码第 10 行就是增加了异常，由于数组长度超出了限制，这样会导致在 ListView.separated 抛出数组边界异常。请注意该异常捕获逻辑只会在 release 模式下生效，因此需要正式 build app，利用上一课时的知识，我们将 App build 为一个 apk 文件，然后安装到 Android 手机。</p>\n<p data-nodeid="653">成功安装后，打开 App 选择左侧菜单的“图片流”，这时候你会看到界面异常，大概过 1-2 分钟后，我们前往 Sentry 平台，选择我们创建项目，就会看到如下图 3 的上报内容。</p>\n<p data-nodeid="654"><img src="https://s0.lgstatic.com/i/image/M00/40/C8/CgqCHl8zjR6AAojgAAKndALdwFQ016.png" alt="image (2).png" data-nodeid="731"></p>\n<div data-nodeid="655"><p style="text-align:center">图 3 Sentry 异常例子</p></div>\n<p data-nodeid="656">点击具体的上报内容，就可以看到详细的报错信息，这里面已经将报错的文件和具体函数都说明了，并打印了调用堆栈。你可以在提示信息中查看到具体的报错文件 img_flow.dart 以及具体的报错内容 RangeError ，通过文件以及报错详情，就可以非常容易的定位到具体问题了。</p>\n<p data-nodeid="657">以上就是异常上报的工具模块，通过这种方式，我们就可以快速地收集问题并解决问题。由于本课时将 main.dart 进行了优化，因此这里也顺带介绍下重构的部分。</p>\n<h3 data-nodeid="658">AppProvider</h3>\n<p data-nodeid="659">为了减轻 main.dart 中的代码，使其更精简，我们将 Provider 部分的逻辑转移到一个新的工具模块中，这个工具在 util/tools/app_provider 中。而 main.dart 中从原来调用函数内部的 _getProviders 方法，修改为调用 AppProvider 中的 getProviders 方法，main.dart 代码如下：</p>\n<pre class="lang-dart" data-nodeid="2535"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">App 核心入口文件 </span></span>\n<span class="hljs-keyword">void</span> main() { \n  AppSentry.runWithCatchError(MyApp()); \n} \n<span class="hljs-comment">/// <span class="markdown">MyApp 核心入口界面 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{ \n  <span class="hljs-comment">// This widget is the root of your application. </span>\n  <span class="hljs-meta">@override</span> \n  Widget build(BuildContext context) { \n    <span class="hljs-keyword">return</span> FutureBuilder&lt;Widget&gt;( \n        future: AppProvider.getProviders( \n          context, \n          MaterialApp( \n              title: <span class="hljs-string">\'Two You\'</span>, <span class="hljs-comment">// APP 名字 </span>\n              debugShowCheckedModeBanner: <span class="hljs-keyword">false</span>, \n              theme: ThemeData( \n                primarySwatch: Colors.blue, <span class="hljs-comment">// App 主题 </span>\n              ), \n              routes: Router().registerRouter(), \n              home: Entrance()), \n        ), \n        builder: (BuildContext context, AsyncSnapshot&lt;Widget&gt; snapshot) { \n          <span class="hljs-keyword">if</span> (snapshot.error != <span class="hljs-keyword">null</span>) { \n            <span class="hljs-keyword">return</span> Container( \n              child: CommonError(), \n            ); \n          } \n          <span class="hljs-keyword">return</span> Container( \n            child: snapshot.data, \n          ); \n        }); \n  } \n}\n</code></pre>\n\n\n\n\n\n\n\n<p data-nodeid="661">代码就显得非常精简了，在代码中的第 12 行修改了调用方法，其次在第 23 行中，增加了组件异常处理。AppProvider 中的 getProviders 方法就是原来首页的逻辑，基本没有变化，大家可以自己前往 <a href="https://github.com/love-flutter/flutter-column" data-nodeid="745">github 源码</a>中查看。</p>\n<h3 data-nodeid="662">总结</h3>\n<p data-nodeid="663">本课时着重介绍了通用上报模块的实现方法，同时实践介绍了 Sentry 平台的应用，最后再简单介绍了 main.dart 中的重构逻辑。学完本课时后，需要掌握 Flutter 异常捕获处理方法，并会应用 Sentry 平台来协助分析异常问题。</p>\n<p data-nodeid="664">下一课时我们将进入下一阶段，我们还将继续在 Two You App 上完善功能。</p>\n<p data-nodeid="665" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="752">点击此链接查看本课时源码</a></p>',
          },
        ],
      },
      {
        sectionName: '第三部分：进阶学习',
        sectionId: 3,
        courseList: [
          {
            theme: '20 | 原生通信：应用原生平台交互扩充 Flutter 基础能力',
            id: 322,
            content:
              '<p data-nodeid="673" class="">本课时介绍 Flutter 如何与原生平台进行通信交互方式，让 Flutter 支持各种原生平台的基础能力。</p>\n<h3 data-nodeid="674">使用场景</h3>\n<p data-nodeid="675">由于 Flutter 是一个跨平台 UI 库，因此不支持原生系统的功能，例如：</p>\n<ul data-nodeid="676">\n<li data-nodeid="677">\n<p data-nodeid="678">系统通知；</p>\n</li>\n<li data-nodeid="679">\n<p data-nodeid="680">系统感应、相机、电量、LBS、声音、语音识别；</p>\n</li>\n<li data-nodeid="681">\n<p data-nodeid="682">分享、打开其他 App 或者打开自身 App；</p>\n</li>\n<li data-nodeid="683">\n<p data-nodeid="684">设备信息、本地存储。</p>\n</li>\n</ul>\n<p data-nodeid="685">以上只列举了部分，其实主要是和系统服务调用相关的功能，大部分都不支持。这时候就需要原生平台提供一些基础服务给 Flutter 来调用。我们先来看下 Flutter 与 Android 和 iOS 是怎么进行消息传递和接收的。</p>\n<h3 data-nodeid="686">交互原理</h3>\n<p data-nodeid="687">在 Flutter 中存在三种与原生平台进行交互的方法： MethodChannel 、BasicMessageChannel 和 EventChannel 。这三者在底层是没有区别的，都是基于 binaryMessenger 来实现。不过在应用层中的使用场景有所区别。</p>\n<ul data-nodeid="688">\n<li data-nodeid="689">\n<p data-nodeid="690">MethodChannel ，该方法需要创建一个消息通道句柄，然后再利用其中的 invokeMethod 来调用原生平台，原生平台根据传递的方法和参数，执行并获得具体的异步响应结果。该方法支持两个参数，一个是方法名，一个是方法参数，因此更适合去调用原生客户端的函数方法；</p>\n</li>\n<li data-nodeid="691">\n<p data-nodeid="692">BasicMessageChannel ，该方法需要创建一个消息通道句柄，然后再利用其中的 send 方法发送数据给到原生平台.原生平台接收到数据后，可以针对接收数据响应返回，也可以在接收数据后，不做任何返回。因此该方法更适合向原生平台传递数据，而不是功能调用；</p>\n</li>\n<li data-nodeid="693">\n<p data-nodeid="694">EventChannel ，该方法是数据流传递，适用于大文件或者数据流媒体等的应用。发送方不会有响应，但是它会通过调用 MethodChannel 来通知原生平台，比如开始监听数据接收会发送 listen ，取消了数据接收会发送 cancel。</p>\n</li>\n</ul>\n<p data-nodeid="695">在实际应用中三种方法都是有一定场景，大部分情况下还是基于 MethodChannel 来实现，比如前面我们所应用到的插件：FlutterWebviewPlugin 和 PathProviderPlugin ，当然其中也涉及 EventChannel 的应用，比如 UniLinksPlugin 插件。接下来我们具体看下整个消息交互的流转过程。</p>\n<h4 data-nodeid="696">交互实现过程</h4>\n<p data-nodeid="697">根据官网的知识以及我自己的一个理解，可以将整个过程总结为下图 1 。</p>\n<p data-nodeid="698"><img src="https://s0.lgstatic.com/i/image/M00/41/CC/Ciqc1F82QdiASdHvAAGbIVp4bfI196.png" alt="Drawing 0.png" data-nodeid="773"></p>\n<div data-nodeid="699"><p style="text-align:center">图 1 消息交互流程图</p></div>\n<p data-nodeid="700">从图 1 中我们可以看到，所有的消息都是通过 binaryMessenger 来传递，Flutter 的底层是 C 和 C++ 实现的，binaryMessenger 就是通过 C++ 底层库来调用平台相关的功能，数据返回也是原路处理返回。上面的调用过程，就是 Flutter 官网三层架构（如图 2 所示）的一个典型例子。</p>\n<p data-nodeid="701"><img src="https://s0.lgstatic.com/i/image/M00/41/E1/CgqCHl82ToiAUS0SAAGny7Ud86w285.png" alt="image (8).png" data-nodeid="777"></p>\n<div data-nodeid="702"><p style="text-align:center">图 2 Flutter 三层架构</p></div>\n<h3 data-nodeid="703">应用示例</h3>\n<p data-nodeid="704">原理分析清晰后，我们再基于我们当前 Two You Friend App 项目实践一下这个功能。主要需求就是能够在 Flutter 中查看当前电量信息，具体效果如如图 3 所示。</p>\n<p data-nodeid="705"><img src="https://s0.lgstatic.com/i/image/M00/41/D6/Ciqc1F82TpCAKE8oAAExi3g6bqk260.png" alt="image (7).png" data-nodeid="782"></p>\n<div data-nodeid="706"><p style="text-align:center">图 3 获取电量界面效果图</p></div>\n<p data-nodeid="707">从图中我们可以看到在 Android 中是可以正常获取到当前电量信息，但是在 iOS 中是无法获取（主要原因是在虚拟机上 iOS 不支持 device.batteryState 方法）。接下来我们看下具体的代码实现逻辑。</p>\n<h4 data-nodeid="708">增加测试页面</h4>\n<p data-nodeid="709">在项目中的 lib/pages 下创建一个 test_page 文件夹，在文件夹中创建 index.dart 。因为需要使用到 MethodChannel ，所以在头部增加两个库的引入，代码如下：</p>\n<pre class="lang-dart" data-nodeid="710"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/material.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:flutter/services.dart\'</span>;\n</code></pre>\n<p data-nodeid="711">接下来实现 TestPageIndex 这个类，并在该类中应用 MethodChannel 创建一个消息句柄，代码如下：</p>\n<pre class="lang-dart" data-nodeid="712"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">测试页面 </span></span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPageIndex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{ \n  <span class="hljs-comment">/// <span class="markdown">构造函数 </span></span>\n  <span class="hljs-keyword">const</span> TestPageIndex(); \n  <span class="hljs-comment">/// <span class="markdown">创建数据传输句柄 </span></span>\n  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> platform = MethodChannel(<span class="hljs-string">\'com.example.two_you_friend\'</span>); \n  <span class="hljs-meta">@override</span> \n  Widget build(BuildContext context) { \n    <span class="hljs-keyword">return</span> Container(); <span class="hljs-comment">// @todo</span>\n  } \n}\n</code></pre>\n<p data-nodeid="713">上面代码创建了一个唯一的消息名句柄，为了避免重复性，这里最好的方式就是使用包的名称加上功能。接下来我们实现 build 逻辑。由于调用原生的 invokeMethod 是一个异步消息返回的方法，因此这里需要使用 FutureBuilder<code data-backticks="1" data-nodeid="790">&lt;Widget&gt;</code> 来实现，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="714"><code data-language="dart"><span class="hljs-meta">@override</span> \nWidget build(BuildContext context) { \n  <span class="hljs-keyword">return</span> FutureBuilder&lt;Widget&gt;( \n      future: _getBatteryLevel(), \n      builder: (BuildContext context, AsyncSnapshot&lt;Widget&gt; snapshot) { \n        <span class="hljs-keyword">if</span>(snapshot.error != <span class="hljs-keyword">null</span>) { \n          <span class="hljs-keyword">return</span> Container( \n            child: CommonError(), \n          ); \n        } \n        <span class="hljs-keyword">return</span> Container( \n          child: snapshot.data, \n        ); \n      }); \n}\n</code></pre>\n<p data-nodeid="715">上面的代码调用了一个异步函数 _getBatteryLevel ，正确返回则显示相应的组件，异常则显示通用报错页面，最后再来看下 _getBatteryLevel 的实现逻辑。</p>\n<pre class="lang-dart" data-nodeid="716"><code data-language="dart">Future&lt;Widget&gt; _getBatteryLevel() <span class="hljs-keyword">async</span> { \n  <span class="hljs-built_in">String</span> batteryLevel; \n  <span class="hljs-keyword">try</span> { \n    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> result = <span class="hljs-keyword">await</span> platform.invokeMethod(<span class="hljs-string">\'getBatteryLevel\'</span>); \n    batteryLevel = <span class="hljs-string">\'Battery level at <span class="hljs-subst">$result</span> % .\'</span>; \n    <span class="hljs-built_in">print</span>(batteryLevel); \n  } <span class="hljs-keyword">on</span> PlatformException <span class="hljs-keyword">catch</span> (e) { \n    <span class="hljs-built_in">print</span>(e.message); \n    batteryLevel = <span class="hljs-string">"Failed to get battery level: \'<span class="hljs-subst">${e.message}</span>\'."</span>; \n  } \n  <span class="hljs-keyword">return</span> Center( \n    child: Text(batteryLevel), \n  ); \n}\n</code></pre>\n<p data-nodeid="717">创建一个空字符串，然后通过 platform.invokeMethod 发送给原生平台，原生平台异步返回消息得到 result 结果，由于 invokeMethod 是一个范型，因此可以将结果设置为 int 类型。这里使用 try catch 的目的是避免因为原生平台不支持导致的异常，比如 iOS 就不支持在虚拟机上调用该 API 。</p>\n<h4 data-nodeid="718">增加页面跳转</h4>\n<p data-nodeid="719">页面实现完成后，我们再去 router 中增加该页面的配置。首先使用 import 引入该页面，然后再修改 lib/router.dart 在 routerMapping 中增加一项。</p>\n<pre class="lang-dart" data-nodeid="720"><code data-language="dart"><span class="hljs-string">\'test\'</span>: StructRouter(TestPageIndex(), <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>),\n</code></pre>\n<p data-nodeid="721">完成路由配置后，再前往 lib/widgets/menu/draw.dart 文件，在 ListView 下的 children 中增加一个新的菜单，代码配置如下：</p>\n<pre class="lang-dart" data-nodeid="722"><code data-language="dart">ListTile( \n  leading: Icon(Icons.person), \n  title: Text(<span class="hljs-string">\'原生测试\'</span>), \n  onTap: () { \n    Navigator.pop(context); \n    redirect(<span class="hljs-string">\'tyfapp://test\'</span>); \n  }, \n),\n</code></pre>\n<p data-nodeid="723">以上就完成了在 Flutter 中的代码逻辑。运行程序后，我们是可以正常打开该页面的，只是没有正确的响应数据，接下来我们就分平台实现获取平台电量的代码。</p>\n<h4 data-nodeid="724">Android 代码</h4>\n<p data-nodeid="725">在项目根目录，我们有一个 android 的目录文件夹，使用 Android Studio 打开该项目，然后在 app/java 下创建一个 com.example.two_you_friend 这样的包名（在 Android Studio 是叫作 Package ），如果你不想再打开一个项目，也可以在当前项目的 android/app/src/main/java 目录下创建 com.example.two_you_friend 包，然后在该目录下新建一个 MainActivity.java 文件。接下来我们看下具体的代码实现。</p>\n<p data-nodeid="726">第一步还是 import 我们需要的库文件。</p>\n<pre class="lang-java" data-nodeid="727"><code data-language="java"><span class="hljs-keyword">package</span> com.example.two_you_friend; \n<span class="hljs-keyword">import</span> android.content.ContextWrapper; \n<span class="hljs-keyword">import</span> android.content.Intent; \n<span class="hljs-keyword">import</span> android.content.IntentFilter; \n<span class="hljs-keyword">import</span> android.os.BatteryManager; \n<span class="hljs-keyword">import</span> android.os.Build.VERSION; \n<span class="hljs-keyword">import</span> android.os.Build.VERSION_CODES; \n<span class="hljs-keyword">import</span> androidx.annotation.NonNull; \n<span class="hljs-keyword">import</span> io.flutter.embedding.android.FlutterActivity; \n<span class="hljs-keyword">import</span> io.flutter.embedding.engine.FlutterEngine; \n<span class="hljs-keyword">import</span> io.flutter.plugin.common.MethodChannel; \n<span class="hljs-keyword">import</span> io.flutter.plugins.GeneratedPluginRegistrant;\n</code></pre>\n<p data-nodeid="728">接下来创建 MainActivity 来继承 FlutterActivity ，创建一个与 Flutter 中对应的消息名字，并创建两个未实现的方法 configureFlutterEngine 和 getBatteryLevel 。</p>\n<pre class="lang-java" data-nodeid="729"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FlutterActivity</span> </span>{ \n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CHANNEL = <span class="hljs-string">"com.example.two_you_friend"</span>; \n    <span class="hljs-meta">@Override</span> \n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureFlutterEngine</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FlutterEngine flutterEngine)</span> </span>{ \n    } \n\n    <span class="hljs-comment">/** \n     * 获取电量信息 \n     * <span class="hljs-doctag">@return</span> string \n     */</span> \n    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBatteryLevel</span><span class="hljs-params">()</span> </span>{ \n    } \n}\n</code></pre>\n<p data-nodeid="730">configureFlutterEngine 重写的父类方法，主要是用来处理 MethodChannel 发送过来的数据。getBatteryLevel 获取当前电量信息。我们先来看下 configureFlutterEngine 代码：</p>\n<pre class="lang-dart" data-nodeid="731"><code data-language="dart"><span class="hljs-meta">@Override</span> \npublic <span class="hljs-keyword">void</span> configureFlutterEngine(<span class="hljs-meta">@NonNull</span> FlutterEngine flutterEngine) { \n    GeneratedPluginRegistrant.registerWith(flutterEngine); \n    <span class="hljs-keyword">new</span> MethodChannel(flutterEngine.getDartExecutor().getBinaryMessenger(), CHANNEL) \n            .setMethodCallHandler( \n                    (call, result) -&gt; { \n                        <span class="hljs-keyword">if</span> (call.method.equals(<span class="hljs-string">"getBatteryLevel"</span>)) { \n                            <span class="hljs-built_in">int</span> batteryLevel = getBatteryLevel(); \n                            <span class="hljs-keyword">if</span> (batteryLevel != <span class="hljs-number">-1</span>) { \n                                result.success(batteryLevel); \n                            } <span class="hljs-keyword">else</span> { \n                                result.error(<span class="hljs-string">"UNAVAILABLE"</span>, <span class="hljs-string">"Battery level not available."</span>, <span class="hljs-keyword">null</span>); \n                            } \n                        } <span class="hljs-keyword">else</span> { \n                            result.notImplemented(); \n                        } \n                    } \n            ); \n}\n</code></pre>\n<p data-nodeid="732">上面代码核心部分是在 call.method.equals ，判断 Flutter 需要调用的方法，根据不同的数据调用不同的函数，比如 getBatteryLevel 则调用 getBatteryLevel() 。最后我们再来看下电量获取部分的代码：</p>\n<pre class="lang-java" data-nodeid="733"><code data-language="java"><span class="hljs-comment">/** \n * 获取电量信息 \n * <span class="hljs-doctag">@return</span> string \n */</span> \n<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBatteryLevel</span><span class="hljs-params">()</span> </span>{ \n    <span class="hljs-keyword">int</span> batteryLevel = -<span class="hljs-number">1</span>; \n    <span class="hljs-keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) { \n        BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE); \n        batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY); \n    } <span class="hljs-keyword">else</span> { \n        Intent intent = <span class="hljs-keyword">new</span> ContextWrapper(getApplicationContext()). \n                registerReceiver(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED)); \n        batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -<span class="hljs-number">1</span>) * <span class="hljs-number">100</span>) / \n                intent.getIntExtra(BatteryManager.EXTRA_SCALE, -<span class="hljs-number">1</span>); \n    } \n    <span class="hljs-keyword">return</span> batteryLevel; \n}\n</code></pre>\n<p data-nodeid="734">由于是 Java 代码，我了解的也较少，也非本课时的知识点，具体大家参考下了解就可以。<br>\n以上就完成了整个开发过程，不过这里有一个非常大的坑，在 Flutter 项目创建完成后，app 目录下的 src/main/kotlin 目录中也会存在另外一个 MainActivity 类，这样会导致 Android 项目编译失败，可以将 src/main/kotlin 下的 MainActivity 类改一个名字即可，需要时再将 java 和 kotlin 中的两个类名修改回来。</p>\n<p data-nodeid="735">开发完成后，就可以使用 Android 虚拟机来测试了。接下来我们看下 iOS 代码。</p>\n<h4 data-nodeid="736">iOS 代码</h4>\n<p data-nodeid="737">iOS 也支持两种语言 Object-C 和 Swift ，这里我们使用 Swift 来演示。直接在 Android Studio 中打开 ios/Runner 目录下的 .swift 文件。添加下以下部分代码，由于是 Swift 代码，我就不过多介绍如何实现的细节了。</p>\n<pre class="lang-swift" data-nodeid="738"><code data-language="swift"><span class="hljs-keyword">import</span> UIKit \n<span class="hljs-keyword">import</span> Flutter \n<span class="hljs-meta">@UIApplicationMain</span> \n<span class="hljs-meta">@objc</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">FlutterAppDelegate</span> </span>{ \n <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">( \n  <span class="hljs-number">_</span> application: UIApplication, \n  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="hljs-keyword">Any</span>]?)</span></span> -&gt; <span class="hljs-type">Bool</span> { \n  <span class="hljs-keyword">let</span> controller : <span class="hljs-type">FlutterViewController</span> = window?.rootViewController <span class="hljs-keyword">as</span>! <span class="hljs-type">FlutterViewController</span> \n  <span class="hljs-keyword">let</span> batteryChannel = <span class="hljs-type">FlutterMethodChannel</span>(name: <span class="hljs-string">"com.example.two_you_friend"</span>, \n                       binaryMessenger: controller.binaryMessenger) \n  batteryChannel.setMethodCallHandler({ \n   [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (call: <span class="hljs-type">FlutterMethodCall</span>, result: <span class="hljs-type">FlutterResult</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> \n   <span class="hljs-comment">// Note: this method is invoked on the UI thread. </span>\n   <span class="hljs-keyword">guard</span> call.method == <span class="hljs-string">"getBatteryLevel"</span> <span class="hljs-keyword">else</span> { \n    result(<span class="hljs-type">FlutterMethodNotImplemented</span>) \n    <span class="hljs-keyword">return</span> \n   } \n   <span class="hljs-keyword">self</span>?.receiveBatteryLevel(result: result) \n  }) \n  <span class="hljs-type">GeneratedPluginRegistrant</span>.register(with: <span class="hljs-keyword">self</span>) \n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions) \n } \n  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receiveBatteryLevel</span><span class="hljs-params">(result: FlutterResult)</span></span> { \n   <span class="hljs-keyword">let</span> device = <span class="hljs-type">UIDevice</span>.current \n   device.isBatteryMonitoringEnabled = <span class="hljs-literal">true</span> \n   <span class="hljs-keyword">if</span> device.batteryState == <span class="hljs-type">UIDevice</span>.<span class="hljs-type">BatteryState</span>.unknown { \n    result(<span class="hljs-type">FlutterError</span>(code: <span class="hljs-string">"UNAVAILABLE"</span>, \n              message: <span class="hljs-string">"Battery info unavailable"</span>, \n              details: <span class="hljs-literal">nil</span>)) \n   } <span class="hljs-keyword">else</span> { \n    result(<span class="hljs-type">Int</span>(device.batteryLevel * <span class="hljs-number">100</span>)) \n   } \n  } \n}\n</code></pre>\n<p data-nodeid="739">代码完成后，使用 iOS 模拟器运行项目就可以看到图 3 所示的一个效果了。</p>\n<h3 data-nodeid="740">Flutter 插件</h3>\n<p data-nodeid="741">学习掌握与原生通信原理后，我们就可以利用该功能做一些跨平台原生 Flutter 插件，通过插件的方式来屏蔽平台特性。具体大家可以尝试创建一个试试：</p>\n<p data-nodeid="742">1.在 Android Studio 创建一个新的项目，项目类型选择 Flutter Plugin ，或者使用下面的命令行；</p>\n<pre class="lang-powershell" data-nodeid="743"><code data-language="powershell">flutter create -<span class="hljs-literal">-org</span> com.example -<span class="hljs-literal">-template</span>=plugin plugin_name\n</code></pre>\n<p data-nodeid="744">2.创建完成后，里面会包含相应的测试代码，以及会准备好最基础的代码部分，只需要在模版代码上增加我们应用示例的代码；</p>\n<p data-nodeid="745">3.创建完成后，在不修改示例的基础上运行，可以看到如图 4 所示的一个效果。</p>\n<p data-nodeid="746"><img src="https://s0.lgstatic.com/i/image/M00/41/E1/CgqCHl82TqCAWzXCAAAwHz1zoOw595.png" alt="image (9).png" data-nodeid="830"></p>\n<div data-nodeid="747"><p style="text-align:center">图 4 Flutter Plugin 效果</p></div>\n<p data-nodeid="748">4.开发完成插件后，如果需要使用该插件，方法还是在 pubspec.yaml 增加依赖，例如下面的配置。</p>\n<pre class="lang-yaml" data-nodeid="749"><code data-language="yaml"><span class="hljs-attr">dependencies:</span> \n  <span class="hljs-attr">flutter:</span> \n    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span> \n  <span class="hljs-attr">battery:</span> \n    <span class="hljs-comment"># When depending on this package from a real application you should use: </span>\n    <span class="hljs-comment">#   battery2: ^x.y.z </span>\n    <span class="hljs-comment"># See https://dart.dev/tools/pub/dependencies#version-constraints </span>\n    <span class="hljs-comment"># The example app is bundled with the plugin so we use a path dependency on </span>\n    <span class="hljs-comment"># the parent directory to use the current plugin\'s version.</span>\n    <span class="hljs-attr">path:</span> <span class="hljs-string">../</span>\n</code></pre>\n<p data-nodeid="750">battery 是我们测试的插件名称，path 是一个相对路径，指向插件的项目根目录即可。</p>\n<p data-nodeid="751">以上就是原生插件的开发过程，需要有一定的原生平台开发能力，这也是我一开始介绍到的后面大前端的一个方向，跨端团队作为业务支撑，而 Android 、 iOS 以及 Web 作为平台底层支持跨端的团队。</p>\n<h3 data-nodeid="752">总结</h3>\n<p data-nodeid="753">本课时核心是介绍了如何在 Flutter 中与原生平台进行通信，从而扩充 Flutter 基础功能，这部分还是需要有一定的原生编程能力。在掌握通信机制后，也顺便介绍了如何创建 Flutter plugin ，从而将多平台代码作为插件进行开发，而在 Flutter 端屏蔽多终端的问题。学完本课时以后，需要掌握 Flutter 与原生平台的通信方式，并且了解 Flutter plugin 的开发过程。</p>\n<p data-nodeid="1333">下一课时我将介绍 Flutter 中的性能监控和分析，并利用性能分析来优化我们当前 Two You APP 项目。</p>\n<p data-nodeid="1669" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="1672">点击此链接查看本课时源码</a></p>',
          },
          {
            theme: '21 | 性能优化：掌握 Flutter 的性能分析和监控',
            id: 323,
            content:
              '<p data-nodeid="42225" class="">本课时主要带你学习 Flutter 中的性能分析工具 —— devTools 的使用，以及掌握 Flutter 性能分析思路和方法。其次也会介绍到在 Flutter 中如何上报性能相关的数据，从服务端数据出发分析 App 用户体验数据。</p>\n<h3 data-nodeid="42226">devTools 的使用</h3>\n<p data-nodeid="42227">devTools 是官方出的一套 Dart 和 Flutter 的性能调试工具，其核心是帮开发者定位 UI 或者 GPU 线程问题，从而协助开发者解决 Flutter App 的性能问题。在应用该工具之前，需要启动 App 调试功能。</p>\n<p data-nodeid="42228">打开我们的 Two You App，如果是在 Android Studio IDE 中，可以直接点击如下图所示的红色圈部分。</p>\n<p data-nodeid="42229"><img src="https://s0.lgstatic.com/i/image/M00/43/EA/Ciqc1F886IyANVraAABwZCwQP1s839.png" alt="Drawing 0.png" data-nodeid="42358"></p>\n<div data-nodeid="42230"><p style="text-align:center">打开 devTools 指引</p></div>\n<p data-nodeid="42231">如果不是在 Android Studio 中，需要按照下面的四个步骤启动 dev\bTools 工具。</p>\n<p data-nodeid="42232">1.使用下面命令启动 devTools 工具。</p>\n<pre class="lang-plain" data-nodeid="42233"><code data-language="plain">flutter pub global run devtools\n</code></pre>\n<p data-nodeid="42234">2.运行成功后，会提示 devTools 访问的地址。打开访问地址后，可以看到如下图的界面，界面中需要输入一个 Flutter App 的监听地址。</p>\n<p data-nodeid="42235"><img src="https://s0.lgstatic.com/i/image/M00/43/F5/CgqCHl886JiAFj7bAABf4KvYysQ626.png" alt="Drawing 1.png" data-nodeid="42364"></p>\n<div data-nodeid="42236"><p style="text-align:center">devTools 主界面</p></div>\n<p data-nodeid="42237">3.接下来需要获取 Flutter 运行的 WS 地址，重新运行项目（请注意不是热启动，需要停止运行，然后点击重新运行），启动成功后，在运行栏可以看到如下图所示的信息。</p>\n<p data-nodeid="42238"><img src="https://s0.lgstatic.com/i/image/M00/43/EA/Ciqc1F886KuAF95mAACDP4U2o5I743.png" alt="Drawing 2.png" data-nodeid="42368"></p>\n<div data-nodeid="42239"><p style="text-align:center">调试提示</p></div>\n<p data-nodeid="42240">4.将其中的 listening on 的地址输入到刚才 devTools 页面就可以了，打开页面后，可以看到下图所示的功能。</p>\n<p data-nodeid="42241"><img src="https://s0.lgstatic.com/i/image/M00/43/F5/CgqCHl886LeAHz3YAAEP13-CfMA452.png" alt="Drawing 3.png" data-nodeid="42372"></p>\n<div data-nodeid="42242"><p style="text-align:center">devTools 功能</p></div>\n<p data-nodeid="42243">接下来我介绍下 devTools 功能，即上图中每个工具的作用。</p>\n<ul data-nodeid="42244">\n<li data-nodeid="42245">\n<p data-nodeid="42246"><strong data-nodeid="42378">Flutter Inspector</strong>，可以查看组件的布局信息，类似于前端的 Chrome 工具的 CSS 布局查看器，应用该功能可以快速定位布局问题。</p>\n</li>\n<li data-nodeid="42247">\n<p data-nodeid="42248"><strong data-nodeid="42383">Timeline</strong>，时间线事件图表，跟踪显示来自应用程序的所有事件。监听 Flutter App 在构建 UI 树，绘制界面以及其他（例如 HTTP 流量）事件等，并将监听到的事件所花费的时间，显示在时间轴上。</p>\n</li>\n<li data-nodeid="42249">\n<p data-nodeid="42250"><strong data-nodeid="42388">Memory</strong>，使用时间线的方式，展示 Flutter App 的内存变化，通过该工具可以定位内存泄漏的问题。</p>\n</li>\n<li data-nodeid="42251">\n<p data-nodeid="42252"><strong data-nodeid="42393">Performance</strong>，性能分析工具，可以通过录制界面操作，获取界面性能数据。该工具的主要用途还是在定位某个功能卡顿问题，例如我们发现主界面很卡顿，这时候就可以通过该工具录制首页加载过程，然后分析出具体性能异常逻辑。</p>\n</li>\n<li data-nodeid="42253">\n<p data-nodeid="42254"><strong data-nodeid="42398">Debugger</strong>，断点调试功能，和 IDE 上的断点调试是一样的。</p>\n</li>\n<li data-nodeid="42255">\n<p data-nodeid="42256"><strong data-nodeid="42403">Network</strong>，可以抓取网络请求，并分析返回数据，类似于前端 Chrome 的 Network 工具。</p>\n</li>\n<li data-nodeid="42257">\n<p data-nodeid="42258"><strong data-nodeid="42408">Logging</strong>，运行期间的日志显示。日志中包含：Dart 运行时的垃圾回收事件、Flutter 框架事件，比如创建帧的事件、应用的 stdout 和 stderr 和应用的自定义日志事件。</p>\n</li>\n</ul>\n<p data-nodeid="42259">介绍完以上功能后，我们着重介绍 Timeline 工具，应用该工具来做性能分析和优化。</p>\n<h4 data-nodeid="42260">Timeline</h4>\n<p data-nodeid="42261">Timeline 会记录每一帧的绘制，每一帧绘制又包括 UI 线程构建图形树和 GPU 线程绘制图像两个过程。在应用开发完成后，我们可以使用 Timeline 工具来走一遍 App 所有页面，记录每一帧的性能耗时。请注意该功能最好是在外接实体机上进行测试，不然会出现数据相差较大。我们分为以下七个步骤来进行实践。</p>\n<p data-nodeid="42262">1.连接实体调试机器，然后运行 flutter run --profile 启动 App。<br>\n2.打开 devTools 工具，点击 Timeline 工具，点击 Clear 清空旧数据。<br>\n3.可以在某个页面上进行一系列的基础操作，操作完成后，回到 devTools 中，点击 Refresh，这时候会有一个短暂的分析过程，分析完成后，你会看到下图所示的内容。</p>\n<p data-nodeid="42263"><img src="https://s0.lgstatic.com/i/image/M00/43/EA/Ciqc1F886MKAXHUJAADEduC9Pvw266.png" alt="Drawing 4.png" data-nodeid="42419"></p>\n<div data-nodeid="42264"><p style="text-align:center">Timeline 性能柱状图</p></div>\n<p data-nodeid="46046" class="">4.在界面中，你会看到浅蓝（ UI 线程耗时，小于  16.67ms）、深蓝（ GPU 耗时，小于 16.67 ms）、橘黄（ UI 线程耗时，大于 16.67 ms）和深红（ GPU 耗时，大于 16.67 ms）的柱状数据，浅蓝和橘黄都代表 UI 线程耗时，深蓝和深红都代表 GPU 耗时，在 UI 线程耗时和 GPU 耗时都小于 16.67 ms 时显示浅蓝和深蓝，而当 UI 线程耗时或者 GPU 耗时任意一个大于 16.67 ms 时，则显示橘黄和深红。</p>\n\n\n\n\n\n\n\n<p data-nodeid="42266">5.当发现有橘黄和深红的柱状图时，则需要进行具体的分析，这时候只需要点击这部分柱状图，就可以看到下图所示的一个效果。</p>\n<p data-nodeid="42267"><img src="https://s0.lgstatic.com/i/image/M00/43/EA/Ciqc1F886NuAOv4lAAMBs3hz5KY064.png" alt="Drawing 5.png" data-nodeid="42424"></p>\n<div data-nodeid="42268"><p style="text-align:center">Timeline 单个数据分析图</p></div>\n<p data-nodeid="42269">6.如果 UI 线程耗时比较长，点击具体较长的柱状图，可以看到具体的火焰图。如下图所示，其中的宽度就代表执行的时间长度，宽度越长表明性能损耗越大，而这就是性能优化的部分。</p>\n<p data-nodeid="42270"><img src="https://s0.lgstatic.com/i/image/M00/43/EA/Ciqc1F886OOABOHtAAOrn9ZoZMo713.png" alt="Drawing 6.png" data-nodeid="42428"></p>\n<div data-nodeid="42271"><p style="text-align:center">UI 线程耗时分析</p></div>\n<p data-nodeid="42272">7.如果 GPU 耗时较长，则可以往下拉查看 GPU 页面绘制问题，如下图所示。</p>\n<p data-nodeid="42273"><img src="https://s0.lgstatic.com/i/image/M00/43/F5/CgqCHl886OqAdQZ0AAJb7VYSQsA920.png" alt="Drawing 7.png" data-nodeid="42432"></p>\n<div data-nodeid="42274"><p style="text-align:center">GPU 耗时分析</p></div>\n<p data-nodeid="42275">接下来我们就分别从 UI 线程问题和 GPU （ Raster ）来分析具体的性能问题。</p>\n<h4 data-nodeid="42276">UI 线程问题实践分析</h4>\n<p data-nodeid="42277">如果出现橘黄色和深红色的柱状图时，我们需要单独分析这块的性能问题。大部分情况是因为在 Dart 中执行了比较耗时的函数，或者在组件树设计上没有注意性能导致的问题。这里介绍下可能会提升或者影响性能的几个关键点。</p>\n<ul data-nodeid="42278">\n<li data-nodeid="42279">\n<p data-nodeid="42280">不会发生任何变化的组件，使用 const ，减少绘制，例如我们的通用 loading 组件。</p>\n</li>\n<li data-nodeid="42281">\n<p data-nodeid="42282">减少组件绘制，这点就是我们之前提到的尽量减少有状态组件下的子组件，或者通过状态管理模块 Provider 来辅助管理状态。</p>\n</li>\n<li data-nodeid="42283">\n<p data-nodeid="42284">复杂业务 build 函数在代码逻辑中，避免复杂业务在 build 逻辑中去执行。例如我们代码中的 user_page/guest.dart 这个页面，这个页面逻辑是相当复杂的，首先需要使用 JSON 的方式获取参数，其次还需要进行接口拉取，这块是比较耗费性能的。</p>\n</li>\n</ul>\n<p data-nodeid="42285">例如这里我们需要分析 guest.dart 页面的问题。首先我们连接真机调试，然后启动程序，可以看到如下图的界面，并选择 Track Widget Builds 统计（该工具会显示具体的组件名字，以方便我们查看问题）。</p>\n<p data-nodeid="42286"><img src="https://s0.lgstatic.com/i/image/M00/43/F5/CgqCHl886PKAA9UrAAFt4lddgwk448.png" alt="Drawing 8.png" data-nodeid="42444"></p>\n<div data-nodeid="42287"><p style="text-align:center">Timeline 调试主页</p></div>\n<p data-nodeid="42288">接下来在真机上，点击某个人的头像，进入用户页面，也就是访问我们的 user_page/guest.dart 。访问完成后，点击 Timeline 工具中的 Refresh ，就可以看到如下图的界面。</p>\n<p data-nodeid="42289"><img src="https://s0.lgstatic.com/i/image/M00/43/F5/CgqCHl886PiAccZGAADxVxH-wTs542.png" alt="Drawing 9.png" data-nodeid="42450"></p>\n<div data-nodeid="42290"><p style="text-align:center">Refresh 性能检测结果</p></div>\n<p data-nodeid="42291">从上面，我们可以很明显地看到几条橘黄色的柱状图，我们随便选择一个去分析，点击后，可以在界面中看到下图的 UI 构建耗时分布的火焰图。</p>\n<p data-nodeid="42292"><img src="https://s0.lgstatic.com/i/image/M00/43/EA/Ciqc1F886QKAFvlNAAHmvu171ZY675.png" alt="Drawing 10.png" data-nodeid="42454"></p>\n<div data-nodeid="42293"><p style="text-align:center">UI 耗时火焰图</p></div>\n<p data-nodeid="42294">接下来我们就可以看到 build 逻辑调用的各个组件的耗时情况，也可以看到这其中构建了多少个组件，其次通过这张图也可以快速地定位到哪些组件没有更新。在上面图中，我们可以看到 BottomNavigationBar 相对其他组件来说，耗时就非常大。那我们就具体来看看，到底是什么原因导致的。</p>\n<p data-nodeid="42295">我们在 guest.dart 中并没有应用 BottomNavigationBar 组件，那么怎么会产生调用呢？接下来我们就使用 debug 功能，在 guest.dart 的 build 逻辑加上断点，然后使用 debug 模式运行。</p>\n<p data-nodeid="42296">这个问题最终发现是因为 Navigator.push 引发 Scaffold 的更新，而 Scaffold 是 BottomNavigationBar 和 AppBar 的父组件，从而又引发了这个组件的下的子组件发生 rebuild 行为。之前官方有修复一个 bug 就是在 Navigator.push 会引起前面的页面 rebuild 操作，但是这个问题好像没有发现并引起重视。关于这个问题我已经提交 <a href="https://github.com/flutter/flutter/issues/63312" data-nodeid="42460">github issue</a> ，如果有进展或者你有解决方案，也帮忙在此评论下。</p>\n<p data-nodeid="42297">其他问题寻找方式也是类似的，只要按照上面的过程去分析。</p>\n<h4 data-nodeid="42298">GPU（ Raster ）</h4>\n<p data-nodeid="42299">一般情况下都是较复杂的图片绘制产生的问题，比如说复杂的动效或者复杂的图片资源。上面的工具也不能完全帮你定位到异常的问题。需要根据实际的代码逻辑来分析，这点是比较困难的，只能排除法步步寻找问题点。Timeline 图只能协助我们去找到 GPU 存在性问题。</p>\n<p data-nodeid="42300">你在遇到 GPU 问题时，可以在 devTools 中的 Timeline 打开 Performance Overlay 工具，打开后在真机或者虚拟机上就可以看到效果，当出现 GPU 性能问题时，会出现红色线条。</p>\n<p data-nodeid="42301"><img src="https://s0.lgstatic.com/i/image/M00/43/F5/CgqCHl886Q6AUmANAAEEvCCE5Hg305.png" alt="Drawing 11.png" data-nodeid="42468"></p>\n<div data-nodeid="42302"><p style="text-align:center">Performance Overlay</p></div>\n<p data-nodeid="42303">以上就是 devTools 的工具使用，通过这个工具可以大大提升我们定位问题的效率。以上是在开发中或者上线前所需要做的一些前期性能分析准备，那么在上线后我们应该如何来分析性能呢？</p>\n<h3 data-nodeid="42304">性能上报</h3>\n<p data-nodeid="42305">为了能够更好地分析和判断性能问题，我们有时候需要采集现网运行期间的一些性能数据，例如我们需要主要的两个指标：Crash 率和 FPS 数据。接下来我们主要介绍下如何计算和采集这两个数据的方法。</p>\n<p data-nodeid="42306">由于这部分肯定会影响主线程的性能，因此我们将该计算和上报过程放入到一个新的线程去处理，避免影响主线程。</p>\n<h4 data-nodeid="42307">Isolate 线程</h4>\n<p data-nodeid="42308">这部分知识点，在之前的课时中已经有介绍到了，这部分代码在 lib/util/tools/isolate_handle.dart 中。代码中唯一的不同点是需要进行双向的通信，该原理的实现思想是：在新线程回调函数中，向主线程发送一个回包，回包的内容就是自身接收信息句柄，然后主线程可以应用该句柄发送消息给到新线程。主线程代码如下：</p>\n<pre class="lang-dart" data-nodeid="42309"><code data-language="dart"><span class="hljs-keyword">var</span> receivePort = ReceivePort(); \n<span class="hljs-keyword">if</span>(isolate == <span class="hljs-keyword">null</span> ) { \n  isolate = <span class="hljs-keyword">await</span> Isolate.spawn(otherIsolate, receivePort.sendPort); \n} \n<span class="hljs-built_in">Map</span> dataInfo = { \n  <span class="hljs-string">\'fun\'</span> : callFun, \n  <span class="hljs-string">\'routerFrames\'</span> : routerFrames, \n  <span class="hljs-string">\'deviceInfo\'</span> : deviceInfo, \n  <span class="hljs-string">\'routerName\'</span> : routerName \n}; \n<span class="hljs-keyword">if</span>(sendPort != <span class="hljs-keyword">null</span>){ <span class="hljs-comment">// 如果已经连接成功，则直接使用 sendPort 发送消息 </span>\n  sendPort.send(dataInfo); \n} \nreceivePort.listen((data) { \n  <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">is</span> SendPort) { <span class="hljs-comment">// 创建初始连接 </span>\n    sendPort = data; \n    <span class="hljs-keyword">return</span>; \n  } \n  sendPort.send(dataInfo); \n});\n</code></pre>\n<p data-nodeid="42310">为了避免创建太多的线程，我们需要将线程连接保存起来，下次可以直接发送消息。再看下新线程的处理逻辑。</p>\n<pre class="lang-dart" data-nodeid="42311"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">其他线程，处理计算和上报 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> otherIsolate(SendPort sendPort) <span class="hljs-keyword">async</span> { \n  <span class="hljs-keyword">var</span> receivePort = ReceivePort(); \n  receivePort.listen((data) { \n    <span class="hljs-keyword">if</span>(data[<span class="hljs-string">\'fun\'</span>] == <span class="hljs-string">\'calculateFps\'</span>) { \n      isolateCalculateFps( \n          data[<span class="hljs-string">\'routerFrames\'</span>] <span class="hljs-keyword">as</span> ListQueue&lt;FrameTiming&gt;, \n          data[<span class="hljs-string">\'routerName\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>, \n          data[<span class="hljs-string">\'deviceInfo\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span> \n      ); \n    } \n    <span class="hljs-keyword">if</span>(data[<span class="hljs-string">\'fun\'</span>] == <span class="hljs-string">\'reportPv\'</span>) { \n      isolateReportPv( \n          data[<span class="hljs-string">\'routerName\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>, \n          data[<span class="hljs-string">\'deviceInfo\'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span> \n      ); \n    } \n  }); \n  <span class="hljs-comment">// 首先需要回句柄，创建通信连接 </span>\n  sendPort.send(receivePort.sendPort); \n  <span class="hljs-comment">// 再发送回包，处理具体的信息 </span>\n  sendPort.send(<span class="hljs-string">\'success\'</span>); \n}\n</code></pre>\n<p data-nodeid="42312">代码的第 22 行首先回第一个包执行连接成功，然后再发送一个回包，用来告诉主线程已经连接成功。连接成功后就可以发送具体的消息实体，让新线程来处理了。以上就是双向通信的实现，<a href="https://github.com/love-flutter/flutter-column" data-nodeid="42481">详细代码大家请参考 Github 源码</a>。接下来我们看下两个指标的实现逻辑。</p>\n<h4 data-nodeid="42313">Crash 率</h4>\n<p data-nodeid="42314">异常率的计算方法是需要根据手机机型和手机版本来进行分析，我们先制定如下数据指标：</p>\n<ul data-nodeid="42315">\n<li data-nodeid="42316">\n<p data-nodeid="42317">机型的 Crash 率 = 机型的 Crash 量 / 该机型页面访问量</p>\n</li>\n<li data-nodeid="42318">\n<p data-nodeid="42319">版本的 Crash 率 = 版本的 Crash 量 / 该版本页面的访问量</p>\n</li>\n<li data-nodeid="42320">\n<p data-nodeid="42321">版本机型的 Crash 率 = 机型版本的 Crash 量 / 该机型特定版本的访问量</p>\n</li>\n</ul>\n<p data-nodeid="42322">根据上面的计算方式，我们需要增加一些数据上报，主要包括：机型、版本、页面名称、Crash 情况。之前我们已经介绍了 Sentry 平台上报异常的方法，这里只需要补充上页面的 PV 就可以了。</p>\n<p data-nodeid="42323">在上面的计算公式中，需要获取设备和版本信息，这部分可以使用通用类来实现，这里我们将代码临时也放在 IsolateHandle 类中，具体代码如下：</p>\n<pre class="lang-dart" data-nodeid="42324"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">获取设备信息 </span></span>\n<span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; getDeviceInfo() <span class="hljs-keyword">async</span>{ \n  <span class="hljs-built_in">String</span> deviceName = <span class="hljs-string">\'\'</span>; \n  <span class="hljs-comment">/// <span class="markdown">获取设备插件句柄 </span></span>\n  DeviceInfoPlugin deviceInfo = DeviceInfoPlugin(); \n  <span class="hljs-keyword">if</span>(Platform.isAndroid) { <span class="hljs-comment">// 判断平台 </span>\n    AndroidDeviceInfo androidInfo = <span class="hljs-keyword">await</span> deviceInfo.androidInfo; \n    deviceName = androidInfo.model; \n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Platform.isIOS) { <span class="hljs-comment">// 判断平台 </span>\n    IosDeviceInfo iosInfo = <span class="hljs-keyword">await</span> deviceInfo.iosInfo; \n    deviceName = iosInfo.utsname.machine; \n  } \n  <span class="hljs-comment">// 获取当前客户端版本信息 </span>\n  PackageInfo packageInfo = <span class="hljs-keyword">await</span> PackageInfo.fromPlatform(); \n  <span class="hljs-built_in">String</span> version = packageInfo.version; \n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'<span class="hljs-subst">${deviceName}</span>\\t<span class="hljs-subst">${version}</span>\'</span>; \n}\n</code></pre>\n<p data-nodeid="42325">上面代码中应用到了两个第三方库，package_info 获取版本相关信息，device_info 获取设备相关信息。</p>\n<pre class="lang-dart" data-nodeid="42326"><code data-language="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">\'package:package_info/package_info.dart\'</span>; \n<span class="hljs-keyword">import</span> <span class="hljs-string">\'package:device_info/device_info.dart\'</span>;\n</code></pre>\n<p data-nodeid="42327">获取到设备后，我们只需要在每次打开页面时进行数据上报就可以了，代码如下：</p>\n<pre class="lang-dart" data-nodeid="42328"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">这里上报 pv 数据 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> isolateReportPv(<span class="hljs-built_in">String</span> routerName, <span class="hljs-built_in">String</span> deviceInfo) <span class="hljs-keyword">async</span> { \n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'<span class="hljs-subst">${deviceInfo}</span>\\t<span class="hljs-subst">${routerName}</span>\'</span>); \n  <span class="hljs-comment">/// <span class="markdown">@todo report to server </span></span>\n}\n</code></pre>\n<h4 data-nodeid="42329">FPS</h4>\n<p data-nodeid="42330">计算 FPS 的逻辑相对来说较复杂一些，首先需要使用 Flutter 的 SchedulerBinding.instance.addTimingsCallback 函数来获取每一帧耗时，这段代码主要是在 Flutter 绘制完成每一帧后都会进行回调处理，通过回调的方式可以采集到每一帧的耗时信息，具体代码逻辑如下：</p>\n<pre class="lang-dart" data-nodeid="42331"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">启动监听数据 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> start() <span class="hljs-keyword">async</span>{ \n  deviceInfo = <span class="hljs-keyword">await</span> IsolateHandle.getDeviceInfo(); \n  SchedulerBinding.instance.addTimingsCallback( \n      Report.onReportTimings \n  ); \n}\n</code></pre>\n<p data-nodeid="42332">然后在 onReportTimings 中将每一帧数据分别保存到 frames 和 routerFrames ，代码如下：</p>\n<pre class="lang-dart" data-nodeid="42333"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">数据处理 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> onReportTimings(<span class="hljs-built_in">List</span>&lt;FrameTiming&gt; timings) { \n  <span class="hljs-keyword">for</span> (FrameTiming timing <span class="hljs-keyword">in</span> timings) { \n    frames.addFirst(timing); \n    routerFrames.addFirst(timing); \n  } \n}\n</code></pre>\n<p data-nodeid="42334">routerFrames 为当前页面路由的帧耗时的队列，frames 为所有帧耗时的队列。有了绘制的每一帧数据后，我们再将数据传递到其他线程进行计算，这里会传递到 IsolateHandle 的 calculateFps 方法，我们具体看下这个方法的计算逻辑。</p>\n<pre class="lang-dart" data-nodeid="42335"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">计算当个页面的 fps </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> isolateCalculateFps( \n    ListQueue&lt;FrameTiming&gt; calculateList, \n    <span class="hljs-built_in">String</span> routerName, \n    <span class="hljs-built_in">String</span> deviceInfo \n    ) { \n  <span class="hljs-keyword">if</span>(calculateList == <span class="hljs-keyword">null</span>){ \n    <span class="hljs-keyword">return</span>; \n  } \n  <span class="hljs-built_in">String</span> fpsStr = <span class="hljs-number">60.</span>toStringAsFixed(<span class="hljs-number">3</span>); \n  <span class="hljs-built_in">int</span> lostNum = <span class="hljs-number">0</span>; \n  <span class="hljs-comment">// flutter 标准渲染频率 </span>\n  <span class="hljs-built_in">double</span> standardFps = <span class="hljs-number">1000</span>/<span class="hljs-number">60</span>; \n  <span class="hljs-comment">// 计算多少出现掉帧情况，请注意如果是 33秒，其掉帧为2，用34/16。67下取整。 </span>\n  calculateList.forEach((frame) { \n    <span class="hljs-keyword">if</span>(frame.totalSpan.inMilliseconds &gt; standardFps) { <span class="hljs-comment">// 超出 16ms 的帧 </span>\n      lostNum = lostNum + ( \n          frame.totalSpan.inMilliseconds/standardFps \n      ).floor(); \n    } \n  }); \n  <span class="hljs-keyword">if</span>(calculateList.length + lostNum &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 尽量避免分母为0情况 </span>\n    <span class="hljs-built_in">double</span> fps = ( <span class="hljs-number">60</span> * calculateList.length ) / \n        ( calculateList.length + lostNum ); \n    fpsStr = fps.toStringAsFixed(<span class="hljs-number">3</span>); \n  } \n  <span class="hljs-built_in">print</span>(<span class="hljs-string">\'<span class="hljs-subst">${deviceInfo}</span>\\t<span class="hljs-subst">${fpsStr}</span>\'</span>); \n}\n</code></pre>\n<p data-nodeid="42336">上述代码中，首先获取标准的一帧绘制时间 16.67 ms（目前这部分是hardcode 60 HZ，后续需要匹配 120 HZ），然后分别计算每一帧的渲染耗时情况，并与 16.67 ms 进行对比，得到掉帧数量。计算掉帧的方式是，用耗时时间除以 16.67 ms 下取整就代表掉帧数量。比如耗时 34 ms，代表掉帧了 2 帧，因为 34 / 16.67 = 2.039。最后用以下公式来计算 FPS 。</p>\n<pre class="lang-dart" data-nodeid="42337"><code data-language="dart">( list.length * <span class="hljs-number">60</span> ) / ( list.length + lostNum )\n</code></pre>\n<p data-nodeid="42338">FPS 和 PV 一样将数据上报到服务端，后续在服务端进行分析。</p>\n<p data-nodeid="42339">以上就完成了所有的性能上报功能，接下来我们在某个页面进行尝试，这里选择之前侧边栏的“单图片信息”。</p>\n<h4 data-nodeid="42340">应用</h4>\n<p data-nodeid="42341">在该类中的 initState 中上报 PV ，并在页面开始加载前，将帧放入到具体的 routerFrames 中，代码如下：</p>\n<pre class="lang-dart" data-nodeid="42342"><code data-language="dart"><span class="hljs-meta">@override</span> \n<span class="hljs-keyword">void</span> initState() { \n  <span class="hljs-keyword">super</span>.initState(); \n  <span class="hljs-comment">/// <span class="markdown">开始记录fps </span></span>\n  Report.startRecord(<span class="hljs-string">\'<span class="hljs-subst">${<span class="hljs-keyword">this</span>.runtimeType}</span>\'</span>); \n  indexPos = <span class="hljs-number">0</span>; \n  <span class="hljs-comment">// 拉取推荐内容 </span>\n  ApiContentIndex.getRecommendList().then((retInfo) { \n    <span class="hljs-keyword">if</span> (retInfo.ret != <span class="hljs-number">0</span>) { \n      <span class="hljs-comment">// 判断返回是否正确 </span>\n      <span class="hljs-keyword">return</span>; \n    } \n    setState(() { \n      contentList = retInfo.data; \n    }); \n  }); \n}\n</code></pre>\n<p data-nodeid="42343">其中的第 5 行就是上报 PV ，并开始记录 routerFrames ，这里通过 this.runtimeType 可以获得具体的类名。FPS 则在页面最后一帧加载完成后回调，然后在回调中计算 FPS 相关数据。在 Flutter 提供了接收帧绘制完成后回调的方法，需要在 build 逻辑中增加下面的代码。</p>\n<pre class="lang-dart" data-nodeid="42344"><code data-language="dart">WidgetsBinding.instance.addPostFrameCallback( \n        (_) =&gt; Report.endRecord(<span class="hljs-string">\'<span class="hljs-subst">${<span class="hljs-keyword">this</span>.runtimeType}</span>\'</span>) \n);\n</code></pre>\n<p data-nodeid="42345">然后在 Report.endRecord 调用其他线程函数，计算 FPS，并需要清空 routerFrames 。</p>\n<pre class="lang-dart" data-nodeid="42346"><code data-language="dart"><span class="hljs-comment">/// <span class="markdown">结束并显示数据 </span></span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> endRecord(<span class="hljs-built_in">String</span> routerName) { \n  IsolateHandle.calculateFps(routerFrames, routerName, deviceInfo); \n  routerFrames.clear(); \n}\n</code></pre>\n<p data-nodeid="42347">完成后就可以在虚拟机或者真机上进行模拟测试了，不过这里的 FPS 数据不一定完全准确，后续会进一步再优化更新到<a href="https://github.com/love-flutter/flutter-column" data-nodeid="42510">Github 源码</a>中。</p>\n<h3 data-nodeid="42348">总结</h3>\n<p data-nodeid="42349">本课时着重介绍了 devTools 中的 Timeline 工具的使用，并且应用该工具带领大家实践分析性能问题，其次也简单介绍了 GPU 的问题，不过 GPU 问题需要根据实际情况来分析。最后通过多线程的方式来计算和上报页面相关的性能数据。</p>\n<p data-nodeid="42350">学完本课时，你需要掌握 Timeline 分析 UI 性能问题的方法，并且了解如何捕获 Flutter 页面的绘制耗时数据，以及如何简单计算 FPS。</p>\n<p data-nodeid="42351" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="42517">点击链接查看本课时代码</a></p>',
          },
          {
            theme:
              '22 | 自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略',
            id: 324,
            content:
              '<p data-nodeid="4705" class="">在自渲染模式中，Flutter 三棵树是一个比较关键的知识点。本课时将带你学习 Flutter 自渲染模式的三棵树，然后从三棵树的绘制过程中了解 Flutter 是如何做性能优化和如何进行 Flutter App 的性能提升。</p>\n<h3 data-nodeid="4706">三棵树</h3>\n<p data-nodeid="4707">在 Flutter 中存在三棵树，分别是 Widget 、Element 和 RenderObject。</p>\n<ul data-nodeid="4708">\n<li data-nodeid="4709">\n<p data-nodeid="4710">Widget，是用来描述 UI 界面的，里面主要包含了一些基础的 UI 渲染的配置信息。</p>\n</li>\n<li data-nodeid="4711">\n<p data-nodeid="4712">Element，类似于前端的虚拟 Dom，介于 Widget 和 RenderObject 之间。</p>\n</li>\n<li data-nodeid="4713">\n<p data-nodeid="4714">RenderObject，则是实际上需要渲染的树，渲染引擎会根据 RenderObject 来进行界面渲染。</p>\n</li>\n</ul>\n<p data-nodeid="4715">在 Flutter 中经过一系列处理后，将会生成一份这样的配置信息，如图 1 所示（你可以使用 debug 模式得到这份渲染树的结构信息）。</p>\n<p data-nodeid="4716"><img src="https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_i_CAfmbFAAJQmkbVhaU299.png" alt="Drawing 0.png" data-nodeid="4831"></p>\n<div data-nodeid="4717"><p style="text-align:center">图 1 渲染树结构</p></div>\n<p data-nodeid="4718">在图 1 中比较关键的是 3 个属性：</p>\n<ul data-nodeid="4719">\n<li data-nodeid="4720">\n<p data-nodeid="4721">_widget 就是我们所说的 Widget 树；</p>\n</li>\n<li data-nodeid="4722">\n<p data-nodeid="4723">_chilid 就是我们所说的 Element 树；</p>\n</li>\n<li data-nodeid="4724">\n<p data-nodeid="4725">而 _renderObject 就是 RenderObject 树。</p>\n</li>\n</ul>\n<p data-nodeid="4726">以上的渲染树结构对于我们所看到的 Widget 是一份非常简单的配置，如下：</p>\n<pre class="lang-dart" data-nodeid="4727"><code data-language="dart"><span class="hljs-keyword">void</span> main() {\n  runApp(MaterialApp(\n    title: <span class="hljs-string">\'Navigation Basics\'</span>,\n    home: FirstRoute(),\n  ));\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstRoute</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{\n  <span class="hljs-meta">@override</span>\n  Widget build(BuildContext context) {\n    <span class="hljs-keyword">return</span> Center(\n      child: Text(<span class="hljs-string">\'flutter test\'</span>),\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="4728">上面代码描述的是一个简单的页面组件，不过在这个简单页面组件背后是一个非常复杂的树型结构，具体看看渲染的 Element 树到底是个什么样子，如图 2 所示。</p>\n<p data-nodeid="4729"><img src="https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_i_uAHvbgAAFqAXyCe9s498.png" alt="Drawing 1.png" data-nodeid="4844"></p>\n<div data-nodeid="4730"><p style="text-align:center">图 2 Element 树结构</p></div>\n<p data-nodeid="4731">你有没有发现就一个非常简单的 Widget ，在 Flutter 中实际生成的 Element 树结构图是如此的复杂。你有没有发现在树的最底层才是我们使用的组件 FirstRoute-&gt;Center-&gt;Text-&gt;RichText（如图 2 中红色的部分）。了解完三棵树结构后，我们再来看下三棵树是如何进行转化的。</p>\n<h3 data-nodeid="4732">三棵树对应关系</h3>\n<p data-nodeid="4733">在 Flutter 中，Widget 和 Element 树是一一对应的，但是与 RenderObject 不是一一对应的。因为有些 Widget 是不需要渲染的，比如我们上面测试代码中的 FirstRoute 就是不需要渲染的 Widget。最终只有 RenderObjectWidget 相关的 Widget 才会转化为 RenderObject，也只有这种类型才需要进行渲染。可以看下表格 1 所展示的三棵树部分类型的对应关系。</p>\n<p data-nodeid="4734"><img src="https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jAWASaH5AABxjuioTcw001.png" alt="Drawing 2.png" data-nodeid="4850"></p>\n<div data-nodeid="4735"><p style="text-align:center">表格 1 Widget 、 Element 和 RenderObject 对应关系</p></div>\n<p data-nodeid="4736">接下来我们看下三者是如何进行转化的。</p>\n<h3 data-nodeid="4737">三棵树转化流程</h3>\n<p data-nodeid="4738">Flutter 运行中的一部分核心逻辑就是在处理这三棵树的转化，所有的界面交互和事件处理，最终都反应在这三棵树上的操作结果。一般情况下，我们都是这样去运行 Flutter 项目的。</p>\n<pre class="lang-dart" data-nodeid="4739"><code data-language="dart"><span class="hljs-keyword">void</span> main() {\n  runApp(MaterialApp(\n    title: <span class="hljs-string">\'Navigation Basics\'</span>,\n    home: FirstRoute(),\n  ));\n}\n</code></pre>\n<p data-nodeid="4740">其中的 MaterialApp 就是我们所描述的一个 Widget ，Flutter 会经过 scheduleAttachRootWidget 、 attachRootWidget 、attachToRenderTree 调用到 RenderObjectToWidgetElement 的 mount 方法。在过程中会涉及相当多的源码函数，这里我们选择几个比较重要的函数介绍下。</p>\n<h4 data-nodeid="4741">重要函数说明</h4>\n<p data-nodeid="4742">在介绍函数之前我们先来看下整体的架构流程图，如图 3 所示。</p>\n<p data-nodeid="4743"><img src="https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jBaAPZtCAADE5IavI9E126.png" alt="Drawing 3.png" data-nodeid="4859"></p>\n<div data-nodeid="4744"><p style="text-align:center">图 3 Flutter 树转化图</p></div>\n<p data-nodeid="4745">上述图比较复杂，你可以先简单了解下，等下我们会详细拆分来讲解。我们先来看下这几个关键函数的作用。</p>\n<ul data-nodeid="4746">\n<li data-nodeid="4747">\n<p data-nodeid="4748"><strong data-nodeid="4865">scheduleAttachRootWidget</strong>，创建根 widget ，并且从根 widget 向子节点递归创建元素Element，对子节点为 RenderObjectWidget 的小部件创建 RenderObject 树节点，从而创建出 View 的渲染树，这里源代码中使用 Timer.run 事件任务的方式来运行，目的是避免影响到微任务的执行。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="4749"><code data-language="dart"><span class="hljs-keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) {\n  Timer.run(() {\n    attachRootWidget(rootWidget);\n  });\n}\n</code></pre>\n<ul data-nodeid="4750">\n<li data-nodeid="4751">\n<p data-nodeid="4752"><strong data-nodeid="4870">attachRootWidget</strong> 与 scheduleAttachRootWidget 作用一致，首先是创建根节点，然后调用 attachToRenderTree 循环创建子节点。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="4753"><code data-language="dart"><span class="hljs-keyword">void</span> attachRootWidget(Widget rootWidget) {\n  _readyToProduceFrames = <span class="hljs-keyword">true</span>;\n  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(\n    container: renderView,\n    debugShortDescription: <span class="hljs-string">\'[root]\'</span>,\n    child: rootWidget,\n  ).attachToRenderTree(buildOwner, renderViewElement <span class="hljs-keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;);\n}\n</code></pre>\n<ul data-nodeid="4754">\n<li data-nodeid="4755">\n<p data-nodeid="4756"><strong data-nodeid="4875">attachToRenderTree</strong>，该方法中有两个比较关键的调用，我只举例出核心代码部分，这里会先执行 buildScope ，但是在 buildScope 中会优先调用第二个参数（回调函数，也就是 element.mount ），而 mount 就会循环创建子节点，并在创建的过程中将需要更新的数据标记为 dirty。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="4757"><code data-language="dart">owner.buildScope(element, () {\n  element.mount(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);\n});\n</code></pre>\n<ul data-nodeid="4758">\n<li data-nodeid="4759">\n<p data-nodeid="4760"><strong data-nodeid="4880">buildScope</strong>，如果首次渲染 dirty 是空的列表，因此首次渲染在该函数中是没有任何执行流程的，该函数的核心还是在第二次渲染或者 setState 后，有标记 dirty 的 Element 时才会起作用，该函数的目的也是循环 dirty 数组，如果 Element 有 child 则会递归判断子元素，并进行子元素的 build ，创建新的 Element 或者修改 Element 或者创建 RenderObject。</p>\n</li>\n<li data-nodeid="4761">\n<p data-nodeid="4762"><strong data-nodeid="4885">updateChild</strong>，该方法非常重要，所有子节点的处理都是经过该函数，在该函数中 Flutter 会处理 Element 与 RenderObject 的转化逻辑，通过 Element 树的中间状态来减少对 RenderObject 树的影响，从而提升性能。具体这个函数的代码逻辑，我们拆解来分析。该函数的输入参数，包括三个参数：Element child、Widget newWidget、dynamic newSlot 。child 为当前节点的 Element 信息， newWidget 为 Widget 树的新节点，newSlot 为节点的新位置。在了解参数后接下来看下核心逻辑，首先判断是否有新的 Widget 节点。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="4763"><code data-language="dart"><span class="hljs-keyword">if</span> (newWidget == <span class="hljs-keyword">null</span>) {\n  <span class="hljs-keyword">if</span> (child != <span class="hljs-keyword">null</span>)\n    deactivateChild(child);\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n}\n</code></pre>\n<p data-nodeid="4764">如果不存在，则将当前节点的 Element 直接销毁，如果 Widget 存在该节点，并且 Element 中也存在该节点，那么就首先判断两个节点是否一致，如代码第一行，如果一致只是位置不同，则更新位置即可。其他情况下判断是否可更新子节点，如果可以则更新，如果不可以则销毁原来的 Element 子节点，并重新创建一个。</p>\n<pre class="lang-dart" data-nodeid="4765"><code data-language="dart"><span class="hljs-keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) {\n  <span class="hljs-keyword">if</span> (child.slot != newSlot)\n    updateSlotForChild(child, newSlot);\n  newChild = child;\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) {\n  <span class="hljs-keyword">if</span> (child.slot != newSlot)\n    updateSlotForChild(child, newSlot);\n  child.update(newWidget);\n  <span class="hljs-keyword">assert</span>(child.widget == newWidget);\n  <span class="hljs-keyword">assert</span>(() {\n    child.owner._debugElementWasRebuilt(child);\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n  }());\n  newChild = child;\n} <span class="hljs-keyword">else</span> {\n  deactivateChild(child);\n  <span class="hljs-keyword">assert</span>(child._parent == <span class="hljs-keyword">null</span>);\n  newChild = inflateWidget(newWidget, newSlot);\n}\n</code></pre>\n<p data-nodeid="4766">上面代码的第 8 行非常关键，在 child.update 函数逻辑里面，会根据当前节点的类型，调用不同的 update ，可参考图 3 中的 update 下的流程，每一个流程也都会递归调用子节点，并循环返回到 updateChild 中。有以下三个核心的函数会重新进入 updateChild 流程中，分别是 performRebuild、inflateWidget 和 markNeedsBuild，接下来我们看下这三个函数具体的作用。</p>\n<ul data-nodeid="4767">\n<li data-nodeid="4768">\n<p data-nodeid="4769"><strong data-nodeid="4892">performRebuild</strong>是非常关键的一个代码，这部分就是我们在组件中写的 build 逻辑函数，StatelessWidget 和 StatefulWidget 的 build 函数都是在此执行，执行完成后将作为该节点的子节点，并进入 updateChild 递归函数中。</p>\n</li>\n<li data-nodeid="4770">\n<p data-nodeid="4771"><strong data-nodeid="4897">inflateWidget</strong>创建一个新的节点，在创建完成后会根据当前 Element 类型，判断是 RenderObjectElement 或者 ComponentElement 。根据两者类型的不同，调用不同 mount 挂载到当前节点上，在两种类型的 mount 中又会循环子节点，调用 updateChild 重新进入子节点更新流程。这里还有一点，当为 RenderObjectElement 的时候会去创建 RenderObject 。</p>\n</li>\n<li data-nodeid="4772">\n<p data-nodeid="4773"><strong data-nodeid="4902">markNeedsBuild</strong>，标记为 dirty ，并且调用 scheduleBuildFor 等待下一次 buildScope 操作。</p>\n</li>\n</ul>\n<p data-nodeid="4774">以上就是比较关键的几个函数，其他函数你可以自己查看官网的文档。下面结合图 3 的流程图，我结合两个流程来讲解：首次 build 的流程和 setState 的流程。</p>\n<h4 data-nodeid="4775">首次 build</h4>\n<p data-nodeid="4776">当我们首次加载一个页面组件的时候，由于所有节点都是不存在的，因此这时候的流程大部分情况下都是创建新的节点，流程会如图 4 所示。</p>\n<p data-nodeid="4777"><img src="https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jEiAbM-GAAFJbtV_XLo642.png" alt="Drawing 4.png" data-nodeid="4908"></p>\n<div data-nodeid="4778"><p style="text-align:center">图 4 首次 build 流程</p></div>\n<p data-nodeid="4779">runApp 到 RenderObjectToWidgetElement(mount) 逻辑都是一样的，在 _rebuild 中会调用 updateChild 更新节点，由于节点是不存在的，因此这时候就调用 inflateWidget 来创建 Element。</p>\n<p data-nodeid="4780">当 <strong data-nodeid="4919">Element 为 Component</strong> 时，会调用 Component.mount ，在 Component.mount 中会创建 Element 并挂载到当前节点上，其次会调用 _firstBuild 进行子组件的 build ，build 完成后则将 build 好的组件作为子组件，进入 updateChild 的子组件更新。</p>\n<p data-nodeid="4781">当 <strong data-nodeid="4925">Element 为 RenderObjectElement</strong> 时，则会调用 RenderObjectElement.mount，在 RenderObjectElement.mount 中会创建 RenderObjectElement 并且调用 createRenderObject 创建 RenderObject，并将该 RenderObject 和 RenderObjectElement 分别挂载到当前节点的 Element 树和 RenderObject 树，最后同样会调用 updateChild 来递归创建子节点。</p>\n<p data-nodeid="4782">以上就是首次 build 的逻辑，单独来看还是非常清晰的，接下来我们看下 setState 的逻辑。</p>\n<h4 data-nodeid="4783">setState</h4>\n<p data-nodeid="4784">当我们调用 setState 后，我们实际上调用的是组件的 markNeedsBuild ，而这个函数上面已经介绍到是将组件设置为 dirty ，并且添加下一次 buildScope 的逻辑，等待下一次 rebuild 循环。如图 5 流程。buildScope 会调用 rebuild 然后进入 build 操作，从而进入 updateChild 的循环体系。</p>\n<p data-nodeid="4785"><img src="https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jJGATAlDAAFF3eMI6D8595.png" alt="Drawing 6.png" data-nodeid="4931"></p>\n<div data-nodeid="4786"><p style="text-align:center">图 5 setState 流程</p></div>\n<p data-nodeid="4787">在图 5 中，我们就可以了解到，在 Flutter 中，如果父节点更新以后，也就是 setState 调用必定会引起子节点的递归循环判断 build 逻辑，虽然不一定会进行 RenderObject 树的创建（因为可能子节点没有变化，因此没有改变），但还是存在一定的性能影响。</p>\n<p data-nodeid="4788">以上就是三棵树的转化过程，其中我省略了部分非核心流程函数，大家如果感兴趣，可以在<a href="https://github.com/flutter/flutter/tree/master/packages" data-nodeid="4936">Flutter 官网的 Github</a> 上进行学习。在掌握了整体的流程，我们接下来就要从这个转化过程中，提炼出可以提升我们 Flutter APP 性能的关键点。</p>\n<h3 data-nodeid="4789">性能提升要点</h3>\n<p data-nodeid="4790">在图 3 的整体流程中，我们要特别注意的就是 updateChild 这个函数，这也是 Flutter 从 Widget 到 Element 再到 RenderObject 性能提升的关键点。这个函数的作用在上面已经有介绍到了，关键点就是在 Widget 转化为 Element，然后 Element 转化 RenderObject 过程中做的一些细节的判断优化，这些细节处理包括以下这五点。</p>\n<ul data-nodeid="4791">\n<li data-nodeid="4792">\n<p data-nodeid="4793">新节点被删除了，则直接删除 Element 节点。</p>\n</li>\n<li data-nodeid="4794">\n<p data-nodeid="4795">节点存在，组件类型相同，并且组件相等时，则更新节点位置。</p>\n</li>\n<li data-nodeid="4796">\n<p data-nodeid="4797">节点存在，组件类型相同，组件不相同，并且组件可进行更新时，则更新组件，由于当前组件更新了，因此需要更新当前组件的子节点，所以调用 update 来更新子节点列表，在此过程中也会对节点的 RenderObject 的子节点进行更新。</p>\n</li>\n<li data-nodeid="4798">\n<p data-nodeid="4799">节点存在，组件类型相同，组件不相同，其次也无法进行组件更新时，则创建节点，同时在创建过程中判断是否为 RenderObject ，如果是则创建 RenderObject ，并循环判断子节点。</p>\n</li>\n<li data-nodeid="4800">\n<p data-nodeid="4801">节点不存在，则同样走创建流程。</p>\n</li>\n</ul>\n<p data-nodeid="4802">通过这种方式就可以减少 Widget 对 RenderObject 的影响，只有需要创建和更新的节点才会反映到 RenderObject 树中。从这个树节点的转化过程，我们可以提炼出以下四个关键点，从而提升我们 APP 的性能。</p>\n<h4 data-nodeid="4803">const</h4>\n<p data-nodeid="4804">上面提到了父组件更新，导致子组件都需要进行 rebuild 操作，一种办法就是减少有状态组件下的子组件，还有一种办法就是尽量多用 const 组件，这样即使父组件更新了，子组件也不会重新 rebuild 操作。这里就是在上面的判断逻辑，节点存在，组件类型相同，并且组件相等时的处理逻辑。</p>\n<p data-nodeid="4805">这点在我们项目的源代码中，也有一些实践优化的点，特别是一些长期不修改的组件，例如通用报错组件和通用 loading 组件等，当然只能针对不带变量的组件返回，例如下面这部分代码。</p>\n<pre class="lang-dart" data-nodeid="4806"><code data-language="dart"><span class="hljs-keyword">if</span> (error) {\n    <span class="hljs-keyword">return</span> CommonError(action: <span class="hljs-keyword">this</span>.setFirstPage);\n  }\n  <span class="hljs-keyword">if</span> (contentList == <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Loading();\n  }\n}\n</code></pre>\n<p data-nodeid="4807">第 2 行代码中有一个变量 action ，因此是不能设置为 const 的，下面的 Loading 由于没有携带变量，因此是可以设置为 const 的。其他代码可以同样进行修改，对性能提升还是有一定的帮助的，特别是在组件设计不合理的过程中。</p>\n<h4 data-nodeid="4808">canUpdate</h4>\n<p data-nodeid="4809">在 updateChild 上面流程中，有一个执行函数 canUpdate ，这个也是一个性能提升的关键点，特别是在需要对多个元素进行调整时，可以看下具体的逻辑实现。</p>\n<pre class="lang-dart" data-nodeid="4810"><code data-language="dart"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) {\n  <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType\n      &amp;&amp; oldWidget.key == newWidget.key;\n}\n</code></pre>\n<p data-nodeid="4811">主要是判断运行时的类是否相同，同时判断 key 是否一样，如果都一样，则可直接更新组件 Element 位置，提升性能，因此在组件设计时，尽量减少组件的 key 的变化，可以默认设置为空。</p>\n<p data-nodeid="4812">其次在如果需要频繁地对组件进行排序、删除或者新增处理时，最好要将组件增加上 key ，以提升性能。这里要非常注意，由于 StatefulWidget 的 state 是保存在 Element 中，因此如果希望区分两个相同类名（ runtimeType ）的 Widget 时，必须携带不同的 key ，不然无法区分新旧 Widget 的变化，特别是在一个列表数据，每个列表都是一个有状态类，如果需要切换列表中项目列表时，则必须设置 key，不然会导致顺序切换失效。了解更多关于这点的，可以参考这篇<a href="https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d" data-nodeid="4956">英文的文章</a>。</p>\n<h4 data-nodeid="4813">inflateWidget</h4>\n<p data-nodeid="4814">在 updateChild 中的 inflateWidget 执行函数也是一个比较关键的性能提升点，这个函数在创建之前会检查 key 是否为 GlobalKey ，如果是则表明 Element 存在，那么这时候直接启用即可，如果不存在则需要重新创建，这就类似与组件缓存，只能说减少组件的 build 成本，看下如下这部分代码。</p>\n<pre class="lang-dart" data-nodeid="4815"><code data-language="dart"><span class="hljs-keyword">final</span> Key key = newWidget.key;\n<span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) {\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);\n  <span class="hljs-keyword">if</span> (newChild != <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">assert</span>(newChild._parent == <span class="hljs-keyword">null</span>);\n    <span class="hljs-keyword">assert</span>(() {\n      _debugCheckForCycles(newChild);\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n    }());\n    newChild._activateWithParent(<span class="hljs-keyword">this</span>, newSlot);\n    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);\n    <span class="hljs-keyword">assert</span>(newChild == updatedChild);\n    <span class="hljs-keyword">return</span> updatedChild;\n  }\n}\n<span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = newWidget.createElement();\n</code></pre>\n<p data-nodeid="4816">但是这部分也是非常损耗内存的，因为它会将组件缓存到内存中，导致垃圾内容无法进行回收，因此在使用 GlobalKey 要非常注意，尽量应用在复用性高且 build 业务复杂的组件上。</p>\n<h4 data-nodeid="4817">setState</h4>\n<p data-nodeid="4818">在图 3 中的 setState 被触发后，当前组件会进行 rebuild 操作，由于当前组件的 build ，会引起当前组件下的所有子组件发生 rebuild 行为，因此在设计时，<strong data-nodeid="4967">尽量减少有状态组件下的无状态组件</strong>，从而减少没必要的 build 逻辑。这也是我们之前提到的一些组件设计要点，虽然说 Flutter 构建 Widget 和 Element 是比较快的，但是为了性能考虑，还是尽量减少这部分没必要的损耗。其次也注意减少 build 中的业务逻辑，因为 Flutter 中的 build 是会经常被触发，特别是有状态组件。</p>\n<h3 data-nodeid="4819">总结</h3>\n<p data-nodeid="4820">本课时着重介绍了 Flutter 自渲染中的三棵树知识，从 Flutter 的三棵树概念到三棵树对应关系，其中着重介绍了三棵树的转化流程，并在流程中总结出性能优化需要着重注意的点。</p>\n<p data-nodeid="10069">学完本课时后，你需要掌握 Flutter 的三棵树概念，并非常清晰的了解三棵树的转化过程，通过对转化过程中性能优化知识的学习，从而在编码过程中养成一个非常好的编码习惯。</p>\n<p data-nodeid="34281" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="34284">点击链接，查看本课时源码</a></p>',
          },
          {
            theme: '23 | 架构原理：为什么 Flutter 性能更佳',
            id: 325,
            content:
              '<p data-nodeid="961" class="">本课时将继续深入源码，学习 Flutter 渲染原理，特别是为什么 Flutter 可以保持比较好的性能体验。</p>\n<h3 data-nodeid="962">性能优势</h3>\n<p data-nodeid="963">在这之前，业内一直都说 Flutter 的性能优于其他的跨端技术框架，并且基本与原生平台体验几乎一样。那么具体是怎么做到的呢？在了解 Flutter的自渲染原理之前，我们就先来看看原生平台 Android 与 iOS 是如何渲染 UI 的。经过前后对比之后，更能体现出其性能与原生几乎无差异的特点。</p>\n<h4 data-nodeid="964">UI 渲染基本原理</h4>\n<p data-nodeid="965">我们先来讲解一个最基础的知识点，日常我们所看到的 UI 交互界面，操作系统是如何实现的，参考下图 1 的渲染过程。</p>\n<p data-nodeid="966"><img src="https://s0.lgstatic.com/i/image/M00/46/CD/CgqCHl9GHCiAcll1AABzhn4c_Mc466.png" alt="Drawing 0.png" data-nodeid="1062"></p>\n<div data-nodeid="967"><p style="text-align:center">图1 系统 UI 界面绘制原理</p></div>\n<p data-nodeid="968">从图 1 我们可以看到，一个界面显示出来，首先是经过了 CPU 的数据计算，然后将数据发送给到 GPU， GPU 再根据相应的数据绘制成像素界面，然后放入帧缓存区中，最终显示器定时从帧缓存区获取帧数据显示在显示器上。</p>\n<p data-nodeid="969">在上面的渲染实现过程中，需要进行 CPU 和 GPU 之间的通信。因此，如何调度 GPU 是一个比较关键的点，目前有一套规范叫作 OpenGL，开发者可以通过这套规范，更方便、更高效地调用 GPU进行界面渲染。Android 和iOS 系统都在系统层面实现了这套功能，将其分别封装成 SDK API。而在 Flutter 中也实现了这套规则，也就是应用 OpenGL 规范封装了一套 Dart API，因此 Flutter 的渲染原理和 Android 以及 iOS 是一致的，所以在性能上基本没有区别。</p>\n<p data-nodeid="970">了解了 Flutter 渲染原理以后，我们再来看看目前比较常用的两个跨端框架的渲染原理。</p>\n<h4 data-nodeid="971">其他跨端技术框架渲染原理</h4>\n<p data-nodeid="972">目前比较常见的两个跨端技术框架，分别是 ReactNative 和 Weex。它们在原理上非常相近，因此这里单独介绍 ReactNative 的原理。我们先来看下图 2 的一个技术架构。</p>\n<p data-nodeid="973"><img src="https://s0.lgstatic.com/i/image/M00/46/CD/CgqCHl9GHD6AMhMQAACUmX1O0GA575.png" alt="Drawing 2.png" data-nodeid="1070"></p>\n<div data-nodeid="974"><p style="text-align:center">图2 ReactNative 技术架构图</p></div>\n<p data-nodeid="975">从图 2 ，我们可以非常清晰地看到一点，ReactNative 完全是基于原生平台来进行渲染的，而这之间主要是通过 JSbridge 来通信，将需要渲染的数据通过 JSbridge 传递给原生平台。这样的通信方式在 Flutter 中也有，在我们第 20 课时“原生通信：应用原生平台交互扩充 Flutter 基础能力”中有介绍到，这部分和 ReactNative 比较相近。而两者的最大的区别就在于，<strong data-nodeid="1076">Flutter UI 界面是自渲染的，而 ReactNative 则是通过通信的方式告知原生平台，然后原生平台再绘制出界面。</strong>。</p>\n<p data-nodeid="976">我们再回到最原始的跨端技术框架 Hybrid ，它是界面上使用 H5 ，其他功能则使用 JSbridge 来调用原生服务，因此并不会使用原生绘制界面，而仅仅只使用了原生平台能力。</p>\n<p data-nodeid="977">以上就是三种技术框架的对比说明，我们再来总结下三种框架突出解决的问题点，其次也说明当前框架存在的问题点。</p>\n<ul data-nodeid="978">\n<li data-nodeid="979">\n<p data-nodeid="980">Hybrid 是在图 2 中仅仅支持了原生能力，例如相机、存储、日历等，而 UI 交互界面则还是H5，因此不管是体验和性能都是相对较差的。</p>\n</li>\n<li data-nodeid="981">\n<p data-nodeid="982">ReactNative为了解决页面性能问题，同样应用 JSbridge 通信方式，将虚拟 DOM 以及页面渲染相关数据，传递给到原生平台，原生平台则根据虚拟 DOM 以及渲染相关数据，绘制出原生体验的界面，这样用户感知上就是原生的界面，但是这个过程中需要进行 JavaScript的代码解析和运行，然后再与原生平台通信，从而有一定的性能损耗。</p>\n</li>\n<li data-nodeid="983">\n<p data-nodeid="984">为了解决上述问题，Flutter 进一步优化了这种体验。Flutter 不借助原生的渲染能力，而是自己实现了一套与 Android 和 iOS 一样的渲染原理，从而在性能上与原生平台保持基本一致。不过这里由于目前 Flutter 只是一个 UI 框架，因此在原生功能方面还是需要依赖原生平台，这也是它存在的一些问题。</p>\n</li>\n</ul>\n<h3 data-nodeid="985">渲染原理</h3>\n<p data-nodeid="986">在了解了 Flutter 渲染原理的特殊性后，我们再具体看下整个绘制流程是如何实现的。上一课时我介绍了三棵树的转化过程，那么接下来就需要进一步去分析如何将三棵树渲染为 UI 交互界面。在介绍下转化的三棵树怎么绘制成 UI 交互界面之前，我们先来了解 vsync 这个概念。</p>\n<h4 data-nodeid="987">vsync</h4>\n<p data-nodeid="2155" class="">从图 1 中我们看到视频控制器，会从帧缓存器中获取需要显示的帧数据，并展示在显示器上。显示器有一个刷新频率（比如 60 Hz 或者 120 Hz），代表的意思是显示器会每秒钟获取 60 帧的数据，也就是每隔 1000 ms / 60 = 16.67 ms 从视频控制器中定时获取帧数据。这个就是我们常说的一个概念“<strong data-nodeid="2161">垂直同步信号”（vsync）</strong>。</p>\n\n\n\n<p data-nodeid="989">Flutter 的自渲染模式也遵循这个原则，因此在Flutter的性能要求上，必须是 UI线程处理时间加上 GPU 绘制时间小于 16.67 ms 才不会出现掉帧现象。掌握了这个 vysnc 概念后，我们再来看看 Flutter 内部逻辑是如何实现的。</p>\n<h4 data-nodeid="990">渲染流程</h4>\n<p data-nodeid="991">整个绘制过程所涉及的核心函数流程，如图 3 所示。</p>\n<p data-nodeid="992"><img src="https://s0.lgstatic.com/i/image/M00/46/C2/Ciqc1F9GHHWARkxZAAJL5Wf7xQQ911.png" alt="Drawing 3.png" data-nodeid="1096"></p>\n<div data-nodeid="993"><p style="text-align:center">图3 绘制整体流程图</p></div>\n<p data-nodeid="994">在图 3 的流程中会涉及几个比较重要的函数分别是 scheduleWarmUpFrame 、handleDrawFrame、drawFrame 、flushLayout 、 flushCompositingBits 、 markNeedsPaint 、 flushPaint 、 compositeFrame 和 flushSemantics。接下来我们就先来看下这些函数的作用。</p>\n<h4 data-nodeid="995">重要函数</h4>\n<ul data-nodeid="996">\n<li data-nodeid="997">\n<p data-nodeid="998"><strong data-nodeid="1103">scheduleWarmUpFrame</strong>，这个函数的核心是调用 handleBeginFrame和 handleDrawFrame 两个方法。</p>\n</li>\n<li data-nodeid="999">\n<p data-nodeid="1000"><strong data-nodeid="1114">handleDrawFrame</strong>，主要是执行_persistentCallbacks这个回调函数列表，_persistentCallbacks 中存放了很多执行函数，其中存放了最重要的一个函数 RenderBing 的 drawFrame ，该方法主要是通过 WidgetsFlutterBinding 绑定阶段存放在 _persistentCallbacks 中。</p>\n</li>\n<li data-nodeid="1001">\n<p data-nodeid="1002"><strong data-nodeid="1119">drawFrame</strong>，在函数中主要执行界面的绘制工作，依次会执行 flushLayout 、 flushCompositingBits、 flushPaint 、 compositeFrame 和 flushSemantics 函数。</p>\n</li>\n<li data-nodeid="1003">\n<p data-nodeid="1004"><strong data-nodeid="1126">flushLayout</strong>，更新了所有被标记为“dirty”的 RenderObject 的布局信息。主要的动作发生在 node._layoutWithoutResize() 方法中，该方法中会调用 performLayout() 进行重新布局计算，请注意这里的 performLayout 会根据不同类型的 RenderObject 调用不同的 performLayout 布局方法。该方法还会调用 markNeedsPaint 标记需要重新绘制的RenderObject，源码如下：</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="1005"><code data-language="dart"><span class="hljs-keyword">while</span> (_nodesNeedingLayout.isNotEmpty) {\n  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;\n  _nodesNeedingLayout = &lt;RenderObject&gt;[];\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> RenderObject node <span class="hljs-keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) {\n    <span class="hljs-keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="hljs-keyword">this</span>)\n      node._layoutWithoutResize();\n  }\n}\n</code></pre>\n<ul data-nodeid="1006">\n<li data-nodeid="1007">\n<p data-nodeid="1008"><strong data-nodeid="1133">flushCompositingBits</strong>，主要是循环检查 RenderObject 以及子节点是否需要新建图层，如果需要则 _needsCompositing 属性标记为 true，其次会循环判断父节点，如果父节点需要新的图层，则该标记位也需要设置为 true，如果图层发生了变化，最终也会调用 markNeedsPaint 来进行重新绘制操作，部分源码如下：</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="1009"><code data-language="dart">visitChildren((RenderObject child) {\n  child._updateCompositingBits();\n  <span class="hljs-keyword">if</span> (child.needsCompositing)\n    _needsCompositing = <span class="hljs-keyword">true</span>;\n});\n<span class="hljs-keyword">if</span> (isRepaintBoundary || alwaysNeedsCompositing)\n  _needsCompositing = <span class="hljs-keyword">true</span>;\n<span class="hljs-keyword">if</span> (oldNeedsCompositing != _needsCompositing)\n  markNeedsPaint();\n</code></pre>\n<ul data-nodeid="1010">\n<li data-nodeid="1011">\n<p data-nodeid="1012"><strong data-nodeid="1138">markNeedsPaint</strong>，这个方法和 Element 中的 markNeedsBuild 相似，由于当前节点需要重新绘制，因此会循环在父节点上，寻找最近一个 isRepaintBoundary 类型，然后进行绘制，如果父节点一直往上没有找到，则只能绘制当前节点。</p>\n</li>\n<li data-nodeid="1013">\n<p data-nodeid="1014"><strong data-nodeid="1149">flushPaint</strong>，循环判断需要更新重绘的 RenderObject 节点，并调用 PaintingContext.repaintCompositedChild 进行重新绘制操作。在repaintCompositedChild中会调用paint 方法，这个方法有点类似 Element 的 update 方法，它会根据不同类型的 RenderObject 调用不同的 paint 方法，比如 custom_paint.dart 又或者 sliver_persistent_header.dart 都实现了自身的 paint 方法，在具体 paint 方法中会调用 canvas api 完成绘制，并递归判断子节点类型，调用不同的 paint 方法完成最终绘制工作，最终生成一棵 Layer Tree，并把绘制指令保存在 Layer 中。</p>\n</li>\n</ul>\n<pre class="lang-dart" data-nodeid="1015"><code data-language="dart"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> RenderObject node <span class="hljs-keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) {\n  <span class="hljs-keyword">assert</span>(node._layer != <span class="hljs-keyword">null</span>);\n  <span class="hljs-keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="hljs-keyword">this</span>) {\n    <span class="hljs-keyword">if</span> (node._layer.attached) {\n      PaintingContext.repaintCompositedChild(node);\n    } <span class="hljs-keyword">else</span> {\n      node._skippedPaintingOnLayer();\n    }\n  }\n}\n</code></pre>\n<ul data-nodeid="1016">\n<li data-nodeid="1017">\n<p data-nodeid="1018"><strong data-nodeid="1154">compositeFrame</strong>，将 canvas 绘制好的 scene 信息，转化为二进制像素信息传递给到 GPU ，完成具体的界面渲染操作；</p>\n</li>\n<li data-nodeid="1019">\n<p data-nodeid="1020"><strong data-nodeid="1159">flushSemantics</strong>，将渲染对象的语意发送给操作系统，这与 Flutter 绘制流程关系不大。</p>\n</li>\n</ul>\n<p data-nodeid="1021">以上就是非常关键的几个核心函数的介绍，接下来我们看下具体的执行过程。</p>\n<h4 data-nodeid="1022">流程说明</h4>\n<p data-nodeid="1023">如下是各个过程中所执行的函数，如图 4 所示。</p>\n<p data-nodeid="1024"><img src="https://s0.lgstatic.com/i/image/M00/46/E5/CgqCHl9GQHCAKO25AAEzFRZSEzw956.png" alt="image (2).png" data-nodeid="1165"></p>\n<div data-nodeid="1025"><p style="text-align:center">图4 核心绘制流程执行过程</p></div>\n<p data-nodeid="1026">根据图 3 的整体流程，我们知道在绘制过程中涉及 4 个比较重要的函数，图 4 就分别说明了这四个函数在执行过程中所执行的具体逻辑。</p>\n<ul data-nodeid="1027">\n<li data-nodeid="1028">\n<p data-nodeid="1029">flushLayout，准备布局相关的处理工作，这里会判断是否需要重新布局，调用 performLayout。由于不同基础组件布局相关实现不一样，因此这里会根据不同组件类型调用不同的 performLayout 从而完成布局相关的准备工作。在 performLayout 处理逻辑的最后，还会调用 markNeedsPaint 来标记需要重新绘制的 RenderObject。在 performLayout 中还会执行 markNeedsLayout 用来标记哪些需要进行重新布局，这个会在具体 layout 函数中使用到。</p>\n</li>\n<li data-nodeid="1030">\n<p data-nodeid="1031">flushCompositingBits，准备图层的相关处理逻辑，同样将需要重新绘制的 RenderObject 调用 markNeedsPaint 来标记。</p>\n</li>\n<li data-nodeid="1032">\n<p data-nodeid="1033">flushPaint，将需要进行重新绘制的 RenderObject 调用 paint 方法转化为 Layer tree，这里的 paint 中也会根据 RenderObject 类型不同，调用不同的paint方法，最终再调用 canvas 实现界面绘制。</p>\n</li>\n<li data-nodeid="1034">\n<p data-nodeid="1035">compositeFrame，根据 canvas绘制好的 Layertree，调用 layer.buildScene 方法将 Layertree 转化为 scene 信息，最终再调用 window 的 render 方法，将界面显示给用户。</p>\n</li>\n</ul>\n<p data-nodeid="1036">以上就是绘制的流程说明，基于上述的执行过程，我们再来详细分析下，在编码过程中哪些环节，可以提升性能体验。</p>\n<h3 data-nodeid="1037">性能优化方向</h3>\n<p data-nodeid="1038">以上过程中有两个是比较关键的流程，一个是布局，另外一个是绘制。布局过程中会根据 markNeedsLayout函数执行结果来判断是否需要重新布局，另外一个则是根据 markNeedsPaint 结果来判断是否需要重新绘制。那么在这两个函数中，我们平时编码到底应该要注意哪些细节呢？</p>\n<h4 data-nodeid="1039">markNeedsPaint</h4>\n<p data-nodeid="1040">在图 4 过程中的 markNeedsPaint 是一个非常关键的点，这个标记将直接影响到最终的绘制函数 flushPaint 的执行性能，我们来拆解一步步看这个函数：</p>\n<pre class="lang-dart" data-nodeid="1041"><code data-language="dart"><span class="hljs-keyword">void</span> markNeedsPaint() {\n  <span class="hljs-keyword">assert</span>(owner == <span class="hljs-keyword">null</span> || !owner.debugDoingPaint);\n  <span class="hljs-keyword">if</span> (_needsPaint)\n    <span class="hljs-keyword">return</span>;\n  _needsPaint = <span class="hljs-keyword">true</span>;\n  <span class="hljs-comment">/// <span class="markdown">...更多代码</span></span>\n}\n</code></pre>\n<p data-nodeid="1042">首先判断是否已经标记了 _needsPaint 为 true，如果标记了则直接退出。</p>\n<pre class="lang-dart" data-nodeid="1043"><code data-language="dart">_needsPaint = <span class="hljs-keyword">true</span>;\n<span class="hljs-keyword">if</span> (isRepaintBoundary) {\n  <span class="hljs-keyword">assert</span>(() {\n    <span class="hljs-keyword">if</span> (debugPrintMarkNeedsPaintStacks)\n      debugPrintStack(label: <span class="hljs-string">\'markNeedsPaint() called for <span class="hljs-subst">$this</span>\'</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n  }());\n  <span class="hljs-comment">// If we always have our own layer, then we can just repaint</span>\n  <span class="hljs-comment">// ourselves without involving any other nodes.</span>\n  <span class="hljs-keyword">assert</span>(_layer <span class="hljs-keyword">is</span> OffsetLayer);\n  <span class="hljs-keyword">if</span> (owner != <span class="hljs-keyword">null</span>) {\n    owner._nodesNeedingPaint.add(<span class="hljs-keyword">this</span>);\n    owner.requestVisualUpdate();\n  }\n}\n</code></pre>\n<p data-nodeid="1044">将该 RenderObject 的 _needsPaint 标记为 true，然后判断是否为 isRepaintBoundary ，那什么是 isRepaintBoundary 呢？</p>\n<p data-nodeid="1045">在 Flutter 中有一个这样的组件 RepaintBoundary ，该组件自带 isRepaintBoundary 属性为 true ，你可以将其他组件使用 RepaintBoundary 来包裹。这个组件代表的是将组件作为一个独立的渲染模块。在上面代码中，如果当前是 isRepaintBoundary 则将当前 RenderObject添加到 nodesNeedingPaint 然后返回即可。</p>\n<pre class="lang-dart" data-nodeid="1046"><code data-language="dart"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">is</span> RenderObject) {\n  <span class="hljs-keyword">final</span> RenderObject parent = <span class="hljs-keyword">this</span>.parent <span class="hljs-keyword">as</span> RenderObject;\n  parent.markNeedsPaint();\n  <span class="hljs-keyword">assert</span>(parent == <span class="hljs-keyword">this</span>.parent);\n}\n</code></pre>\n<p data-nodeid="1047">如果当前不是 isRepaintBoundary ，则需要往父节点层层寻找，也层层标记 _needsPaint ，导致当前节点上的所有父节点都需要进行 _needsPaint 操作。</p>\n<p data-nodeid="1048">因此这里有一点编码性能考量的点，我们可以将那些频繁需要重绘的组件使用 RepaintBoundary 进行封装，减少当前节点的绘制引发的父节点的重绘操作。在 Flutter 中的大部分基础组件都是使用了 RepaintBoundary 进行包裹的，因此如果你单纯修改某部分组件时是不会引起到父组件的重绘，从而影响性能体验。</p>\n<h4 data-nodeid="1049">markNeedsLayout</h4>\n<p data-nodeid="1050">markNeedsLayout 主要是用来标记是否需要重新布局的，里面的逻辑和 markNeedsPaint 非常相似。同样也是存在性能提升的空间，当对一个组件需要频繁的进行布局调整时，比如需要频繁增删元素的组件，需要频繁调整大小的组件，使用 RelayoutBoundary 来封装将会有一定的性能提升空间。</p>\n<p data-nodeid="1051">如果是自己在写一个基础组件的时候，就要非常注意这点，对于一些频繁改动的点，或者需要频繁进行布局修改的组件，使用 RepaintBoundary 和 RelayoutBoundary进行封装。其次你在性能分析的时候，特别要留意这两个关键的点，当性能出现问题时，可以尝试从这两个点出发去寻找。</p>\n<h3 data-nodeid="1052">总结</h3>\n<p data-nodeid="1053">本课时从操作系统的渲染原理，分析了 Flutter 在性能体验上，为什么优于其他跨端技术框架的。接下来着重介绍了 Flutter核心渲染原理，并从渲染原理中分析后续在编码过程中需要注意的性能优化方向。学完本课时后，你需要掌握 Flutter 渲染核心流程，并且掌握在编码过程中着重注意 RepaintBoundary 和 RelayoutBoundary的使用。</p>\n<p data-nodeid="1054" class=""><a href="https://github.com/love-flutter/flutter-column" data-nodeid="1196">点击此链接查看本课时源码</a></p>',
          },
        ],
      },
      {
        sectionName: '结束语',
        sectionId: 4,
        courseList: [
          {
            theme: '结束语 | 对技术的发展要有所远见',
            id: 326,
            content:
              '<p data-nodeid="195132">看到这里，恭喜你学完了本专栏的全部内容。最后的结束语，我打算跟你聊聊我自己。</p>\n\n\n<p data-nodeid="195029">我自身是一个前端研发人员，经历了前端技术的各种更新换代，从最初的手写纯 JavaScript，再到 Jquery，后来由于 Node.js 的出现，各种前端工程化的方案应运而生，再发展到现在比较成熟的 Vue 和 React 两个前端技术框架。你有没有发现如果我在短短的 1-2 年没跟上时代的步伐，那么我很可能被前端技术所抛弃了。</p>\n<p data-nodeid="195030">或许你可能不会体会到兼容 IE 和 非 IE 浏览器是多么的痛苦，特别是在 PC 端。你现在可能不需要再考虑关于兼容 IE 的问题，因为现在可以轻松地解决。然而你回到那个年代，你应该是可以猜测到会有这么一天，但是不知道具体是哪一天。</p>\n<p data-nodeid="195031">同样现在终端设备千奇百态，对于一家公司而言，会涉及多种人才的招聘，每一种人才又需要各种不同的管理岗位，可能你只需要一个可以在多终端上线的版本，但是你可能需要 N * 终端类型 * 1.x 的人力来支持。那么这个问题就真的解决不了吗？我相信随着技术的发展，这个问题一定可以得到解决的，或许那个时间节点还没到来，抑或是我们还没有更好的解决方案。这就是我想告诉你的一点，作为前端研发人员，<strong data-nodeid="195051">在前端技术的发展一定要有所远见，要明白在什么时间节点，我应该去学习或者掌握什么技术知识。</strong></p>\n<p data-nodeid="195032">我毕业 8 年之久了，像上面所说，作为一个前端技术人员，我需要对技术的发展有所远见，因此我选择了大前端这个方向。那么在大前端方向上，当前为什么我会选择 Flutter 呢，可能不是我觉得它能解决这个一统大前端的问题，但是它确实是在这个发展过程中，起到了一个比较关键的进步作用。它可以算是一个时代的进步，更可能为后面大前端的统一发展，迈出了非常重要的一步，所以我选择了 Flutter ，因为我更希望去了解它，找到它的优点，并解决它的痛点。</p>\n<p data-nodeid="195033">在互联网这个圈子，你经常可以看到一些人在对撕，讨论这个替代那个，那个替代这个。我希望来学习我专栏的同学，尽量减少这种讨论。技术的出现一定是解决了一部分问题，并不是替代，比如说存储技术的发展，你会觉得谁替代了谁吗？又比如 Go 的出现，是否又有所替代？然而都没有，只是说给技术者提供更多选择。同样 Flutter 也是，虽然它只是一个 UI 技术框架，但是它却是一种进步。</p>\n<p data-nodeid="195034">所以我希望你能够好好学习 Flutter ，虽然在工作中，你可能暂时还不会应用，但还是希望你能够掌握它的技术原理和目标。就好比 Vue 和 React 的技术也不是一朝一夕，立马出现，而是经过了多种技术演变改良而出现的高级产物。</p>\n<h3 data-nodeid="195035">专栏体会</h3>\n<p data-nodeid="195036">本专栏是我结合我自己的学习方法和学习实践写出来的，其中会带着我个人的学习方法。专栏内容在技术层面，可能并不一定非常有深度，但它一定是可以带你完全掌握 Flutter 相关的研发技术知识点，也同样会让你了解 Flutter 在大前端发展上到底做出了哪些比较有质量的技术提升。其次我希望你可以学会怎么去学习一门新的技术，这也是我经常喜欢在面试过程中去询问别人的一点。因为从学习方法，可以明白一个人值不值得更深度的培养。</p>\n<p data-nodeid="195037">最后再安利一下，如果你目前是一个研发人员，请尝试说服团队，在小的功能或者应用上开始尝试 Flutter 技术；如果你是前端、终端团队的技术管理人员，请开始设计你的技术引入计划，慢慢地将一些功能转移到 Flutter 上；如果你是老板或者 CTO，请将 Flutter 作为一个半年计划下发到技术团队，让他们给出实践计划，并开始一些小的尝试，对比效果。</p>\n<p data-nodeid="195038">最后，我邀请你为本专栏课程进行结课评价，因为你的每一个观点都是我和拉勾教育最关注的点。<a href="https://wj.qq.com/s2/6901229/2773" data-nodeid="195061">点击链接，既可参与课程评价。</a></p>',
          },
        ],
      },
    ],
  },
};
