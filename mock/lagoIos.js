export default {
  'GET /api/react/courseList': {
    data: [
      {
        sectionName: '开篇词',
        sectionId: 0,
        courseList: [
          {
            theme: '开篇词 | iOS 架构与开发工程化，让你成为10(x)程序员',
            id: 0,
            content:
              '<p data-nodeid="1594" class="">你好，我叫林永坚，在澳洲互联网公司 REA Group 担任 Mobile Tech Lead 一职。作为技术负责人，我主要负责移动端的架构与研发，同时也负责移动团队的建设和推动公司的工程化实践。</p>\n<p data-nodeid="1595">在我所负责的 App 中， realestate.com.au App 是澳洲本土企业流量排名前几的 App，几乎每个在澳洲买房、卖房、租房的人都会使它。在 App Store 上，这款 App 的评分也一直保持在 4.7 星以上。要知道，在 2020 年澳洲排名前 20 的免费 App 只有 8 个能到达 4.7 星。</p>\n<p data-nodeid="1596">现在看这款 App 已经是一个非常成功的产品了，但其实在几年前，我们也面临着重重困境。</p>\n<h3 data-nodeid="1597">工程化实践的重要性</h3>\n<p data-nodeid="1598">那是五六年前，我刚加入 REA Group 公司，当时我们的 App 版本发布周期长达 8 个月到一年。</p>\n<p data-nodeid="1599">为什么会这么长呢？因为我们没有好的开发流程和工程化标准。</p>\n<p data-nodeid="1600">举例来说，仅仅在准备发布阶段，由于没有代码管理规范，也缺乏自动化工具的支持，我们都需要专门停止手头工作，用一两个月的时间来准备。比如合并代码，需要手工操作，要花 2周 ~ 4 周；部署测试也是手动，需要 1 周时间；最后再进行回归测试，又要 2 周 ~ 3 周。</p>\n<p data-nodeid="1601">当时因为发布流程十分复杂，人工操作繁重还容易出错，有的同事为了逃避麻烦甚至请了病假。</p>\n<p data-nodeid="1602">虽然我们花那么长时间来准备，但 App 在 App Store 上的评分只有 2.5 星。主要原因是用户体验非常不好，经常崩溃，差不多每 5 个中就有一个用户的 App 会闪退。</p>\n<p data-nodeid="1603">为什么会这样？</p>\n<p data-nodeid="1604">其中一个原因就是没有<strong data-nodeid="1667">统一的代码管理流程</strong>，开发者想要 Push 什么风格的代码都可以。比如，当时就有一名开发者为了学习 Core Data，在一个周末期间把学习的 Core Data 的代码直接 push 到了主分支。</p>\n<p data-nodeid="1605">结果，他的这个 Push 操作让 App 的崩溃率上涨了 10%。事后虽然我们想要补救，但因为这部分代码没有任何架构设计，花了两三年才逐渐把相关代码移除完毕！</p>\n<p data-nodeid="1606">另一个原因就是，代码没有<strong data-nodeid="1674">统一而灵活的系统架构设计与开发模式</strong>。就像前面的那次事故，之所以要花两三年才移除干净，就是因为缺乏面向接口的编码模式，Core Data 的数据对象污染了整个代码库。同时，又因为 App 缺乏分层的架构设计，导致所有逻辑都编写在臃肿的 View Controller 里，单元测试覆盖率几乎为零。可以说，代码库进入几乎没法维护的状态，很多崩溃情况无法修复。</p>\n<p data-nodeid="1607">为了避免同类的事情再次发生，也为了提高效率，我们开始了漫长而十分崎岖的工程化实践之路。最终，App 的崩溃率从 20% 以上下降到 0.01% 以下，App Store 的评分也从 2.5 拉升到 4.7 星。</p>\n<h3 data-nodeid="1608">为什么有这门课程？</h3>\n<p data-nodeid="1609">虽然我们下定决心改变现状，但在开始实施工程化实践的时候还是面临许多困难。</p>\n<p data-nodeid="1610">当时我们想要规范代码管理流程，提高开发、迭代、打包和发布效率，不再纯手动操作，但实际做下来事情千头万绪，既没有明确的工程化目标和方向，市面也没有相关的资料可供参考，只能通过不断试错来推进。</p>\n<p data-nodeid="1611">而且，既然是要进行 iOS 工程化开发，就需要工具支持。但当时不仅相关的工程化、自动化工具稀少，苹果公司所提供的工具链也非常不友好，市面上的 CI（Continuous Integration，持续集成）工具并不支持脚本化和版本管理，很多时候需要人手操作来搭建，且每次 MacOS 或者 Xcode 更新，都需要重新搭建。</p>\n<p data-nodeid="1612">如今四五年过去了， 适用于 iOS 开发的 Swift 语言逐渐成熟，可重用组件的编写以及可扩展架构的设计变得越来越方便；而苹果公司的工具链，特别是支持自动化和工程化的开源工具和在线服务（如 Fastlane、 TravisCI ）也越来越丰富。</p>\n<p data-nodeid="1613">此外，像 GitHub 、GitLab 等代码管理平台的出现，也使我们的开发流程更容易统一和规范。</p>\n<p data-nodeid="1614">但我发现，<strong data-nodeid="1687">还有些 iOS 开发者并没有意识到技术的变化，仍在用纯手工的形式开发和发布 App</strong>。</p>\n<p data-nodeid="1615">另外，虽然过去了很长时间，但市面上有关 iOS 开发的工程化实践资料仍然很少，有的只是介绍如何使用系统 API 来开发一款 iOS App，还有的是介绍各种自动化和工程化工具的使用，并没有连贯起来形成体系。</p>\n<p data-nodeid="1616">为了让你不再像我以前那样一直掉坑填坑，也为了帮助更多的开发者，我结合多年的工程化实践经验，做了这样一门课程。我希望以一个类似朋友圈的 App 为案例，来向你介绍如何在架构和开发 App 的时候进行工程化实践，降低开发门槛和维护成本，同时还能快速迭代与发布。</p>\n<p data-nodeid="1617">之所以选择以<strong data-nodeid="1695">一个开发类似朋友圈的 App 为案例</strong>，是因为该 App 的架构非常通用，它包含了网络访问、 JSON 数据解析、数据存储，以及响应式数据流处理等功能模块。通过它，我们可以把这一套架构应用到各种场景中，例如电商类 App、生活类的房产App、卖车 App，以及社交类短视频 App，等等。</p>\n<h3 data-nodeid="1618">课程设计与收获</h3>\n<p data-nodeid="1619">根据实际项目开发流程，我把本课程分为五大部分。</p>\n<p data-nodeid="1620"><strong data-nodeid="1701">第一部分：配置与规范</strong></p>\n<p data-nodeid="1621">在这部分，我主要介绍如何定义和配置一套统一的规范，具体包括：搭建统一的开发环境，使用 CocoaPods 统一管理第三方的依赖库，统一 Project 和 Target 的配置，使用 Swiftlint 统一编码规范，以及使用 Git 和 GitHub 来规范源代码管理流程。</p>\n<p data-nodeid="1622">我希望通过这部分的学习，能让你在开发所有的 iOS 项目时更规范。如果你的团队有新成员，它也可以帮助你更好地让新成员接手项目，同时也可以极大减轻团队成员之间的沟通成本。</p>\n<p data-nodeid="1623"><strong data-nodeid="1707">第二部分：基础组件设计</strong></p>\n<p data-nodeid="1624">因为基础组件能够帮助功能模块之间解藕，提高可重用性，还能支撑业务功能的快速开发。所以，我将会介绍如何使用极少的工作量来构建一些非常实用的基础组件。这些组件包括：设计规范组件、路由组件、多语言支持组件、动态字体和深色模式的支持组件。除此之外， 我还会介绍如何使用隐藏功能菜单来分离生产环境与研发环境。</p>\n<p data-nodeid="1625"><strong data-nodeid="1712">第三部分：架构与实现</strong></p>\n<p data-nodeid="1626">随着 iOS 和 Android 成为移动端的两大霸主，为了兼顾两者，有些公司使用 React Native 或者 Fluter 等非官方方案。而我们则致力于使用官方平台所提供的原生技术，通过一套架构设计，使得开发者可以很方便地在 iOS 和 Android 之间进行业务代码的开发。</p>\n<p data-nodeid="1627">在这一部分，我会为你详细介绍如何使用 BFF 和 MVVM 来设计一套跨平台的架构。</p>\n<p data-nodeid="1628">具体来说，我会详细介绍这套框架中的 iOS 的部分，包括 MVVM 模式中每一层的功能、责任，以及具体的代码实现。同时我还会演示如何通过 TDD 方法来对 MVVM 中每一个功能模块进行单元测试，从而提高代码的质量和有效地降低 App 的崩溃率。</p>\n<p data-nodeid="1629">通过这部分的介绍，我希望你能学会如何<strong data-nodeid="1721">从零开始设计一个符合你团队具体情况的 App</strong>，同时也可以尝试在原有的 App 里面，循序渐进地引入 MVVM 架构来提高代码的灵活性、扩展性和可维护性。</p>\n<p data-nodeid="1630"><strong data-nodeid="1725">第四部分：上架与优化</strong></p>\n<p data-nodeid="1631">在这部分我会介绍自动化上架以及上线后优化的一些技巧。比如，如何统一管理证书与描述文件，如何快速交付，如何灵活支持统计分析，如何借助崩溃报告解决线上的 Bug，如何设置远程开关，如何进行A/B 测试，等等。</p>\n<p data-nodeid="1632">我希望你可以在这部分<strong data-nodeid="1732">学会搭建一套自动化的流程</strong>，来实现无人操作打包、签名、分发与上架，有效提升 App 的交付速度。</p>\n<p data-nodeid="1633"><strong data-nodeid="1736">第五部分：加餐</strong></p>\n<p data-nodeid="1634">缺乏架构设计的 App 都会遇到一些问题，每当一个新的功能，或者更好的技术栈出现后，想要引进来会带来很多麻烦。</p>\n<p data-nodeid="1635">比如想支持动态字体或者深色模式，由于最初开发时没有考虑到，后来想要加进这些功能时就变得十分麻烦，几乎需要修改整个 App。所以架构设计的可扩展性、灵活性对产品不断迭代尤为重要。</p>\n<p data-nodeid="1636">为了测试架构的灵活性，我就做了一个大胆设想，在不改动任何原有代码的基础上把 UI 层从 UIKit 替换成苹果公司最新的 UI 框架 SwiftUI（下面是 SwiftUI 的实现效果）。在专栏中，我会详细告诉你我是一步步怎么做的。</p>\n<p data-nodeid="1637"><img src="https://s0.lgstatic.com/i/image6/M00/0A/95/CioPOWA3b1CAHmUvAJGsb5PxzYc810.gif" alt="Moments.gif" data-nodeid="1742"></p>\n<h3 data-nodeid="1638">讲师寄语</h3>\n<p data-nodeid="1639">如果你已经在 iOS 开发上有 2~3 年的经验，能读懂系统 API 和使用三方库开发绝大部分的功能，想要自己从头到尾架构设计一个 App；如果你平常需要花很长时间做大量的重复劳动，例如管理证书、打包、签名、部署测试设备和上架，迫切想从中解放出来；如果你想提升自己，彰显技术实力，帮助团队规范开发流程，甚至成为团队的技术负责人……</p>\n<p data-nodeid="1640">那么，这门课非常适合你。</p>\n<p data-nodeid="1641">通过它，你可以掌握一套工程级的 iOS 开发流程。它能让你编写出更高效、易读，易于维护和扩展的代码，同时还能减少大量重复劳动，提高技术工作效率，助你以一当十，成为<strong data-nodeid="1752">10x 程序员。</strong></p>\n<p data-nodeid="1642">在学习上有一个 721 法则，说的是，一个人的能力习得，70%来自实践，20%来自他人，10%来自培训学习。我希望通过这次实战课程，能让你更上一层楼。</p>\n<p data-nodeid="1643"><img src="https://s0.lgstatic.com/i/image6/M00/0A/32/Cgp9HWA3DfqAS68IAAUsVkFwlpM721.png" alt="ios 金句.png" data-nodeid="1756"></p>\n<hr data-nodeid="1644">\n<p data-nodeid="1645"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1761"><img src="https://s0.lgstatic.com/i/image6/M00/08/77/Cgp9HWA0wqWAI70NAAdqMM6w3z0673.png" alt="Drawing 1.png" data-nodeid="1760"></a></p>\n<p data-nodeid="1646"><strong data-nodeid="1765">《大前端高薪训练营》</strong></p>\n<p data-nodeid="1647" class="te-preview-highlight">12 个月打磨，6 个月训练，优秀学员大厂内推，<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1769">点击报名，高薪有你</a>！</p>',
          },
        ],
      },
      {
        sectionName: '模块一：配置与规范',
        sectionId: 1,
        courseList: [
          {
            theme: '01 | 开发环境：如何使用 Ruby 工具链统一开发环境？',
            id: 10,
            content:
              '<p data-nodeid="849" class="">在 iOS 开发过程中，你是不是会经常遇到这些情况：</p>\n<p data-nodeid="850">每次打开一个新项目，都需要手动搭建开发环境；有时候在安装第三方工具时使用到 sudo 权限，导致以后安装工具都需要手工输入密码而无法实施自动化。还有，每当启动一台新 CI 时，就需要手工登录并配置一遍，更可怕的是，原先搭建好的 CI 会随着 Xcode 版本更新需要重新配置。</p>\n<p data-nodeid="851">为什么会这么麻烦呢？就是因为你在项目开始之初没有做好统一配置。</p>\n<p data-nodeid="852">所谓统一配置，就是所有的配置信息都以文本的格式存放在 Git 里面，我们可以随时查看修改记录，以此来帮助我们比较不同配置之间的差异性，然后在这个基础上不断更新迭代。</p>\n<p data-nodeid="853">可以说，有了统一配置，任何工程师都可以搭建出一模一样的开发环境，构建出功能一致的 App；有了统一配置，还可以让我们按需延展 CI 服务，而不用任何手工操作。更重要的是，它还可以应用到各个类似的 iOS 项目中，极大地减轻了项目前期的搭建成本。</p>\n<p data-nodeid="854">既然统一的配置那么重要，那么我们怎样搭建统一配置的开发环境呢？</p>\n<h3 data-nodeid="855">Ruby 工具链</h3>\n<p data-nodeid="856">我们可以通过 Ruby 工具链为整个项目搭建一致的开发和构建环境。为什么选择 Ruby 而不是其他语言环境呢？因为在 iOS 开发方面，目前流行的第三方工具 CocoaPods 和 fastlane 都是使用 Ruby 来开发的。特别是 Ruby 有非常成熟的依赖库管理工具 RubyGems 和 Bundler，其中 Bundler 可以帮我们有效地管理 CocoaPods 和 fastlane 的版本。</p>\n<p data-nodeid="857">下面一起来看看怎样搭建一个统一的开发环境吧。</p>\n<p data-nodeid="858"><img src="https://s0.lgstatic.com/i/image6/M01/0A/3D/Cgp9HWA3F9SAPGu_AALEFvdRBzw539.png" alt="图片2.png" data-nodeid="924"></p>\n<div data-nodeid="859"><p style="text-align:center">开发环境统一配置图</p></div>\n<p data-nodeid="860">通常，统一的开发环境应该从操作系统开始。对于 iOS 开发来说，<strong data-nodeid="930">MacOS</strong> 是目前 iOS 开发唯一支持的操作系统。在公司，MacOS 的版本一般由 IT 部门统一管理和更新。要注意，当公司统一更新了我们开发环境的 MacOS 版本以后，需要同时更新 CI 上 MacOS 的版本，以保持一致。</p>\n<h4 data-nodeid="861">Xcode</h4>\n<p data-nodeid="862">位于 MacOS 上层的是 Xcode 和 rbenv。其中，<strong data-nodeid="937">Xcode</strong> 是 iOS 开发和构建工具，在同一个项目里，最好使用同一个版本的 Xcode 进行开发和构建，我们可以在项目的 README.md 文件标注 Xcode 的版本。</p>\n<p data-nodeid="863">像我们将要开发的这款类似朋友圈的 Moments App 项目，我就在对应的 README.md 文件里标明了需要使用 Xcode Version 12.2 (12B45b)。具体内容你也可以在<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/README.md" data-nodeid="941">代码仓库</a>找到。</p>\n<p data-nodeid="864"><img src="https://s0.lgstatic.com/i/image6/M01/0A/3D/Cgp9HWA3GA-AYvZfAAND2HpeMGs775.png" alt="图片3.png" data-nodeid="945"></p>\n<p data-nodeid="865">那我们怎样才能保证每个人都安装同一个版本号的 Xcode 呢？技巧就是我们不要到有自动更新功能的 Mac App Store 中下载 Xcode，而是到<a href="https://developer.apple.com/download/more/" data-nodeid="949">苹果的开发者网站</a>搜索并下载。</p>\n<p data-nodeid="866"><img src="https://s0.lgstatic.com/i/image6/M00/0A/39/CioPOWA3F5OAUokNAARwNdiYhbs294.png" alt="图片1.png" data-nodeid="953"></p>\n<p data-nodeid="867">有时候我们会同时开发多个项目，这样有可能要安装多个不同版本的 Xcode。如果你的机器有多于一个版本的 Xcode，此时需要特别注意，为了保证所使用的编译器版本一致，在每次执行自动化命令之前（如执行<code data-backticks="1" data-nodeid="955">bundle exec fastlane test</code>），要先使用<code data-backticks="1" data-nodeid="957">xcode-select -s</code>来选择该项目所对应版本的 Xcode。</p>\n<p data-nodeid="868">比如说我的电脑上有多个 Xcode 版本，在开发 Moments App 时，每次执行自动化命令之前都会执行这样一条命令<code data-backticks="1" data-nodeid="960">xcode-select -s /Applications/Xcode12.2.app/Contents/Developer</code>来选择 Moments App 项目所使用的 Xcode。这里的<code data-backticks="1" data-nodeid="962">Xcode12.2.app</code>就是我安装的 Xcode 12.2 版所在的位置。</p>\n<h4 data-nodeid="869">rbenv</h4>\n<p data-nodeid="870">有了版本一致的 Xcode 以后，因为后期我们会用到 CocoaPods 等第三方 Ruby 工具，为了自动化安装和管理这些工具，整个项目团队所使用的 Ruby 版本也必须保持一致。为此，我们就需要用到 Ruby 环境管理工具。</p>\n<p data-nodeid="871">目前流行的 Ruby 环境管理工具有 RVM 和 rbenv。我推荐使用的是 rbenv，因为它使用 shims 文件夹来分离各个 Ruby 版本，相对于 RVM 更加轻装而方便使用。千万注意，团队内部不要同时使用不同的 Ruby 环境管理工具，否则项目编译会出错。</p>\n<p data-nodeid="872"><strong data-nodeid="971">rbenv</strong> 是 Ruby 环境管理工具，能够安装、管理、隔离以及在多个 Ruby 版本之间切换。要使用 rbenv，我们可以通过 Homebrew 来安装它，下面是安装 Homebrew 和 rbenv 的脚本。</p>\n<pre class="lang-java" data-nodeid="1699"><code data-language="java">$ /bin/bash -c <span class="hljs-string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"</span>\nbrew install rbenv ruby-build rbenv-vars\n</code></pre>\n<p data-nodeid="2600" class="">一旦安装 rbenv 完毕，我们需要把以下的设置信息放到你的 Shell 配置文件里面，例如 ~/.bash_profile 或者 ~/.zshrc 等文件，这样能保证每次打开终端的时候都会初始化 rbenv。</p>\n<pre class="lang-java te-preview-highlight" data-nodeid="9877"><code data-language="java">export PATH=<span class="hljs-string">"$HOME/.rbenv/bin:$PATH"</span> \neval <span class="hljs-string">"$(rbenv init -)"</span>\n</code></pre>\n\n\n\n<p data-nodeid="8553" class="">接着我们就可以安装和设置项目的 Ruby 环境了。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre class="lang-java" data-nodeid="875"><code data-language="java">$ cd $(PROJECT_DIR)\n$ rbenv install <span class="hljs-number">2.7</span><span class="hljs-number">.1</span>\n$ rbenv local <span class="hljs-number">2.7</span><span class="hljs-number">.1</span>\n</code></pre>\n<p data-nodeid="876">此处是把项目的 Ruby 环境配置为 2.7.1 版本。rbenv 会帮我们建立 一个叫作.<strong data-nodeid="982">ruby-version</strong> 的文件，该文件里面只保存一个版本号（例如<code data-backticks="1" data-nodeid="978">2.7.1</code>）的字符串。这个包含了版本号的文件可以用 Git 进行管理。如果要更新版本，可以通过<code data-backticks="1" data-nodeid="980">rbenv local</code>命令进行，每次更新也由 Git 统一管理，这样就能让其他开发者使用同一版本的 Ruby 开发环境了。</p>\n<h4 data-nodeid="877">RubyGems 和 Bundler</h4>\n<p data-nodeid="878">RubyGems 和 Bundler 主要是用来安装和管理 CocoaPods 和 fastlane 等第三方工具。</p>\n<p data-nodeid="879">具体来说，RubyGems&nbsp;是 Ruby 依赖包管理工具。在 Ruby 的世界，包叫作 Gem，我们可以通过<code data-backticks="1" data-nodeid="986">gem install</code>命令来安装。但是 RubyGems 在管理 Gem 版本的时候有些缺陷，就有人开发了 Bundler，用它来检查和安装 Gem 的特定版本，以此为 Ruby 项目提供一致性的环境。</p>\n<p data-nodeid="880">要安装 Bundler，我们可执行<code data-backticks="1" data-nodeid="989">gem install bundler</code>命令进行，之后，再执行<code data-backticks="1" data-nodeid="991">bundle init</code>就可以生成一个 Gemfile 文件，像 CocoaPods 和 fastlane 等依赖包，我们就可以添加到这个文件里面。</p>\n<p data-nodeid="881">具体代码如下：</p>\n<pre class="lang-java" data-nodeid="882"><code data-language="java">source <span class="hljs-string">"https://rubygems.org"</span>\ngem <span class="hljs-string">"cocoapods"</span>, <span class="hljs-string">"1.10.0"</span>\ngem <span class="hljs-string">"fastlane"</span>, <span class="hljs-string">"2.166.0"</span>\n</code></pre>\n<p data-nodeid="883">注意我们在<code data-backticks="1" data-nodeid="995">gem</code>命令里面都指定了依赖包的特定版本号。例如，在我们的 Moment App 就使用了<code data-backticks="1" data-nodeid="997">1.10.0</code>版的 CocoaPods，然后执行<code data-backticks="1" data-nodeid="999">bundle install</code>来安装各个 Gem。 Bundler 会自动生成一个 Gemfile.lock 文件来锁定所安装的 Gem 的版本，例如：</p>\n<pre class="lang-java" data-nodeid="884"><code data-language="java"><span class="hljs-function">DEPENDENCIES\n  <span class="hljs-title">cocoapods</span> <span class="hljs-params">(= <span class="hljs-number">1.10</span><span class="hljs-number">.0</span>)</span>\n  <span class="hljs-title">fastlane</span> <span class="hljs-params">(= <span class="hljs-number">2.166</span><span class="hljs-number">.0</span>)</span>\n</span></code></pre>\n<p data-nodeid="885">为了保证团队其他成员都可以使用版本号一致的 Gem，我们需要把 Gemfile 和 Gemfile.lock 一同保存到 Git 里面统一管理起来。</p>\n<p data-nodeid="886">到此为止，我们已经知道怎样使用 Ruby 工具链配置一个统一的开发环境。但在真实的开发环境中，搭建环境只需要一个人来完成即可，其他成员执行以下脚本就能完成整套开发环境的搭建。</p>\n<pre class="lang-java" data-nodeid="887"><code data-language="java">$ ./scripts/setup.sh\n</code></pre>\n<p data-nodeid="888">我们一起看看这个脚本做了些什么？</p>\n<pre class="lang-java" data-nodeid="889"><code data-language="java"># Install ruby using rbenv\nruby_version=`cat .ruby-version`\nif [[ ! -d "$HOME/.rbenv/versions/$ruby_version" ]]; then\n  rbenv install $ruby_version;\nfi\n# Install bunlder\ngem install bundler\n# Install all gems\nbundle install\n# Install all pods\nbundle exec pod install\n</code></pre>\n<p data-nodeid="890">该脚本主要做了四件事情，第一步是在 rbenv 下安装特定版本的 Ruby 开发环境，然后通过 RubyGems 安装 Bunlder，接着使用 Bundler 安装 CocoaPods 和 fastlane 等依赖包，最后安装各个 Pod。这样，一个统一的项目环境就搭建完成了，接下来开发者就可以打开 <strong data-nodeid="1009">Moments.xcworkspace</strong>进行开发了。</p>\n<p data-nodeid="891">说完 Ruby 环境搭建以后，最后我们一起聊聊保证项目文件一致性的 .gitignore 文件。</p>\n<h3 data-nodeid="892">.gitignore 文件</h3>\n<p data-nodeid="893">.gitignore 文件是一个配置文件，用来指定让 Git 需要忽略的文件或者目录。如果没有 .gitignore 文件，项目成员可能会不小心把一些自动生成等无关重要的文件或者具有个人信息(例如 xcuserdata)的文件保存到 Git 里面。这就大大增加了查看 Git 修改历史的难度。因此，在项目初期就配置一个合适的 .gitignore 文件，能减轻后续的管理工作。</p>\n<p data-nodeid="894">如何创建 .gitignore 文件呢？</p>\n<p data-nodeid="895">我一般会在 gitignore.io 里面输入关键字，例如 Xcode，Swift 等，然后该网站会帮我们生成一个默认的 .gitignore 文件。咱们项目 Moments App 的.gitignore 文件你可以到<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.gitignore" data-nodeid="1017">拉勾教育的仓库中</a>查看。</p>\n<p data-nodeid="896"><img src="https://s0.lgstatic.com/i/image6/M01/08/75/CioPOWA0xDCALL3FAABG42Ok7aU292.png" alt="Drawing 3.png" data-nodeid="1021"></p>\n<h3 data-nodeid="897">总结</h3>\n<p data-nodeid="898">以上，我们通过 Xcode、rbenv、RubyGems 和 Bundler 搭建一个统一的 iOS 开发和构建环境。</p>\n<p data-nodeid="899"><img src="https://s0.lgstatic.com/i/image6/M01/0A/39/CioPOWA3FsqAOn0YAAq1IyqbxEs043.png" alt="开发环境.png" data-nodeid="1026"></p>\n<p data-nodeid="900">再次强调下，为了让各个开发和构建环境能保持一致，我们要把 .ruby-version、 Gemfile 和 Gemfile.lock 文件通过 Git 统一管理起来，并共享给整个项目团队使用。</p>\n<p data-nodeid="901">而且，由于我们的开发环境已经通过 Bundler 管理起来，今后，当使用各个 Gem 工具的时候，也需要使用 Bundler。例如在使用 CocoaPods 时要执行<code data-backticks="1" data-nodeid="1029">bundle exec pod</code>，以保证我们使用的是项目级别而不是操作系统级别的 Gem 工具。</p>\n<p data-nodeid="902">思考题：</p>\n<blockquote data-nodeid="903">\n<p data-nodeid="904">请问如果我们不使用 rbenv ，那我们使用的 Ruby 来自哪里？使用 CocoaPods 等工具又来自哪里？不同项目能使用不同版本的 CocoaPods 吗？</p>\n</blockquote>\n<p data-nodeid="905">你可以把回答写到下面的留言区哦，下一讲我将介绍如何使用 CocoaPods 统一依赖库的管理。</p>\n<p data-nodeid="906">源码地址：</p>\n<blockquote data-nodeid="907">\n<p data-nodeid="908">README.md<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/README.md" data-nodeid="1039">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/README.md</a><br>\nMoments App 的.gitignore 文件<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.gitignore" data-nodeid="1045">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.gitignore</a></p>\n</blockquote>\n<hr data-nodeid="909">\n<p data-nodeid="910"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1050"><img src="https://s0.lgstatic.com/i/image6/M00/08/77/Cgp9HWA0wqWAI70NAAdqMM6w3z0673.png" alt="Drawing 1.png" data-nodeid="1049"></a></p>\n<p data-nodeid="911"><strong data-nodeid="1054">《大前端高薪训练营》</strong></p>\n<p data-nodeid="912" class="">12 个月打磨，6 个月训练，优秀学员大厂内推，<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="1058">点击报名，高薪有你</a>！</p>',
          },
          {
            theme: '02 | 依赖管理：如何使用 CocoaPods 统一依赖库的管理？',
            id: 11,
            content:
              '<p data-nodeid="1721" class="">在 iOS App 开发方面，几乎所有的 App 都需要使用到第三方依赖库。依赖库不仅能为我们提供丰富的功能，还能避免我们从头开发，在节省时间的同时也减少许多 Bug 。</p>\n<p data-nodeid="1722">但伴随着软件功能越来越丰富，依赖库数量越来越多，由此也出现了“依赖地狱”，比如依赖库循环依赖，底层依赖库版本冲突等。为了解决此类问题，于是，依赖库管理工具也就出现了。</p>\n<p data-nodeid="1723">目前流行的依赖库管理工具主要有：Git Submodules、Carthage、 Swift Package Manager 和 CocoaPods。在这里我们选择 CocoaPods。为什么呢？原因有三：</p>\n<ol data-nodeid="1724">\n<li data-nodeid="1725">\n<p data-nodeid="1726">CocoaPods 非常成熟，十分稳定，并且简单易用，学习成本低，效果明显；</p>\n</li>\n<li data-nodeid="1727">\n<p data-nodeid="1728">CocoaPods 会自动整合 Xcode 项目，使得其他项目成员在使用第三方库时无须任何额外的手工操作；</p>\n</li>\n<li data-nodeid="1729">\n<p data-nodeid="1730">CocoaPods 已经成为 iOS 业界标准，支持几乎所有的开源库和商业库，即便是 Objective-C 的依赖库以及二进制文件（binary）依赖库，CocoaPods 也提供支持。</p>\n</li>\n</ol>\n<p data-nodeid="1731">那么，怎样使用 CocoaPods 来管理第三方依赖库呢？接下来我会从语义化版本管理、Pod 版本管理、Pod 版本更新三个方面展开介绍。</p>\n<h3 data-nodeid="1732">语义化版本管理</h3>\n<p data-nodeid="1733">开发软件，免不了要更新迭代，所以每一次更新的版本号管理变得很重要。并且，一旦版本号混乱，就会导致一系列问题，比如很难查找和修改线上崩溃，没办法支持多团队并行开发，等等。为了避免此类问题，我们可以使用语义化版本管理（Semantic Versioning）来统一版本号的定义规范。</p>\n<p data-nodeid="1734">语义化版本号是一种通用的版本号格式规范，目前绝大部分优秀的第三方依赖库都遵循这一规范来发布版本。</p>\n<p data-nodeid="1735">具体来说，语义化版本号的版本号一般包括四部分：MAJOR、MINOR、PATCH、BUILD。每一部分都由递增的数值组成，例如 1.2.3.4，其中 1 是MAJOR， 2 是 MINOR。如果我们更新 MINOR 版本号，那么下一个版本就是 1.3.0.0。接下来我详细介绍下这四部分。</p>\n<ul data-nodeid="1736">\n<li data-nodeid="1737">\n<p data-nodeid="1738">MAJOR 是指主版本号，通常在重大更新的时候才会需要更新主版本号。例如 iOS 每年都会更新一个主版本号。而对于第三方库来说，主版本号的更新，表示该库的 API 新增了重大功能，或者引入了不可兼容的更新 （breaking changes）。</p>\n</li>\n<li data-nodeid="1739">\n<p data-nodeid="1740">MINOR 是指副版本号，用于小功能的改善。例如 iOS 14 在发布主版本后，在一年内可能发布多个副版本如 14.1、 14.2 来完善其系统功能。一般对于第三方库来说，副版本的更新就是新增一些 API，但不包含不可兼容的更新。</p>\n</li>\n<li data-nodeid="1741">\n<p data-nodeid="1742">PATCH 是指补丁版本号，一般用于 bug fix 以及修复安全性问题等。对于第三方库来说，补丁版本号的更新也不应该有不可兼容的更新。虽然实际操作中这会有些困难，但我们可以通过把原有 API 标记为 deprecated，或者为新 API 参数提供默认值等办法来解决。</p>\n</li>\n<li data-nodeid="1743">\n<p data-nodeid="1744">BUILD 是指构建版本号，通常在内部测试时使用。一般当我们使用 CI 服务器进行自动构建时，构建版本号会自动更新。</p>\n</li>\n</ul>\n<h3 data-nodeid="1745">Pod 版本管理</h3>\n<p data-nodeid="1746">要使用 CocoaPods 管理第三方依赖库，首先要新建一个 Podfile 文件，然后执行<code data-backticks="1" data-nodeid="1868">bundle exec pod install</code>命令来安装所有依赖库。这时候 CocoaPods 会自动帮我们建立一个 Podfile.lock 文件和一个 Workspace文档。</p>\n<p data-nodeid="1747">注意，在第一讲我们说过，由于是通过 Bundler 来安装 CocoaPods，每次执行<code data-backticks="1" data-nodeid="1871">pod</code>命令前，都需要加上<code data-backticks="1" data-nodeid="1873">bundle exec</code>。不过为了简洁，后面涉及<code data-backticks="1" data-nodeid="1875">pod</code>命令时，我会省略<code data-backticks="1" data-nodeid="1877">bundle exec</code>部分。</p>\n<p data-nodeid="1748">接下来，我详细介绍下 Podfile 文件、 Podfile.lock 和 Workspace 文档到底是什么，以及如何使用。</p>\n<h4 data-nodeid="1749">Podfile 文件</h4>\n<p data-nodeid="1750">Podfile 文件是一个配置文件，它主要是用来描述 Xcode 项目里各个 target 的依赖库。我们项目的 Podfile 文件可以在<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Podfile" data-nodeid="1884">仓库中</a>找到。在这里，我主要和你介绍一下 Podfile 文件中的几个重要配置。</p>\n<p data-nodeid="1751"><strong data-nodeid="1889">source 配置</strong></p>\n<p data-nodeid="1752"><code data-backticks="1" data-nodeid="1890">source</code>用于指向 PodSpec（Pod 规范）文件的 Repo，从而使得 CocoaPods 能查询到相应的 PodSpec 文件。</p>\n<p data-nodeid="1753">具体来说，当使用公共依赖库的时候，<code data-backticks="1" data-nodeid="1893">source</code>需要指向 CocoaPods Master Repo，这个主仓库集中存放所有公共依赖库的 PodSpec 文件。 由于 CocoaPods 经常被开发者吐槽 Pod 下载很慢，因此 CocoaPods 使用了 CDN （Content Delivery Network，内容分发网络）来缓存整个 CocoaPods Master Repo， 方便开发者快速下载。具体的配置方法就是使<code data-backticks="1" data-nodeid="1895">source</code>指向 CND 的地址，代码示例如下：</p>\n<pre class="lang-java" data-nodeid="1754"><code data-language="java">source <span class="hljs-string">\'https://cdn.cocoapods.org/\'</span>\n</code></pre>\n<p data-nodeid="1755">如果使用的是私有依赖库，我们也需要把<code data-backticks="1" data-nodeid="1898">source</code>指向私有库的 PodSpec Repo，以使得 CocoaPods 能找到相应的 PodSpec 文件。 代码示例如下：</p>\n<pre class="lang-java" data-nodeid="1756"><code data-language="java">source <span class="hljs-string">\'https://my-git-server.com/internal-podspecs\'</span>\n</code></pre>\n<p data-nodeid="1757">注意，当我们使用私有库时，执行<code data-backticks="1" data-nodeid="1901">pod install</code>命令的机器必须能访问到<code data-backticks="1" data-nodeid="1903">source</code>所指向的 Repo。</p>\n<p data-nodeid="1758"><strong data-nodeid="1908">project 和 workspace</strong></p>\n<p data-nodeid="1759"><code data-backticks="1" data-nodeid="1909">project</code>用于指定我们的主项目文档。该项目文档会使用到 CocoaPods 管理的所有第三方依赖库。</p>\n<p data-nodeid="1760"><code data-backticks="1" data-nodeid="1911">workspace</code>用于指定要生成和更新的 Workspace 文档。和其他依赖库管理工具不一样，CocoaPods 会自动生成一个 Workspace 文档，然后我们只能使用该文档而不是 Xcode 项目文档来进行后续开发。</p>\n<p data-nodeid="1761">代码示例如下：</p>\n<pre class="lang-java" data-nodeid="1762"><code data-language="java">project <span class="hljs-string">\'./Moments/Moments.xcodeproj\'</span>\nworkspace <span class="hljs-string">\'./Moments.xcworkspace\'</span>\n</code></pre>\n<p data-nodeid="1763">这其中 Moments.xcodeproj 就是我们的主项目文档，它一般放在和项目名字相同的下一层目录下。</p>\n<p data-nodeid="1764">而 Moments.xcworkspace 是 CocoaPods 为我们生成的 Workspace文档，为了统一，我建议名字也是和主项目相同。</p>\n<p data-nodeid="1765"><strong data-nodeid="1921">platform 和 use_frameworks</strong></p>\n<p data-nodeid="1766">先看示例，它表示什么呢？</p>\n<pre class="lang-java" data-nodeid="1767"><code data-language="java">platform :ios, <span class="hljs-string">\'14.0\'</span>\nuse_frameworks!\n</code></pre>\n<p data-nodeid="1768">为了保证所有依赖库与主项目在编译和运行时兼容，我们指定的系统版本号需要和主项目所支持的系统版本号保持一致。而<code data-backticks="1" data-nodeid="1924">platform</code>就是用于指定操作系统以及所支持系统的最低版本号。比如，例子中的<code data-backticks="1" data-nodeid="1926">platform :ios, \'14.0\'</code>就表示支持 iOS 14.0 以上的所有 iOS 版本。</p>\n<p data-nodeid="1769">另外一行的<code data-backticks="1" data-nodeid="1929">use_frameworks!</code>这一配置会让 CocoaPods 把所有第三方依赖库打包生成一个动态加载库，而不是静态库。因为动态库是我们经常用到的，它能有效地加快编译和链接的速度。</p>\n<p data-nodeid="1770"><strong data-nodeid="1934">组织同类型的第三方依赖库</strong></p>\n<pre class="lang-java" data-nodeid="1771"><code data-language="java">def dev_pods\n  pod <span class="hljs-string">\'SwiftLint\'</span>, <span class="hljs-string">\'0.40.3\'</span>, configurations: [<span class="hljs-string">\'Debug\'</span>]\n  pod <span class="hljs-string">\'SwiftGen\'</span>, <span class="hljs-string">\'6.4.0\'</span>, configurations: [<span class="hljs-string">\'Debug\'</span>]\nend\n</code></pre>\n<p data-nodeid="1772">其中<code data-backticks="1" data-nodeid="1936">configurations: [\'Debug\']</code>用于指定该依赖库只是使用到<code data-backticks="1" data-nodeid="1938">Debug</code>构建目标（target）里面，而不在其他（如<code data-backticks="1" data-nodeid="1940">Release</code>）构建目标里面，这样做能有效减少 App Store 发布版本的体积。</p>\n<p data-nodeid="1773"><code data-backticks="1" data-nodeid="1942">def dev_pods end</code>代码块是“复用同一类依赖库方式”的意思，我们可以把同类型的依赖库都放进这个代码块里面。比如，我们的 Moments 项目中就分别有<code data-backticks="1" data-nodeid="1944">dev_pods</code>（开发相关的库）,<code data-backticks="1" data-nodeid="1946">core_pods</code>（核心库）以及<code data-backticks="1" data-nodeid="1948">thirdparty_pods</code>(第三方库)等代码块定义。</p>\n<p data-nodeid="1774"><strong data-nodeid="1953">target 配置</strong></p>\n<p data-nodeid="1775">有了这些复用库定义以后，怎样使用到项目的构建目标（target）里面呢？下面就是一个例子。</p>\n<pre class="lang-java" data-nodeid="1776"><code data-language="java">target \'Moments\' do\n  dev_pods\n  core_pods\n  # other pods...\nend\n</code></pre>\n<p data-nodeid="1777">我们可以把构建目标所使用的所有依赖库放进<code data-backticks="1" data-nodeid="1956">target</code>代码块中间，上面中的<code data-backticks="1" data-nodeid="1958">Moments</code>就是我们的 App 构建目标。该构建目标依赖了<code data-backticks="1" data-nodeid="1960">dev_pods</code>和<code data-backticks="1" data-nodeid="1962">core_pods</code>等各组依赖库。执行<code data-backticks="1" data-nodeid="1964">pod install</code>的时候，CocoaPods 会把<code data-backticks="1" data-nodeid="1966">dev_pods</code>代码块自动展开为<code data-backticks="1" data-nodeid="1968">SwiftLint</code>和<code data-backticks="1" data-nodeid="1970">SwiftGen</code>，那么<code data-backticks="1" data-nodeid="1972">Moments</code>构建目标能使用<code data-backticks="1" data-nodeid="1974">SwiftLint</code>和<code data-backticks="1" data-nodeid="1976">SwiftGen</code>依赖库了。</p>\n<p data-nodeid="1778"><strong data-nodeid="1981">依赖库的版本</strong></p>\n<pre class="lang-java" data-nodeid="1779"><code data-language="java"> pod <span class="hljs-string">\'RxSwift\'</span>, <span class="hljs-string">\'= 5.1.1\'</span>\n pod <span class="hljs-string">\'RxRelay\'</span>, <span class="hljs-string">\'= 5.1.1\'</span>\n</code></pre>\n<p data-nodeid="1780">在 CocoaPods 里面，每一个依赖库称为一个 Pod （注意这里首字母大写，Pod 指一个库），指定一个 Pod 的命令是<code data-backticks="1" data-nodeid="1983">pod</code>（注意这里是小写，表示一条命令）。在 Podfile 里面我们可以通过这样的格式<code data-backticks="1" data-nodeid="1985">pod \'RxSwift\', \'= 5.1.1\'</code>来配置依赖库的版本号。其中，<code data-backticks="1" data-nodeid="1987">RxSwift</code>或者<code data-backticks="1" data-nodeid="1989">RxRelay</code>是依赖库的名字，<code data-backticks="1" data-nodeid="1991">5.1.1</code>为版本号。这些库的名字以及版本号都可以在 CocoaPods 官网上找到。</p>\n<p data-nodeid="1781"><strong data-nodeid="1998">为了统一管理第三方依赖库的版本，我建议统一使用 = 来锁定该依赖库的版本，这样就能保证每次执行</strong><code data-backticks="1" data-nodeid="1996">pod install</code>的时候都可以为同一个库下载同一个版本。</p>\n<p data-nodeid="1782">除了 = 操作符以外，CocoaPods 还支持其他操作符来指定版本：</p>\n<ul data-nodeid="1783">\n<li data-nodeid="1784">\n<p data-nodeid="1785"><code data-backticks="1" data-nodeid="2000">&gt; 0.1</code>表示大于 0.1 的任何版本，这样可以包含 0.2 或者 1.0；</p>\n</li>\n<li data-nodeid="1786">\n<p data-nodeid="1787"><code data-backticks="1" data-nodeid="2002">&gt;= 0.1</code>表示大于或等于 0.1 的任何版本；</p>\n</li>\n<li data-nodeid="1788">\n<p data-nodeid="1789"><code data-backticks="1" data-nodeid="2004">&lt; 0.1</code>表示少于 0.1 的任何版本；</p>\n</li>\n<li data-nodeid="1790">\n<p data-nodeid="1791"><code data-backticks="1" data-nodeid="2006">&lt;= 0.1</code>表示少于或等于 0.1 的任何版本；</p>\n</li>\n<li data-nodeid="1792">\n<p data-nodeid="1793"><code data-backticks="1" data-nodeid="2008">~&gt; 0.1.2</code>表示大于 0.1.2 而且最高支持 0.1.* 的版本，但不包含 0.2 版本。</p>\n</li>\n</ul>\n<p data-nodeid="1794">这几个操作符相里面，<code data-backticks="1" data-nodeid="2013">~&gt;</code>（Squiggy arrow）操作符更为常用，它是以最后一个部分的版本号（例子中 0.1.2 的最后一个部分是补丁版本号 <em data-nodeid="2019">.</em>.2）来计算可以支持的最高版本号。</p>\n<p data-nodeid="1795">例如<code data-backticks="1" data-nodeid="2021">~&gt; 0.1.2</code>表示 &gt;= 0.1.2&nbsp;并且 &lt; 0.2.0，但不能等于 0.2.0， 因为 0.2.0 已经更新了副版本号而不仅仅是补丁版本号了。另外一个例子是<code data-backticks="1" data-nodeid="2025">~&gt; 0.1</code>，表示 &nbsp;&gt;= 0.1&nbsp; 并且 &lt; 1.0，举例来说，我们可以更新到 0.9 但不能更新到 1.0。</p>\n<p data-nodeid="1796">前面我介绍的是引用外部的第三方依赖库，如果我们的项目有自己的内部依赖库，要怎样在 CocoaPods 引用它呢？其实很简单，我们可以执行以下命令：</p>\n<pre class="lang-java" data-nodeid="1797"><code data-language="java">pod <span class="hljs-string">\'DesignKit\'</span>, :path =&gt; <span class="hljs-string">\'./Frameworks/DesignKit\'</span>, :inhibit_warnings =&gt; <span class="hljs-keyword">false</span>\n</code></pre>\n<p data-nodeid="1798">和其他外部依赖库不一样，我们需要使用<code data-backticks="1" data-nodeid="2031">:path</code>来指定该内部库的路径。</p>\n<h4 data-nodeid="1799">Podfile.lock 文件</h4>\n<p data-nodeid="1800">Podfile.lock 文件是由 CocoaPods 自动生成和更新的，该文件会详细列举所有依赖库具体的版本号。比如，</p>\n<pre class="lang-java" data-nodeid="1801"><code data-language="java">DEPENDENCIES:\n&nbsp; - Alamofire (= <span class="hljs-number">5.2</span><span class="hljs-number">.0</span>)\n&nbsp; - Firebase/Analytics (= <span class="hljs-number">7.0</span><span class="hljs-number">.0</span>)\nPODFILE CHECKSUM: <span class="hljs-number">400</span>d19dbc4f5050f438797c5c6459ca0ef74a777\n</code></pre>\n<p data-nodeid="1802">当执行<code data-backticks="1" data-nodeid="2036">pod install</code>后，CocoaPods 会根据 Podfile 文件解释出各依赖库的特定版本号，然后一一列举在 DEPENDENCIES 下面。在上述的例子中，我们的 App 在构建过程中使用了5.2.0 的 Alamofire 库以及 7.0.0 的 Firebase Analytics 库。</p>\n<p data-nodeid="1803">PODFILE CHECKSUM 用于记录 Podfile 的验证码，任何库的版本号的更改，都会改变该验证码。这样能帮助我们在不同的机器上，快速检测依赖库的版本号是否一致。</p>\n<p data-nodeid="1804">我建议要把 Podfile 和 Podfile.lock 文件一同 commit 并 push 到 Git 代码管理服务器里面。特别是在团队开发的环境下，这样能帮助我们保证各个依赖库版本号的一致性。</p>\n<p data-nodeid="1805">在实践操作中，无论我们在哪台机器上执行<code data-backticks="1" data-nodeid="2041">pod install</code>， PODFILE CHECKSUM 都不应该发生任何改变。因为我们在 Git 保存了 Podfile.lock，一旦我们发现老版本 App 的 Bug ，就可以根据该文件为各个依赖库重新安装同一版本号，来重现和定位问题，从而帮助我们快速修改这些 Bug。</p>\n<h4 data-nodeid="1806">Workspace 文档</h4>\n<p data-nodeid="1807">Workspace 文档是 Xcode 管理子项目的方式。通过 Workspace，我们可以把相关联的多个 Xcode 子项目组合起来方便开发。</p>\n<p data-nodeid="1808">前面说过，当我们执行<code data-backticks="1" data-nodeid="2046">pod install</code>的时候，CocoaPods 会自动创建或者更新一个叫作 Pods 的项目文档（Pods.xcodeproj&nbsp;）以及一个 Workspace 文档（在我们项目中叫作 Moments.xcworkspace）。</p>\n<p data-nodeid="1809">其中，Pods 项目文档负责统一管理各个依赖库，当我们在 Podfile 里面指定构建成动态库的时候，该项目会自动生成一个名叫<code data-backticks="1" data-nodeid="2049">Pods_&lt;项目名称&gt;.framework</code>的动态库供我们项目使用。</p>\n<p data-nodeid="1810">而 Workspace 文档则统一管理了我们原有的主项目 （Moments.xcodeproj）以及那个 Pods 项目。</p>\n<p data-nodeid="1811">与此同时，CocoaPods 还会修改 Xcode 项目中的 Build Phases&nbsp; 以此来检测 Podfile.lock 和 Manifest.lock 文件的一致性，并把<code data-backticks="1" data-nodeid="2053">Pods_&lt;项目名称&gt;.framework</code>动态库嵌入我们的主项目中去。</p>\n<p data-nodeid="1812">以上所有操作都是由 CocoaPods 自动帮我们完成。以后的开发，我们都可以打开 Workspace 文档而不是原有的 Xcode 项目文档来进行。</p>\n<h3 data-nodeid="1813">Pod 版本更新</h3>\n<p data-nodeid="1814">使用 CocoaPods 管理第三方依赖库的操作非常简单，可是一旦使用不当，特别是在 Pod 更新的时候，很容易引起依赖库版本不一致，从而出现各种问题。</p>\n<p data-nodeid="1815">比如，在编译程序的时候，有些开发者可以顺利进行，而另外一些开发者编译时候就会出错；或者程序在本地编译时运行良好，一旦在 CI 上构建，就会出现 App 崩溃，等等。</p>\n<p data-nodeid="1816">那么，怎么保证更新 Pod 的时候都能保证版本一致呢？</p>\n<p data-nodeid="1817">下面结合我的实践经验，以第三方网络库 Alamofire 为例子和你介绍下。</p>\n<p data-nodeid="1818">第一步，CocoaPods 已经为我们提供了<code data-backticks="1" data-nodeid="2062">pod outdated</code>命令，我们可以用它一次查看所有 Pod 的最新版本，而无须到 GitHub 上逐一寻找。下面是执行<code data-backticks="1" data-nodeid="2064">pod outdated</code>命令的其中一条结果：</p>\n<pre class="lang-java" data-nodeid="1819"><code data-language="java">The following pod updates are available:\n- Alamofire <span class="hljs-number">5.2</span><span class="hljs-number">.0</span> -&gt; <span class="hljs-number">5.2</span><span class="hljs-number">.0</span> (latest version <span class="hljs-number">5.4</span><span class="hljs-number">.0</span>)\n</code></pre>\n<p data-nodeid="1820">这表示当前我们使用了版本为 5.2.0 的 Alamofire ，其最新版本为 5.4.0。如果我们决定更新到版本 5.4.0，那么可以继续下一步。</p>\n<p data-nodeid="1821">第二步，在更新依赖库版本之前，为了避免在新版本中不小心引入 Bug，我们需要了解新的版本到底提供了哪些新功能，修改了哪些 Bug，与老版本是否兼容等事项。具体我们可以到 CocoaPods 官网上查找需要更新的第三方依赖库，然后在 GitHub 等平台上找到，并仔细阅读该库的版本说明（release note）。</p>\n<p data-nodeid="1822"><strong data-nodeid="2072">请注意，我们要阅读当前使用版本到要更新的版本之间的所有版本说明。</strong> 在这个例子中，我们要阅读 5.2.1，5.2.2，5.3.0 和 5.4.0 的所有版本说明。这些版本说明会列出新增功能，更新的 API，修改的 Bug，有没有不可兼容的更新 。</p>\n<p data-nodeid="1823">第三步，在 Podfile 文件里把要更新的 Pod 的版本号进行修改。例如把<code data-backticks="1" data-nodeid="2074">pod \'Alamofire\', \'= 5.2.0\'</code>改成<code data-backticks="1" data-nodeid="2076">pod \'Alamofire\', \'= 5.4.0\'</code>。 然后执行<code data-backticks="1" data-nodeid="2078">pod install</code>来重新生成 Podfile.lock 文件。</p>\n<p data-nodeid="3014" class="te-preview-highlight">此时特别注意的是，我们要使用<code data-backticks="1" data-nodeid="3016">pod install</code>而不是<code data-backticks="1" data-nodeid="3018">pod update</code>。因为执行<code data-backticks="1" data-nodeid="3020">pod update</code>会自动更新所有 Pod 的版本，这可能会更新了一些我们目前还不想更新的 Pod，从而会引入一些难以觉察的问题。</p>\n\n\n<p data-nodeid="1825">第四步，如果所更新的版本包含了不可兼容的更新，我们需要修改代码来保证代码能顺利完成编译。</p>\n<p data-nodeid="1826">第五步，很多第三方依赖库都是一些通用的基础组件，一旦发生问题会影响到整个 App 的功能，因此我们需要根据所更新的库进行回归测试。例如当更新了 Alamofire 库的时候，我们需要把每个网络请求都执行一遍，避免所更新的版本引入新的 Bug。</p>\n<p data-nodeid="1827">第六步，为了把更新的版本共享给所有开发者和 CI 服务器，我们需要把 Podfile 和 Podfile.lock 文件一同 commit 并 push 到 Git 代码管理服务器，并通过 Pull Request 流程并入主分支。</p>\n<p data-nodeid="1828">第七步，一旦更新的代码并入主分支后，要通过 Slack 等内部通信软件告诉所有开发者 pull 或者 rebase 主分支的代码，并执行<code data-backticks="1" data-nodeid="2095">pod install</code>来更新他们开发环境的所有依赖库。</p>\n<p data-nodeid="1829"><strong data-nodeid="2104">特别注意，千万不要使用</strong><code data-backticks="1" data-nodeid="2100">pod update</code>，因为<code data-backticks="1" data-nodeid="2102">pod update</code>会自动把开发者机器上所有 Pod 的版本自动更新了。这种更新往往不是我们想要的结果，我们希望统一更新各个 Pod 的版本，并通过 Git 进行集中管理。</p>\n<p data-nodeid="1830">如果开发者在编译新代码前没有执行<code data-backticks="1" data-nodeid="2106">pod install</code>命令，会出现以下的错误。</p>\n<blockquote data-nodeid="1831">\n<p data-nodeid="1832">The sandbox is not in sync with the Podfile.lock. Run \'pod install\' or update your CocoaPods installation.</p>\n</blockquote>\n<p data-nodeid="1833">这错误可以有效提醒所有开发者，需要再次执行<code data-backticks="1" data-nodeid="2114">pod install</code>来更新他们本地的依赖库，从而保证所有开发者使用的依赖库的版本都是一致的。</p>\n<p data-nodeid="1834">另外，如果更新了基础组件的依赖库（如网络库），在测试阶段，我们还需要进行全面的回归测试。因为这些基础组件库的新版本如果有 Bug 很可能导致我们的 App 会发生大比例的崩溃，严重影响用户的体验。</p>\n<p data-nodeid="1835">有了上面的一流程，我们就可以有效地保证每个开发者使用的依赖库版本都是一致的，同时也能保证 CI 在自动构建 App 的时候所使用的依赖库版本也是统一的。</p>\n<h3 data-nodeid="1836">总结</h3>\n<p data-nodeid="1837">这一讲我介绍了如何使用 CocoaPods 来统一管理依赖库的版本。特别是根据我自己的经验总结了一套更新 Pod 版本的流程，希望你灵活使用这些步骤，从而少走弯路。</p>\n<p data-nodeid="1838"><img src="https://s0.lgstatic.com/i/image6/M00/0A/3A/CioPOWA3GR6AIe4nAApbaq5B2h0899.png" alt="依赖管理.png" data-nodeid="2122"></p>\n<p data-nodeid="1839">这里我再特别强调一下，为了保证依赖库版本都能保持一致，尽量不要执行<code data-backticks="1" data-nodeid="2124">pod update</code>，而是使用通过修改 Podfile 文件里的版本号并执行<code data-backticks="1" data-nodeid="2126">pod install</code>来更新 Pod 的版本，然后把 Podfile 和 Podfile.lock 文件一同并入 Git 主分支中进行统一管理。</p>\n<p data-nodeid="1840">思考题：</p>\n<blockquote data-nodeid="1841">\n<p data-nodeid="1842">CocoaPods 非常简单易用，它可以同时管理依赖库的依赖项，例如我们的 App 依赖 A 库， 而 A 库又依赖 B 库，同时 B 库依赖 C 库，CocoaPods 可以帮我们自动找出所有依赖项并按顺序安装所有依赖库。 那你知道 CocoaPods 是如何管理依赖库的依赖呢？</p>\n</blockquote>\n<p data-nodeid="1843">下一讲，我将为你介绍如何统一构建配置。</p>\n<p data-nodeid="1844">源码地址：</p>\n<blockquote data-nodeid="1845">\n<p data-nodeid="1846">Podfile 文件地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Podfile" data-nodeid="2136">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Podfile</a></p>\n</blockquote>\n<hr data-nodeid="1847">\n<p data-nodeid="1848"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="2141"><img src="https://s0.lgstatic.com/i/image6/M00/08/77/Cgp9HWA0wqWAI70NAAdqMM6w3z0673.png" alt="Drawing 1.png" data-nodeid="2140"></a></p>\n<p data-nodeid="1849"><strong data-nodeid="2145">《大前端高薪训练营》</strong></p>\n<p data-nodeid="1850" class="">12 个月打磨，6 个月训练，优秀学员大厂内推，<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="2149">点击报名，高薪有你</a>！</p>',
          },
          {
            theme: '03 | 配置准备：如何搭建多环境支持，为 App 开发作准备',
            id: 12,
            content:
              '<p data-nodeid="10683" class="">在开始之前，我先问你几个问题，在测试的时候，App 一般需要连接测试服务器，那么在上架后，还需要连生产服务器吗？在发布前，你的 App 需要通过 Ad-hoc 分发给内部测试组吗？在发布到 App Store 的时候，你的 App 需要同时支持免费版和收费版吗？</p>\n<p data-nodeid="10684">如果你的回答是“是”，那么你的 App 就需要搭建多环境支持，优化开发的工作流程。多环境提供很多好处，比如能基于同一套源代码自动构建出有差异功能的 App；能支持多个团队并行开发，也能分离测试和生产环境，提高产品的迭代速度，保证上架的 App 通过严格测试和功能验证。</p>\n<p data-nodeid="10685">在 Moments App 项目中，我们就使用了三个不同的环境，分别是开发环境，测试环境和生产环境。它们到底有什么区别呢？</p>\n<ul data-nodeid="10686">\n<li data-nodeid="10687">\n<p data-nodeid="10688"><strong data-nodeid="10858">开发环境，</strong> 用于日常的开发，一般有未完成的功能模块。编译时，也不进行任何优化，可以打印更多的日志，帮助开发者快速定位问题。</p>\n</li>\n<li data-nodeid="10689">\n<p data-nodeid="10690"><strong data-nodeid="10863">测试环境，</strong> 主要是用于测试，以及为产品经理进行功能验证，包括部分完成的功能模块，也提供一些隐藏功能，方便我们进行开发和迭代，例如快速切换用户，清理 Cache，连接到不同后台服务器等等。</p>\n</li>\n<li data-nodeid="10691">\n<p data-nodeid="10692"><strong data-nodeid="10868">生产环境，</strong> 只包含通过了测试并验证过的功能模块，它是最终提交到 App Store 供终端用户使用的版本。</p>\n</li>\n</ul>\n<p data-nodeid="10693">多环境支持需要用到 Xcode 的构建配置，这一讲，我就结合 Moments App 项目来聊聊这个问题。</p>\n<h3 data-nodeid="10694">Xcode 构建基础概念</h3>\n<p data-nodeid="10695">一般在构建一个 iOS App 的时候，需要用到 Xcode Project，Xcode Target，Build Settings，Build Configuration 和 Xcode Scheme 等构建配置。它们各有什么用呢？</p>\n<h4 data-nodeid="10696">Xcode Project</h4>\n<p data-nodeid="10697"><strong data-nodeid="10877">Xcode Project</strong>用于组织源代码文件和资源文件。一个 Project 可以包含多个 Target，例如当我们新建一个 Xcode Project 的时候，它会自动生成 App 的主 Target，Unit Test Target 和 UI Test Target。</p>\n<p data-nodeid="10698">在 Moments App 项目中，主 Target 就是 Moments，Unit Test Target 是 MomentsTests， UI Test Target 就是 MomentsUITests。</p>\n<p data-nodeid="10699"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9Eb2ARf3OAAK1tf7-bjM651.png" alt="Drawing 1.png" data-nodeid="10881"></p>\n<h4 data-nodeid="10700">Xcode Target</h4>\n<p data-nodeid="10701"><strong data-nodeid="10887">Xcode Target</strong>用来定义如何构建出一个产品（例如 App， Extension 或者 Framework），Target 可以指定需要编译的源代码文件和需要打包的资源文件，以及构建过程中的步骤。</p>\n<p data-nodeid="10702">例如在我们的 Moments App 项目中，负责单元测试的<strong data-nodeid="10897">MomentsTests</strong>Target 就指定了 14 个测试文件需要构建（见下图的 Compile Sources），并且该 Target 依赖了主 App Target<strong data-nodeid="10898">Moments</strong>（见下图的 Dependencies）。</p>\n<p data-nodeid="10703"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9EciAH1boAAaiePlJeSA718.png" alt="Drawing 3.png" data-nodeid="10901"></p>\n<p data-nodeid="10704">有了 Target 的定义，构建系统就可以读取相关的源代码文件进行编译，然后把相关的资源文件进行打包，并严格按照 Target 所指定的设置和步骤执行。那么 Target 所指定的设置哪里来的呢？来自 Build Settings。</p>\n<h4 data-nodeid="10705">Build Settings</h4>\n<p data-nodeid="10706"><strong data-nodeid="10908">Build Setting</strong>保存了构建过程中需要用到的信息，它以一个变量的形式而存在，例如所支持的设备平台，或者支持操作系统的最低版本等。</p>\n<p data-nodeid="10707">通常，一条 Build Setting 信息由两部分组成：名字和值。比如下面是一条 Setting 信息，<code data-backticks="1" data-nodeid="10910">iOS Development Target</code>是名字，而<code data-backticks="1" data-nodeid="10912">iOS 14.0</code>是值。</p>\n<p data-nodeid="10708"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9Ed2ACeq0AAKM_xm8xxI584.png" alt="Drawing 5.png" data-nodeid="10916"></p>\n<p data-nodeid="10709">有了这些基础知识以后，接下来我就结合 Moments App 来和你介绍下如何进行多环境配置，从而生成不同环境版本的 App。</p>\n<h3 data-nodeid="10710">Moments App 构建配置</h3>\n<p data-nodeid="10711">一般用 Xcode 编译出不同环境版本的 App 有多种办法，例如拷贝复制所有源代码，建立多个 Target 来包含不同的源码文件等等。不过，在这里我推荐使用 Build Configuration 和 Xcode Scheme 来管理多环境，进而构建出不同环境版本的 App。为什么？因为这两个是目前管理成本最低的办法。接下来我一一介绍下。</p>\n<h4 data-nodeid="10712">Build Configuration</h4>\n<p data-nodeid="10713">当我们在 Xcode 上新建一个项目的时候，Xcode 会自动生成两个 Configuration：<strong data-nodeid="10934">Debug</strong>和<strong data-nodeid="10935">Release</strong>。Debug 用于日常的本地开发，Release 用于构建和分发 App。而在我们的 Moments App 项目中，有三个 configuration：Debug，Internal 和 AppStore。它们分别用于构建开发环境、测试环境和生产环境。 其中 Internal 和 AppStore 是从自动生成的 Release 拷贝而来的。<br>\n<img src="https://s0.lgstatic.com/i/image6/M01/0F/0F/CioPOWA9EfSAY2OBAALUPeNgNGQ665.png" alt="Drawing 7.png" data-nodeid="10933"></p>\n<p data-nodeid="10714">那什么是 Build Configuration 呢？</p>\n<p data-nodeid="10715"><strong data-nodeid="10941">Build Configuration</strong>就是一组 Build Setting。 我们可以通过 Build Configuration 来分组和管理不同组合的 Build Setting 集合，然后传递给 Xcode 构建系统进行编译。</p>\n<p data-nodeid="10716">有了 Build Configuration 以后，我们就能为同一个 Build Setting 设置不同的值。例如<code data-backticks="1" data-nodeid="10943">Build Active Architecture Only</code>在 Debug configuration 是<code data-backticks="1" data-nodeid="10945">Yes</code>，而在 Internal 和 AppStore configuration 则是<code data-backticks="1" data-nodeid="10947">No</code>。这样就能做到同一份源代码通过使用不同的 Build Configuration 来构建出功能不一样的 App 了。</p>\n<p data-nodeid="10717"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9EfyAVTM7AAPlUPRPHoQ921.png" alt="Drawing 9.png" data-nodeid="10951"></p>\n<p data-nodeid="10718">那么，在构建过程中怎样才能选择不同的 Build Configuration 呢？答案是使用 Xcode Scheme。</p>\n<h4 data-nodeid="10719">Xcode Scheme</h4>\n<p data-nodeid="10720"><strong data-nodeid="10958">Xcode Scheme</strong>用于定义一个完整的构建过程，其包括指定哪些 Target 需要进行构建，构建过程中使用了哪个 Build Configuration ，以及需要执行哪些测试案例等等。在项目新建的时候只有一个 Scheme，但可以为同一个项目建立多个 Scheme。不过这么多 Scheme 中，同一时刻只能有一个 Scheme 生效。</p>\n<p data-nodeid="10721">我们一起看一下 Moments App 项目的 Scheme 吧。 Moments App 项目有三个 Scheme 来分别代表三个环境，Moments Scheme 用于开发环境，Moments-Internal Scheme 用于测试环境，而 Moments-AppStore Scheme 用于生产环境。</p>\n<p data-nodeid="10722"><img src="https://s0.lgstatic.com/i/image6/M01/0F/0F/CioPOWA9EgeAYsQhAAy86ZVIPDY023.png" alt="Drawing 11.png" data-nodeid="10962"></p>\n<p data-nodeid="10723">下面是<strong data-nodeid="10968">Moments</strong>Scheme 的配置。</p>\n<p data-nodeid="10724"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9Eg6AF5o_AA7dS4NRt4E058.png" alt="Drawing 13.png" data-nodeid="10971"></p>\n<p data-nodeid="10725">左边是该 Scheme 的各个操作，如当前选择了 Build 操作；右边是对应该操作的配置，比如 Build 对应的 Scheme 可以构建三个不同的 Targets。不同的 Scheme 所构建的 Target 数量可以不一样，例如下面是<strong data-nodeid="10977">Moments-Internal</strong>Scheme 的配置。</p>\n<p data-nodeid="10726"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9EheABikxAA6wBftOxsw011.png" alt="Drawing 15.png" data-nodeid="10980"></p>\n<p data-nodeid="10727">该 Scheme 只构建主 App Target<strong data-nodeid="10986">Moments</strong>，而不能构建其他两个测试 Target。</p>\n<p data-nodeid="10728">当我们选择 Run、Test、Profile、 Analyze 和 Archive 等操作时，在右栏有一个很关键的配置<del data-nodeid="10992">是</del>叫作 Build Configuration，我们可以通过下拉框来选择 Moments App 项目里面三个 Configuration （Debug，Internal 和 AppStore） 中的其中一个。</p>\n<p data-nodeid="10729"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9Eh-AcgcJABDw5Uj21A0457.png" alt="Drawing 17.png" data-nodeid="10995"></p>\n<p data-nodeid="10730">为了方便管理，我们通常的做法是，一个 Scheme 对应一个 Configuration。有了这三个 Scheme 以后，我们就可以很方便地构建出 Moments α（开发环境），Moments β（测试环境）和 Moments（生产环境）三个功能差异的 App。</p>\n<p data-nodeid="10731">￼<br>\n<img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9EiqAFjzxAA135y-7y-8462.png" alt="Drawing 19.png" data-nodeid="11001"></p>\n<p data-nodeid="10732">你可能已经注意到这三个 App 的名字都不一样，怎么做到的呢？实际上是我们为不同的 Configuration 设置了不一样的 Build Setting。其中决定 App 名字的 Build Setting 叫作<code data-backticks="1" data-nodeid="11003">PRODUCT_BUNDLE_NAME</code>，然后在 Info.plist 文件里面为 Bundle name 赋值，就能构建出名字不一样的 App。</p>\n<p data-nodeid="10733"><img src="https://s0.lgstatic.com/i/image6/M01/0F/12/Cgp9HWA9EjyAJgqrAAsJppbAhkc094.png" alt="Drawing 21.png" data-nodeid="11007"></p>\n<p data-nodeid="10734">为了构建出不同环境版本的 App，我们需要经常为各个 Build Configuration 下的 Build Setting 设置不一样的值。 在这其中，使用好 xcconfig 配置文件就显得非常重要。</p>\n<h3 data-nodeid="10735">xcconfig 配置文件</h3>\n<p data-nodeid="10736">xcconfig 会起到什么作用呢？</p>\n<p data-nodeid="10737">一般修改 Build Setting 的办法是在 Xcode 的 Build Settings 界面上进行。 例如下面的例子中修改 Suppress Warnings。</p>\n<p data-nodeid="10738"><img src="https://s0.lgstatic.com/i/image6/M01/0F/0F/CioPOWA9EkaAcmKDAAScwhg-YKw659.png" alt="Drawing 23.png" data-nodeid="11014"></p>\n<p data-nodeid="10739">这样做有一些不好的地方，首先是手工修改很容易出错，例如有时候很难看出来修改的 Setting 到底是 Project 级别的还是 Target 级别的。其次，最关键的是每次修改完毕以后都会修改了 xcodeproj 项目文档 （如下图所示），导致 Git 历史很难查看和对比。</p>\n<p data-nodeid="10740"><img src="https://s0.lgstatic.com/i/image6/M01/0F/0F/CioPOWA9ElCAUe6vAAfIFrFWo48879.png" alt="Drawing 25.png" data-nodeid="11018"></p>\n<p data-nodeid="10741">幸运的是，Xcode 为我们提供了一个统一管理这些 Build Setting 的便利方法，那就是使用 xcconfig 配置文件来管理。</p>\n<h4 data-nodeid="10742">xcconfig 概念及其作用</h4>\n<p data-nodeid="10743"><strong data-nodeid="11025">xcconfig</strong>也叫作 Build configuration file（构建配置文件），我们可以使用它来为 Project 或 Target 定义一组 Build Setting。由于它是一个纯文本文件，我们可以使用 Xcode 以外的其他文本编辑器来修改，而且可以保存到 Git 进行统一管理。 这样远比我们在 Xcode 的 Build Settings 界面上手工修改要方便很多，而且还不容易出错。</p>\n<p data-nodeid="10744">在 xcconfig 文件里面的每一条 Setting 都是下面的格式：</p>\n<pre class="lang-java" data-nodeid="10745"><code data-language="java">BUILD_SETTING_NAME = value\n</code></pre>\n<p data-nodeid="10746">其中，<code data-backticks="1" data-nodeid="11028">BUILD_SETTING_NAME</code>表示 Build Setting 的名字，而<code data-backticks="1" data-nodeid="11030">value</code>是该 Setting 的值。下面是一个例子。</p>\n<pre class="lang-java" data-nodeid="10747"><code data-language="java">SWIFT_VERSION = <span class="hljs-number">5.0</span>\n</code></pre>\n<p data-nodeid="10748"><code data-backticks="1" data-nodeid="11032">SWIFT_VERSION</code>是用于定义 Swift 语言版本的 Build Setting，其值是<code data-backticks="1" data-nodeid="11034">5.0</code>。Setting 的名字都是由大写字母，数值和下划线组成。这种命名法我们一般成为蛇型命名法，例如<code data-backticks="1" data-nodeid="11036">SNAKE_CASE_NAME</code>。</p>\n<p data-nodeid="10749">当我们使用 xcconfig 时，Xcode 构建系统会按照下面的优先级来计算出 Build Setting 的最后生效值：</p>\n<ul data-nodeid="10750">\n<li data-nodeid="10751">\n<p data-nodeid="10752">Platform Defaults (平台默认值)</p>\n</li>\n<li data-nodeid="10753">\n<p data-nodeid="10754">Xcode Project xcconfig File（Project 级别的 xcconfig 文件）</p>\n</li>\n<li data-nodeid="10755">\n<p data-nodeid="10756">Xcode Project File Build Settings（Project 级别的手工配置的 Build Setting）</p>\n</li>\n<li data-nodeid="10757">\n<p data-nodeid="10758">Target xcconfig File （Target 级别的 xcconfig 文件）</p>\n</li>\n<li data-nodeid="10759">\n<p data-nodeid="10760">Target Build Settings（Target 级别的手工配置的 Build Setting）</p>\n</li>\n</ul>\n<p data-nodeid="10761">Xcode 构建系统会按照上述列表从上而下读取 Build Setting，如果发现同样的 Setting ，就会把下面的 Setting 覆盖掉上面的，越往下优先级别越高。</p>\n<p data-nodeid="11214" class="te-preview-highlight">例如我们在 Project 级别的 xcconfig 文件配置了<code data-backticks="1" data-nodeid="11216">SWIFT_VERSION = 5.0</code>而在Target 级别的 xcconfig 文件配置了<code data-backticks="1" data-nodeid="11218">SWIFT_VERSION = 5.1</code>，那么Target 级别的 Build Setting 会覆盖 Project 级别的<code data-backticks="1" data-nodeid="11220">SWIFT_VERSION</code>设置，最终<code data-backticks="1" data-nodeid="11222">SWIFT_VERSION</code>生效的值是<code data-backticks="1" data-nodeid="11224">5.1</code>。</p>\n\n<p data-nodeid="10763">那么，要怎样做才能做到不覆盖原有的 Build Setting 呢？我们可以使用下面例子中的<code data-backticks="1" data-nodeid="11057">$(inherited)</code>来实现。</p>\n<pre class="lang-java" data-nodeid="10764"><code data-language="java">BUILD_SETTING_NAME = $(inherited) additional value\n</code></pre>\n<p data-nodeid="10765">可以保留原先的 Setting，然后把新的值添加到后面去。比如：</p>\n<pre class="lang-java" data-nodeid="10766"><code data-language="java">FRAMEWORK_SEARCH_PATHS = $(inherited) ./Moments/Pods\n</code></pre>\n<p data-nodeid="10767">其中的<code data-backticks="1" data-nodeid="11061">FRAMEWORK_SEARCH_PATHS</code>会保留原有的值，然后加上<code data-backticks="1" data-nodeid="11063">./Moments/Pods</code>作为新值。<br>\n在配置 Build Setting 时，还可以引用其他已定义的 Build Setting。</p>\n<p data-nodeid="10768">例如下面的例子中，<code data-backticks="1" data-nodeid="11068">FRAMEWORK_SEARCH_PATHS</code>使用了另外一个 Build Setting<code data-backticks="1" data-nodeid="11070">PROJECT_DIR</code>。</p>\n<pre class="lang-java" data-nodeid="10769"><code data-language="java">FRAMEWORK_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)\n</code></pre>\n<p data-nodeid="10770">为了重用，我们可以通过<code data-backticks="1" data-nodeid="11073">#include</code>引入其他 xcconfig 文件。</p>\n<pre class="lang-java" data-nodeid="10771"><code data-language="java">#include "path/to/OtherFile.xcconfig"\n</code></pre>\n<h4 data-nodeid="10772">Moments App xcconfig 配置文件</h4>\n<p data-nodeid="10773">下面我们一起来看看 Moments App 项目是怎样管理 xcconfig 配置文件吧。</p>\n<p data-nodeid="10774"><img src="https://s0.lgstatic.com/i/image6/M00/0F/12/Cgp9HWA9EmOAPIq1ABD7ml3cabY856.png" alt="Drawing 27.png" data-nodeid="11079"></p>\n<p data-nodeid="10775">我们把所有 xcconfig 文件分成三大类：Shared、 Project 和 Targets。</p>\n<p data-nodeid="10776">其中 Shared 文件夹用于保存分享到整个 App 的 Build Setting，例如 Swift 的版本号、App 所支持的 iOS 版本号等各种共享的基础信息。 下面是 SDKAndDeviceSupport.xcconfig 文件里面所包含的信息：</p>\n<pre class="lang-java" data-nodeid="10777"><code data-language="java">TARGETED_DEVICE_FAMILY = <span class="hljs-number">1</span>\nIPHONEOS_DEPLOYMENT_TARGET = <span class="hljs-number">14.0</span>\n</code></pre>\n<p data-nodeid="10778"><code data-backticks="1" data-nodeid="11082">TARGETED_DEVICE_FAMILY</code>表示支持的设备，<code data-backticks="1" data-nodeid="11084">1</code>表示 iPhone。而<code data-backticks="1" data-nodeid="11086">IPHONEOS_DEPLOYMENT_TARGET</code>表示支持 iOS 的最低版本，我们的 Moments App 所支持的最低版本是 iOS 14.0。</p>\n<p data-nodeid="10779">Project 文件夹用于保存 Xcode Project 级别的 Build Setting，其中 BaseProject.xcconfig 会引入 Shared 文件夹下所有的 xcconfig 配置文件，如下所示：</p>\n<pre class="lang-java" data-nodeid="10780"><code data-language="java">#include "CompilerAndLanguage.xcconfig"\n#include "SDKAndDeviceSupport.xcconfig"\n#include "BaseConfigurations.xcconfig"\n</code></pre>\n<p data-nodeid="10781">然后我们会根据三个不同的环境分别建了三个xcconfig 配置文件，如下：</p>\n<ul data-nodeid="10782">\n<li data-nodeid="10783">\n<p data-nodeid="10784">DebugProject.xcconfig 文件</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="10785"><code data-language="java">#include "BaseProject.xcconfig"\nSWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited) DEBUG\n</code></pre>\n<ul data-nodeid="10786">\n<li data-nodeid="10787">\n<p data-nodeid="10788">InternalProject.xcconfig 文件</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="10789"><code data-language="java">#include "BaseProject.xcconfig"\nSWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited) INTERNAL\n</code></pre>\n<ul data-nodeid="10790">\n<li data-nodeid="10791">\n<p data-nodeid="10792">AppStoreProject.xcconfig 文件</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="10793"><code data-language="java">#include "BaseProject.xcconfig"\nSWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited) PRODUCTION\n</code></pre>\n<p data-nodeid="10794">它们的共同点是都引入了用于共享的 BaseProject.xcconfig 文件，然后分别定义了 Swift 编译条件配置<code data-backticks="1" data-nodeid="11094">SWIFT_ACTIVE_COMPILATION_CONDITIONS</code>。其中<code data-backticks="1" data-nodeid="11096">$(inherited)</code>表示继承原有的配置，<code data-backticks="1" data-nodeid="11098">$(inherited)</code>后面的<code data-backticks="1" data-nodeid="11100">DEBUG</code>或者<code data-backticks="1" data-nodeid="11102">INTERNAL</code>表示在原有配置的基础上后面添加了一个新条件。有了这些编译条件，我们就可以在代码中这样使用：</p>\n<pre class="lang-java" data-nodeid="10795"><code data-language="java">#if DEBUG\n    print("Debug Environment")\n#endif\n</code></pre>\n<p data-nodeid="10796">该段代码只在开发环境执行，因为只有开发环境的<code data-backticks="1" data-nodeid="11105">SWIFT_ACTIVE_COMPILATION_CONDITIONS</code>才有<code data-backticks="1" data-nodeid="11107">DEBUG</code>的定义。这样做能有效分离各个环境，保证同一份代码构建出对应不同环境的 App。</p>\n<p data-nodeid="10797">Targets 文件夹用于保存 Xcode Target 级别的 Build Setting，也是由一个 BaseTarget.xcconfig 文件来共享所有 Target 都需要使用的信息。</p>\n<pre class="lang-java" data-nodeid="10798"><code data-language="java">PRODUCT_BUNDLE_NAME = Moments\n</code></pre>\n<p data-nodeid="10799">这里的<code data-backticks="1" data-nodeid="11111">PRODUCT_BUNDLE_NAME</code>是 App 的名字。<br>\n下面是三个不同环境的 Target xcconfig 文件。</p>\n<ul data-nodeid="10800">\n<li data-nodeid="10801">\n<p data-nodeid="10802">DebugTarget.xcconfig</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="10803"><code data-language="java">#include "../Pods/Target Support Files/Pods-Moments/Pods-Moments.debug.xcconfig"\n#include "BaseTarget.xcconfig"\nPRODUCT_BUNDLE_NAME = $(inherited) α\nPRODUCT_BUNDLE_IDENTIFIER = com.ibanimatable.moments.development\n</code></pre>\n<ul data-nodeid="10804">\n<li data-nodeid="10805">\n<p data-nodeid="10806">InternalTarget.xcconfig</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="10807"><code data-language="java">#include "../Pods/Target Support Files/Pods-Moments/Pods-Moments.internal.xcconfig"\n#include "BaseTarget.xcconfig"\nPRODUCT_BUNDLE_NAME = $(inherited) β\nPRODUCT_BUNDLE_IDENTIFIER = com.ibanimatable.moments.internal\n</code></pre>\n<ul data-nodeid="10808">\n<li data-nodeid="10809">\n<p data-nodeid="10810">AppStoreTarget.xcconfig</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="10811"><code data-language="java">#include "../Pods/Target Support Files/Pods-Moments/Pods-Moments.appstore.xcconfig"\n#include "BaseTarget.xcconfig"\nPRODUCT_BUNDLE_NAME = $(inherited)\nPRODUCT_BUNDLE_IDENTIFIER = com.ibanimatable.moments\n</code></pre>\n<p data-nodeid="10812">它们都需要引入 CocoaPods 所生成的 xcconfig 和共享的 BaseTarget.xcconfig 文件，然后根据需要改写 App 的名字。例如<strong data-nodeid="11131">Debug</strong>Target 覆盖了<code data-backticks="1" data-nodeid="11123">PRODUCT_BUNDLE_NAME</code>的值为<code data-backticks="1" data-nodeid="11125">Moments α*</code>, 其所构建的 App 叫作<strong data-nodeid="11132">Moments α</strong>。</p>\n<p data-nodeid="10813">一般在 App Store 上所有 App 的标识符都必须是唯一的。如果你的项目通过 Configuration 和 Scheme 来生成免费版和收费版的 App，那么，你必须在两个 Configuration 中分别为<code data-backticks="1" data-nodeid="11134">PRODUCT_BUNDLE_IDENTIFIER</code>配置对应的标识符，例如<code data-backticks="1" data-nodeid="11136">com.lagou.free</code>和<code data-backticks="1" data-nodeid="11138">com.lagou.paid</code>。</p>\n<p data-nodeid="10814">在 Moments App 中，我们也为各个环境下的 App 使用了不同的标识符，以方便我们通过 CI 自动构建，并分发到内部测试组或者 App Store。同时，这也能为各个环境版本的 App 分离用户行为数据，方便统计分析。</p>\n<p data-nodeid="10815">一旦有了这些 xcconfig 配置文件，今后我们就可以在 Xcode 的 Project Info 页面里的 Configurations 上引用它们。</p>\n<p data-nodeid="10816"><img src="https://s0.lgstatic.com/i/image6/M00/0F/12/Cgp9HWA9EnyAOX4GABH86gYqfAc683.png" alt="Drawing 29.png" data-nodeid="11144"></p>\n<p data-nodeid="10817">下面是所有 Configurations 所引用的 xcconfig 文件。</p>\n<p data-nodeid="10818"><img src="https://s0.lgstatic.com/i/image6/M00/0F/12/Cgp9HWA9EoSARVwGAAZ4k9BLebE007.png" alt="Drawing 31.png" data-nodeid="11148"></p>\n<p data-nodeid="10819">在配置好所有 xcconfig 文件的引用以后，可以在 Build Settings 页面查看某个 Build Setting 的生效值。我们以<code data-backticks="1" data-nodeid="11150">IPHONEOS_DEPLOYMENT_TARGET</code>为例，一起看看。</p>\n<p data-nodeid="10820"><img src="https://s0.lgstatic.com/i/image6/M00/0F/0F/CioPOWA9EoyAfB15AAMBWeDhWeI967.png" alt="Drawing 33.png" data-nodeid="11154"></p>\n<p data-nodeid="10821">当我们选择<strong data-nodeid="11164">All</strong>和<strong data-nodeid="11165">Levels</strong>时，可以看到所有配置信息分成了不同的列。这些列分别代表前面的 Build Settng 优先级：</p>\n<ul data-nodeid="10822">\n<li data-nodeid="10823">\n<p data-nodeid="10824">平台默认值</p>\n</li>\n<li data-nodeid="10825">\n<p data-nodeid="10826">Project 级别的 xcconfig 文件</p>\n</li>\n<li data-nodeid="10827">\n<p data-nodeid="10828">Xcode 项目文件中的 Project 级别配置</p>\n</li>\n<li data-nodeid="10829">\n<p data-nodeid="10830">Target 级别的 xcconfig 文件</p>\n</li>\n<li data-nodeid="10831">\n<p data-nodeid="10832">Xcode 项目文件中的 Target 级别配置</p>\n</li>\n</ul>\n<p data-nodeid="10833">Build Settng 的优先级是从左到右排序的。越是左边优先级就越高。例如，我们在 Project 级别的 xcconfig 文件里面定义了<code data-backticks="1" data-nodeid="11172">IPHONEOS_DEPLOYMENT_TARGET</code>的值为<code data-backticks="1" data-nodeid="11174">14.0</code>，那么Project 级别的 xcconfig 文件（Project Config File） 一列上就会显示<code data-backticks="1" data-nodeid="11176">iOS 14.0</code>，它覆盖了系统的默认值 （iOS Default）<code data-backticks="1" data-nodeid="11178">iOS 14.2</code>。这就是因为 Project 级别的 xcconfig 文件，它的优先级高于系统默认值，因此最后生效的值是<code data-backticks="1" data-nodeid="11180">iOS 14.0</code>。</p>\n<h3 data-nodeid="10834">总结</h3>\n<p data-nodeid="10835">本讲我介绍了如何通过 Build Configuration、 Xcode Scheme 以及 xcconfig 配置文件来统一项目的构建配置，从而搭建出多个不同环境，为后期构建出对应环境的 App 做准备。</p>\n<p data-nodeid="10836"><img src="https://s0.lgstatic.com/i/image6/M00/0F/12/Cgp9HWA9EpaASYdnAAaN1YenVoI219.png" alt="Drawing 34.png" data-nodeid="11186"></p>\n<p data-nodeid="10837">在使用 xcconfig 配置时，还是需要注意以下两点：</p>\n<p data-nodeid="10838">首先，我们必须把所有 Build Setting 都配置在 xcconfig 文件里面，并通过 Git 进行统一管理；</p>\n<p data-nodeid="10839">其次，我们千万不要在 Xcode 的 Build Settings 页面修改任何 Setting，否则该配置会覆盖 xcconfig 文件里面的配置。如果你不小心修改了，可以通过点击删除键把页面是的配置删掉。</p>\n<p data-nodeid="10840">思考题：</p>\n<blockquote data-nodeid="10841">\n<p data-nodeid="10842">请问我们 Moments App 项目的主 App 为什么只使用了一个 Target 吗？如果使用多个 Target，例如 Debug Target，Internal Target 和 Release Target 会有什么问题？</p>\n</blockquote>\n<p data-nodeid="10843">你可以把回答写到下面的留言区哦，下一讲我将介绍如何使用 Swiftlint 统一编码规范。</p>\n<p data-nodeid="10844"><strong data-nodeid="11196">源码地址：</strong></p>\n<blockquote data-nodeid="10845">\n<p data-nodeid="10846"><a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Configurations" data-nodeid="11199">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Configurations</a></p>\n</blockquote>\n<hr data-nodeid="10847">\n<p data-nodeid="10848"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="11204"><img src="https://s0.lgstatic.com/i/image6/M00/08/77/Cgp9HWA0wqWAI70NAAdqMM6w3z0673.png" alt="Drawing 1.png" data-nodeid="11203"></a></p>\n<p data-nodeid="10849"><strong data-nodeid="11208">《大前端高薪训练营》</strong></p>\n<p data-nodeid="10850" class="">12 个月打磨，6 个月训练，优秀学员大厂内推，<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="11212">点击报名，高薪有你</a>！</p>',
          },
          {
            theme: '04 | 编码规范：如何使用 SwiftLint 统一编码规范？',
            id: 13,
            content:
              '<p data-nodeid="10665" class="">在软件开发领域有很多有趣且重要的话题，比如使用什么样的系统架构来让代码更容易维护，使用哪些第三方库能提高开发效率，等等。但也有一些话题不仅无趣，还很难得出结论，比如像下面这行变量定义，里面的空格哪个正确？</p>\n<pre class="lang-java" data-nodeid="10666"><code data-language="java">let name: String = <span class="hljs-string">"Jake"</span>\nlet name : String = <span class="hljs-string">"Jake"</span>\nlet name :String = <span class="hljs-string">"Jake"</span>\nlet name: String= <span class="hljs-string">"Jake"</span>\nlet name: String=<span class="hljs-string">"Jake"</span>\n</code></pre>\n<p data-nodeid="10667">还有代码缩减，到底是用 2 个空格还是 4 个？这就像豆浆到底是喝甜的还是喝咸的一样，并没有标准答案。也因此，出现了许多永无休止的讨论。特别是当新成员所提交的代码风格，与团队其他成员有很大的区别时，往往会出现沟通与协作问题，甚至发生争执而影响工作。此时，团队如果有一套统一的编码规范，那么这样的问题就很容易解决。</p>\n<p data-nodeid="10668">除了能促进沟通协作，一套统一的编码规范还能降低代码维护的成本和减少 Bug 的数量。此外，由于规范往往由团队资深开发者指定并不断完善，也有助于其他团队成员快速成长。</p>\n<p data-nodeid="10669">既然统一的编码规范由那么多优点，那么我们如何在团队中实施统一编码规范呢？在 iOS 开发领域，使用 SwiftLint 能有效地建立和改进 Swift 项目的编码规范。接下来我就和你聊聊这方面的内容。</p>\n<h3 data-nodeid="10670">安装 SwiftLint</h3>\n<p data-nodeid="10671">安装 SwiftLint 的方式有很多种，例如使用 Homebrew，Mint，下载 SwiftLint.pkg 安装包等等。但我只推荐 CocoaPods 这一种方法，因为通过 CocoaPods 可以有效地管理 SwiftLint 的版本，从而保证团队内各个成员都能使用一模一样的 SwiftLint 及其编码规范。</p>\n<p data-nodeid="10672">通过 CocoaPods 来安装 SwiftLint 非常简单。在 Moments App 项目中，我们在<code data-backticks="1" data-nodeid="10736">Podfile</code>文件中添加<code data-backticks="1" data-nodeid="10738">SwiftLint</code>Pod 即可。</p>\n<pre class="lang-java" data-nodeid="10673"><code data-language="java">pod <span class="hljs-string">\'SwiftLint\'</span>, <span class="hljs-string">\'= 0.41.0\'</span>, configurations: [<span class="hljs-string">\'Debug\'</span>]\n</code></pre>\n<p data-nodeid="10674">由于我们只在开发环境下使用 SwiftLint，因此配置了只有<code data-backticks="1" data-nodeid="10741">Debug</code>的 Build Configuration 才生效。</p>\n<p data-nodeid="10675">为了每次编译完都使用 SwiftLint 来检查代码，我们需要在主 App Target<strong data-nodeid="10754">Moments</strong>的 Build Phases 里面添加<strong data-nodeid="10755">Run SwiftLint</strong>步骤。然后配置它执行<code data-backticks="1" data-nodeid="10752">"${PODS_ROOT}/SwiftLint/swiftlint"</code>命令。</p>\n<p data-nodeid="10676"><img src="https://s0.lgstatic.com/i/image6/M00/0F/0F/CioPOWA9Et6AK5ZLAAKntpgVJ2o333.png" alt="Drawing 0.png" data-nodeid="10758"></p>\n<p data-nodeid="10677">这里要注意，由于 SwiftLint 的设计是检查有效的 Swift 代码（编译通过的代码就是有效的代码），我们需要把<strong data-nodeid="10768">Run SwiftLint</strong>步骤放在<strong data-nodeid="10769">Compile Source</strong>步骤之后。否则 SwiftLint 可能会反馈一些错误的结果。</p>\n<p data-nodeid="10678">有了上面的配置以后，每次编译程序， SwiftLint 都会自动执行检查，我们可以在 Xcode 上修正这些警告信息来保证编码规范的统一。</p>\n<p data-nodeid="10679">￼<img src="https://s0.lgstatic.com/i/image6/M01/11/28/CioPOWA_X36AaLBrAAH6eimbZ_o003.png" alt="图片1.png" data-nodeid="10774"></p>\n<p data-nodeid="10680">例如上面的截图所示，SwiftLint 告诉我们空格的使用不正确。</p>\n<p data-nodeid="10681">那么，这些警告信息到底怎样来的呢？我们一起看看<code data-backticks="1" data-nodeid="10777">.swiftlint.yml</code>文件吧。</p>\n<h3 data-nodeid="10682">.swiftlint.yml 文件</h3>\n<p data-nodeid="10683">当我们执行 SwiftLint 命令时，它会自动帮我们启动一堆编码规则，并扫描和检查我们的项目。这些规则有<code data-backticks="1" data-nodeid="10781">comma</code>（逗号前后的空格处理），<code data-backticks="1" data-nodeid="10783">private_over_fileprivate</code>（优先使用 priviate），<code data-backticks="1" data-nodeid="10785">force_cast</code>（避免强制转型）等等 。详细规则列表你也可以在<a href="https://realm.github.io/SwiftLint/rule-directory.html" data-nodeid="10789">SwiftLint 官网</a>找到。</p>\n<p data-nodeid="10684">但正如 SwiftLint 的作者所说： “规则存在，但并不意味着你必须用它”。我们需要根据团队自身的情况和成员的统一意见，来决定需要启动和关闭哪些规则。此时，就需要用到 .swiftlint.yml 文件了。</p>\n<p data-nodeid="10685"><strong data-nodeid="10796">.swiftlint.yml</strong>主要用于启动和关闭 SwiftLint 所提供的规则，以及自定义配置与规则。一旦我们有了 .swiftlint.yml 文件以后，SwiftLint 在执行过程中会严格按照该文件的定义来扫描和检查代码。由于 .swiftlint.yml 是一个纯文本文件，我们可以通过 Git 统一管理，这样能保证整个团队在执行 SwiftLint 的时候都会得到一模一样的效果，从而保证了整个团队代码规范的一致性。</p>\n<h3 data-nodeid="10686">规则设置</h3>\n<p data-nodeid="10687">SwiftLint 提供了<code data-backticks="1" data-nodeid="10799">disabled_rules</code>,<code data-backticks="1" data-nodeid="10801">opt_in_rules</code>和<code data-backticks="1" data-nodeid="10803">only_rules</code>三种规则设置方法。其中，￼￼<code data-backticks="1" data-nodeid="10805">disabled_rules</code>能帮我们关闭默认生效的规则，而<code data-backticks="1" data-nodeid="10807">opt_in_rules</code>可以启动默认关闭的规则。</p>\n<p data-nodeid="10688">另外，SwiftLint 所提供的每条规则都有一个叫作<strong data-nodeid="10818">Enabled by default</strong>的属性来表示该规则是否默认启动。例如<code data-backticks="1" data-nodeid="10814">class_delegate_protocol</code>规则是默认启动的，而<code data-backticks="1" data-nodeid="10816">array_init</code>规则是默认关闭的。</p>\n<pre class="lang-java" data-nodeid="10689"><code data-language="java">disabled_rules:\n  - class_delegate_protocol\nopt_in_rules:\n  - array_init\n</code></pre>\n<p data-nodeid="10690">上面的配置表示，关闭默认生效的<code data-backticks="1" data-nodeid="10820">class_delegate_protocol</code>，并同时启动<code data-backticks="1" data-nodeid="10822">array_init</code>。</p>\n<p data-nodeid="10691">虽然使用<code data-backticks="1" data-nodeid="10825">disabled_rules</code>和<code data-backticks="1" data-nodeid="10827">opt_in_rules</code>能够完成配置，但我不推荐你使用它们&nbsp;，而是用<code data-backticks="1" data-nodeid="10829">only_rules</code>来定义每条生效的规则。</p>\n<p data-nodeid="10692">我们在 Moments App 项目中也使用了<code data-backticks="1" data-nodeid="10832">only_rules</code>。你可以在<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/.swiftlint.yml" data-nodeid="10836">拉勾教育的代码仓库</a>找到该 .swiftlint.yml 文件来查看项目启动的所有规则。由于<code data-backticks="1" data-nodeid="10838">only_rules</code>是 SwiftLint 0.41.0 引入的，如果你需要以前版本，可以使用<code data-backticks="1" data-nodeid="10840">whitelist_rules</code>来替代。下面是 .swiftlint.yml 文件中的部分规则。</p>\n<pre class="lang-java" data-nodeid="10693"><code data-language="java">only_rules:\n  - array_init\n  - attributes\n  - block_based_kvo\n  - class_delegate_protocol\n  - closing_brace\n</code></pre>\n<p data-nodeid="10694">通过<code data-backticks="1" data-nodeid="10843">only_rules</code>，我们可以把每一条规则明确添加到 SwiftLint 里面。这样能保证我们整个团队都使用一致的规则，而不会像使用<code data-backticks="1" data-nodeid="10845">disabled_rules</code>和<code data-backticks="1" data-nodeid="10847">opt_in_rules</code>那样，随着 SwiftLint 默认规则的改变，导致最终启动的规则不一样。</p>\n<h4 data-nodeid="10695">自定义配置</h4>\n<p data-nodeid="10696">在我们配置一条规则的时候，为了符合团队自身的情况，可以修改其默认配置。例如<code data-backticks="1" data-nodeid="10851">line_length</code>的默认配置是当一行代码多于 120 个字符的时候会报告编译警告，而多于 200 个字符的时候报告编译错误。</p>\n<p data-nodeid="10697"><img src="https://s0.lgstatic.com/i/image6/M01/11/2B/Cgp9HWA_X6yAHMc8AAHVx2uT2fY153.png" alt="图片2.png" data-nodeid="10855"></p>\n<div data-nodeid="10698"><p style="text-align:center">来源：SwiftLintFramework Docs</p></div>\n<p data-nodeid="10699">我们可以在 .swiftlint.yml 文件中修改这些配置。</p>\n<pre class="lang-java" data-nodeid="10700"><code data-language="java">line_length: <span class="hljs-number">110</span>\nfile_length:\n  warning: <span class="hljs-number">500</span>\n  error: <span class="hljs-number">1200</span>\n</code></pre>\n<p data-nodeid="10701">上述的配置表示我们修改了<code data-backticks="1" data-nodeid="10858">line_length</code>的配置，当一行代码多于 110 个字符（而不是默认的 120 个字符）时就会报告编译警告。我们也可以同时覆盖编译警告和编译错误的配置，例如把<code data-backticks="1" data-nodeid="10860">file_length</code>的编译警告改成 500，而编译错误改成 1200。</p>\n<h4 data-nodeid="10702">自定义规则</h4>\n<p data-nodeid="10703">除了 SwiftLint 所提供的默认规则以外，我们还可以自定义规则。例如在 Moments App 项目中，我就自定义了“不能硬编码字符串”的规则，具体如下：</p>\n<pre class="lang-java" data-nodeid="10704"><code data-language="java">custom_rules:\n  no_hardcoded_strings:\n    regex: <span class="hljs-string">"([A-Za-z]+)"</span>\n    match_kinds: string\n    message: <span class="hljs-string">"Please do not hardcode strings and add them to the appropriate `Localizable.strings` file; a build script compiles all strings into strongly typed resources available through `Generated/Strings.swift`, e.g. `L10n.accessCamera"</span>\n    severity: warning\n</code></pre>\n<p data-nodeid="10705">该规则<code data-backticks="1" data-nodeid="10865">no_hardcoded_strings</code>会通过正则表达式来检查字符串是否进行了硬编码。如果是SwiftLint 会根据我们的自定义规则显示警告信息，如下图所示。</p>\n<p data-nodeid="10706"><img src="https://s0.lgstatic.com/i/image6/M00/11/2C/Cgp9HWA_X_2AWg7XAAJqf2s12IA729.png" alt="图片4.png" data-nodeid="10869"></p>\n<h4 data-nodeid="10707">排除扫描文件</h4>\n<p data-nodeid="10708">默认情况下 SwiftLint 会扫描和检查整个项目的所有代码。因为一些第三方依赖库的源码风格可能和我们团队的风格不一致，为了方便使用第三方依赖库，我们可以用<code data-backticks="1" data-nodeid="10872">excluded</code>来把它排除在外，避免扫描和检查。示例如下：</p>\n<pre class="lang-java" data-nodeid="10709"><code data-language="java">excluded:\n  - Pods\n</code></pre>\n<p data-nodeid="10710">现在我们已经通过配置 .swiftlint.yml 文件来帮助我们统一编码规范了。</p>\n<h3 data-nodeid="10711">总结</h3>\n<p data-nodeid="10712">在这一讲，我介绍了如何使用 SwiftLint 来统一编码规范。特别是其中的<code data-backticks="1" data-nodeid="10877">only_rules</code>，我们要使用它来定义需要生效的规则。</p>\n<p data-nodeid="10713"><img src="https://s0.lgstatic.com/i/image6/M00/11/29/Cgp9HWA_XxiAF_9EAAJXiOcRtSY049.png" alt="思维导图+二维码.png" data-nodeid="10881"></p>\n<p data-nodeid="10714">此外，在制定编码规范时，我们还需要注意以下几点。</p>\n<p data-nodeid="10715">首先，所制定的规范要和业界标准同步，这能让新成员接手代码时，更容易接受而不是反驳。一个建议是，你可以从 SwiftLint 所提供的默认规则开始，毕竟这些规则都是通过许多人沟通和完善下来的，比你独自一人想出来要靠谱得多。</p>\n<p data-nodeid="10716">其次，在制定规范时，重点是提高代码的可读性，而不是为了高大上去使用黑魔法或者选择那些不常用功能等。这样可以让团队绝大部分成员更容易理解和遵循这些规范。</p>\n<p data-nodeid="10717">最后要强调的是，一套编码规范是需要不断迭代和完善的，我建议团队要定时 Retro（Retrospective，敏捷回顾），讨论和优化这些规范，让得大家都有机会贡献到规范中，增加他的认同感。这种做法在多团队平行开发的环境下特别有效。</p>\n<p data-nodeid="10718">思考题：</p>\n<blockquote data-nodeid="10719">\n<p data-nodeid="10720">你所做的团队除了使用 SwiftLint 等工具检查以外，还使用了哪些手段来保证编码规范的统一呢？</p>\n</blockquote>\n<p data-nodeid="10721">请把回答写到下面的留言区哦，下一讲我将介绍如何使用 Fastlane 执行自动化操作。</p>\n<p data-nodeid="10722"><strong data-nodeid="10892">源码地址：</strong></p>\n<blockquote data-nodeid="10723">\n<p data-nodeid="10724">swiftlint.yml 文件<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/.swiftlint.yml" data-nodeid="10897">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/.swiftlint.yml</a></p>\n</blockquote>\n<hr data-nodeid="10725">\n<p data-nodeid="10726"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="10902"><img src="https://s0.lgstatic.com/i/image6/M00/08/77/Cgp9HWA0wqWAI70NAAdqMM6w3z0673.png" alt="Drawing 1.png" data-nodeid="10901"></a></p>\n<p data-nodeid="10727"><strong data-nodeid="10906">《大前端高薪训练营》</strong></p>\n<p data-nodeid="10728" class="te-preview-highlight">12 个月打磨，6 个月训练，优秀学员大厂内推，<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="10910">点击报名，高薪有你</a>！</p>',
          },
          {
            theme: '05 | 自动化准备：如何使用 Fastlane 管理自动化操作？',
            id: 14,
            content:
              '<p data-nodeid="1141" class="">要成为一个优秀的 iOS 开发者，我们要做的事情远多于“开发”，例如我们要构建和打包 App，管理证书，为 App 进行签名，把 App 分发给测试组，上传 App 到 App Store，等等。这些操作不但繁琐费时，而且容易出错。那么，有没有更便利的方法呢？有，那就是使用 fastlane 来完成这些重复性的工作。接下来这一讲，我们主要聊的也就是这个主题。</p>\n<h3 data-nodeid="1142">fastlane 安装</h3>\n<p data-nodeid="1143"><strong data-nodeid="1239">fastlane</strong> 是用 Ruby 语言编写的一个命令行工具，可以自动化几乎所有 iOS 开发所需要的操作，例如自动打包和签名 App，自动上传到 App Store 等等。有了 fastlane，我们就可以开发一套统一的、可靠的和可共享的配置，团队所有成员都可以通过这套配置实现自动化操作，减少重复性劳动。</p>\n<p data-nodeid="1144">如何安装 fastlane 呢？我记得在第一讲就曾提到过，可以使用 Bundler 来安装，只需要在 Gemfile 文件里面添加以下一行即可：</p>\n<pre class="lang-java" data-nodeid="1145"><code data-language="java">gem <span class="hljs-string">"fastlane"</span>, <span class="hljs-string">"2.166.0"</span>\n</code></pre>\n<p data-nodeid="1146">注意，由于是通过 Bundler 来安装 fastlane，每次执行 fastlane 命令前，都需要加上<code data-backticks="1" data-nodeid="1242">bundle exec</code>（<code data-backticks="1" data-nodeid="1244">bundle exec fastlane</code>）。不过为了简洁，在这里后面凡涉及 fastlane 命令时，我会省略<code data-backticks="1" data-nodeid="1246">bundle exec</code>部分。</p>\n<h3 data-nodeid="1147">Action 与 Lane</h3>\n<p data-nodeid="1148">fastlane 为我们提供了一百多个 Action，它们是 iOS 项目开发中所有自动化操作的基础。所谓的<strong data-nodeid="1254">Action</strong>，你可以理解成是 fastlane 自动化流程中的最小执行单元。一般常用的 Action 有：</p>\n<ul data-nodeid="1149">\n<li data-nodeid="1150">\n<p data-nodeid="1151">scan，用于自动测试 App；</p>\n</li>\n<li data-nodeid="1152">\n<p data-nodeid="1153">cert，用于自动生成和管理 iOS App 签名的证书；</p>\n</li>\n<li data-nodeid="1154">\n<p data-nodeid="1155">sigh，用于自动生成、更新、下载和修复 Provisioning Profile；</p>\n</li>\n<li data-nodeid="1156">\n<p data-nodeid="1157">match，为整个团队自动管理和同步证书和 Provisioning Profile；</p>\n</li>\n<li data-nodeid="1158">\n<p data-nodeid="1159">gym，用于自动构建和打包 App；</p>\n</li>\n<li data-nodeid="1160">\n<p data-nodeid="1161">snapshot，用于自动在不同设备上截屏；</p>\n</li>\n<li data-nodeid="1162">\n<p data-nodeid="1163">pilot，用于自动把 App 部署到 TestFlight 并管理测试用户；</p>\n</li>\n<li data-nodeid="1164">\n<p data-nodeid="1165">deliver，用于自动把 App 上传到 App Store；</p>\n</li>\n<li data-nodeid="1166">\n<p data-nodeid="1167">pem，用于自动生成和更新推送消息的 Profile。</p>\n</li>\n</ul>\n<p data-nodeid="1168">这些 Action 怎么执行呢？我们可以通过<code data-backticks="1" data-nodeid="1265">fastlane &lt;action&gt;</code>（例如<code data-backticks="1" data-nodeid="1267">fastlane scan</code>）来执行。下面是执行效果，它提示我选择其中一个 Scheme 来继续执行。</p>\n<p data-nodeid="1169"><img src="https://s0.lgstatic.com/i/image6/M00/16/10/CioPOWBF-DaAV56WAAR8Ne2bQ4c230.png" alt="Drawing 0.png" data-nodeid="1271"></p>\n<p data-nodeid="1170">从运行情况可知，尽管这些 Action 为我们提供了不少便利，但还是需要手工输入来继续。所以，我不推荐你直接使用这些 Action，而是根据项目需要，在开发自己的自动化操作时通过传入合适的参数来调用 fastlane 所提供的 Action。</p>\n<p data-nodeid="1171">具体来说，我们可以把所需的 Action 组合在一起，开发出对应的自动化操作。在 fastlane 中，我们把这个自动化操作或者任务叫作 <strong data-nodeid="1281">Lane</strong>。<strong data-nodeid="1282">实际上， iOS 开发中的所有自动化操作，主要通过 Lane 来封装和配置的。</strong></p>\n<p data-nodeid="1172"><img src="https://s0.lgstatic.com/i/image6/M00/16/10/CioPOWBF-EqACKcpAAC6PT8Ghi4740.png" alt="Drawing 2.png" data-nodeid="1285"></p>\n<p data-nodeid="1173">Lane 和 Action 的关系如上图所示， 一条 Lane 可以通过参数调用一个或几个 Action 。以 Moments app&nbsp;为例，我们要自动打包和签名 App，那么我就建了一条名叫<code data-backticks="1" data-nodeid="1287">archive_appstore</code>的 Lane。因为这条 Lane 用到的“更新签名”和“打包”在 fastalne 里已经提供了相关的 Action——<code data-backticks="1" data-nodeid="1289">update_code_signing_settings</code>和<code data-backticks="1" data-nodeid="1291">gym</code>，我就可以到它官网去寻找，从而减轻了开发工作量。</p>\n<p data-nodeid="1174">一般，iOS 项目所需的自动化操作都配置为 Lane 并保存在 Fastfile 文件，由 Git 统一管理起来，共享给所有成员。然后，大家就可以使用统一的自动化配置了。</p>\n<p data-nodeid="1175">这里的 Fastfile 文件是怎么出来的呢？</p>\n<p data-nodeid="1176">它是由<code data-backticks="1" data-nodeid="1296">fastlane init</code>命令自动生成。这条命令会建立一个 fastlane 文件夹，文件夹里除了 Fastfile ，还有 Appfile，以及执行过程中所生成的一些中间文件（如截图、日志与报告等）。因为我们之前已经在 .gitignore 文件里把这些中间文件忽略了，因此这些中间文件不再保存到 Git 里面。</p>\n<p data-nodeid="1177">fastlane 文件夹里的 Appfile，用于保存 App 的唯一标识符和 Apple ID 等信息。当 fastlane 在执行一个 Action 的时候，首先会使用传递进来的参数，当参数没有传递进来时，fastlane 会从 Appfile 文件中查找并使用对应的信息。</p>\n<p data-nodeid="1178">比如，我们在 Appfile 配置了<code data-backticks="1" data-nodeid="1300">app_identifier "com.ibanimatable.moments"</code>以后，在调用<code data-backticks="1" data-nodeid="1302">match</code>Action 时可以不传入<code data-backticks="1" data-nodeid="1304">app_identifier</code>参数，fastlane 会自动把<code data-backticks="1" data-nodeid="1306">"com.ibanimatable.moments"</code>作为<code data-backticks="1" data-nodeid="1308">app_identifier</code>的值进行调用。</p>\n<p data-nodeid="1179">但是为了方便管理所有的 Lane ，保证每次执行的效果都一样，我建议在每次调用 Action 的时候，都明确传递每一个所需的参数，而不是从 Appfile 文件读取。下面我就演示下如何明确传递每一个参数来执行<code data-backticks="1" data-nodeid="1311">match</code>Action。</p>\n<pre class="lang-java" data-nodeid="1180"><code data-language="java">  match(\n&nbsp; &nbsp; &nbsp; type: "appstore",\n&nbsp; &nbsp; &nbsp; force: true,\n&nbsp; &nbsp; &nbsp; storage_mode: "git",\n&nbsp; &nbsp; &nbsp; git_url: "https://github.com/JakeLin/moments-codesign",\n&nbsp; &nbsp; &nbsp; app_identifier: "com.ibanimatable.moments", # pass  app_identifier explicitly\n&nbsp; &nbsp; &nbsp; team_id: "6HLFCRTYQU",\n&nbsp; &nbsp; &nbsp; api_key: api_key\n  )\n</code></pre>\n<h3 data-nodeid="1181">常用 Lane 定义</h3>\n<p data-nodeid="1182">通过上面的介绍你已经知道，我们会使用 Lane 来封装项目所需的各个自动化操作。那么，这些 Lane 是如何开发定义的呢？接下来，我就为你介绍几种非常实用的 Lane，一起来看看怎么做。</p>\n<h4 data-nodeid="1183">扫描和检查代码</h4>\n<p data-nodeid="1184">每条 Lane 的定义都是放在一个<code data-backticks="1" data-nodeid="1317">lane &lt;lane_name&gt; do &lt;lane_body&gt; end</code>的代码块里面。它以关键字<code data-backticks="1" data-nodeid="1319">lane</code>开头，接着是这条 Lane 的名字。 下面是用于检查代码的 Lane 源码。</p>\n<pre class="lang-ruby" data-nodeid="1185"><code data-language="ruby">lane <span class="hljs-symbol">:lint_code</span> <span class="hljs-keyword">do</span>\n  puts(<span class="hljs-string">"Lint code using SwfitLint"</span>)\n  swiftlint(\n    <span class="hljs-symbol">mode:</span> <span class="hljs-symbol">:lint</span>,\n    <span class="hljs-symbol">executable:</span> <span class="hljs-string">"./Pods/SwiftLint/swiftlint"</span>,  <span class="hljs-comment"># Important if you\'ve installed it via CocoaPods</span>\n    <span class="hljs-symbol">config_file:</span> <span class="hljs-string">\'./Moments/.swiftlint.yml\'</span>,\n    <span class="hljs-symbol">raise_if_swiftlint_error:</span> <span class="hljs-literal">true</span>)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1186">在上面的例子中，我们定义了一个叫作<code data-backticks="1" data-nodeid="1322">lint_code</code>的 Lane。因为 fastlane 使用 Ruby 开发，所以在 Fastfile 里面，Lane 的名字也遵循它的编码规范，使用小写字母和下划线组合的蛇式命名法。</p>\n<p data-nodeid="1187">Lane 的实现逻辑放在<code data-backticks="1" data-nodeid="1325">do</code>和<code data-backticks="1" data-nodeid="1327">end</code>中间，我们可以调用 fastlane 提供的任意 Action。在这个例子中我们就调用了<code data-backticks="1" data-nodeid="1329">swiftlint</code>Action，并把<code data-backticks="1" data-nodeid="1331">lint</code>传递给<code data-backticks="1" data-nodeid="1333">mode</code>参数，以此来执行代码扫描和检查操作。</p>\n<p data-nodeid="1188">特别需要注意的是，由于我们之前使用了 CocoaPods 来安装 SwiftLint，因此要为<code data-backticks="1" data-nodeid="1336">executable</code>参数指定 SwiftLint 的安装路径<code data-backticks="1" data-nodeid="1338">./Pods/SwiftLint/swiftlint</code>。同时要把 .swiftlint.yml 文件的所在路径也传递给<code data-backticks="1" data-nodeid="1340">config_file</code>参数。这样就能保证 fastlane 使用了统一的 SwiftLint 版本和规则文件，方便团队所有人执行该 Lane 时得到统一的效果。</p>\n<p data-nodeid="2287" class="te-preview-highlight">当一条 Lane 开发配置完毕以后，我们就可以在项目的根目录执行 <code data-backticks="1" data-nodeid="2289">fastlane &lt;lane_name&gt;</code>。比如扫描和检查代码的 Lane ，我们可以在终端输入<code data-backticks="1" data-nodeid="2291">fastlane lint_code</code>看到它的执行效果。</p>\n\n\n<blockquote data-nodeid="1190">\n<p data-nodeid="1191">Driving the lane \'ios lint_code\'<br>\nLint code using SwfitLint<br>\n--- Step: swiftlint ---<br>\n$ ./Pods/SwiftLint/swiftlint lint --config ./Moments/.swiftlint.yml<br>\nLinting Swift files in current working directory<br>\nLinting \'Strings.swift\' (1/87)<br>\nLinting \'MomentListItemViewModel.swift\' (2/87)<br>\nLinting ......s</p>\n<p data-nodeid="1192">UIButtonExtensions.swift:14:46: warning: no_hardcoded_strings Violation: Please do not hardcode strings and add them to the appropriate <code data-backticks="1" data-nodeid="1386">Localizable.strings</code> file; a build script compiles all strings into strongly typed resources available through <code data-backticks="1" data-nodeid="1388">Generated/Strings.swift</code>, e.g. `L10n.accessCamera (no_hardcoded_strings)<br>\nDone linting! Found 6 violations, 0 serious in 87 files.<br>\nfastlane.tools finished successfully</p>\n</blockquote>\n<p data-nodeid="1193">在执行过程中，fastlane 先从 Fastfile 文件里名叫<code data-backticks="1" data-nodeid="1403">lint_code</code>的 Lane 的定义，然后执行了该 Lane 里使用到的 swiftlint Action。swiftlint Action 会把项目下 87 个 Swift 源代码文件进行扫描和检查，并把所有不符合规范的代码提示给我们。</p>\n<h4 data-nodeid="1194">格式化代码</h4>\n<p data-nodeid="1195">检查代码之后，接下来就是清理不符合规范的代码，比如删掉所有代码中不必要的空格或者空行，修正缩进的大小等等。我们可以定义一条叫作<code data-backticks="1" data-nodeid="1407">format_code</code>的 Lane 来执行该功能。有了它以后，我们只需要执行<code data-backticks="1" data-nodeid="1409">fastlane format_code</code>就能把整个项目所有的代码进行格式化。</p>\n<pre class="lang-ruby" data-nodeid="1196"><code data-language="ruby">lane <span class="hljs-symbol">:format_code</span> <span class="hljs-keyword">do</span>\n  puts(<span class="hljs-string">"Lint and format code using SwfitLint"</span>)\n  swiftlint(\n    <span class="hljs-symbol">mode:</span> <span class="hljs-symbol">:autocorrect</span>,\n    <span class="hljs-symbol">executable:</span> <span class="hljs-string">"./Pods/SwiftLint/swiftlint"</span>,  <span class="hljs-comment"># Important if you\'ve installed it via CocoaPods</span>\n    <span class="hljs-symbol">config_file:</span> <span class="hljs-string">\'./Moments/.swiftlint.yml\'</span>,\n    <span class="hljs-symbol">raise_if_swiftlint_error:</span> <span class="hljs-literal">true</span>)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1197"><code data-backticks="1" data-nodeid="1411">format_code</code>和<code data-backticks="1" data-nodeid="1413">lint_code</code>两条 Lane 都使用了<code data-backticks="1" data-nodeid="1415">swiftlint</code>Action，唯一不同的地方是为<code data-backticks="1" data-nodeid="1417">mode</code>参数传递了<code data-backticks="1" data-nodeid="1419">autocorrect</code>。</p>\n<h4 data-nodeid="1198">排序 Xcode 项目文件列表</h4>\n<p data-nodeid="1199">在多人开发的项目下，我们经常会修改项目文件，这往往很容易引起合并冲突，而合并 xcodeproj 文件又是一件非常麻烦的事情。怎么办呢？</p>\n<p data-nodeid="1200">一个有效办法就是在每次新建源代码和资源文件时，把 xcodeproj 里面的文件列表进行重新排序。这样能极大地减低合并冲突的发生。我们把这一个经常使用到的操作也配置到 Fastfile 里面，如下所示。</p>\n<pre class="lang-ruby" data-nodeid="1201"><code data-language="ruby">lane <span class="hljs-symbol">:sort_files</span> <span class="hljs-keyword">do</span>\n  puts(<span class="hljs-string">"Sort the files for the Xcode project"</span>)\n  sh <span class="hljs-string">"../scripts/sort-Xcode-project-file.pl ../Moments/Moments.xcodeproj"</span>\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1202">可以看到，fastlane 除了能调用其提供的 Action 以外，还可以通过<code data-backticks="1" data-nodeid="1425">sh</code>来调用其他程序命令。在这里我们调用了由苹果公司提供的一个<strong data-nodeid="1435">Perl 程序来为 xcodeproj 里面的文件列表进行排序</strong>。你也可以在<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/scripts/sort-Xcode-project-file.pl" data-nodeid="1433">拉勾教育的代码仓库</a>找到这个Perl 程序。</p>\n<h4 data-nodeid="1203">调用其他 Lane 操作</h4>\n<p data-nodeid="1204">除了调用一些程序命令（如<code data-backticks="1" data-nodeid="1438">sh</code>）以外，一条 Lane 还可以调用 Fastfile 里面其他的 Lane。例如我们定义了一条叫作<code data-backticks="1" data-nodeid="1440">prepare_pr</code>的 Lane ，它可以帮我们在提交 Pull Request 之前做一些必要的准备。下面这个代码表示的就是，这条 Lane 在内部调用了另外两条 Lane ——<code data-backticks="1" data-nodeid="1442">format_code</code>和<code data-backticks="1" data-nodeid="1444">sort_files</code>，以此来同时完成格式化代码和排序 Xcode 项目文件列表的操作。</p>\n<pre class="lang-ruby" data-nodeid="1205"><code data-language="ruby">lane <span class="hljs-symbol">:prepare_pr</span> <span class="hljs-keyword">do</span>\n  format_code\n  sort_files\n<span class="hljs-keyword">end</span>\n</code></pre>\n<h4 data-nodeid="1206">定义私有 Lane 和返回值</h4>\n<p data-nodeid="1207">类似于 Swift 语言能通过<code data-backticks="1" data-nodeid="1448">private</code>来定义内部使用的方法，我们也能定义私有 Lane 给Fastfile 内的其他 Lane 所调用，提高代码的复用。其做法就是把原先的关键字<code data-backticks="1" data-nodeid="1450">lane</code>替换成<code data-backticks="1" data-nodeid="1452">private_lane</code>。例如我们定义一条叫作<code data-backticks="1" data-nodeid="1454">get_pi</code>的私有 Lane，代码如下。</p>\n<pre class="lang-ruby" data-nodeid="1208"><code data-language="ruby">private_lane <span class="hljs-symbol">:get_pi</span> <span class="hljs-keyword">do</span>\n  pi = <span class="hljs-number">3.1415</span>\n  pi\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1209">该 Lane 的实现体有两行代码，第一行是给一个临时变量<code data-backticks="1" data-nodeid="1457">pi</code>赋值。第二行表示把<code data-backticks="1" data-nodeid="1459">pi</code>作为返回值传递给调用者。例如下面就演示了如何调用<code data-backticks="1" data-nodeid="1461">get_pi</code>并取得返回值。</p>\n<pre class="lang-ruby" data-nodeid="1210"><code data-language="ruby">lane <span class="hljs-symbol">:foo</span> <span class="hljs-keyword">do</span>\n  pi = get_pi\n  puts(pi)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1211">这是执行<code data-backticks="1" data-nodeid="1464">fastlane foo</code>的结果：</p>\n<blockquote data-nodeid="1212">\n<p data-nodeid="1213">Driving the lane \'ios foo\'<br>\n--- Step: Switch to ios get_pi lane ---<br>\nCruising over to lane \'ios get_pi\'<br>\nCruising back to lane \'ios foo\'<br>\n3.1415</p>\n</blockquote>\n<p data-nodeid="1214">fastlane 首先调用<code data-backticks="1" data-nodeid="1495">foo</code>Lane，然后进去<code data-backticks="1" data-nodeid="1497">get_pi</code>Lane 并返回到<code data-backticks="1" data-nodeid="1499">foo</code>，同时把返回结果打印出来。</p>\n<h3 data-nodeid="1215">总结</h3>\n<p data-nodeid="1216">这一讲我介绍了如何从头开始搭建一个 fastlane 环境。在这里需要注意三点：</p>\n<ol data-nodeid="1217">\n<li data-nodeid="1218">\n<p data-nodeid="1219">不要单独手工执行 fastlane 所提供的 Action，而是使用 Fastfile 文件来统一开发、配置和管理日常中经常使用的所有自动化操作；</p>\n</li>\n<li data-nodeid="1220">\n<p data-nodeid="1221">在开发我们的 Lane 时，要优先使用和调用 fastlane 提供的 Action，因为这些 Action 都是经过社区完善的，且会随着 Xcode 版本的升级而更新；</p>\n</li>\n<li data-nodeid="1222">\n<p data-nodeid="1223">当我们调用 fastlane 所提供的 Action 时，要明确传递各个参数，在执行过程中就无须任何手工交互就能从头到尾执行整个操作。</p>\n</li>\n</ol>\n<p data-nodeid="1224"><img src="https://s0.lgstatic.com/i/image6/M00/16/13/Cgp9HWBF-HeACPAgAAQVQ3FLLec967.png" alt="Drawing 4.png" data-nodeid="1508"></p>\n<p data-nodeid="1225">有了项目需要的所有 Lane 以后，能有效减轻团队成员的重复劳动，并为项目的自动化和工程化打下坚实的基础。在后面的章节中，我会详细介绍如何使用 fastlane 来管理证书，打包 App 和上传到 App Store。</p>\n<p data-nodeid="1226">思考题：</p>\n<blockquote data-nodeid="1227">\n<p data-nodeid="1228">在你的项目中是怎样实施自动化的？如果你是第一次使用 fastlane，请按照上述的文章和 fastlane 的官方文档来开发一条执行测试的 Lane。</p>\n</blockquote>\n<p data-nodeid="1229">可以把你的答案写得留言区哦，下一讲我将介绍如何使用 Git 与 GitHub 统一代码管理流程。</p>\n<p data-nodeid="1230"><strong data-nodeid="1516">源码地址：</strong></p>\n<blockquote data-nodeid="1231">\n<p data-nodeid="1232" class="">Fastfile 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L19-L50" data-nodeid="1520">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L19-L50</a></p>\n</blockquote>',
          },
          {
            theme: '06 | 代码管理：如何使用 Git 与 GitHub 统一代码管理流程？',
            id: 15,
            content:
              '<p data-nodeid="808" class="">在软件开发当中，代码管理一直是其中重要的一环，每当软件出现问题，我们就需要查看源码，及时发现其中的漏洞加以修复。并且，由于分工不同，软件开发需要多个人共同完成，如何保证每个人编写的代码符合要求，能够相互配合，也是一个重要的问题。所以，一个非常实用的代码管理工具和一套统一的代码管理流程在开发当中必不可少。</p>\n<p data-nodeid="809">而在这方面，StackOverflow 曾调查发现，有超过 87% 的开发者使用 Git，有超过 82% 的开发者使用 GitHub 来进行代码托管和开发协作。可以说，熟练使用 Git 和 GitHub 已经成为开发者的基本技能，而如何结合它们来规范代码管理也是 iOS 开发工程化实践当中的基础。</p>\n<h3 data-nodeid="810">Git 分支管理</h3>\n<p data-nodeid="811">现代的软件开发活动通常需要多人参与。为了保证不同开发者可以同时贡献到同一个代码库，Git 提供了分支（Branch）来支持并行开发。不同团队有不同的 Git 分支管理方式，根据我们团队多年的经验，经过不断的完善，最终形成出一套简单并十分有效的 Git 分支管理规范，你可以参考下。这套规范是怎样的呢？</p>\n<p data-nodeid="812">具体来说，我把所有的 Git 分支分成三类：<strong data-nodeid="890">主分支，功能分支和发布分支</strong>，让它们各自承担不同的功能。</p>\n<p data-nodeid="813">其中主分支也称为<code data-backticks="1" data-nodeid="892">master</code>或者<code data-backticks="1" data-nodeid="894">main</code>分支， 是 Git 代码仓库的默认分支。在 Xcode 12 以后，新建项目时也会默认生成命名为<code data-backticks="1" data-nodeid="896">main</code>的主分支。</p>\n<p data-nodeid="814">主分支在软件开发中非常重要，它是我们 App 的唯一的信息源（Single source of truth），不论是编译出不同版本的 App 还是排查问题，都需要用到主分支的代码。并且，团队同事的代码，最终也必须汇总到这个主分支中，且不能出错。所以，<strong data-nodeid="902">所谓的统一代码管理流程，就是制定其他分支的代码如何合并到主分支的流程。</strong></p>\n<p data-nodeid="815"><strong data-nodeid="907">功能分支</strong>是我们在开发过程中建立的临时分支，它可以用来保存一次开发活动的状态。根据不同的开发活动，我把功能分支分成几个小类。</p>\n<ol data-nodeid="816">\n<li data-nodeid="817">\n<p data-nodeid="818"><code data-backticks="1" data-nodeid="908">feature</code>分支，当开发一个新功能的时候，我会为每一个功能建立一个叫作<code data-backticks="1" data-nodeid="910">feature</code>分支，当整个功能完成后就<del data-nodeid="916">可以</del>合并到主分支里面，并把该分支从 Git 代码仓库中删除掉。</p>\n</li>\n<li data-nodeid="819">\n<p data-nodeid="820"><code data-backticks="1" data-nodeid="917">bugfix</code>分支，当发现 Bug 的时候，会专门建立一个<code data-backticks="1" data-nodeid="919">bugfix</code>分支，修改 Bug 后把它合并到主分支里面去。</p>\n</li>\n<li data-nodeid="821">\n<p data-nodeid="822"><code data-backticks="1" data-nodeid="921">spike</code>分支，当我们探索或研究一些新技术（如 App Clips 功能）的时候，会建立一个叫作<code data-backticks="1" data-nodeid="923">spike</code>的分支。在得出结论以后，我才决定是否把该分支合并到主分支。如果探索失败，我就不会把相关的<code data-backticks="1" data-nodeid="925">spike</code>分支合并到主分支了。</p>\n</li>\n</ol>\n<p data-nodeid="823">在新建一个功能分支的时候，我们都遵循一定的命名规范，一般会把功能的描述作为分支的名称。例如当我们要开发一个点赞功能时，会把该分支可以命名为<code data-backticks="1" data-nodeid="928">feature/add-like-button-to-moments-screen</code>。又例如当我们需要修改用户头像的一个 UI Bug 时，会把分支命名为<code data-backticks="1" data-nodeid="930">bugfix/fix-avatar-ui-bug</code>。</p>\n<p data-nodeid="824">有那么多功能分支，在并行开发过程中我们该如何管理它们呢？</p>\n<p data-nodeid="825">来看下面这幅。</p>\n<p data-nodeid="826"><img src="https://s0.lgstatic.com/i/image6/M00/16/11/CioPOWBF-duAKS0tAAC-6ZH1k9w147.png" alt="Drawing 0.png" data-nodeid="936"></p>\n<p data-nodeid="827">举例来说，我有一个同事要开发点赞功能，他就从主分支最新的<code data-backticks="1" data-nodeid="938">MC1</code>commit 签出（checkout）并新建<code data-backticks="1" data-nodeid="940">feature/add-like-button-to-moments-screen</code>来进行点赞功能的开发。与此同时，另外一个同事发现了一个用户头像的 UI Bug，她也从<code data-backticks="1" data-nodeid="942">MC1</code>commit 签出并新建了<code data-backticks="1" data-nodeid="944">bugfix/fix-avatar-ui-bug</code>来修改 Bug。</p>\n<p data-nodeid="828">当头像的 Bug 修改完成后，开发组长把<code data-backticks="1" data-nodeid="947">BC2</code>commit 合并到主分支里面。在此之后点赞功能也开发完毕，开发组长又把该功能分支上的<code data-backticks="1" data-nodeid="949">FC4</code>commit 合并到主分支里面。这两个分支彼此独立，而且互不影响。</p>\n<p data-nodeid="829">除了主分支和功能分支以外，我们在发布 App 的时候还使用到发布分支。</p>\n<p data-nodeid="830"><strong data-nodeid="958">发布分支</strong>一般命名为<code data-backticks="1" data-nodeid="956">release</code>。每次当我们发布 App 之前都会把主分支的最新代码合并到发布分支去。因此发布分支会一直保存 App 发布版的源码记录。</p>\n<p data-nodeid="831">有了发布分支以后，一旦发生严重的线上事故，例如出现引起高崩溃率的 Bug 时，我们可以马上在发布分支上进行修复。一般的做法是从发布分支上签出一个功能分支，例如当修复点赞按钮引起的崩溃时，我们可以建立一个叫作<code data-backticks="1" data-nodeid="960">bugfix/fix-like-button-crash</code>的功能分支，在修复该崩溃以后马上合并到发布分支，并提交到 App Store ，更新线上的 App。</p>\n<p data-nodeid="832"><img src="https://s0.lgstatic.com/i/image6/M00/16/14/Cgp9HWBF-eaARQ3lAACY5uUYZq0336.png" alt="Drawing 1.png" data-nodeid="964"></p>\n<p data-nodeid="833">由上图可见，当我们把主分支最新的<code data-backticks="1" data-nodeid="966">MC1</code>commit 合并到<code data-backticks="1" data-nodeid="968">release</code>分支以后，提交了一个版本号为<code data-backticks="1" data-nodeid="970">V2.0</code>的 App 到 App Store。当我们通过查看崩溃报告，得知新上线的点缀功能引起很多崩溃时，可以采取如下措施：</p>\n<ol data-nodeid="834">\n<li data-nodeid="835">\n<p data-nodeid="836">马上从<code data-backticks="1" data-nodeid="973">release</code>分支的<code data-backticks="1" data-nodeid="975">V2.0</code>commit 签出<code data-backticks="1" data-nodeid="977">bugfix/fix-like-button-crash</code>分支并修复该崩溃；</p>\n</li>\n<li data-nodeid="837">\n<p data-nodeid="838">把<code data-backticks="1" data-nodeid="980">BC2</code>commit 合并回<code data-backticks="1" data-nodeid="982">release</code>分支，并立刻提交版本号为<code data-backticks="1" data-nodeid="984">V2.1</code>的 App 到 App Store；</p>\n</li>\n<li data-nodeid="839">\n<p data-nodeid="840">把包含了该修复的<code data-backticks="1" data-nodeid="987">V2.1</code>commit 合并到<code data-backticks="1" data-nodeid="989">main</code>分支，保证主分支统一管理所有代码的更新状态。</p>\n</li>\n</ol>\n<p data-nodeid="841">有了上面讲的三大分支，以及它们签出和合并的流程，我们就定义了一部分的代码管理规范——知道什么时候要使用哪个分支进行开发或者发布。但是你可能已经察觉到，当我们把功能分支合并到主分支的时候并没有进行任何的审查，万一有人不小心把 Bug 合并到主分支怎么办？</p>\n<p data-nodeid="842">我们在这方面就吃过很多大的亏，有人把没有经过验证的代码直接 Push 到主分支，使得 App 的崩溃率提升了 10% 以上。为了保证主分支受控，我们就需要引入一个代码管理流程来管控主分支的合并过程。目前管控这一流程最有效的办法是使用<strong data-nodeid="997">Pull Request</strong>，众多代码托管和协作平台（如 GitLab，BitBucket 等）都支持 Pull Request 功能。下面我就以 GitHub Pull Request 为例子来看看它是如何工作的。</p>\n<h3 data-nodeid="843">GitHub Pull Request 流程</h3>\n<p data-nodeid="844"><strong data-nodeid="1003">Pull Request</strong>我把它简称为 PR。PR 是一种团队协助的机制，在 GitLab 也叫作 Merge Request。当一个开发者完成一个功能的开发时，可以通过 PR 来通知团队其他成员进行代码审查和讨论。在协商并得到共识后可以通过 PR 把功能代码合并到主分支中。</p>\n<p data-nodeid="845">一套完善的 PR 流程能有效降低沟通成本，提高代码质量，以及提升项目的自动化和工程化程度。</p>\n<p data-nodeid="846">下面我们一起看一套完整的，并经过我们多年实践证明过的 PR 流程。</p>\n<p data-nodeid="847"><img src="https://s0.lgstatic.com/i/image6/M00/16/14/Cgp9HWBF-fKAVu_QAAKUNfBQLr8841.png" alt="Drawing 2.png" data-nodeid="1008"></p>\n<p data-nodeid="848">这套流程分成六步。</p>\n<p data-nodeid="849">第一步，当我们要开发一个新功能或者修改一个 Bug 时，从主分支的签出并建立一个功能分支。这里需要注意的是，为了减少合并时出现的冲突，我们需要从主分支最新的一个 commit 签出。</p>\n<p data-nodeid="850">第二步，我们可以在功能分支上持续开发并多次提交 commit。因为我们是在独立的功能分支上进行开发，所有的变动都不会影响到主分支，所以可以放心修改所需的代码。</p>\n<p data-nodeid="851">第三步，当我们完成一个功能的开发以后，就可以提交一个 PR 了。为了避免合并冲突，我建议在提交 PR 前先 rebase 主分支的 Git 历史。同时为了方便其他成员审查代码和参与讨论，我们在提交 PR 的时候需要清楚地描述所完成的功能，并把注意 事项，UI 前后变动的区别，测试步骤等等一同写到 PR 描述文档里面。</p>\n<p data-nodeid="852">在我们 Moments App 项目中，为了方便开发者编写 PR 描述文档，我们建立了一个模板文件<code data-backticks="1" data-nodeid="1014">pull_request_template.md</code>。当我们提交 PR 的时候，GitHub 会自动读取并准备好描述文档的模板，我们只需要填写相关内容即可。</p>\n<p data-nodeid="853"><img src="https://s0.lgstatic.com/i/image6/M00/1A/11/Cgp9HWBK9gSAXnguAAMUTTFvSAg277.png" alt="图片1.png" data-nodeid="1018"></p>\n<p data-nodeid="854">你可以到<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.github/pull_request_template.md" data-nodeid="1022">拉钩的代码仓库</a>查看该模板文件。</p>\n<p data-nodeid="855">在提交 PR 的时候，我们还可以加上代码审查人（Reviewer）来通知他/她审查代码。同时也可以加上分类的标签（Label）来方便管理所有的 PR，例如使用<code data-backticks="1" data-nodeid="1025">enhancement</code>表示功能开发，使用<code data-backticks="1" data-nodeid="1027">bug</code>表示 Bug 修改。如果你的项目由多团队同时开发，我们还会为每个产品团队都建立一个标签，这样就能清楚地知道这个 PR 来自那个产品团队了。</p>\n<p data-nodeid="856"><img src="https://s0.lgstatic.com/i/image6/M00/1A/0E/CioPOWBK9fKAaGtgAAHLCg2avjU907.png" alt="图片2.png" data-nodeid="1031"></p>\n<p data-nodeid="857">第四步，一旦 PR 提交以后，其他成员就会收到通知消息，他们可以进行代码审查，并把反馈意见留言到 RP 里面。提交者可以根据留言来修改代码和提交新的 commit。当所有留言都修正和完善以后，可以再次通知审查人进行进一步的审查。</p>\n<p data-nodeid="858">在项目之初，这个过程可能需要来回好几遍。但随着团队的不断磨合，这个过程会越来越快。因为代码审查人一般由项目中最资深开发者组成，他们的留言能帮助团队新成员迅速熟悉项目相关的技术和背景知识。同时能保证代码风格的一致性和提高整个项目的代码质量。</p>\n<p data-nodeid="859">根据我们的经验，在代码审查上的投资所得到的好处，远高于所花的时间成本，我建议你或者你所在的团队在项目初期多投入 PR 审查工作。</p>\n<p data-nodeid="860">第五步，大家通过协商得到共识以后，审查人就可以批准（approve）该 PR。这表示该 PR 可以随时合并到主分支了。</p>\n<p data-nodeid="861">第六步，当 PR 得到批准以后，提交人可以把 PR 合并到主分支里面去。我建议在合并之前先 rebase 主分支上的最新 commit，这样能保证合并过程没有冲突，并使得 Git 的历史更加简洁。</p>\n<p data-nodeid="862">上面就是我们的统一的代码管理流程。为了进一步保证少犯错误，我们可以通过修改 GitHub 上的配置来为每一步操作做自动检查，以保证所有成员都必须严格遵循一致的代码管理流程。</p>\n<h3 data-nodeid="863">GitHub 配置</h3>\n<p data-nodeid="864">首先，我们可以把主分支保护起来，不允许任何人直接 Push 到主分支。</p>\n<p data-nodeid="865"><img src="https://s0.lgstatic.com/i/image6/M01/1A/11/Cgp9HWBK9eKAGESRAAJW2j80OLg852.png" alt="图片3.png" data-nodeid="1042"></p>\n<p data-nodeid="866">然后要求所有 PR 在合并之前都必须经过一个或以上的代码审查人批准。审查人的数量可以根据团队的情况进行调整。</p>\n<p data-nodeid="867"><img src="https://s0.lgstatic.com/i/image6/M01/1A/10/CioPOWBK9pGAWYgdAANH9SPivxA932.png" alt="图片7.png" data-nodeid="1046"></p>\n<p data-nodeid="868">当 Github 检查到有某些条件不完全符合时，就不允许我们合并该 PR。</p>\n<p data-nodeid="869"><img src="https://s0.lgstatic.com/i/image6/M01/1A/0F/CioPOWBK9lyAEzO1AAOXuc4tDlg494.png" alt="图片6.png" data-nodeid="1050"></p>\n<p data-nodeid="870">比如，因为我们的 Moments 项目配置了所有的 PR 都必须有一个或以上的代码审查人批准后才能合并。上图可以见 GitHub PR 页面上的<strong data-nodeid="1056">Merge pull request</strong>按钮是失效的，并提示 “Merging can be performed automatically with 1 approving review” （需要一个代码审查通过后才能合并）。</p>\n<h3 data-nodeid="871">总结</h3>\n<p data-nodeid="2727">在这一讲我介绍了 Git 的分支管理和 GitHub 的 Pull Request 流程。根据多年的项目经验，我给出了一套完整的统一代码管理流程，其重点是把 Git 分支分成三类，主分支、功能分支和发布分支，然后严格按照 GitHub Pull Request 流程来把代码合并到主分支里面。</p>\n<p data-nodeid="3281"><img src="https://s0.lgstatic.com/i/image6/M00/1A/14/Cgp9HWBK-BSAHpViAAapoc7YA9U941.png" alt="思维导图+二维码.png" data-nodeid="3285"></p>\n<p data-nodeid="3282">有了这个规范，开发者就能严格遵循这个流程贡献代码，从而保证主分支在管控状态，同时也为项目的自动化和工程化打下基础。</p>\n\n\n\n\n\n\n\n<p data-nodeid="874">思考题：</p>\n<blockquote data-nodeid="875">\n<p data-nodeid="876">请问你是使用怎样的流程来进行代码管理的？在上述 PR 流程的第一步是从主分支签出一个功能分支，而不是使用 Fork，为什么这样做？</p>\n</blockquote>\n<p data-nodeid="877">可以把你的答案写得留言区哦，下一讲我将介绍如何统一设计规范，提高沟通效率。</p>\n<p data-nodeid="878">源码地址：</p>\n<blockquote data-nodeid="879">\n<p data-nodeid="880" class="">pull_request_template.md<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.github/pull_request_template.md" data-nodeid="1076">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.github/pull_request_template.md</a></p>\n</blockquote>',
          },
          {
            theme: '07 | 设计规范：如何统一设计规范，提高沟通效率？',
            id: 16,
            content:
              '<p data-nodeid="1880" class="">作为 iOS 工程师，我们开发的绝大部分功能都是与用户界面和用户交互有关。所以，和设计师协调沟通也成了我们的日常工作之一。在这个过程中，就免不了和他们争论有关间距大小、字体粗细、字号大小、颜色深浅等问题。想必有时候你也很烦恼，怎么和这些设计师们沟通就那么麻烦呢！</p>\n\n\n\n<p data-nodeid="842">其实，这些问题都可以用一套统一的设计规范来解决，从而有效降低沟通成本。有了规范，设计师可以根据明确的指引和预定义好的设计元素，来设计出新的界面；而开发者也能使用预先封装好的、可重用的设计组件实现快速开发。最后，开发的产品为用户提供一致的体验。</p>\n<p data-nodeid="843">那一套统一的设计规范到底是怎样的呢？它通常包括间距、字体、颜色、图标和常用组件等，这一讲，我们就一起看看怎样定义这些设计规范吧。</p>\n<h3 data-nodeid="844">间距</h3>\n<p data-nodeid="845"><strong data-nodeid="937">间距</strong>（Spacing）是父子组件之间，以及平级组件之间的留白，合理使用间距能有效分离和组织内容，也能保证页面风格一致，提升用户体验。</p>\n<p data-nodeid="846">但是，在实际工作当中，你有没有遇到过打开设计师给的设计稿后发现，同一个界面里的间距定义杂乱无章，不同页面类似组件的间距也大不相同，这样导致的结果是，开发出的 App 在视觉上会给人风格混乱的感觉。</p>\n<p data-nodeid="847">那怎样定义统一的间距呢？其实很简单，我们只保留几个可用的间距，并给它们赋予定义，下面是我们 Moments App 的间距定义。</p>\n<p data-nodeid="848"><img src="https://s0.lgstatic.com/i/image6/M00/1D/13/Cgp9HWBPIESAQtxiAAC49ptAY10830.png" alt="图片2.png" data-nodeid="942"></p>\n<p data-nodeid="2712" class="">根据我们的经验，在选择间距的值时，为了具有和谐感，我们把间距分成三组：小（Small）、中（Medium）、大（Large）。两个小间距之间的差别是 4pt，中间距与小间距相差 6pt，而大间距直接相差 8pt，给用户一种循序渐进的感觉。这些间距的定义能覆盖 App 所有的使用需求了。</p>\n\n\n<p data-nodeid="850" class="">有了统一的间距定义，设计师就可以在设计稿里面标注间距的定义，而不是具体的值。开发者也可以通过代码中原先定义好的间距，而无须每次都硬编码（Hardcode）间距的值。</p>\n<p data-nodeid="4398" class="">除了 iOS 以外，统一的间距还可以用到 Android 和 Web 上，如下面是开源设计规范 Backpack 所定义的间距，其包含了 iOS、 Android 和 Web 三个平台。</p>\n\n\n<p data-nodeid="852"><img src="https://s0.lgstatic.com/i/image6/M00/1D/10/CioPOWBPIE6AQByeAAGm6psQ2cY050.png" alt="图片1.png" data-nodeid="948"></p>\n<p data-nodeid="853">有了这些间距的定义以后，设计师只需设计一份设计稿，不同平台的开发者都可以使用同一份设计稿进行开发。</p>\n<h3 data-nodeid="854">字体</h3>\n<p data-nodeid="855" class="">任何一款 App，都离不开文字，除了其本身传达信息，文字的各种样式，包括字体类型、大小、粗细，在其中也承担着重要角色。比如合理使用行楷会给人美感；字体放大可以暗示优先阅读；字体加粗，会起到强调的作用，吸引用户关注等等。</p>\n<p data-nodeid="856">在开发当中，字体类型、字号大小、字体粗细分别由 Font family、Font size、Font weight 属性定义。除非有特殊的原因（如品牌需要，或者为了增强游戏体验），iOS 的 App 一般都使用 iOS 系统所自带的字体系列。这样更能符合用户的阅读习惯。在自带的字体系列的基础上，通过把字号大小和字体粗细组合起来定义一些字体类型。下面是我们 Moments App 所定义的字体规范。</p>\n<p data-nodeid="857"><img src="https://s0.lgstatic.com/i/image6/M00/1D/13/Cgp9HWBPIFmAZ3I7AAGL_JUZsWA282.png" alt="图片3.png" data-nodeid="955"></p>\n<p data-nodeid="858">根据字体类型的时候，我们分成四组：</p>\n<ul data-nodeid="3555">\n<li data-nodeid="3556">\n<p data-nodeid="3557">大标题（Display），用于显示这个页面的唯一标题，使用特大字号（如 42pt 和 36pt）；</p>\n</li>\n<li data-nodeid="3558">\n<p data-nodeid="3559">标题（Titile），用于显示段落的标题，我们提供了五种不同的段落标题，其字号由大变小；</p>\n</li>\n<li data-nodeid="3560">\n<p data-nodeid="3561">文本（Body），用于显示一般的内容文本，我们提供了普通和加粗两种类型来呈现不同的文本；</p>\n</li>\n<li data-nodeid="3562" class="">\n<p data-nodeid="3563" class="">小文本（Small text），使用较小的字体来显示辅佐内容，例如备注、版本信息等。</p>\n</li>\n</ul>\n\n\n<p data-nodeid="868">为了让读者有更好的阅读体验，我们在字体粗细上都统一选择了偏细的字重，比如使用<code data-backticks="1" data-nodeid="962">semibold</code>而不是<code data-backticks="1" data-nodeid="964">bold</code>，并且选择<code data-backticks="1" data-nodeid="966">light</code>而不是<code data-backticks="1" data-nodeid="968">regular</code>来定义这套字体。</p>\n<p data-nodeid="4814" class="">有了这些字体类型的定义，设计师可以很方便地选择字体，比如在设计文章内容部分时，可以从<code data-backticks="1" data-nodeid="4816">body</code>或者<code data-backticks="1" data-nodeid="4818">bodyBold</code>中选择出来，而不需要思考到底是使用 14p、15pt 还是 16pt。同时，开发者也可以使用原先定义好的字体组件，提升效率。</p>\n\n<p data-nodeid="870" class="">除此之外，还有动态字体，因为我们在此之前已经对字体的类型、大小、粗细做了定义，设计师只需要做一个设计稿就行了，无须为不同的字体设计出不同的版本，而我们开发者只需要通过封装好的字体组件来支持即可。具体如何封装字体组件，我会在第 12 讲详细介绍。</p>\n<h3 data-nodeid="871">颜色</h3>\n<p data-nodeid="872">在一款 App 的视觉体验中，颜色毫无疑问在其中占据很重要的位置。如果颜色搭配不当，很容易被用户吐槽甚至弃用。所以设计之初，就要对颜色做好规范。</p>\n<p data-nodeid="6482" class="">为了给用户提供颜色一致的体验，在 App 设计中，我们一般采用统一的调色板（Color palette）来完成。在实际工作当中，你可以和设计师一起在各类开源设计网站中寻找，比如，以天蓝为主色调的 Backpack，还有谷歌的 Material Design 还提供了调色板生成工具，你可以根据自己品牌的颜色来生成一个调色板。</p>\n\n\n\n\n<p data-nodeid="874"><img src="https://s0.lgstatic.com/i/image6/M00/1D/10/CioPOWBPIGyAArUOAARif6OrlTI705.png" alt="图片4.png" data-nodeid="981"></p>\n<div data-nodeid="875"><p style="text-align:center">来源：backpack.github.io</p></div>\n<p data-nodeid="876"><img src="https://s0.lgstatic.com/i/image6/M00/1D/10/CioPOWBPIHSAUGNaAASjT7YUZno486.png" alt="图片5.png" data-nodeid="984"></p>\n<div data-nodeid="877"><p style="text-align:center">来源：2014 Material Design color palettes</p></div>\n<p data-nodeid="878">有了调色板，我们就可以在设计常用组件时（如按钮，卡片，警告信息等）使用调色板里面的颜色。例如 Backpack 的主色是天蓝色，在设计按钮时，主按钮的背景可以使用天蓝色（#0770e3）。</p>\n<p data-nodeid="879">为了照顾不同用户的使用习惯，提高夜间视觉体验，iOS 系统在原有的浅色模式之外，还提供了深色模式。我们在设计调色板的时候，也最好考虑到对深色模式的支持。</p>\n<p data-nodeid="880"><a href="https://backpack.github.io/guidelines/colour/#dark-mode-dynamic-colours" data-nodeid="991"><img src="https://s0.lgstatic.com/i/image6/M00/16/15/Cgp9HWBF-8iAdDeqAAQTjxb8lPw437.png" alt="Drawing 2.png" data-nodeid="990"></a></p>\n<div data-nodeid="881"><p style="text-align:center">来源：backpack.github.io</p></div>\n<p data-nodeid="882">在&nbsp; Moments App 项目中，我们采用 Backpack 的调色板来设计深色模式下的颜色。该调色板定义了一组语义化的颜色（Semantic color）供我们选择。比如设计师在选择背景颜色的时候可以根据需要从背景主色、背景副色、背景第三色中任选一个，Backpack 每种颜色都提供了浅色模式和深色模式两种类型，设计师在设计过程中就不需要为这两种模式制作不同的设计稿了，开发者也可以使用定义好的颜色组件来同时支持两种模式，不需任何额外的工作。</p>\n<p data-nodeid="883">需要注意的是，在定义语义化颜色时要特别注意颜色之间的对比度，例如使用了<code data-backticks="1" data-nodeid="994">Text Primary Color</code>的文本在使用<code data-backticks="1" data-nodeid="996">Background Color</code>的背景下能容易阅读，而使用灰色的背景再使用黑色的文本会难以阅读。</p>\n<p data-nodeid="884">如果你所在团队没有专门的设计师来定义这些颜色，也可以使用 iOS 提供的动态系统颜色（Dynamic System Colors），它为我们定义了同时支持浅色和深色模式的各种颜色。</p>\n<h3 data-nodeid="885">图标</h3>\n<p data-nodeid="886">图标（Iconography）在 App 设计中也承担重要的作用，它可以有效地把功能呈现给用户，例如一个加号（+）的图标能让用户知道点击的时候可以进行新增操作。图标也能简化界面的设计，让页面更加吸引用户，例如在买房的 App 里面我们可以使用一辆车的图标表示多少个车位，一个浴缸的图标表示多少个洗手间，这样能省去大量的文件描述。图标还能帮助用户导航。因此我们在设计 App 的时候也需要合理地使用图标。</p>\n<p data-nodeid="887">如果你们公司没有专门的图标设计师，那么你可能会购买或者使用一些开源的图标。这里我有一些建议。</p>\n<p data-nodeid="888">首先，<strong data-nodeid="1006">同一个 App 只需要一种图标，千万不要把不同风格的图标混合使用。</strong></p>\n<p data-nodeid="889">其次，如果没有特殊要求，我推荐直接使用苹果公司提供的。具体来说，在 iOS 系统内置的 SF Symbols 为我们提供了 3150 个一致的、可定制的图标，如下面的例子。</p>\n<p data-nodeid="890"><img src="https://s0.lgstatic.com/i/image6/M00/1D/13/Cgp9HWBPIImAXKhhAAPeaviZKqA532.png" alt="图片6.png" data-nodeid="1010"></p>\n<p data-nodeid="891">SF Symbols 有很多优点：</p>\n<ul data-nodeid="892">\n<li data-nodeid="893">\n<p data-nodeid="894">它数量巨大，几乎覆盖所有应用场景；</p>\n</li>\n<li data-nodeid="895">\n<p data-nodeid="896">整合了 San Francisco 字体系统，当用户改变字体大小的时候，这些图标都会自动对齐；</p>\n</li>\n<li data-nodeid="897">\n<p data-nodeid="898">所有图标都支持颜色，我们可以根据需求搭配不同的颜色；</p>\n</li>\n<li data-nodeid="899">\n<p data-nodeid="900">使用这些图标时也无须安装，可以减少 App 的体积。</p>\n</li>\n</ul>\n<p data-nodeid="901">我们的 Moments App 也使用到 SF Symbols 来呈现点赞按钮。</p>\n<p data-nodeid="902"><img src="https://s0.lgstatic.com/i/image6/M00/1D/10/CioPOWBPIJOAPceNAAP7idtkklI920.png" alt="图片7.png" data-nodeid="1019"></p>\n<p data-nodeid="903">SF Symbols 里绝大部分的图标都通过了轮廓和填充两个版本，我们可以使用填充的图标表示选中状态。</p>\n<p data-nodeid="904"><img src="https://s0.lgstatic.com/i/image6/M00/1D/10/CioPOWBPIJyAREyHAAPWaRoJ2ZA576.png" alt="图片8.png" data-nodeid="1023"></p>\n<h3 data-nodeid="905">常用组件</h3>\n<p data-nodeid="906">随着 App 功能的增多，你会发现一些 UI 会出现在许多地方，例如下图的用户头像，分别出现在个人主页、朋友圈、点赞处。</p>\n<p data-nodeid="907"><img src="https://s0.lgstatic.com/i/image6/M00/1D/10/CioPOWBPIKWAeE3NAArOXBxBWDQ128.png" alt="图片9.png" data-nodeid="1028"></p>\n<p data-nodeid="908">在这种情况下，我们就可以把这个重复出现的 UI 封装成一个常用的设计组件，并纳入我们在制定设计规范中。常用的组件一般有按钮（Button）、用户头像（User avatar）、复选框（Checkbox）、徽章（Badge）等等。下面是 Moments App 设计规定中用户头像组件的定义。</p>\n<p data-nodeid="909"><img src="https://s0.lgstatic.com/i/image6/M00/1D/13/Cgp9HWBPIK2AUwu1AAWVmRyk8yo083.png" alt="图片10.png" data-nodeid="1032"></p>\n<p data-nodeid="8355" class="te-preview-highlight">有了用户头像组件，设计师在设计过程中就不需要考虑在呈现头像时需要怎样设计，使用的圆角到底要多少度，是否需要阴影和边框等等。开发者也可以使用原先封装好的组件来加快开发。</p>\n\n\n\n\n\n<p data-nodeid="911">需要注意的是，UI 组件是在开发过程中发现某个 UI 反复使用后才封装的，在开始的时候不要贪多，避免定义一堆不用的组件。</p>\n<h3 data-nodeid="912">总结</h3>\n<p data-nodeid="913">在这一讲，我们通过间距，字体，颜色，图标和常用组件为例子来讲述一套统一的设计规范。有了它，能极大降低设计师与开发者的沟通成本，也节省设计师和开发者在设计或实现过程的时间，一举多得。</p>\n<p data-nodeid="914"><img src="https://s0.lgstatic.com/i/image6/M00/1D/13/Cgp9HWBPIMGATXhkAAYS7jjGAi4492.png" alt="思维导图+二维码.png" data-nodeid="1039"></p>\n<p data-nodeid="915">在定义和管理设计规范过程中需要注意这几点：</p>\n<ul data-nodeid="916">\n<li data-nodeid="917">\n<p data-nodeid="918">在定义规范过程中，设计师和开发者要一起参与进来，达成共识方便后期彼此间的沟通与协作；</p>\n</li>\n<li data-nodeid="919">\n<p data-nodeid="920">在更新规范时，要有设计审查流程保证主设计版本一直在受控状态，我建议使用上节课所说的 GitHub Pull Request 流程来管理这套规范；</p>\n</li>\n<li data-nodeid="921">\n<p data-nodeid="922">每次更新的时候，都需要更新设计文档，就像 Backpack 的文档一样，当设计师或者开发者有疑问的时候都可以把这个文档作为唯一信息源来查看；</p>\n</li>\n<li data-nodeid="923">\n<p data-nodeid="924">坚持少即是多的原则，特别是在定义规范开始的时候，不要求多求全，可以根据业务需要不断地迭代完善。</p>\n</li>\n</ul>\n<p data-nodeid="925">思考题：</p>\n<blockquote data-nodeid="926">\n<p data-nodeid="927">你们公司有没有统一的设计规范，如果有，是通过怎样的方式来管理的？</p>\n</blockquote>\n<p data-nodeid="928" class="">你可以把自己的思考写到下面的留言区哦，这一讲设计规范我就介绍到这里，下一讲我将介绍如何封装和开发设计组件。</p>',
          },
        ],
      },
      {
        sectionName: '模块二：基础组件设计',
        sectionId: 2,
        courseList: [
          {
            theme: '08 | 设计组件：DesignKit 组件桥接设计与开发规范',
            id: 20,
            content:
              '<p data-nodeid="15834" class="">在上一模块“配置与规范”中，我主要介绍了如何统一项目的配置，以及如何制定统一开发和设计规范。</p>\n<p data-nodeid="15835">接下来我们将进入基础组件设计模块，我会为你介绍一些在 iOS 开发过程中，工程化实践需要用的组件，比如设计组件、路由组件。除此之外，我还会聊聊在开发中如何支持多语言、动态字体和深色模式等辅助功能，让你的 App 既有国际范，获取更多用户，还能提升用户体验，获得更多好评。</p>\n<p data-nodeid="15836">这一讲，我们就先来聊聊公共组件库，以及如何封装基础设计组件。</p>\n<h3 data-nodeid="15837">封装公共功能组件库</h3>\n<p data-nodeid="15838">随着产品不断发展，我们会发现，越来越多的公共功能可以封装成组件库，从而被各个模块甚至多个 App 共同使用，比如字体、调色板、间距和头像可以封装成 UI 设计组件库，登录会话和权限管理可以封装成登录与鉴权组件库。</p>\n<p data-nodeid="15839">通过利用这些公共功能组件库，不仅能节省大量开发时间，不需要我们再为每个模块重复实现类似的功能；还能减少编译时间，因为如果没有独立的组件库，一点代码的改动都会导致整个 App 重新编译与链接。</p>\n<p data-nodeid="15840">那么，怎样才能创建和使用公共功能组件库呢？下面我们以一个设计组件库 DesignKit 为例子介绍下具体怎么做。</p>\n<h4 data-nodeid="15841">创建内部公共功能组件库</h4>\n<p data-nodeid="15842">公共功能组件库根据使用范围可以分为三大类：内部库、私有库和开源库。</p>\n<ul data-nodeid="15843">\n<li data-nodeid="15844">\n<p data-nodeid="15845">内部库是指该库和主项目共享一个 Repo ，它可以共享到主项目的所有模块中。</p>\n</li>\n<li data-nodeid="15846">\n<p data-nodeid="15847">私有库是指该库使用独立的私有 Repo ，它可以共享到公司多个 App 中。</p>\n</li>\n<li data-nodeid="15848">\n<p data-nodeid="15849">开源库是指该库发布到 GitHub 等开源社区提供给其他开发者使用。</p>\n</li>\n</ul>\n<p data-nodeid="15850">这三类库的创建和使用方式都是一致的。<strong data-nodeid="15958">在实际操作中，我们一般先创建内部库，如果今后有必要，可以再升级为私有库乃至开源库</strong>。下面咱们一起看看怎样创建内部库。</p>\n<p data-nodeid="15851">为了方便管理各个内部公共功能组件库，首先我们新建一个叫作<strong data-nodeid="15964">Frameworks 的文件夹</strong>来保存所有的内部库。这个文件夹和主项目文件夹（在我们例子中是 Moments）以及 Workplace 文档（Moments.xcworkspace）平衡。例如下面的文件结构：</p>\n<pre class="lang-objectivec" data-nodeid="15852"><code data-language="objectivec">Frameworks          Moments             Pods            Moments.xcworkspace\n</code></pre>\n<p data-nodeid="15853">然后我们通过 CocoaPods 创建和管理这个内部库。</p>\n<p data-nodeid="15854">怎么做呢？有两种办法可以完成这项工作，<strong data-nodeid="15974">一种是使用</strong><code data-backticks="1" data-nodeid="15970">pod lib create [pod name]</code>命令。比如在这个案例当中，我们可以在 Frameworks 文件夹下执行<code data-backticks="1" data-nodeid="15972">bundle exec pod lib create DesignKit</code>命令，然后输入邮箱、语言和平台等信息，让 CocoaPods 创建一个 DesignKit.podspec 以及例子项目等一堆文件。具体如下：</p>\n<pre class="lang-java" data-nodeid="15855"><code data-language="java">DesignKit         Example           README.md\nDesignKit.podspec LICENSE           _Pods.xcodeproj\n</code></pre>\n<p data-nodeid="15856">DesignKit.podspec 是 DesignKit 库的 Pod 描述文件，用于描述该 Pod 库的一个特定版本信息。它存放在 CocoaPods 的中心 Repo 供使用者查找和使用。</p>\n<p data-nodeid="15857">随着这个 Pod 库的迭代，CocoaPods 的中心 Repo 会为每个特定的 Pod 版本存放一个对应的 podspec 文件。每个 podspec 文件都包括 Pod 对应 Repo 的 URL、源码存放的位置、所支持的系统平台及其系统最低版本号、Swift 语言版本，以及 Pod 的名字、版本号和描述等信息。</p>\n<p data-nodeid="15858">DesignKit 组件库的 podspec 文件你可以在<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Frameworks/DesignKit/DesignKit.podspec?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="15980">拉勾教育的仓库中</a>找到。下面是该&nbsp;podspec 文件的一些重要配置：</p>\n<pre class="lang-java" data-nodeid="15859"><code data-language="java">  s.name             = <span class="hljs-string">\'DesignKit\'</span>\n  s.version          = <span class="hljs-string">\'1.0.0\'</span>\n\n  s.ios.deployment_target = <span class="hljs-string">\'14.0\'</span>\n  s.swift_versions = <span class="hljs-string">\'5.3\'</span>\n  s.source_files = <span class="hljs-string">\'src/**/*\'</span>\n  s.resources = <span class="hljs-string">\'assets/**/*\'</span>\n</code></pre>\n<p data-nodeid="15860"><code data-backticks="1" data-nodeid="15982">name</code>是该组件的名字，<code data-backticks="1" data-nodeid="15984">version</code>是组件的版本号，当我们更新组件的时候同时需要使用 Semantic Versioning（语义化版本号）更新该版本号。</p>\n<p data-nodeid="15861"><code data-backticks="1" data-nodeid="15986">ios.deployment_target</code>为该库所支持的平台和所支持平台的最低版本号。<code data-backticks="1" data-nodeid="15988">swift_versions</code>是支持 Swift 语言的版本号。<code data-backticks="1" data-nodeid="15990">source_files</code>是该库的源代码所在的文件夹，在我们例子中是 src。<code data-backticks="1" data-nodeid="15992">resources</code>是该库资源文件所在的文件夹。</p>\n<p data-nodeid="15862"><strong data-nodeid="15998">另外一种是手工创建 DesignKit.podspec 文件。我偏向于这一种，因为手工创建出来的项目更简练</strong>。</p>\n<p data-nodeid="15863">比如在这里，我们只需要在 Frameworks 新建一个叫作 DesignKit 的文件夹，然后在它下面建立 src 和 assets 这两个文件夹，以及 LICENSE 和 DesignKit.podspec 这两个文件即可。</p>\n<p data-nodeid="15864">如下所示：</p>\n<pre class="lang-java" data-nodeid="15865"><code data-language="java">DesignKit.podspec LICENSE           assets            src\n</code></pre>\n<p data-nodeid="15866">以后所有源代码文件都存放在 src 文件夹下面，而图片、Xib 和 Storyboard 等资源文件存放在 assets 文件夹下。</p>\n<p data-nodeid="15867">LICENSE 是许可证文件，如果是开源库，我们必须严格选择一个许可证，这样才能方便其他开发者使用我们的库。</p>\n<h4 data-nodeid="15868">检测内部公共功能组件库</h4>\n<p data-nodeid="15869">为了保证组件库的使用者能顺利安装和使用我们的库，当我们配置好 DesignKit.podspec 文件后，需要执行<code data-backticks="1" data-nodeid="16005">bundle exec pod spec lint</code>命令来检测该 podspec 文件是否正确。如果我们维护的是一个开源库，这一步尤为重要。因为它会影响到使用者的第一印象，因此我们在发布该 Pod 之前需要把每个错误或者警告都修复好。</p>\n<p data-nodeid="15870">不过需要注意的是， CocoaPods 对内部库的检测存在一个 Bug， 会显示下面的警告以及错误信息：</p>\n<pre data-nodeid="23239" class="te-preview-highlight"><code>WARN | Missing primary key for source attribute \nERROR | unknown: Encountered an unknown error (Unsupported download strategy `{:path=&gt;"."}`.) during validation\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="15873">由于我们创建的是内部库，所以可以忽略这个警告和错误，只要没有其他错误信息就可以了。</p>\n<h4 data-nodeid="15874">使用内部公共功能组件库</h4>\n<p data-nodeid="15875">使用内部公共功能组件库非常简单，只要在主项目的 Podfile 里面使用<code data-backticks="1" data-nodeid="16011">:path</code>来指定该内部库的路径即可。</p>\n<pre class="lang-java" data-nodeid="15876"><code data-language="java">pod <span class="hljs-string">\'DesignKit\'</span>, :path =&gt; <span class="hljs-string">\'./Frameworks/DesignKit\'</span>, :inhibit_warnings =&gt; <span class="hljs-keyword">false</span>\n</code></pre>\n<p data-nodeid="15877">当执行<code data-backticks="1" data-nodeid="16014">bundle exec pod install</code>命令以后，CocoaPods 会在 Pods 项目下建立一个<strong data-nodeid="16024">Development Pods</strong>文件夹来存放所有内部库的相关文件。<br>\n<img src="https://s0.lgstatic.com/i/image6/M00/1F/4C/Cgp9HWBRveSAYt47AASIGxbwB9s124.png" alt="Drawing 0.png" data-nodeid="16023"></p>\n<p data-nodeid="15878">有了 CocoaPods，我们新建、管理和使用公共组件库就会变得非常简单。下面我们介绍下如何开发设计组件 DesignKit。</p>\n<h3 data-nodeid="15879">DesignKit 设计组件</h3>\n<p data-nodeid="15880">DesignKit 是一个设计组件，用于封装与 UI 相关的公共组件。为了方便维护，每次新增一个组件，我们最好都建立一个独立的文件夹，例如把 Spacing.swift 放在新建的 Spacing 文件夹中。</p>\n<p data-nodeid="15881"><img src="https://s0.lgstatic.com/i/image6/M00/1F/4C/Cgp9HWBRve-AVJZSAACVtoXExgU145.png" alt="Drawing 1.png" data-nodeid="16030"></p>\n<p data-nodeid="15882">下面以几乎每个 App 都会使用到的三个组件：间距（Spacing）、头像（Avatar）和点赞按钮（Favorite Button）为例子，介绍下如何封装基础设计组件。</p>\n<h4 data-nodeid="15883">间距</h4>\n<p data-nodeid="15884">为了呈现信息分组并体现信息的主次关系，所有 App 的所有页面都会使用到间距来添加留白效果。</p>\n<p data-nodeid="15885">间距看起来这么简单，为什么我们还需要为其独立封装为一个公共组件呢？主要原因有这么几条。</p>\n<ol data-nodeid="15886">\n<li data-nodeid="15887">\n<p data-nodeid="15888">可以为整个 App 提供一致的体验，因为我们统一定义了所有间距，各个功能模块的 UI 呈现都保持一致。</p>\n</li>\n<li data-nodeid="15889">\n<p data-nodeid="15890">可以减低设计师和开发者的沟通成本，不会再为某些像素值的多与少而争论不休。设计师只使用预先定义的间距，而开发者也只使用在代码中定义好的间距就行了。</p>\n</li>\n<li data-nodeid="15891">\n<p data-nodeid="15892">可以减低设计师的工作量，很多 UI 界面可以只提供一个设计稿来同时支持 iOS、Android 以及移动 Web。因为设计师只提供预先定义的间距名，而不是 hardcoded （硬编码）的像素值。不同设备上像素值有可能不一样，但间距名却能保持一致。</p>\n</li>\n<li data-nodeid="15893">\n<p data-nodeid="15894">在支持响应式设计的时候，这些间距定义可以根据设备的宽度而自动调整。这远比硬编码的像素值灵活很多，例如在 iPhone 中 twoExtraSmall 是 4 points，而在 iPad 中是 6 points。</p>\n</li>\n</ol>\n<p data-nodeid="15895">别看间距公共组件有那么多优点，但实现起来并不难，一个<strong data-nodeid="16044">struct</strong>就搞定了，简直是一本万利的投入。</p>\n<pre class="lang-java" data-nodeid="15896"><code data-language="java"><span class="hljs-keyword">public</span> struct Spacing {\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let twoExtraSmall: CGFloat = <span class="hljs-number">4</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let extraSmall: CGFloat = <span class="hljs-number">8</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let small: CGFloat = <span class="hljs-number">12</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let medium: CGFloat = <span class="hljs-number">18</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let large: CGFloat = <span class="hljs-number">24</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let extraLarge: CGFloat = <span class="hljs-number">32</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let twoExtraLarge: CGFloat = <span class="hljs-number">40</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> let threeExtraLarge: CGFloat = <span class="hljs-number">48</span>\n}\n</code></pre>\n<p data-nodeid="15897">有了上述的定义以后，使用这些间距变得很简单。请看：</p>\n<pre class="lang-java" data-nodeid="15898"><code data-language="java"><span class="hljs-keyword">import</span> DesignKit\n\n<span class="hljs-keyword">private</span> let likesStakeView: UIStackView = configure(.init()) {\n    $<span class="hljs-number">0</span>.spacing = Spacing.twoExtraSmall\n    $<span class="hljs-number">0</span>.directionalLayoutMargins = NSDirectionalEdgeInsets(top: Spacing.twoExtraSmall, leading: Spacing.twoExtraSmall, bottom: Spacing.twoExtraSmall, trailing: Spacing.twoExtraSmall)\n}\n</code></pre>\n<p data-nodeid="15899">我们可以先 import (引入) DesignKit 库，然后通过<code data-backticks="1" data-nodeid="16047">Spacing</code>结构体直接访问预定义的间距，例如<code data-backticks="1" data-nodeid="16049">Spacing.twoExtraSmall</code>。</p>\n<h4 data-nodeid="15900">头像组件</h4>\n<p data-nodeid="15901">iOS 开发者都知道，头像组件应用广泛，例如在房产 App 中显示中介的头像，在我们例子 Moments App 中显示自己和好友头像，在短视频 App 中显示视频博主头像等。</p>\n<p data-nodeid="15902">也许你会问，头像那么简单，为什么需要独立封装为一个组件？原因主要是方便以后改变其 UI 的呈现方式，例如从圆角方形改成圆形，添加边界线（border），添加阴影效果（shadow）等。有了独立的组件以后，我们只需要修改一个地方就能把这个 App 的所有头像一次性地修改呈现效果。</p>\n<p data-nodeid="15903">下面是头像组件的实现方式：</p>\n<pre class="lang-java" data-nodeid="15904"><code data-language="java"><span class="hljs-keyword">public</span> extension UIImageView {\n    <span class="hljs-function">func <span class="hljs-title">asAvatar</span><span class="hljs-params">(cornerRadius: CGFloat = <span class="hljs-number">4</span>)</span> </span>{\n        clipsToBounds = <span class="hljs-keyword">true</span>\n        layer.cornerRadius = cornerRadius\n    }\n}\n</code></pre>\n<p data-nodeid="15905">我们为 UIKit 所提供的<code data-backticks="1" data-nodeid="16056">UIImageView</code>实现了一个扩展方法<code data-backticks="1" data-nodeid="16058">asAvatar(cornerRadius:)</code>，该方法接收<code data-backticks="1" data-nodeid="16060">cornerRadius</code>作为参数来配置圆角的角度，默认值是<code data-backticks="1" data-nodeid="16062">4</code>。</p>\n<p data-nodeid="15906">使用也是非常简单，只有创建一个<code data-backticks="1" data-nodeid="16065">UIImageView</code>的实例，然后调用<code data-backticks="1" data-nodeid="16067">asAvatar(cornerRadius:)</code>方法即可。</p>\n<pre class="lang-java" data-nodeid="15907"><code data-language="java">    <span class="hljs-keyword">private</span> let userAvatarImageView: UIImageView = configure(.init()) {\n        $<span class="hljs-number">0</span>.asAvatar(cornerRadius: <span class="hljs-number">4</span>)\n    }\n</code></pre>\n<p data-nodeid="15908">这是人像组件的显示效果，可以在内部菜单查看。<br>\n<img src="https://s0.lgstatic.com/i/image6/M00/1F/49/CioPOWBRvgqAL1THABqNofQMQ_4461.png" alt="Drawing 2.png" data-nodeid="16073"></p>\n<h4 data-nodeid="15909">点赞按钮</h4>\n<p data-nodeid="15910">可以说，每个具有社交属性的 App 都会用到点赞功能，所以在开发当中，点赞按钮也是必不可少的功能组件。</p>\n<p data-nodeid="15911">那么，点赞按钮该如何封装呢？和人像组件十分类似，我们可以通过扩展<code data-backticks="1" data-nodeid="16077">UIButton</code>来实现。示例代码如下：</p>\n<pre class="lang-java" data-nodeid="15912"><code data-language="java"><span class="hljs-keyword">public</span> extension UIButton {\n    <span class="hljs-function">func <span class="hljs-title">asStarFavoriteButton</span><span class="hljs-params">(pointSize: CGFloat = <span class="hljs-number">18</span>, weight: UIImage.SymbolWeight = .semibold, scale: UIImage.SymbolScale = .<span class="hljs-keyword">default</span>, fillColor: UIColor = UIColor(hex: <span class="hljs-number">0xf1c40f</span>)</span>) </span>{\n        let symbolConfiguration = UIImage.SymbolConfiguration(pointSize: pointSize, weight: weight, scale: scale)\n        let starImage = UIImage(systemName: <span class="hljs-string">"star"</span>, withConfiguration: symbolConfiguration)\n        setImage(starImage, <span class="hljs-keyword">for</span>: .normal)\n        let starFillImage = UIImage(systemName: <span class="hljs-string">"star.fill"</span>, withConfiguration: symbolConfiguration)\n        setImage(starFillImage, <span class="hljs-keyword">for</span>: .selected)\n        tintColor = <span class="hljs-function">fillColor\n        <span class="hljs-title">addTarget</span><span class="hljs-params">(self, action: #selector(touchUpInside)</span>, <span class="hljs-keyword">for</span>: .touchUpInside)\n    }\n}\n<span class="hljs-keyword">private</span> extension UIButton </span>{\n    <span class="hljs-meta">@objc</span>\n    <span class="hljs-function"><span class="hljs-keyword">private</span> func <span class="hljs-title">touchUpInside</span><span class="hljs-params">(sender: UIButton)</span> </span>{\n        isSelected = !isSelected\n    }\n}\n</code></pre>\n<p data-nodeid="15913">其核心逻辑把当前 UIButton 对象的普通 (<code data-backticks="1" data-nodeid="16080">.normal</code>) 状态和选中 (<code data-backticks="1" data-nodeid="16082">.selected</code>) 状态设置不同的图标。比如在这里我就把星星按钮的普通状态设置成了名叫 “Star” 的图标，并把它的选中状态设置成了名叫 “tar.fill"” 的图标。</p>\n<p data-nodeid="15914">注意，这些图标来自苹果公司的 SF Symbols 不需要额外安装，iOS 14 系统本身就自带了。而且它们的使用也非常灵活，支持字号、字重、填充色等配置。</p>\n<p data-nodeid="15915">使用点赞按钮组件也非常简单，只需要建立一个<code data-backticks="1" data-nodeid="16088">UIButton</code>的实例，然后调用<code data-backticks="1" data-nodeid="16090">asStarFavoriteButton</code>方法就可以了。</p>\n<pre class="lang-java" data-nodeid="15916"><code data-language="java">    <span class="hljs-keyword">private</span> let favoriteButton: UIButton = configure(.init()) {\n        $<span class="hljs-number">0</span>.asStarFavoriteButton()\n    }\n</code></pre>\n<p data-nodeid="15917">点赞按钮的运行效果，也可以在内部菜单查看。</p>\n<p data-nodeid="15918">以上我们以间距、头像、点赞按钮为例介绍了如何使用 DesignKit 封装与 UI 相关的公共组件。以我多年的开发经验来说，在封装 UI 组件的时候，可以遵循下面几个原则。</p>\n<ol data-nodeid="15919">\n<li data-nodeid="15920">\n<p data-nodeid="15921">尽量使用扩展方法而不是子类来扩展组件，这样做可以使其他开发者在使用这些组件时，仅需要调用扩展方法，而不必使用特定的类。</p>\n</li>\n<li data-nodeid="15922">\n<p data-nodeid="15923">尽量使用代码而不要使用 Xib 或者 Storyboard，因为有些 App 完全不使用 Interface Builder。</p>\n</li>\n<li data-nodeid="15924">\n<p data-nodeid="15925">如果可以，要为组件加上<code data-backticks="1" data-nodeid="16097">@IBDesignable</code>和<code data-backticks="1" data-nodeid="16099">@IBInspectable</code>支持，这样能使得开发者在使用 Interface Builder 的时候预览我们的组件。</p>\n</li>\n<li data-nodeid="15926">\n<p data-nodeid="15927">尽量只使用 UIkit 而不要依赖任何第三方库，否则我们可能会引入一个不可控的依赖库。</p>\n</li>\n</ol>\n<h3 data-nodeid="15928">总结</h3>\n<p data-nodeid="15929">前面我介绍了如何封装公共功能组件库，以及以怎样封装基础设计组件，希望对你有所帮助。合理使用功能组件可以让你的开发事半功倍。<br>\n<img src="https://s0.lgstatic.com/i/image6/M00/1F/73/Cgp9HWBR3wyAAnwjAAcCv2pASBs854.png" alt="思维导图+二维码.png" data-nodeid="16107"><br>\n不过，在封装组件的时候，我还需要提醒你注意这么几点。</p>\n<p data-nodeid="15930">首先，为了减低组件之间的耦合性，提高组件的健壮性，组件的设计需要符合单一功能原则 。也就是说，一个组件只做一件事情，一个组件库只做一类相关的事情。每个组件库都要相对独立且功能单一。</p>\n<p data-nodeid="15931">比如，我们可以分别封装网络库、UI 库、蓝牙处理库等底层库，但不能把所有库合并在一个单独的库里面，这样可以方便上层应用按需使用这些依赖库。例如，广告 SDK 可以依赖于网络库、UI 库，但并不依赖蓝牙处理库。这样做一方面可以减少循环依赖的可能性，另一方面可以加快编译和链接的速度，方便使用。</p>\n<p data-nodeid="15932">其次，每次发布新增和更新组件的时候，都需要严格按照 Semantic Versioning 来更新版本号，这样有效防止因为版本的问题而引入 Bug。</p>\n<p data-nodeid="15933">最后，组件的开发并不是一蹴而就，很多时候可以根据业务需求把公共模块一点点地移入公共组件库中，一步步地完善组件库的功能。不要为了开发组件而开发组件，很多时候当我们充分理解了使用者的需求后，才能为组件定义完善的接口和完整的功能。</p>\n<p data-nodeid="15934">思考题：</p>\n<blockquote data-nodeid="15935">\n<p data-nodeid="15936">上面我们讲述了如何使用 CocoaPods 来封装内部组件，请问怎样把内部组件升级成为私有组件和开源组件呢？</p>\n</blockquote>\n<p data-nodeid="15937">可以把回答写到下面的留言区哦，我们下一讲将介绍如何使用功能开关支持产品快速迭代。</p>\n<p data-nodeid="15938">源码地址：</p>\n<blockquote data-nodeid="15939">\n<p data-nodeid="15940" class="">DesignKit 源代码：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Frameworks/DesignKit?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="16121">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Frameworks/DesignKit</a></p>\n</blockquote>',
          },
          {
            theme: '09 | 开关组件：如何使用功能开关，支持产品快速迭代',
            id: 21,
            content:
              '<p data-nodeid="3319" class="">代码管理规范一讲我提到过，开发功能的时候要新建功能分支。在实际工作当中，有一种功能分支我把它叫作长命功能分支（Long lived feature branch），因为有些大功能需要我们花几周甚至几个月来开发，相对应地它的功能分支也会非常庞大。</p>\n<p data-nodeid="3320">当整个功能开发完毕后，我们需要把它合并到主分支里面，因为里面代码实在太多了，不可避免地就会出现许多合并冲突。哪怕勉强修正并编译通过，App 里面也很可能隐藏一些不容易发现的 Bug。</p>\n<p data-nodeid="3321">怎样解决这种难题呢？</p>\n<p data-nodeid="3322">通常的办法是我们会把一个庞大的功能分拆成多个小任务，每个任务都建一个独立的功能分支，当一个任务完成后马上合并到主分支里面。</p>\n<p data-nodeid="3323"><img src="https://s0.lgstatic.com/i/image6/M01/24/4D/CioPOWBYUUeARJ5qAAjTjIXDSJA208.png" alt="图片8.png" data-nodeid="3397"></p>\n<p data-nodeid="3324">如上图所示，为了完成一个庞大的功能，如实时通讯功能，我们分拆成多个小的功能分支，比如显示对话的子功能分支<code data-backticks="1" data-nodeid="3399">branch-1</code>，显示表情符号的子功能分支<code data-backticks="1" data-nodeid="3401">branch-2</code>等等。注意，我在图里面使用数字作为分支名字只是为了演示同一个大功能使用多个子分支，在现实情况下要根据每个小任务的内容进行命名。</p>\n<p data-nodeid="3325">但这样拆分成多个小的功能分支会导致什么问题呢？会出现我们每次把小任务合并到主分支的时候，不小心把未完成的功能发布给用户。例如我们在发布<code data-backticks="1" data-nodeid="3404">V1.2</code>版本的 App 时就包含了<code data-backticks="1" data-nodeid="3406">branch-1</code>分支上的代码，可是整个功能还没有开发完毕，我们并不愿意把这部分代码发布给 App Store 的用户。</p>\n<p data-nodeid="3326">那有没有什么办法既能及时合并代码，又能保证主分支可以随时发布呢？有，答案就是使用功能开关组件。</p>\n<h3 data-nodeid="3327">功能开关的好处</h3>\n<p data-nodeid="3328"><strong data-nodeid="3414">功能开关</strong>是软件开发中一种十分实用且功能强大的技术，它允许我们在不改变代码的情况下调整软件的行为。有了它，我们在快速开发的同时，也能放心定期发布新版本。</p>\n<p data-nodeid="3329">具体来说，当我们开发每一个大功能时，如果先定义一个功能开关，然后在整个功能开发完毕后再移除它，那么在移除之前，我们提交的任何版本就能避免因为疏忽大意而把未完成的功能发布到终端用户手上。</p>\n<p data-nodeid="3330"><img src="https://s0.lgstatic.com/i/image6/M01/1F/4A/CioPOWBRvmeAGcsiAAHzX6EpRRU507.png" alt="Drawing 1.png" data-nodeid="3418"></p>\n<p data-nodeid="3331">如上图所示，当我们开发一个大功能时，先从主分支签出一个功能分支<code data-backticks="1" data-nodeid="3420">add-toggle</code>来添加一个功能开关。 然后我们就可以把该功能拆分成多个子功能分支来进行开发，并不断地合并到主分支里面。在整个功能开发完毕以后，我们可以从主分支签出一个分支<code data-backticks="1" data-nodeid="3422">remove-toggle</code>来把功能开关删除掉。这个功能只会在 <code data-backticks="1" data-nodeid="3424">V1.4</code> 版本里面才会发布给终端用户。在此之前用户完全不知道这个功能的存在。</p>\n<p data-nodeid="3332">使用功能开关是保证主分支可以随时进行发布的有效手段。可以说，<strong data-nodeid="3431">一个能随时发布的主分支是衡量一个开发环境成熟与否的标准</strong>，为什么这样说呢？有两大原因：</p>\n<ol data-nodeid="3333">\n<li data-nodeid="3334">\n<p data-nodeid="3335">它是多团队平行开发的基础，当其中一个团队完成了一个功能以后，就可以在不与任何其他团队沟通的情况下马上进行发布；</p>\n</li>\n<li data-nodeid="3336">\n<p data-nodeid="3337">它是自动化发布的基础，有了随时可以发布的主分支，我们只需要更新版本号就可以让 CI 在任何时候打包并发布到 App Store，无须任何人为参与。</p>\n</li>\n</ol>\n<p data-nodeid="3338">既然功能开关那么强大，那怎么实现呢？接下来我们就结合 Moments App 一起来看看。</p>\n<h3 data-nodeid="3339">功能开关组件的实现</h3>\n<p data-nodeid="3340">根据不同的使用场景，我们为Moments App 开发了三类功能开关组件：<strong data-nodeid="3440">编译时开关、本地开关和远程开关。</strong></p>\n<ul data-nodeid="3341">\n<li data-nodeid="3342">\n<p data-nodeid="3343">编译时开关：让编译器通过检查编译条件来启动或者关闭一些功能。</p>\n</li>\n<li data-nodeid="3344">\n<p data-nodeid="3345">本地开关：让用户在 App 里面手动启动或者关闭一些功能。</p>\n</li>\n<li data-nodeid="3346">\n<p data-nodeid="3347">远程开关：让产品经理远程遥控 App 来启动或者关闭一些功能。</p>\n</li>\n</ul>\n<p data-nodeid="3348">下面我们一起来看看怎样实现这些功能开关组件吧。首先我们定义了一个名字叫作 <code data-backticks="1" data-nodeid="3445">ToggleType</code> 的协议（Protocol），然后分别定义了三个枚举类型（Enum）来代表三类开关。</p>\n<p data-nodeid="3349"><img src="https://s0.lgstatic.com/i/image6/M00/25/6C/CioPOWBZrCOACNxtAAKd2755Bx0933.png" alt="图片1.png" data-nodeid="3449"></p>\n<p data-nodeid="3350">有了这些功能开关的定义以后，接着我们定义这些开关的 DataStore。首先建立了一个名叫 <code data-backticks="1" data-nodeid="3451">TogglesDataStoreType</code>的协议，它只定义了两个方法，其中<code data-backticks="1" data-nodeid="3453">isToggleOn(_ toggle: ToggleType) -&gt; Bool</code> 用于读取某个开关的值，而 <code data-backticks="1" data-nodeid="3455">update(toggle: ToggleType, value: Bool)</code> 用于更新某个开关的值。</p>\n<p data-nodeid="3351"><img src="https://s0.lgstatic.com/i/image6/M00/24/4D/CioPOWBYURiAff7BAALmppeDy9I518.png" alt="图片6.png" data-nodeid="3459"></p>\n<p data-nodeid="3352">然后我们为每一类开关定义一个实现的结构体（Struct）。因为远程开关我会在后面的 29 讲详细介绍，所以在这一讲我主要为你介绍下编译时开关和本地开发怎样实现的。</p>\n<p data-nodeid="3353"><strong data-nodeid="3464">编译时开关组件</strong></p>\n<p data-nodeid="3354">下面是编译时开关 <code data-backticks="1" data-nodeid="3466">BuildTargetTogglesDataStore</code>的实现代码。</p>\n<pre class="lang-swift" data-nodeid="3355"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BuildTargetTogglesDataStore</span>: <span class="hljs-title">TogglesDataStoreType</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">BuildTargetTogglesDataStore</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> buildTarget: <span class="hljs-type">BuildTargetToggle</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() {\n        #<span class="hljs-keyword">if</span> <span class="hljs-type">DEBUG</span>\n        buildTarget = .debug\n        #endif\n        #<span class="hljs-keyword">if</span> <span class="hljs-type">INTERNAL</span>\n        buildTarget = .<span class="hljs-keyword">internal</span>\n        #endif\n        #<span class="hljs-keyword">if</span> <span class="hljs-type">PRODUCTION</span>\n        buildTarget = .production\n        #endif\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isToggleOn</span><span class="hljs-params">(<span class="hljs-number">_</span> toggle: ToggleType)</span></span> -&gt; <span class="hljs-type">Bool</span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> toggle = toggle <span class="hljs-keyword">as</span>? <span class="hljs-type">BuildTargetToggle</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n        }\n        <span class="hljs-keyword">return</span> toggle == buildTarget\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(toggle: ToggleType, value: Bool)</span></span> { }\n}\n</code></pre>\n<p data-nodeid="3356">因为 <code data-backticks="1" data-nodeid="3469">BuildTargetTogglesDataStore</code> 遵循了 <code data-backticks="1" data-nodeid="3471">TogglesDataStoreType</code>，我在这里实现了 <code data-backticks="1" data-nodeid="3473">isToggleOn</code> 和 <code data-backticks="1" data-nodeid="3475">update</code> 两个方法。由于我们不可能在运行时更新编译时的编译条件，因此 <code data-backticks="1" data-nodeid="3477">update</code> 方法的实现体为空。</p>\n<p data-nodeid="3357">而在 <code data-backticks="1" data-nodeid="3480">isToggleOn</code> 方法里面，我们会检查传递进来的 <code data-backticks="1" data-nodeid="3482">ToggleType</code> 的值是否和属性 <code data-backticks="1" data-nodeid="3484">buildTarget</code> 的值相等，如果相等就返回 <code data-backticks="1" data-nodeid="3486">true</code>，如果不相等就返回 <code data-backticks="1" data-nodeid="3488">false</code>。</p>\n<p data-nodeid="3358">那 <code data-backticks="1" data-nodeid="3491">buildTarget</code> 的值是怎样来的呢？我们可以看看 <code data-backticks="1" data-nodeid="3493">init</code> 方法。</p>\n<p data-nodeid="3359"><img src="https://s0.lgstatic.com/i/image6/M01/1F/53/CioPOWBRxW6AV4TlAAI7l4yPlhE343.png" alt="Drawing 4.png" data-nodeid="3497"></p>\n<p data-nodeid="3360">在 init 方法里面，我们有三条判断编译条件的语句，当编译条件包含了 <code data-backticks="1" data-nodeid="3499">INTERNAL</code> 时，就会把 <code data-backticks="1" data-nodeid="3501">buildTarget</code> 赋值为 <code data-backticks="1" data-nodeid="3503">.internal</code> 。那 <code data-backticks="1" data-nodeid="3505">INTERNAL</code> 从哪里来的呢？</p>\n<p data-nodeid="3361">我在如何搭建多环境支持那一讲提到过怎样通过 <code data-backticks="1" data-nodeid="3508">xcconfig</code> 文件来配置多个 <code data-backticks="1" data-nodeid="3510">Build Configuration</code>。该编译条件 <code data-backticks="1" data-nodeid="3512">INTERNAL</code> 来自 <code data-backticks="1" data-nodeid="3514">InternalProject.xcconfig</code> 文件。如下所示，我们把 <code data-backticks="1" data-nodeid="3516">INTERNAL</code> 赋值给 <code data-backticks="1" data-nodeid="3518">SWIFT_ACTIVE_COMPILATION_CONDITIONS</code> 。</p>\n<pre class="lang-java" data-nodeid="3362"><code data-language="java">SWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited) INTERNAL\n</code></pre>\n<p data-nodeid="3363">在编译的时候，编译器会从<code data-backticks="1" data-nodeid="3521">SWIFT_ACTIVE_COMPILATION_CONDITIONS</code>读取编译条件的值，当发现该编译条件已经定义了，就会编译 <code data-backticks="1" data-nodeid="3523">#if #endif</code> 代码块内的代码。</p>\n<p data-nodeid="3364">回到上图 init 方法的例子，当我们选择了 <strong data-nodeid="3538">Moments-Internal</strong> Scheme 时，编译器就会选择名字叫作 <strong data-nodeid="3539">Internal</strong> 的 Build Configuration。这个 Configuration 读取 InternalProject.xcconfig 后把<code data-backticks="1" data-nodeid="3534">SWIFT_ACTIVE_COMPILATION_CONDITIONS</code>赋值为<code data-backticks="1" data-nodeid="3536">INTERNAL</code>。因此，在编译的时候，上面的代码只有第 25 行会编译，第 21 行和第 29 行都会被忽略掉。</p>\n<p data-nodeid="3365">通过编译时开关，我们就能让不同环境版本的 App 激活或者隐藏不同的功能。下面是如何导航到隐藏功能菜单页面的代码。它的大致逻辑是，我们通过重写 UIWindow 的 motionEnded 方法来捕捉手机震动的事件。</p>\n<pre class="lang-swift" data-nodeid="3366"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIWindow</span> </span>{\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">motionEnded</span><span class="hljs-params">(<span class="hljs-number">_</span> motion: UIEvent.EventSubtype, with event: UIEvent?)</span></span> {\n        <span class="hljs-keyword">if</span> <span class="hljs-type">BuildTargetTogglesDataStore</span>.shared.isToggleOn(<span class="hljs-type">BuildTargetToggle</span>.debug)\n            || <span class="hljs-type">BuildTargetTogglesDataStore</span>.shared.isToggleOn(<span class="hljs-type">BuildTargetToggle</span>.<span class="hljs-keyword">internal</span>) {\n            <span class="hljs-keyword">let</span> router: <span class="hljs-type">AppRouting</span> = <span class="hljs-type">AppRouter</span>()\n            <span class="hljs-keyword">if</span> motion == .motionShake {\n                router.route(to: <span class="hljs-type">URL</span>(string: <span class="hljs-string">"\\(UniversalLinks.baseURL)InternalMenu"</span>), from: rootViewController, using: .present)\n            }\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="3367">具体来说，当用户在摇动手机的时候，代码会通过<code data-backticks="1" data-nodeid="3542">BuildTargetTogglesDataStore</code>的<code data-backticks="1" data-nodeid="3544">isToggleOn</code>方法来检查当前的 App 是否为开发环境或者测试环境版本，如果“是”就会使用<code data-backticks="1" data-nodeid="3546">AppRouter</code>到导航到隐藏功能菜单页面。如果“不是”（如生产环境 App Store版本），就不进行导航。这样能保证从 App Store 上下载 App 的用户，没办法使用隐藏菜单的功能。<br>\n<strong data-nodeid="3552">本地开关组件</strong></p>\n<p data-nodeid="3368">如果说编译时开关能够方便你为不同环境的 App 激活或者隐藏不同的功能，那么本地开关则可以让内部测试人员和产品经理随时测试和验证功能，从而保证产品快速的迭代。</p>\n<p data-nodeid="3369">下面一起看看本地开关的实现代码。</p>\n<pre class="lang-swift" data-nodeid="3370"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InternalToggle</span>: <span class="hljs-title">String</span>, <span class="hljs-title">ToggleType</span> </span>{\n    <span class="hljs-keyword">case</span> isLikeButtonForMomentEnabled\n    <span class="hljs-keyword">case</span> isSwiftUIEnabled\n}\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalTogglesDataStore</span>: <span class="hljs-title">TogglesDataStoreType</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> userDefaults: <span class="hljs-type">UserDefaults</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>(userDefaults: <span class="hljs-type">UserDefaults</span>) {\n        <span class="hljs-keyword">self</span>.userDefaults = userDefaults\n        <span class="hljs-keyword">self</span>.userDefaults.register(defaults: [\n            <span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled.rawValue: <span class="hljs-literal">false</span>,\n            <span class="hljs-type">InternalToggle</span>.isSwiftUIEnabled.rawValue: <span class="hljs-literal">false</span>\n            ])\n    }\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">InternalTogglesDataStore</span> = .<span class="hljs-keyword">init</span>(userDefaults: .standard)\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isToggleOn</span><span class="hljs-params">(<span class="hljs-number">_</span> toggle: ToggleType)</span></span> -&gt; <span class="hljs-type">Bool</span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> toggle = toggle <span class="hljs-keyword">as</span>? <span class="hljs-type">InternalToggle</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n        }\n        <span class="hljs-keyword">return</span> userDefaults.bool(forKey: toggle.rawValue)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(toggle: ToggleType, value: Bool)</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> toggle = toggle <span class="hljs-keyword">as</span>? <span class="hljs-type">InternalToggle</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span>\n        }\n        userDefaults.<span class="hljs-keyword">set</span>(value, forKey: toggle.rawValue)\n    }\n}\n</code></pre>\n<p data-nodeid="3371">当每次新增一个本地开关的时候，我们都在<code data-backticks="1" data-nodeid="3556">InternalToggle</code>枚举里面添加一个<code data-backticks="1" data-nodeid="3558">case</code>。当前的 Moments App 有两个本地开关，分别用于“点赞功能”和“使用 SwiftUI”。</p>\n<p data-nodeid="3372">因为<code data-backticks="1" data-nodeid="3561">InternalTogglesDataStore</code>也遵循了<code data-backticks="1" data-nodeid="3563">TogglesDataStoreType</code>协议，所以也需要实现<code data-backticks="1" data-nodeid="3565">isToggleOn</code>和<code data-backticks="1" data-nodeid="3567">update</code>两个方法。它们都使用了<code data-backticks="1" data-nodeid="3569">UserDefaults</code>来读写配置信息，这样能保证用户重启 App 以后也能获取之前所选择的开关配置。</p>\n<p data-nodeid="3373">这里我给你分享一个管理本地开关的技巧。</p>\n<p data-nodeid="3374">在<code data-backticks="1" data-nodeid="3573">init</code>方法里面，我通过<code data-backticks="1" data-nodeid="3575">UserDefaults</code>的<code data-backticks="1" data-nodeid="3577">register</code>方法为每个开关赋予默认值。绝大多数情况下，这个默认值都为<code data-backticks="1" data-nodeid="3579">false</code>，表示该功能还没有发布。</p>\n<p data-nodeid="3375">那什么时候这个值会成为 <code data-backticks="1" data-nodeid="3582">true</code> 呢？假如我们完成了一个功能，而且产品经理验证过可以发布上线，那么我就可以把该开关的默认值设为<code data-backticks="1" data-nodeid="3584">true</code>。但上线以后发现该功能引起严重的崩溃，我们可以马上把该值修改为<code data-backticks="1" data-nodeid="3586">false</code>并立刻发布新版本。</p>\n<p data-nodeid="3376">还有一点需要注意的是，当功能上线并运行正常的情况下，要及时清理相关的功能开关，因为开关太多会增加代码逻辑的复杂度。</p>\n<p data-nodeid="3377">下面一起看看代码中使用本地开关的例子吧。</p>\n<pre class="lang-swift" data-nodeid="3378"><code data-language="swift"><span class="hljs-keyword">if</span> <span class="hljs-type">InternalTogglesDataStore</span>.shared.isToggleOn(<span class="hljs-type">InternalToggle</span>.isSwiftUIEnabled) {\n    window?.rootViewController = <span class="hljs-type">UIHostingController</span>(rootView: <span class="hljs-type">SwiftUIMomentsListView</span>().environmentObject(<span class="hljs-type">UserDataStoreObservableObject</span>()))\n} <span class="hljs-keyword">else</span> {\n    window?.rootViewController = <span class="hljs-type">MomentsListViewController</span>()\n}\n</code></pre>\n<p data-nodeid="3379">我们通过<code data-backticks="1" data-nodeid="3591">InternalTogglesDataStore</code>来检查<code data-backticks="1" data-nodeid="3593">.isSwiftUIEnabled</code>开关是否启动，如果“是”就启动 SwiftUI 的界面，否则就启动 UIKit 的界面。下面是演示的效果。</p>\n<p data-nodeid="3380"><img src="https://s0.lgstatic.com/i/image6/M00/24/37/Cgp9HWBYPLeAW1FfAKgkEsZ8QtE822.gif" alt="2021322-144332.gif" data-nodeid="3597"></p>\n<p data-nodeid="3381">我们可以在内部隐藏菜单里面启动或者关闭 <strong data-nodeid="3603">SwiftUIEnable</strong>开关。App 在启动的时候会根据该开关来选择启动 SwiftUI 或者 UIKit 的界面。</p>\n<h3 data-nodeid="3382">总结</h3>\n<p data-nodeid="3383">这一讲我主要介绍了如何使用功能开关来解决长命功能分支的问题，并详细介绍了如何开发编译时开关组件和本地开发组件。有了这些功能开关组件以后，既保证我们能快速开发功能，又能保证发布的版本不会出错，让整个团队在安全的环境下快速迭代。</p>\n<p data-nodeid="3384">思考题：</p>\n<blockquote data-nodeid="3385">\n<p data-nodeid="3386">请问你的团队是怎样让测试人员检查未上线功能的？有什么好的经验或者教训给大家分享一下？</p>\n</blockquote>\n<p data-nodeid="3387">可以把回答写到下面的留言区哦，我们下一讲将介绍如何开发内部隐藏菜单，通过隐藏功能来分离生产和研发环境。</p>\n<p data-nodeid="3388"><strong data-nodeid="3612">源码地址：</strong></p>\n<blockquote data-nodeid="3617">\n<p data-nodeid="3618" class="te-preview-highlight">功能开关文件地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Toggles?fileGuid=EubJYGqYgOIGJ2XM" data-nodeid="3623">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Toggles</a></p>\n</blockquote>',
          },
          {
            theme: '10 | 支撑组件：如何实现隐藏菜单，快速测试与验证？',
            id: 22,
            content:
              '<p data-nodeid="9068" class="">不知道在工作当中，你有没有为了测试和验证开发中的功能，特意为测试和产品经理打包一个特殊版本的 App？或者当多个团队并行开发的时候，为了测试，每个团队都单独打包出不同版本的 App？还有当你想添加某些供内部使用的功能（如清理 Cache），但又不想让 App Store 的用户使用，你是不是又专门打包了一个特殊版本的 App？</p>\n<p data-nodeid="9069">每次遇到这些情况，你是不是觉得特麻烦？</p>\n<p data-nodeid="9070">其实，这些都可以通过一个内部隐藏功能菜单来解决。在这一讲我就结合我们的 Moments App 来和你介绍下，如何开发了一个隐藏功能菜单，快速实现功能测试和验证。</p>\n<p data-nodeid="9071"><img src="https://s0.lgstatic.com/i/image6/M00/25/25/Cgp9HWBZZJ2AH9MrAAKIA8i2Fmc948.png" alt="Drawing 0.png" data-nodeid="9183"></p>\n<div data-nodeid="9072"><p style="text-align:center">Moments App 的隐藏菜单</p></div>\n<p data-nodeid="9073">下面是隐藏菜单模块使用到的所有源代码文件。</p>\n<p data-nodeid="9074"><img src="https://s0.lgstatic.com/i/image6/M00/25/25/Cgp9HWBZZKaAdBs7AAsAbhLBscQ965.png" alt="Drawing 1.png" data-nodeid="9187"></p>\n<p data-nodeid="9075">我把这些模块中使用到的类型分成两大类：</p>\n<ul data-nodeid="9076">\n<li data-nodeid="9077">\n<p data-nodeid="9078">用于呈现的 <strong data-nodeid="9194">View</strong>，主要分为 ViewController + Tableview 以及 TableViewCell 两层；</p>\n</li>\n<li data-nodeid="9079">\n<p data-nodeid="9080">用于存储配置数据的 <strong data-nodeid="9200">ViewModel</strong>，它分为用于 TableView 的 ViewModel，用于 TableView Section 的 ViewModel 以及用于 TableView Cell 的 ViewModel。</p>\n</li>\n</ul>\n<p data-nodeid="9081">下面是所有类型的分类总揽图，你可以简单看一下，我会在后面进行一一介绍。</p>\n<p data-nodeid="9082"><img src="https://s0.lgstatic.com/i/image6/M01/26/78/Cgp9HWBa_RSAdIwEAA0pmTe83Oo125.png" alt="图片20.png" data-nodeid="9204"></p>\n<h3 data-nodeid="9083">View</h3>\n<p data-nodeid="9084">下面是 View 部分的所有类型的关系图。</p>\n<p data-nodeid="9085"><img src="https://s0.lgstatic.com/i/image6/M00/26/75/CioPOWBa_MyAWG4pAAZ-OokPy3k632.png" alt="图片19.png" data-nodeid="9209"></p>\n<p data-nodeid="9086">隐藏菜单的 UI 使用了 UIKit 的<code data-backticks="1" data-nodeid="9211">UITableView</code>来实现，其包含了四大部分：<strong data-nodeid="9216">通用信息、DesignKit 范例、功能开关和工具箱，每一部分都是一个 TableView Section。</strong></p>\n<p data-nodeid="9087">为了提高可重用性，以便于快速开发新的隐藏功能，我们把<code data-backticks="1" data-nodeid="9218">UITableView</code>嵌入到<code data-backticks="1" data-nodeid="9220">UIViewController</code>的子类<code data-backticks="1" data-nodeid="9222">InternalMenuViewController</code>里面。然后通过 RxDataSources 把<code data-backticks="1" data-nodeid="9224">tableView</code>和<code data-backticks="1" data-nodeid="9226">viewModel</code>绑定到一起。</p>\n<pre class="lang-swift" data-nodeid="9088"><code data-language="swift"><span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="hljs-type">InternalMenuSection</span>&gt;(\n    configureCell: { <span class="hljs-number">_</span>, tableView, indexPath, item <span class="hljs-keyword">in</span>\n    <span class="hljs-keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: item.type.rawValue, <span class="hljs-keyword">for</span>: indexPath)\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cell = cell <span class="hljs-keyword">as</span>? <span class="hljs-type">InternalMenuCellType</span> {\n            cell.update(with: item)\n        }\n        <span class="hljs-keyword">return</span> cell\n    }, titleForHeaderInSection: { dataSource, section <span class="hljs-keyword">in</span>\n        <span class="hljs-keyword">return</span> dataSource.sectionModels[section].title\n    }, titleForFooterInSection: { dataSource, section <span class="hljs-keyword">in</span>\n        <span class="hljs-keyword">return</span> dataSource.sectionModels[section].footer\n    })\nviewModel.sections\n    .bind(to: tableView.rx.items(dataSource: dataSource))\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="9089">你可以看到，RxDataSources 帮我们把 UIKit 里面恼人的 DataSource 和 Delegate 通过封包封装起来。当生成 Cell 的时候，统一调用<code data-backticks="1" data-nodeid="9229">InternalMenuCellType</code>协议的<code data-backticks="1" data-nodeid="9231">update(with item: InternalMenuItemViewModel)</code>方法来更新 Cell 的 UI。因此所有的 Cell 都必须遵循<code data-backticks="1" data-nodeid="9233">InternalMenuCellType</code>协议。</p>\n<p data-nodeid="9090">根据 Cell 的不同作用，我们把它分成三类：</p>\n<ul data-nodeid="9091">\n<li data-nodeid="9092">\n<p data-nodeid="9093">用于显示描述信息的<code data-backticks="1" data-nodeid="9237">InternalMenuDescriptionCell</code></p>\n</li>\n<li data-nodeid="9094">\n<p data-nodeid="9095">用于响应点击事件的<code data-backticks="1" data-nodeid="9239">InternalMenuActionTriggerCell</code></p>\n</li>\n<li data-nodeid="9096">\n<p data-nodeid="9097">用于功能开关的<code data-backticks="1" data-nodeid="9241">InternalMenuFeatureToggleCell</code></p>\n</li>\n</ul>\n<p data-nodeid="9098">它们都必须实现<code data-backticks="1" data-nodeid="9243">InternalMenuCellType</code>协议里面的<code data-backticks="1" data-nodeid="9245">update(with item: InternalMenuItemViewModel)</code>方法。下面以<code data-backticks="1" data-nodeid="9247">InternalMenuDescriptionCell</code>为例子来看看具体代码是怎样实现的。</p>\n<pre class="lang-swift" data-nodeid="9099"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMenuDescriptionCell</span>: <span class="hljs-title">UITableViewCell</span>, <span class="hljs-title">InternalMenuCellType</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with item: InternalMenuItemViewModel)</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> item = item <span class="hljs-keyword">as</span>? <span class="hljs-type">InternalMenuDescriptionItemViewModel</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span>\n        }\n        selectionStyle = .<span class="hljs-keyword">none</span>\n        textLabel?.text = item.title\n    }\n}\n</code></pre>\n<p data-nodeid="9100">在<code data-backticks="1" data-nodeid="9250">update</code>的方法里，我们通过<code data-backticks="1" data-nodeid="9252">guard</code>语句检查并把<code data-backticks="1" data-nodeid="9254">item</code>的类型从<code data-backticks="1" data-nodeid="9256">InternalMenuItemViewModel</code>向下转型（downcast）为<code data-backticks="1" data-nodeid="9258">InternalMenuDescriptionItemViewModel</code>。因为只有在类型转换成功的时候，才能更新当前 Cell 的 UI。<code data-backticks="1" data-nodeid="9260">InternalMenuActionTriggerCell</code>和<code data-backticks="1" data-nodeid="9262">InternalMenuFeatureToggleCell</code>的实现方法也和<code data-backticks="1" data-nodeid="9264">InternalMenuDescriptionCell</code>一样。<br>\n到此为止， View 部分的实现以及完成了。你可能会问<code data-backticks="1" data-nodeid="9268">InternalMenuItemViewModel</code>和<code data-backticks="1" data-nodeid="9270">InternalMenuDescriptionItemViewModel</code>那些类型是哪里来的？我们一起来看看 ViewModel 部分吧。</p>\n<h3 data-nodeid="9101">ViewModel</h3>\n<p data-nodeid="9102">ViewModel 的作用是为 View 准备需要呈现的数据，因此 ViewModel 的类型层级关系也与 View 类型层级关系一一对应起来，分成三大类。</p>\n<ul data-nodeid="9103">\n<li data-nodeid="9104">\n<p data-nodeid="9105">用于准备 TableView 数据的<code data-backticks="1" data-nodeid="9275">InternalMenuViewModel</code></p>\n</li>\n<li data-nodeid="9106">\n<p data-nodeid="9107">用于准备 TableView Section 数据的<code data-backticks="1" data-nodeid="9277">InternalMenuSection</code></p>\n</li>\n<li data-nodeid="9108">\n<p data-nodeid="9109">由于准备 TableView Cell 数据的<code data-backticks="1" data-nodeid="9279">InternalMenuItemViewModel</code></p>\n</li>\n</ul>\n<p data-nodeid="9110">由于位于上层的类型会引用到下层的类型，为了更好地理解它们的依赖关系，我准备从下往上为你介绍各层类型的实现。</p>\n<h4 data-nodeid="9111">用于 TableView Cell 的 ViewModel</h4>\n<p data-nodeid="9112"><img src="https://s0.lgstatic.com/i/image6/M00/26/75/CioPOWBa_K6AYenCAAQfOR83siU591.png" alt="图片18.png" data-nodeid="9284"></p>\n<p data-nodeid="9113">前面提到过，我把 Cell 分成了三类，与之对应的 ViewModel 也分成三类。我定义了一个名叫<code data-backticks="1" data-nodeid="9286">InternalMenuItemType</code>的枚举类型（enum）来存放这些分类信息，假如以后要在隐藏菜单里开发新功能的 Cell，我们可以在该类型里面增加一个<code data-backticks="1" data-nodeid="9288">case</code>。下面是当前<code data-backticks="1" data-nodeid="9290">InternalMenuItemType</code>的代码。</p>\n<pre class="lang-swift" data-nodeid="9114"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InternalMenuItemType</span>: <span class="hljs-title">String</span> </span>{\n    <span class="hljs-keyword">case</span> description\n    <span class="hljs-keyword">case</span> featureToggle\n    <span class="hljs-keyword">case</span> actionTrigger\n}\n</code></pre>\n<p data-nodeid="9115">因为我们在为<code data-backticks="1" data-nodeid="9293">InternalMenuViewController</code>的<code data-backticks="1" data-nodeid="9295">tableView</code>注册 Cell 的时候使用了这个枚举作为<code data-backticks="1" data-nodeid="9297">ReuseIdentifier</code>，因此把这个枚举的原始值（Raw value）定义为<code data-backticks="1" data-nodeid="9299">String</code>类型。下面是注册 Cell 时的代码。</p>\n<pre class="lang-swift" data-nodeid="9116"><code data-language="swift">$tableView.register(<span class="hljs-type">InternalMenuDescriptionCell</span>.<span class="hljs-keyword">self</span>, forCellReuseIdentifier: <span class="hljs-type">InternalMenuItemType</span>.description.rawValue)\n</code></pre>\n<p data-nodeid="9117">为了提高代码的可扩展性，我们在架构和开发 Moments App 时都遵守面向协议编程（Protocol Oriented Programming）的原则。落实到这个地方，我们为三个 ViewModel 抽象出一个共同的协议<code data-backticks="1" data-nodeid="9302">InternalMenuItemViewModel</code>，其代码如下：</p>\n<pre class="lang-swift" data-nodeid="9118"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">InternalMenuItemViewModel</span> </span>{\n    <span class="hljs-keyword">var</span> type: <span class="hljs-type">InternalMenuItemType</span> { <span class="hljs-keyword">get</span> }\n    <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">select</span><span class="hljs-params">()</span></span>\n}\n</code></pre>\n<p data-nodeid="9119"><code data-backticks="1" data-nodeid="9304">InternalMenuItemViewModel</code>定义了两个属性分别用于表示 Cell 类型以及显示的标题，同时也定义了一个名叫<code data-backticks="1" data-nodeid="9306">select()</code>方法来处理 Cell 的点击事件。我们在<code data-backticks="1" data-nodeid="9308">InternalMenuViewController</code>里通过 RxDataSources 把<code data-backticks="1" data-nodeid="9310">tableView</code>和<code data-backticks="1" data-nodeid="9312">InternalMenuItemViewModel</code>绑定起来，使得<code data-backticks="1" data-nodeid="9314">InternalMenuItemViewModel</code>可以处理 Cell 的点击事件。代码如下：</p>\n<pre class="lang-swift" data-nodeid="9120"><code data-language="swift">tableView.rx\n    .modelSelected(<span class="hljs-type">InternalMenuItemViewModel</span>.<span class="hljs-keyword">self</span>)\n    .subscribe(onNext: { item <span class="hljs-keyword">in</span>\n        item.select()\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="9121">当用户点击 TableView 上某个 Cell 的时候，就会调用对应的 ViewModel 的<code data-backticks="1" data-nodeid="9317">select()</code>方法。 但并不是所有的 Cell 都需要响应点击的事件，例如用于描述 App 版本号的 Cell，就不需要处理点击事件。</p>\n<p data-nodeid="17228" class="te-preview-highlight">为了简化开发的工作量，我们为<code data-backticks="1" data-nodeid="17230">InternalMenuItemViewModel</code>定义了一个名叫<code data-backticks="1" data-nodeid="17232">select()</code>的协议扩展方法，并且为该协议提供了一个默认的实现，即当遵循<code data-backticks="1" data-nodeid="17234">InternalMenuItemViewModel</code>协议的类型未实现<code data-backticks="1" data-nodeid="17236">select()</code>方法时，程序就会执行协议扩展所定义的<code data-backticks="1" data-nodeid="17238">select()</code>方法 。代码如下：</p>\n\n\n\n\n\n\n\n\n\n<pre class="lang-swift" data-nodeid="9123"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">InternalMenuItemViewModel</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">select</span><span class="hljs-params">()</span></span> { }\n}\n</code></pre>\n<p data-nodeid="9124">下面一起看看不同类型 Cell 所对应的 ViewModel 实现方法。</p>\n<h5 data-nodeid="9125">InternalMenuDescriptionItemViewModel</h5>\n<p data-nodeid="9126"><code data-backticks="1" data-nodeid="9332">InternalMenuDescriptionItemViewModel</code>用于显示描述类型的 Cell，其功能非常简单，就是显示一句描述信息，例如 App 的版本号。其代码实现也十分容易，首先它需要实现来自<code data-backticks="1" data-nodeid="9334">InternalMenuItemViewModel</code>的<code data-backticks="1" data-nodeid="9336">type</code>属性并返回<code data-backticks="1" data-nodeid="9338">.description</code>，然后实现<code data-backticks="1" data-nodeid="9340">title</code>属性来存储描述信息的字符串。 其具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="9127"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalMenuDescriptionItemViewModel</span>: <span class="hljs-title">InternalMenuItemViewModel</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> type: <span class="hljs-type">InternalMenuItemType</span> = .description\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>\n}\n</code></pre>\n<h5 data-nodeid="9128">InternalMenuFeatureToggleItemViewModel</h5>\n<p data-nodeid="9129"><code data-backticks="1" data-nodeid="9343">InternalMenuFeatureToggleItemViewModel</code>用于存放本地功能开关的配置数据，因此它引用了上一讲提到过的<code data-backticks="1" data-nodeid="9345">InternalTogglesDataStore</code>来存储和读取本地开关的信息。</p>\n<p data-nodeid="9130">除了实现<code data-backticks="1" data-nodeid="9348">type</code>和<code data-backticks="1" data-nodeid="9350">title</code>属性以外，它提供了两个关键的接口供外部使用：</p>\n<ol data-nodeid="9131">\n<li data-nodeid="9132">\n<p data-nodeid="9133">命名为<code data-backticks="1" data-nodeid="9353">isOn</code>的计算属性（Computed property），供外部读取开关的状态；</p>\n</li>\n<li data-nodeid="9134">\n<p data-nodeid="9135"><code data-backticks="1" data-nodeid="9355">toggle(isOn: Bool)</code>方法，给外部更新开关的状态。</p>\n</li>\n</ol>\n<p data-nodeid="9136">具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="9137"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalMenuFeatureToggleItemViewModel</span>: <span class="hljs-title">InternalMenuItemViewModel</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> toggle: <span class="hljs-type">ToggleType</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span>\n    <span class="hljs-keyword">init</span>(title: <span class="hljs-type">String</span>, toggle: <span class="hljs-type">ToggleType</span>, togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span> = <span class="hljs-type">InternalTogglesDataStore</span>.shared) {\n        <span class="hljs-keyword">self</span>.title = title\n        <span class="hljs-keyword">self</span>.toggle = toggle\n        <span class="hljs-keyword">self</span>.togglesDataStore = togglesDataStore\n    }\n    <span class="hljs-keyword">let</span> type: <span class="hljs-type">InternalMenuItemType</span> = .featureToggle\n    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">var</span> isOn: <span class="hljs-type">Bool</span> {\n       <span class="hljs-keyword">return</span> togglesDataStore.isToggleOn(toggle)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toggle</span><span class="hljs-params">(isOn: Bool)</span></span> {\n        togglesDataStore.update(toggle: toggle, value: isOn)\n    }\n}\n</code></pre>\n<h5 data-nodeid="9138">InternalMenuActionTriggerItemViewModel</h5>\n<p data-nodeid="9139">我们为响应点击事件的 Cell 都封装在<code data-backticks="1" data-nodeid="9360">InternalMenuActionTriggerItemViewModel</code>里面，该 ViewModel 是一个类。代码如下：</p>\n<pre class="lang-swift" data-nodeid="9140"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMenuActionTriggerItemViewModel</span>: <span class="hljs-title">InternalMenuItemViewModel</span> </span>{\n    <span class="hljs-keyword">var</span> type: <span class="hljs-type">InternalMenuItemType</span> { .actionTrigger }\n    <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> { <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorSubclassToImplement) }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">select</span><span class="hljs-params">()</span></span> { <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorSubclassToImplement) }\n}\n</code></pre>\n<p data-nodeid="9141"><code data-backticks="1" data-nodeid="9362">InternalMenuActionTriggerItemViewModel</code>遵循了<code data-backticks="1" data-nodeid="9364">InternalMenuItemViewModel</code>协议，因此也需要实现<code data-backticks="1" data-nodeid="9366">type</code>属性，并返回<code data-backticks="1" data-nodeid="9368">.actionTrigger</code>，同时我还实现了<code data-backticks="1" data-nodeid="9370">title</code>属性和<code data-backticks="1" data-nodeid="9372">select()</code>方法，它们都直接抛出<code data-backticks="1" data-nodeid="9374">fatalError</code>错误。这是为什么呢？</p>\n<p data-nodeid="9142">因为我们想把<code data-backticks="1" data-nodeid="9377">InternalMenuActionTriggerItemViewModel</code>定义为一个抽象类，然后把<code data-backticks="1" data-nodeid="9379">title</code>属性和<code data-backticks="1" data-nodeid="9381">select()</code>方法都定义为抽象属性和抽象方法。可是 Swift 并不支持抽象类，为了模拟概念上的抽象类，我们定义了一个普通的类，然后在<code data-backticks="1" data-nodeid="9383">title</code>属性和<code data-backticks="1" data-nodeid="9385">select()</code>方法里面抛出<code data-backticks="1" data-nodeid="9387">fatalError</code>错误。</p>\n<p data-nodeid="9143">这样做有两个作用，第一是能防止调用者直接构造出<code data-backticks="1" data-nodeid="9390">InternalMenuActionTriggerItemViewModel</code>的实例。第二是强迫其子类重写<code data-backticks="1" data-nodeid="9392">title</code>属性和<code data-backticks="1" data-nodeid="9394">select()</code>方法。下面是它的两个子类的实现代码。</p>\n<pre class="lang-swift" data-nodeid="9144"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMenuCrashAppItemViewModel</span>: <span class="hljs-title">InternalMenuActionTriggerItemViewModel</span> </span>{\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.crashApp\n    }\n    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">select</span><span class="hljs-params">()</span></span> {\n        <span class="hljs-built_in">fatalError</span>()\n    }\n}\n<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMenuDesignKitDemoItemViewModel</span>: <span class="hljs-title">InternalMenuActionTriggerItemViewModel</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> router: <span class="hljs-type">AppRouting</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> routingSourceProvider: <span class="hljs-type">RoutingSourceProvider</span>\n    <span class="hljs-keyword">init</span>(router: <span class="hljs-type">AppRouting</span>, routingSourceProvider: @escaping <span class="hljs-type">RoutingSourceProvider</span>) {\n        <span class="hljs-keyword">self</span>.router = router\n        <span class="hljs-keyword">self</span>.routingSourceProvider = routingSourceProvider\n    }\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.designKitDemo\n    }\n    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">select</span><span class="hljs-params">()</span></span> {\n        router.route(to: <span class="hljs-type">URL</span>(string: <span class="hljs-string">"\\(UniversalLinks.baseURL)DesignKit"</span>), from: routingSourceProvider(), using: .show)\n    }\n}\n</code></pre>\n<p data-nodeid="9145">当我们为<code data-backticks="1" data-nodeid="9397">InternalMenuActionTriggerItemViewModel</code>定义子类的时候，为了让子类不能被其他子类所继承，而且提高编译速度，我们把子类<code data-backticks="1" data-nodeid="9399">InternalMenuCrashAppItemViewModel</code>和<code data-backticks="1" data-nodeid="9401">InternalMenuDesignKitDemoItemViewModel</code>都定义成<code data-backticks="1" data-nodeid="9403">final class</code>。</p>\n<p data-nodeid="9146">这两个子类都重写了<code data-backticks="1" data-nodeid="9406">title</code>属性和<code data-backticks="1" data-nodeid="9408">select()</code>方法。下面分别看看它们的具体实现。</p>\n<p data-nodeid="9147"><code data-backticks="1" data-nodeid="9410">InternalMenuCrashAppItemViewModel</code>的作用是把 App 给闪退了，因此在其<code data-backticks="1" data-nodeid="9412">select()</code>方法里面调用了<code data-backticks="1" data-nodeid="9414">fatalError()</code>。当用户点击<strong data-nodeid="9420">闪退 App</strong> Cell 的时候，App 会立刻崩溃并退出。</p>\n<p data-nodeid="9148">而<code data-backticks="1" data-nodeid="9422">InternalMenuDesignKitDemoItemViewModel</code>是用于打开 DesignKit 的范例页面。我们在其<code data-backticks="1" data-nodeid="9424">select()</code>方法里面调用了<code data-backticks="1" data-nodeid="9426">router.route(to:from:using)</code>进行导航。当用户点击 <strong data-nodeid="9432">DesignKit 范例</strong> Cell 的时候，App 会导航到 DesignKit 的范例页面，方便设计师和产品经理查看公共设计组件。</p>\n<p data-nodeid="9149">以上是如何开发用于显示<code data-backticks="1" data-nodeid="9434">UITableViewCell</code>的 ViewModel 。下面一起看看 TableView Section 所对应的 ViewModel。</p>\n<h4 data-nodeid="9150">用于 TableView Section 的 ViewModel</h4>\n<p data-nodeid="9151">为了准备 TableView Section 的数据，我建立一个名叫<code data-backticks="1" data-nodeid="9438">InternalMenuSection</code>的结构体（Struct）。这个结构体遵循了自于 RxDataSources 的<code data-backticks="1" data-nodeid="9440">SectionModelType</code>协议。</p>\n<p data-nodeid="9152"><img src="https://s0.lgstatic.com/i/image6/M01/26/78/Cgp9HWBa_HGAVEN9AANjLQSDkHA044.png" alt="图片17.png" data-nodeid="9444"></p>\n<p data-nodeid="9153">因为<code data-backticks="1" data-nodeid="9446">SectionModelType</code>使用了<code data-backticks="1" data-nodeid="9448">associatedtype</code>来定义<code data-backticks="1" data-nodeid="9450">Item</code>的类型，所有遵循该协议的类型都必须为<code data-backticks="1" data-nodeid="9452">Item</code>明确指明其类型信息，代码如下。</p>\n<pre class="lang-swift" data-nodeid="9154"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">SectionModelType</span> </span>{\n    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Item</span>\n    <span class="hljs-keyword">var</span> items: [<span class="hljs-type">Item</span>] { <span class="hljs-keyword">get</span> }\n    <span class="hljs-keyword">init</span>(original: <span class="hljs-type">Self</span>, items: [<span class="hljs-type">Item</span>])\n}\n</code></pre>\n<p data-nodeid="9155">因为<code data-backticks="1" data-nodeid="9455">InternalMenuSection</code>遵循了<code data-backticks="1" data-nodeid="9457">SectionModelType</code>协议，所以需要明确指明<code data-backticks="1" data-nodeid="9459">Item</code>的类型为<code data-backticks="1" data-nodeid="9461">InternalMenuItemViewModel</code>。<code data-backticks="1" data-nodeid="9463">InternalMenuSection</code>还实现了两个<code data-backticks="1" data-nodeid="9465">init</code>方法来进行初始化。具体代码如下。</p>\n<pre class="lang-swift" data-nodeid="9156"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalMenuSection</span>: <span class="hljs-title">SectionModelType</span> </span>{\n    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> items: [<span class="hljs-type">InternalMenuItemViewModel</span>]\n    <span class="hljs-keyword">let</span> footer: <span class="hljs-type">String?</span>\n    <span class="hljs-keyword">init</span>(title: <span class="hljs-type">String</span>, items: [<span class="hljs-type">InternalMenuItemViewModel</span>], footer: <span class="hljs-type">String?</span> = <span class="hljs-literal">nil</span>) {\n        <span class="hljs-keyword">self</span>.title = title\n        <span class="hljs-keyword">self</span>.items = items\n        <span class="hljs-keyword">self</span>.footer = footer\n    }\n    <span class="hljs-keyword">init</span>(original: <span class="hljs-type">InternalMenuSection</span>, items: [<span class="hljs-type">InternalMenuItemViewModel</span>]) {\n        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(title: original.title, items: items, footer: original.footer)\n    }\n}\n</code></pre>\n<p data-nodeid="9157">有了用于<code data-backticks="1" data-nodeid="9468">UITableViewCell</code>和 TableView Section 的 ViewModel 以后，现在就剩下最后一个了，一起看看如何实现一个用于<code data-backticks="1" data-nodeid="9470">UITableView</code>的 ViewModel 吧。</p>\n<h4 data-nodeid="9158">用于 TableView 的 ViewModel</h4>\n<p data-nodeid="9159"><img src="https://s0.lgstatic.com/i/image6/M01/26/78/Cgp9HWBa_F2ANOdDAAMyEuhYLPE545.png" alt="1.png" data-nodeid="9475"></p>\n<p data-nodeid="9160">用于<code data-backticks="1" data-nodeid="9477">UITableView</code>的 ViewModel 也是遵循面向协议编程的原则。首先，我们定义了一个名叫<code data-backticks="1" data-nodeid="9479">InternalMenuViewModelType</code>的协议。该协议只有两个属性<code data-backticks="1" data-nodeid="9481">title</code>和<code data-backticks="1" data-nodeid="9483">sections</code>。其中，<code data-backticks="1" data-nodeid="9485">title</code>用于显示 ViewController 的标题，<code data-backticks="1" data-nodeid="9487">sections</code>用于显示 TableView 的数据，代码如下。</p>\n<pre class="lang-swift" data-nodeid="9161"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">InternalMenuViewModelType</span> </span>{\n    <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }\n    <span class="hljs-keyword">var</span> sections: <span class="hljs-type">Observable</span>&lt;[<span class="hljs-type">InternalMenuSection</span>]&gt; { <span class="hljs-keyword">get</span> }\n}\n</code></pre>\n<p data-nodeid="9162"><code data-backticks="1" data-nodeid="9489">InternalMenuViewModel</code>作为一个遵循<code data-backticks="1" data-nodeid="9491">InternalMenuViewModelType</code>协议的结构体，它要实现<code data-backticks="1" data-nodeid="9493">title</code>和<code data-backticks="1" data-nodeid="9495">sections</code>属性。其中，<code data-backticks="1" data-nodeid="9497">title</code>只是返回包含标题的字符串即可。而<code data-backticks="1" data-nodeid="9499">sections</code>则需要使用 RxSwift 的<code data-backticks="1" data-nodeid="9501">Observable</code>来返回一个数组，这个数组包含了多个 Session ViewModel。</p>\n<p data-nodeid="9163">我们会在响应式编程一讲中详细讲述<code data-backticks="1" data-nodeid="9504">Observable</code>。在此你可以把它理解为一个能返回数组的数据流。下面是具体的代码实现。</p>\n<pre class="lang-swift" data-nodeid="9164"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalMenuViewModel</span>: <span class="hljs-title">InternalMenuViewModelType</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> title = <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.area51\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> sections: <span class="hljs-type">Observable</span>&lt;[<span class="hljs-type">InternalMenuSection</span>]&gt;\n&nbsp; &nbsp; <span class="hljs-keyword">init</span>(router: <span class="hljs-type">AppRouting</span>, routingSourceProvider: @escaping <span class="hljs-type">RoutingSourceProvider</span>) {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> appVersion = <span class="hljs-string">"\\(L10n.InternalMenu.version) \\((Bundle.main.object(forInfoDictionaryKey: L10n.InternalMenu.cfBundleVersion) as? String) ?? "</span><span class="hljs-number">1.0</span><span class="hljs-string">")"</span>\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> infoSection = <span class="hljs-type">InternalMenuSection</span>(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.generalInfo,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items: [<span class="hljs-type">InternalMenuDescriptionItemViewModel</span>(title: appVersion)]\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> designKitSection = <span class="hljs-type">InternalMenuSection</span>(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.designKitDemo,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items: [<span class="hljs-type">InternalMenuDesignKitDemoItemViewModel</span>(router: router, routingSourceProvider: routingSourceProvider)])\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> featureTogglesSection = <span class="hljs-type">InternalMenuSection</span>(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.featureToggles,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items: [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">InternalMenuFeatureToggleItemViewModel</span>(title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.likeButtonForMomentEnabled, toggle: <span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">InternalMenuFeatureToggleItemViewModel</span>(title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.swiftUIEnabled, toggle: <span class="hljs-type">InternalToggle</span>.isSwiftUIEnabled)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ])\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> toolsSection = <span class="hljs-type">InternalMenuSection</span>(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.tools,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items: [<span class="hljs-type">InternalMenuCrashAppItemViewModel</span>()]\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; sections = .just([\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infoSection,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; designKitSection,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; featureTogglesSection,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toolsSection\n&nbsp; &nbsp; &nbsp; &nbsp; ])\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="9165">从代码可以看到，<code data-backticks="1" data-nodeid="9507">InternalMenuViewModel</code>的主要任务是把各个 Cell 的 ViewModel 进行初始化，然后放进各组 Section 的 ViewModel 里面，最后把各组 Section 的 ViewModel 放到<code data-backticks="1" data-nodeid="9509">items</code>属性里面。</p>\n<p data-nodeid="9166">因为所有用于<code data-backticks="1" data-nodeid="9512">UITableViewCell</code>的 ViewModel 都遵循了<code data-backticks="1" data-nodeid="9514">InternalMenuItemViewModel</code>协议，所以它们能够保持统一的接口，方便我们快速扩展新功能。比如，我们要为实时聊天功能添加一个新的本地功能开关时，只需要下面一行代码就行了。</p>\n<pre class="lang-swift" data-nodeid="9167"><code data-language="swift"><span class="hljs-type">InternalMenuFeatureToggleItemViewModel</span>(title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.instantMessagingEnabled, toggle: <span class="hljs-type">InternalToggle</span>.isInstantMessagingEnabled)\n</code></pre>\n<p data-nodeid="9168">运行效果如下。<br>\n<img src="https://s0.lgstatic.com/i/image6/M01/27/9B/CioPOWBdV52AV1OAAAF2RV7abDM895.png" alt="图片1.png" data-nodeid="9520"></p>\n<h3 data-nodeid="9169">总结</h3>\n<p data-nodeid="9170">在这一讲中，我向你介绍了如何实现一个隐藏菜单功能，有了这个功能，我们的测试人员和产品经理可以使用这些功能来加速功能的测试与验证。在实现过程，我们把 UI 和配置数据部分进行分离，而且使用了面向协议的编程方式，让这个功能变得灵活且易于可扩展。在实际工作当中，你也可以使用这个模式来快速开发出各种配置页面。<br>\n<img src="https://s0.lgstatic.com/i/image6/M01/26/8B/Cgp9HWBbDhmAB2gcAAUFC1DGm_M896.png" alt="思维导图+二维码.png" data-nodeid="9526"></p>\n<p data-nodeid="9171">思考题：</p>\n<blockquote data-nodeid="9172">\n<p data-nodeid="9173">在当前的实现中还可以进一步的优化，请尝试把<code data-backticks="1" data-nodeid="9529">InternalMenuDesignKitDemoItemViewModel</code>和<code data-backticks="1" data-nodeid="9531">InternalMenuCrashAppItemViewModel</code>重构成结构体（struct），做完记住提交一个 PR 哦。</p>\n</blockquote>\n<p data-nodeid="9174">如果你在做这个任务时有任何问题，可以写到下面的留言区哦，我会不定期回复。我们下一讲将介绍如何开发通用的路由组件。</p>\n<p data-nodeid="9175"><strong data-nodeid="9537">源码地址：</strong></p>\n<blockquote data-nodeid="9176">\n<p data-nodeid="9177" class="">隐藏菜单功能的文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/InternalMenu?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9541">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/InternalMenu</a></p>\n</blockquote>',
          },
          {
            theme: '11 | 功能组件：如何使用路由，支持多页面导航？',
            id: 23,
            content:
              '<p data-nodeid="1633" class="">随着 App 功能的不断丰富，以内容和体验为导向的导航模式变得越来越流行。这种导航模式的特点是一个页面可以导航到任意一个其他的页面。</p>\n<p data-nodeid="1634">比如在 iOS 里使用 UIKit 来实现导航功能时，源 ViewController 需要知道目标 ViewController 的类型信息，换句话说就是源 ViewController 必须直接依赖目标 ViewController。这会导致什么问题呢？如果 App的多个模块之间需要相互导航，那么它们之间就会产生循环依赖，如下图所示。</p>\n<p data-nodeid="1635"><img src="https://s0.lgstatic.com/i/image6/M00/29/B3/CioPOWBhjTiAan3AAAGv59UQhFU067.png" alt="图片1.png" data-nodeid="1734"></p>\n<p data-nodeid="1636">假如随着 Moments App 不断发展，除了朋友圈功能以外，我们还可能新增商城功能和实时通讯功能。当用户点击朋友圈信息的时候可以打开商品信息页面，当点击朋友头像时可以进入实时通讯页面。而在商品信息页面里面，用户还可以打开朋友圈页面进行分享。</p>\n<p data-nodeid="1637">这种模块之间的循环依赖会引起一系列的问题，比如因为代码强耦合，导致代码变得难以维护。如果不同功能由不同产品研发团队负责开发与维护，循环依赖还会增加很多的沟通成本，每次一点小改动都需要通知其他团队进行更新。</p>\n<p data-nodeid="1638">那么，有没有什么好的办法解决这种问题呢？</p>\n<h3 data-nodeid="1639">路由方案的架构与实现</h3>\n<p data-nodeid="1640">我们可以使用一套基于 URL 的路由方案来解决多个模块之间的导航问题。下面是这套路由方案的架构图。</p>\n<p data-nodeid="1641"><img src="https://s0.lgstatic.com/i/image6/M00/29/B3/CioPOWBhjTGARlXPAAL0T-JWwPg795.png" alt="图片2.png" data-nodeid="1742"></p>\n<p data-nodeid="1642">这个架构分成三层，因为上层组件依赖于下层组件，我们从下往上来看。</p>\n<ul data-nodeid="1643">\n<li data-nodeid="1644">\n<p data-nodeid="1645">最底层是基础组件层，路由模块也属于基础组件，路由模块不依赖于任何其他组件。</p>\n</li>\n<li data-nodeid="1646">\n<p data-nodeid="1647">中间层是功能业务层，各个功能都单独封装为一个模块，他们都依赖于基础组件层，但功能层内的各个模块彼此不相互依赖，这能有效保证多个功能研发团队并行开发。</p>\n</li>\n<li data-nodeid="1648">\n<p data-nodeid="1649">最上层是 App 容器模块，它负责把所有功能模块整合起来，形成一个完整的产品。</p>\n</li>\n</ul>\n<p data-nodeid="1650"><strong data-nodeid="1751">这套路由方案主要由两大部分组成，独立的路由模块和嵌入功能模块里面的导航组件。</strong> 接下来，我们以 Moments App 为例子一起看看这套方案是怎样实现的吧。</p>\n<h4 data-nodeid="1651">路由模块</h4>\n<p data-nodeid="1652">路由模块非常简单，主要有两个协议（Protocol）和一个类组成，如下图所示。</p>\n<p data-nodeid="1653"><img src="https://s0.lgstatic.com/i/image6/M00/29/B3/CioPOWBhjSCAPa5mAANi15SVPxc603.png" alt="图片3.png" data-nodeid="1756"></p>\n<p data-nodeid="1654"><strong data-nodeid="1760">AppRouting 和 AppRouter</strong></p>\n<p data-nodeid="1655">我们先来看路由模块里的<code data-backticks="1" data-nodeid="1762">AppRouting</code>和<code data-backticks="1" data-nodeid="1764">AppRouter</code>。其中，<code data-backticks="1" data-nodeid="1766">AppRouting</code>协议定义了路由模块的接口而<code data-backticks="1" data-nodeid="1768">AppRouter</code>是<code data-backticks="1" data-nodeid="1770">AppRouting</code>协议的实现类。</p>\n<p data-nodeid="1656"><code data-backticks="1" data-nodeid="1772">AppRouting</code>协议的代码如下。</p>\n<pre class="lang-swift" data-nodeid="1657"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">AppRouting</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(path: String, navigator: Navigating)</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">route</span><span class="hljs-params">(to url: URL?, from routingSource: RoutingSource?, using transitionType: TransitionType)</span></span>\n}\n</code></pre>\n<p data-nodeid="1658">这个协议只有两个方法：</p>\n<ol data-nodeid="1659">\n<li data-nodeid="1660">\n<p data-nodeid="1661">用于注册 Navigator（导航器）的<code data-backticks="1" data-nodeid="1776">register(path: String, navigator: Navigating)</code>方法；</p>\n</li>\n<li data-nodeid="1662">\n<p data-nodeid="1663">触发路由的<code data-backticks="1" data-nodeid="1779">route(to url: URL?, from routingSource: RoutingSource?, using transitionType: TransitionType)</code>方法。</p>\n</li>\n</ol>\n<p data-nodeid="1664">其中<code data-backticks="1" data-nodeid="1782">route(to:from:using)</code>方法接收三个参数。</p>\n<p data-nodeid="1665">第一个是 URL，我们整套路由系统都是基于 URL 的，因此需要把 URL 传递进来进行导航。</p>\n<p data-nodeid="1666">第二个是类型为<code data-backticks="1" data-nodeid="1786">RoutingSource</code>的参数，该<code data-backticks="1" data-nodeid="1788">RoutingSource</code>是一个协议，代码如下：</p>\n<pre class="lang-swift" data-nodeid="1667"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RoutingSource</span>: <span class="hljs-title">class</span> </span>{ }\n<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIViewController</span>: <span class="hljs-title">RoutingSource</span> </span>{ }\n</code></pre>\n<p data-nodeid="1668">首先，我们定义一个名为<code data-backticks="1" data-nodeid="1791">RoutingSource</code>的空协议，然后让<code data-backticks="1" data-nodeid="1793">UIViewController</code>遵循该协议。这样就能让<code data-backticks="1" data-nodeid="1795">route(to:from:using)</code>方法与<code data-backticks="1" data-nodeid="1797">UIViewController</code>进行解耦。</p>\n<p data-nodeid="1669">第三个参数是<code data-backticks="1" data-nodeid="1800">TransitionType</code>类型。代码如下：</p>\n<pre class="lang-swift" data-nodeid="1670"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TransitionType</span>: <span class="hljs-title">String</span> </span>{\n    <span class="hljs-keyword">case</span> show, present\n}\n</code></pre>\n<p data-nodeid="1671"><code data-backticks="1" data-nodeid="1802">TransitionType</code>是一个枚举（enum）类型，用于表示导航过程中的转场动作。<code data-backticks="1" data-nodeid="1804">show</code>用于把新的目标 ViewController 推进（push）到当前的<code data-backticks="1" data-nodeid="1806">UINavigationController</code>里面。而<code data-backticks="1" data-nodeid="1808">present</code>会把新的目标 ViewController 通过模态窗口（modal）的方式来呈现。</p>\n<p data-nodeid="1672">至于<code data-backticks="1" data-nodeid="1811">AppRouter</code>是<code data-backticks="1" data-nodeid="1813">AppRouting</code>协议的实现类，其他的具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="1673"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppRouter</span>: <span class="hljs-title">AppRouting</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">AppRouter</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> navigators: [<span class="hljs-type">String</span>: <span class="hljs-type">Navigating</span>] = [:]\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() { }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(path: String, navigator: Navigating)</span></span> {\n        navigators[path.lowercased()] = navigator\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">route</span><span class="hljs-params">(to url: URL?, from routingSource: RoutingSource?, using transitionType: TransitionType = .present)</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url = url, <span class="hljs-keyword">let</span> sourceViewController = routingSource <span class="hljs-keyword">as</span>? <span class="hljs-type">UIViewController</span> ?? <span class="hljs-type">UIApplication</span>.shared.rootViewController <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }\n        <span class="hljs-keyword">let</span> path = url.lastPathComponent.lowercased()\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> urlComponents = <span class="hljs-type">URLComponents</span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal">false</span>) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }\n        <span class="hljs-keyword">let</span> parameters: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] = (urlComponents.queryItems ?? []).<span class="hljs-built_in">reduce</span>(into: [:]) { params, queryItem <span class="hljs-keyword">in</span>\n            params[queryItem.name.lowercased()] = queryItem.value\n        }\n        navigators[path]?.navigate(from: sourceViewController, using: transitionType, parameters: parameters)\n    }\n}\n</code></pre>\n<p data-nodeid="1674"><code data-backticks="1" data-nodeid="1815">AppRouter</code>首先定义了一个用于存储各个 Navigator 的私有属性<code data-backticks="1" data-nodeid="1817">navigators</code>。<code data-backticks="1" data-nodeid="1819">navigators</code>是一个字典类型，它的 Key 是字符串类型，用于保存 URL 的路径值。而所存储的值是具体的 Navigator 的实例。</p>\n<p data-nodeid="1675">然后，<code data-backticks="1" data-nodeid="1822">AppRouter</code>实现了<code data-backticks="1" data-nodeid="1824">register</code>和<code data-backticks="1" data-nodeid="1826">route</code>两个方法。<code data-backticks="1" data-nodeid="1828">register</code>方法的实现非常简单，就是把<code data-backticks="1" data-nodeid="1830">path</code>和<code data-backticks="1" data-nodeid="1832">navigator</code>存到私有属性<code data-backticks="1" data-nodeid="1834">navigators</code>里面。接着我详细介绍一下<code data-backticks="1" data-nodeid="1836">route</code>方法的实现。</p>\n<p data-nodeid="1676">因为整套路由方案都是基于 URL 进行导航，因此在该方法里面，首先需要检测<code data-backticks="1" data-nodeid="1839">url</code>是否为空，如果为空就直接返回了，然后把<code data-backticks="1" data-nodeid="1841">routingSource</code>向下转型 (downcast) 为<code data-backticks="1" data-nodeid="1843">UIViewController</code>，如果为空就使用<code data-backticks="1" data-nodeid="1845">rootViewController</code>作为<code data-backticks="1" data-nodeid="1847">sourceViewController</code>来表示导航过程中的源 ViewController。</p>\n<p data-nodeid="1677">这些检验都通过以后，我们从<code data-backticks="1" data-nodeid="1850">url</code>来取出<code data-backticks="1" data-nodeid="1852">path</code>作为导航的 Key，同时从 Query String 里面取出<code data-backticks="1" data-nodeid="1854">parameters</code>并作为参数传递给目标 ViewController。</p>\n<p data-nodeid="1678">最后一步是根据<code data-backticks="1" data-nodeid="1857">path</code>从<code data-backticks="1" data-nodeid="1859">navigators</code>属性中取出对应的 Navigator，然后调用其<code data-backticks="1" data-nodeid="1861">navigate(from viewController: UIViewController, using transitionType: TransitionType, parameters: [String: String])</code>方法进行导航。</p>\n<p data-nodeid="1679"><strong data-nodeid="1866">Navigating 协议</strong></p>\n<p data-nodeid="1680">除了<code data-backticks="1" data-nodeid="1868">AppRouting</code>和<code data-backticks="1" data-nodeid="1870">AppRouter</code>以外，路由模块的核心还包含了一个叫作<code data-backticks="1" data-nodeid="1872">Navigating</code>的协议。它负责具体的导航工作，下面我们一起看看这个协议的定义与实现吧。</p>\n<pre class="lang-swift" data-nodeid="1681"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Navigating</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigate</span><span class="hljs-params">(from viewController: UIViewController, using transitionType: TransitionType, parameters: [String: String])</span></span>\n}\n<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Navigating</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigate</span><span class="hljs-params">(to destinationViewController: UIViewController, from sourceViewController: UIViewController, using transitionType: TransitionType)</span></span> {\n        <span class="hljs-keyword">switch</span> transitionType {\n        <span class="hljs-keyword">case</span> .show:\n            sourceViewController.show(destinationViewController, sender: <span class="hljs-literal">nil</span>)\n        <span class="hljs-keyword">case</span> .present:\n            sourceViewController.present(destinationViewController, animated: <span class="hljs-literal">true</span>)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1682"><code data-backticks="1" data-nodeid="1874">Navigating</code>协议负责桥接路由模块和其他功能模块，它只定义了一个名叫<code data-backticks="1" data-nodeid="1876">navigate(from viewController: UIViewController, using transitionType: TransitionType, parameters: [String: String])</code>的方法供<code data-backticks="1" data-nodeid="1878">AppRouter</code>来调用。</p>\n<p data-nodeid="1683">同时我们也给<code data-backticks="1" data-nodeid="1881">Navigating</code>定义了一个叫作<code data-backticks="1" data-nodeid="1883">navigate(to destinationViewController: UIViewController, from sourceViewController: UIViewController, using transitionType: TransitionType)</code>的扩展方法 (Extension method) 来统一封装导航的处理逻辑。</p>\n<p data-nodeid="1684">当<code data-backticks="1" data-nodeid="1886">transitionType</code>为<code data-backticks="1" data-nodeid="1888">.show</code>的时候，该方法会调用<code data-backticks="1" data-nodeid="1890">UIViewController</code>的<code data-backticks="1" data-nodeid="1892">show(_ vc: UIViewController, sender: Any?)</code>方法进行导航。在调用<code data-backticks="1" data-nodeid="1894">show</code>方法的时候，iOS 系统会判断<code data-backticks="1" data-nodeid="1896">sourceViewController</code>是存放在 NavigationController 还是 SplitViewController 里面，并触发相应的换场（Transition）动作。例如当<code data-backticks="1" data-nodeid="1898">sourceViewController</code>存放在 NavigationController 里面的时候就会把<code data-backticks="1" data-nodeid="1900">destinationViewController</code>推进 NavigationController 的栈（Stack）里面。</p>\n<p data-nodeid="1685">当<code data-backticks="1" data-nodeid="1903">transitionType</code>为<code data-backticks="1" data-nodeid="1905">.present</code>的时候，我们就调用<code data-backticks="1" data-nodeid="1907">UIViewController</code>的<code data-backticks="1" data-nodeid="1909">present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -&gt; Void)? = nil)</code>方法进行导航。在调用<code data-backticks="1" data-nodeid="1911">present</code>方法的时候，iOS 系统会把<code data-backticks="1" data-nodeid="1913">destinationViewController</code>通过模态窗口的方式呈现。</p>\n<p data-nodeid="1686">有了<code data-backticks="1" data-nodeid="1916">Navigating</code>协议以后，我们看看功能模块是怎样关联到路由模块的。</p>\n<h4 data-nodeid="1687">导航组件</h4>\n<p data-nodeid="1688">所有功能模块都通过 Navigator 类型为路由模块提供导航功能。一个目标 ViewController 对应一个 Navigator。假如商城模块有商城主页和商品信息页面两个 ViewController，那么商城模块就需要提供两个 Navigtor 来分别导航到这两个 ViewController。</p>\n<p data-nodeid="1689">下面我们以 Moments App 中内部隐藏功能菜单模块为例子，看看 Navigator 是怎样实现的。</p>\n<p data-nodeid="1690"><img src="https://s0.lgstatic.com/i/image6/M00/29/AB/Cgp9HWBhjQ6AQXGQAAOJFXHFOq8674.png" alt="图片4.png" data-nodeid="1923"></p>\n<p data-nodeid="1691">内部隐藏功能菜单模块有两个 ViewController，因此需要定义两个不同的 \u000eNavigator。它们都遵循了<code data-backticks="1" data-nodeid="1925">Navigating</code>协议。</p>\n<p data-nodeid="1692"><strong data-nodeid="1930">InternalMenuNavigator</strong></p>\n<p data-nodeid="1693"><code data-backticks="1" data-nodeid="1931">InternalMenuNavigator</code>负责导航到<code data-backticks="1" data-nodeid="1933">InternalMenuViewController</code>。下面是它的具体代码实现。</p>\n<pre class="lang-swift" data-nodeid="1694"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalMenuNavigator</span>: <span class="hljs-title">Navigating</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigate</span><span class="hljs-params">(from viewController: UIViewController, using transitionType: TransitionType, parameters: [String : String])</span></span> {\n        <span class="hljs-keyword">let</span> navigationController = <span class="hljs-type">UINavigationController</span>(rootViewController: <span class="hljs-type">InternalMenuViewController</span>())\n        navigate(to: navigationController, from: viewController, using: transitionType)\n    }\n}\n</code></pre>\n<p data-nodeid="1695">从代码可以看到，<code data-backticks="1" data-nodeid="1936">InternalMenuNavigator</code>的实现非常简单。首先，初始化<code data-backticks="1" data-nodeid="1938">InternalMenuViewController</code>的实例，然后把该实例放置到一个<code data-backticks="1" data-nodeid="1940">UINavigationController</code>里面。接下来我们调用<code data-backticks="1" data-nodeid="1942">Navigating</code>的扩展方法<code data-backticks="1" data-nodeid="1944">navigate(to destinationViewController: UIViewController, from sourceViewController: UIViewController, using transitionType: TransitionType)</code>来进行导航。</p>\n<p data-nodeid="1696"><strong data-nodeid="1949">DesignKitDemoNavigator</strong></p>\n<p data-nodeid="1697"><code data-backticks="1" data-nodeid="1950">DesignKitDemoNavigator</code>负责导航到<code data-backticks="1" data-nodeid="1952">DesignKitDemoViewController</code>。下面是实现的代码。</p>\n<pre class="lang-swift" data-nodeid="1698"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DesignKitDemoNavigator</span>: <span class="hljs-title">Navigating</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigate</span><span class="hljs-params">(from viewController: UIViewController, using transitionType: TransitionType, parameters: [String: String])</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> productName = parameters[<span class="hljs-string">"productname"</span>], <span class="hljs-keyword">let</span> versionNumber = parameters[<span class="hljs-string">"version"</span>] <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span>\n        }\n        <span class="hljs-keyword">let</span> destinationViewController = <span class="hljs-type">DesignKitDemoViewController</span>(productName: productName, versionNumber: versionNumber)\n        navigate(to: destinationViewController, from: viewController, using: transitionType)\n    }\n}\n</code></pre>\n<p data-nodeid="1699">与<code data-backticks="1" data-nodeid="1955">InternalMenuNavigator</code>不一样的地方是,<code data-backticks="1" data-nodeid="1957">DesignKitDemoNavigator</code>从<code data-backticks="1" data-nodeid="1959">parameters</code>中取出了<code data-backticks="1" data-nodeid="1961">productName</code>和<code data-backticks="1" data-nodeid="1963">versionNumber</code>两个参数的值，然后传递给<code data-backticks="1" data-nodeid="1965">DesignKitDemoViewController</code>进行初始化。最后也是调用<code data-backticks="1" data-nodeid="1967">Navigating</code>的扩展方法<code data-backticks="1" data-nodeid="1969">navigate(to:from:using:)</code>进行导航。</p>\n<h3 data-nodeid="1700">路由方案的使用</h3>\n<p data-nodeid="1701">以上是有关路由方案的架构和实现，有了这个路由方案以后，那我们该如何使用它呢？接下来我将从它的注册与调用、Universal Links 的路由和验证来介绍下。</p>\n<h4 data-nodeid="1702">路由的注册与调用</h4>\n<p data-nodeid="1703">因为<strong data-nodeid="1981">App 容器模块</strong>依赖所有的功能模块和路由模块，我们可以把路由注册的逻辑放在该模块的<code data-backticks="1" data-nodeid="1979">AppDelegate</code>里面，代码如下：</p>\n<pre class="lang-swift" data-nodeid="1704"><code data-language="swift"><span class="hljs-keyword">let</span> router: <span class="hljs-type">AppRouting</span> = <span class="hljs-type">AppRouter</span>.shared\nrouter.register(path: <span class="hljs-string">"InternalMenu"</span>, navigator: <span class="hljs-type">InternalMenuNavigator</span>())\nrouter.register(path: <span class="hljs-string">"DesignKit"</span>, navigator: <span class="hljs-type">DesignKitDemoNavigator</span>())\n</code></pre>\n<p data-nodeid="1705">从上面可以看到，我们通过传递<code data-backticks="1" data-nodeid="1983">path</code>和<code data-backticks="1" data-nodeid="1985">navigator</code>的实例来注册路由信息。注册完毕以后，各个功能模块就可以调用<code data-backticks="1" data-nodeid="1987">route(to url: URL?, from routingSource: RoutingSource?, using transitionType: TransitionType)</code>方法进行路由。下面是如何路由到内部功能菜单页面的代码。</p>\n<pre class="lang-swift" data-nodeid="1706"><code data-language="swift">router.route(to: <span class="hljs-type">URL</span>(string: <span class="hljs-string">"\\(UniversalLinks.baseURL)InternalMenu"</span>), from: rootViewController, using: .present)\n</code></pre>\n<p data-nodeid="1707">路由的过程中需要传入一个 URL，源 ViewController 以及换场的类型三个参数。</p>\n<p data-nodeid="1708">下面是路由到 DesignKit 范例页面的具体代码。</p>\n<pre class="lang-swift" data-nodeid="1709"><code data-language="swift">router.route(to: <span class="hljs-type">URL</span>(string: <span class="hljs-string">"\\(UniversalLinks.baseURL)DesignKit?productName=DesignKit&amp;version=1.0.1"</span>), from: routingSourceProvider(), using: .show)\n</code></pre>\n<p data-nodeid="1710">这个例子中，我们通过 Query String 的方式把<code data-backticks="1" data-nodeid="1992">productName</code>和<code data-backticks="1" data-nodeid="1994">version</code>参数传递给目标 ViewController。</p>\n<h4 data-nodeid="1711">Universal Links 的路由</h4>\n<p data-nodeid="1712">我们之所以选择基于 URL 的路由方案，其中的一个原因是对 Universal Links 的支持。当我们的 App 支持 Universal Links 以后，一旦用户在 iOS 设备上打开 Universal Links 所支持的 URL 时，就会自动打开我们的 App。</p>\n<p data-nodeid="1713">根据 App 是否支持 Scenes 来区分，目前在 UIKit 里面支持 Universal Links 有两种方式。如果 App 还不支持 Scenes 的话，我们需要在<code data-backticks="1" data-nodeid="1999">AppDelegate</code>里面添加 Universal Links 的支持的代码，如下所示：</p>\n<pre class="lang-swift" data-nodeid="1714"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication,\n                 <span class="hljs-keyword">continue</span> userActivity: NSUserActivity,\n                 restorationHandler: @escaping <span class="hljs-params">([UIUserActivityRestoring]?)</span></span></span> -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Bool</span> {\n    <span class="hljs-keyword">guard</span> userActivity.activityType == <span class="hljs-type">NSUserActivityTypeBrowsingWeb</span>,\n        <span class="hljs-keyword">let</span> incomingURL = userActivity.webpageURL <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n    }\n    <span class="hljs-keyword">let</span> router: <span class="hljs-type">AppRouting</span> = <span class="hljs-type">AppRouter</span>.shared\n    router.route(to: incomingURL, from: <span class="hljs-literal">nil</span>, using: .present)\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n}\n</code></pre>\n<p data-nodeid="1715">我们首先检查<code data-backticks="1" data-nodeid="2002">userActivity.activityType</code>是否为<code data-backticks="1" data-nodeid="2004">NSUserActivityTypeBrowsingWeb</code>，并把 URL 取出来。如果验证都通过，就可以调用<code data-backticks="1" data-nodeid="2006">AppRouting</code>的<code data-backticks="1" data-nodeid="2008">route(to url: URL?, from routingSource: RoutingSource?, using transitionType: TransitionType)</code>方法进行路由。</p>\n<p data-nodeid="1716">在调用<code data-backticks="1" data-nodeid="2011">route</code>方法的时候，我们把<code data-backticks="1" data-nodeid="2013">nil</code>传递给<code data-backticks="1" data-nodeid="2015">routingSource</code>并指定换场方式为<code data-backticks="1" data-nodeid="2017">.present</code>。这样路由模块就会通过模态窗口把目标 ViewController 呈现出来。</p>\n<p data-nodeid="1717">如果 App 已经使用 Scene，例如我们的 Moments App，那么我们需要修改<code data-backticks="1" data-nodeid="2020">SceneDelegate</code>的<code data-backticks="1" data-nodeid="2022">scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</code>方法来支持 Universal Links，代码如下：</p>\n<pre class="lang-swift" data-nodeid="1718"><code data-language="swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> userActivity = connectionOptions.userActivities.first,\n    userActivity.activityType == <span class="hljs-type">NSUserActivityTypeBrowsingWeb</span>,\n    <span class="hljs-keyword">let</span> incomingURL = userActivity.webpageURL {\n    <span class="hljs-keyword">let</span> router: <span class="hljs-type">AppRouting</span> = <span class="hljs-type">AppRouter</span>.shared\n    router.route(to: incomingURL, from: <span class="hljs-literal">nil</span>, using: .present)\n}\n</code></pre>\n<p data-nodeid="1719">从代码可见，当我们从<code data-backticks="1" data-nodeid="2025">connectionOptions</code>取出<code data-backticks="1" data-nodeid="2027">userActivity</code>以后，后面的处理逻辑和上面<code data-backticks="1" data-nodeid="2029">AppDelegate</code>的实现方式一模一样，在这里我就不赘述了。</p>\n<h4 data-nodeid="1720">路由的验证</h4>\n<p data-nodeid="1721">当我们的 App 支持 Universal Links 以后，我们需要在 Navigator 里面增加一些验证的代码，否则可能会引起外部系统的攻击，例如 Moments App 的内部隐藏功能菜单不想给 App Store 用户使用，我们可以在<code data-backticks="1" data-nodeid="2033">InternalMenuNavigator</code>里面添加以下的验证代码。</p>\n<pre class="lang-swift" data-nodeid="1722"><code data-language="swift"><span class="hljs-keyword">let</span> togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span> = <span class="hljs-type">BuildTargetTogglesDataStore</span>.shared\n<span class="hljs-keyword">guard</span> togglesDataStore.isToggleOn(<span class="hljs-type">BuildTargetToggle</span>.debug) || togglesDataStore.isToggleOn(<span class="hljs-type">BuildTargetToggle</span>.<span class="hljs-keyword">internal</span>) <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span>\n}\n</code></pre>\n<p data-nodeid="1723">这段代码会检查当前的 App 是否为开发环境或者测试环境的版本，如果“不是”，说明当前的 App 是 App Store 版本，我们就直接退出，不允许打开内部功能菜单。</p>\n<h3 data-nodeid="1724">总结</h3>\n<p data-nodeid="4525">在这一讲中我介绍了一个基于 URL 的通用路由方案的实现方式，有了这个路由方案，不但可以帮助所有功能模块的解耦，而且能很方便地支持 Universal Links。</p>\n<p data-nodeid="5361"><img src="https://s0.lgstatic.com/i/image6/M00/29/B2/Cgp9HWBhlPqAUXPUAATzGVdjazs511.png" alt="思维导图+二维码.png" data-nodeid="5365"></p>\n<p data-nodeid="5362" class="te-preview-highlight">当我们的 App 支持 Universal Links 以后，需要特别注意对路由的 URL 进行验证，否则会很容易被外部系统进行攻击。这些验证的手段包括不应该允许 Universal Links 更新或者删除数据，不允许 Universal Links 访问任何敏感数据。</p>\n\n\n\n\n\n\n<p data-nodeid="1726">思考题：</p>\n<blockquote data-nodeid="1727">\n<p data-nodeid="1728">在软件开发中，只有合适的方案，没有完美的方案。基于 URL 的路有方案也有一些需要处理的难题，例如如何传递数组和大对象，请问你是怎样处理这些问题的呢？</p>\n</blockquote>\n<p data-nodeid="1729" class="">可以把回答写到下面的留言区哦，我们一起探讨一下。下一讲将介绍如何设置多语言支持。</p>',
          },
          {
            theme: '12 | 功能组件：如何设置多语言支持，为全球化做准备？',
            id: 24,
            content:
              '<p data-nodeid="2448" class="">作为 iOS 开发者，不知道你有没有遇到过这样的情况：每次增加一种新语言，都需要重新改一遍，特别是在 App 进入其他国家的市场时，需要修改整个 App 的代码才能加入新语言。这样是不是很麻烦？</p>\n<p data-nodeid="2449">其实这种情况完全可以通过多语言设置来解决。下面我就以 Moments App 为例，看看怎样支持多语言。</p>\n<h3 data-nodeid="2450">安装 SwiftGen</h3>\n<p data-nodeid="2451">Moments App 使用了 SwiftGen 来自动生成支持多语言常量字符串。为了保证整个团队所使用 SwiftGen 的版本都保持一致，我们使用 CocoaPods 来安装 SwiftGen。具体到 Moments App 项目，我们在 Podfile 文件中添加 SwiftGen Pod 即可。</p>\n<pre class="lang-ruby" data-nodeid="2452"><code data-language="ruby">pod <span class="hljs-string">\'SwiftGen\'</span>, <span class="hljs-string">\'= 6.4.0\'</span>, <span class="hljs-symbol">configurations:</span> [<span class="hljs-string">\'Debug\'</span>]\n</code></pre>\n<p data-nodeid="2453">为了在每次编译代码的时候，SwiftGen 都会启动代码生成任务，我们需要在主 App Target<strong data-nodeid="2510">Moments</strong>的 Build Phases 里面添加 Run SwiftGen 步骤，然后配置它执行<code data-backticks="1" data-nodeid="2508">"${PODS_ROOT}/SwiftGen/bin/swiftgen"</code>命令。</p>\n<p data-nodeid="2454"><img src="https://s0.lgstatic.com/i/image6/M01/2B/A7/CioPOWBkHlSAeXTsAAMc4RV6WTU312.png" alt="图片4.png" data-nodeid="2513"></p>\n<p data-nodeid="2455">这里要注意，由于我们自己的源代码会使用到 SwiftGen 所生成的代码，因此必须把 Run SwiftGen 步骤放在 Compile Source 步骤之前。</p>\n<h3 data-nodeid="2456">增加多语言支持</h3>\n<p data-nodeid="2457">Xcode 使用<code data-backticks="1" data-nodeid="2517">.strings</code>文件来支持多语言。那什么是<code data-backticks="1" data-nodeid="2519">.strings</code>呢？<code data-backticks="1" data-nodeid="2521">.strings</code>文件是一个资源文件，用于存储各种语言的文本。该文件里面保存了一堆 Key-Value 信息，例子如下：</p>\n<pre class="lang-java" data-nodeid="2458"><code data-language="java"><span class="hljs-string">"userNameKey"</span> = <span class="hljs-string">"User name"</span>;\n</code></pre>\n<p data-nodeid="2459">其中<code data-backticks="1" data-nodeid="2524">userNameKey</code>是 Key，而<code data-backticks="1" data-nodeid="2526">User name</code>是具体的值。在 Swift 代码中，我们可以把 Key 传递给<code data-backticks="1" data-nodeid="2528">NSLocalizedString</code>方法来取出<code data-backticks="1" data-nodeid="2530">.strings</code>文件里配置的值。具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="2460"><code data-language="swift"><span class="hljs-keyword">let</span> use rName = <span class="hljs-type">NSLocalizedString</span>(<span class="hljs-string">"userNameKey"</span>, comment: <span class="hljs-string">"Label text for user name"</span>)\n</code></pre>\n<p data-nodeid="2461">由于 Moments App 使用了纯代码的方式来呈现 UI，我们需要在 Xcode 里面建立一个名叫<strong data-nodeid="2539">Localizable.strings</strong>的文件来存储 Key-Value 信息。该文件保存在 Moments/Resources/en.lproj 文件夹下面，其中<code data-backticks="1" data-nodeid="2537">en</code>表示英文，因为 Moments App 的默认语言是英文，假如你的 App 的默认语言是简体中文，那么应该放在 zh-Hans.lproj 文件夹下面。</p>\n<p data-nodeid="2462"><img src="https://s0.lgstatic.com/i/image6/M00/2B/A7/CioPOWBkHmeAY4FcAAgNpRSDhtQ750.png" alt="图片3.png" data-nodeid="2542"></p>\n<p data-nodeid="2463">那怎样支持新语言呢？我们可以在 Project Info 配置里面的 Localizations 下面点击加号按钮 （+），然后选择需要添加的语言，如下图所示，我们添加了简体中文。</p>\n<p data-nodeid="2464"><img src="https://s0.lgstatic.com/i/image6/M00/2B/A7/CioPOWBkHomAUYSMAARlhkCjiB8769.png" alt="图片5.png" data-nodeid="2546"></p>\n<p data-nodeid="2465">接着选择要增加简体中文支持的资源文件。在 Moments App 里面，我们使用了纯代码的方式来编写 UI，因此我们只选择刚才新建的<strong data-nodeid="2552">Localizable.strings</strong>文件。</p>\n<p data-nodeid="2466"><img src="https://s0.lgstatic.com/i/image6/M00/2B/A8/CioPOWBkHq6AeNUbAAkEtHtkg7Y024.png" alt="图片6.png" data-nodeid="2555"></p>\n<p data-nodeid="2467">然后你会看到在<strong data-nodeid="2565">Localizable.strings</strong>下多了一个<strong data-nodeid="2566">Localizable.strings（Chinese, Simplified）</strong> 文件用于保存简体中文的文本信息。</p>\n<p data-nodeid="2468"><img src="https://s0.lgstatic.com/i/image6/M01/2B/9F/Cgp9HWBkHsiAVW0pAAbU0JAhhic101.png" alt="图片7.png" data-nodeid="2569"></p>\n<p data-nodeid="2469">现在我们可以在<strong data-nodeid="2575">Localizable.strings</strong>里面添加下面的 Key-Value 来让 App 显示中文了。</p>\n<pre class="lang-java" data-nodeid="2470"><code data-language="java"><span class="hljs-string">"userNameKey"</span> = <span class="hljs-string">"用户名"</span>;\n</code></pre>\n<p data-nodeid="2471">当用户在 iOS 的 Settings App 里面把语言选择为<strong data-nodeid="2581">简体中文</strong>以后， App 里面的文本就会变成中文。我们也可以使用同样的办法来增加不同的语言支持。</p>\n<p data-nodeid="2472"><img src="https://s0.lgstatic.com/i/image6/M01/2B/A8/CioPOWBkHvaADdnnAAFQMZcn0Qs565.png" alt="图片8.png" data-nodeid="2584"></p>\n<h3 data-nodeid="2473">配置 swiftgen.yml 文件</h3>\n<p data-nodeid="2474">不知道你发现没有，调用<code data-backticks="1" data-nodeid="2587">NSLocalizedString</code>方法来取出文本并不方便，一不小心就会把 Key 写错了。那么，有没有什么好的办法方便我们使用<code data-backticks="1" data-nodeid="2589">.strings</code>文件里面的文本呢？有，那就是<strong data-nodeid="2594">使用 SwiftGen 来自动生成带类型信息的常量字符串。</strong></p>\n<p data-nodeid="2475">为什么呢？因为 SwfitGen 在执行过程中会读取 swiftgen.yml 文件里面的信息，要知道， swiftgen.yml 文件就是用来告诉 SwiftGen 读取那些文件，使用哪个模版以及在哪里存放生成的文件。那么，如何配置该文件，让 SeiftGen 帮我们生成用于全球化和本地化的常量字符串呢？</p>\n<p data-nodeid="2476">做法非常简单，我们可以在 swiftgen.yml 文件添加以下一段代码。</p>\n<pre class="lang-java" data-nodeid="2477"><code data-language="java"> strings:\n   inputs:\n     - Moments/Resources/en.lproj\n   outputs:\n     - templateName: structured-swift5\n       output: Moments/Generated/Strings.swift\n</code></pre>\n<p data-nodeid="2478">其中<code data-backticks="1" data-nodeid="2598">strings</code>表示这是一个用户生成常量字符串的任务。<code data-backticks="1" data-nodeid="2600">inputs</code>用于指定<code data-backticks="1" data-nodeid="2602">.strings</code>文件所在的位置，在我们的项目中，该文件位于 Moments/Resources/en.lproj。要注意的是，我们只需要指定一个语言的文件夹就行，它通常是默认开发语言的文件夹。<br>\n<code data-backticks="1" data-nodeid="2605">outputs.templateName</code>表示生成文件所使用的模版，我们使用<code data-backticks="1" data-nodeid="2607">structured-swift5</code>模版表示所生成的代码支持点号 (.) 分割 Swift 5 代码。<code data-backticks="1" data-nodeid="2609">outputs.output</code>表示所生成文件存放的位置。以下是生成的 Moments/Generated/Strings.swift ：</p>\n<pre class="lang-swift" data-nodeid="2479"><code data-language="swift"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">L10n</span> </span>{\n  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InternalMenu</span> </span>{\n    <span class="hljs-comment">/// Area 51</span>\n    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> area51 = <span class="hljs-type">L10n</span>.tr(<span class="hljs-string">"Localizable"</span>, <span class="hljs-string">"internalMenu.area51"</span>)\n    <span class="hljs-comment">/// Avatars</span>\n    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> generalInfo = <span class="hljs-type">L10n</span>.tr(<span class="hljs-string">"Localizable"</span>, <span class="hljs-string">"internalMenu.generalInfo"</span>)\n  }\n}\n</code></pre>\n<p data-nodeid="2480">因为我们在 Localizable.strings 文件里定义 Key 的时候使用了点号，SwiftGen 会使用内嵌套枚举类型 (Nested enum) 来把各个常量字符串通过命名空间进行分组。下面是英文版本 Localizable.strings 文件的部分定义。</p>\n<pre class="lang-java" data-nodeid="2481"><code data-language="java"><span class="hljs-comment">// Internal Menu</span>\n<span class="hljs-string">"internalMenu.area51"</span> = <span class="hljs-string">"Area 51"</span>;\n<span class="hljs-string">"internalMenu.generalInfo"</span> = <span class="hljs-string">"General Info"</span>;\n<span class="hljs-comment">// Moments List</span>\n<span class="hljs-string">"momentsList.errorMessage"</span> = <span class="hljs-string">"Something went wrong, please try again later"</span>;\n</code></pre>\n<p data-nodeid="2482">我们可以对比一下中文版本 Localizable.strings 文件的部分定义。</p>\n<pre class="lang-java" data-nodeid="2483"><code data-language="java"><span class="hljs-comment">// Internal Menu</span>\n<span class="hljs-string">"internalMenu.area51"</span> = <span class="hljs-string">"51 区"</span>;\n<span class="hljs-string">"internalMenu.generalInfo"</span> = <span class="hljs-string">"通用信息"</span>;\n<span class="hljs-comment">// Moments List</span>\n<span class="hljs-string">"momentsList.errorMessage"</span> = <span class="hljs-string">"出错啦，请稍后再试"</span>;\n</code></pre>\n<p data-nodeid="2484">可以看到，我们在定义所有 Key 的时候，都使用了点号进行分割，这可以帮助我们分组各类文本的同时，保证不同语言的文本信息都使用同样的 Key。</p>\n<h3 data-nodeid="2485">使用生成的字符串</h3>\n<p data-nodeid="2486">当 SwiftGen 自动生成那些常量字符串以后，我们就可以很方便地使用它们，下面的代码演示了如何调用这些字符串。</p>\n<pre class="lang-swift" data-nodeid="2487"><code data-language="swift"><span class="hljs-keyword">let</span> title = <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.area51\n<span class="hljs-keyword">let</span> infoSection = <span class="hljs-type">InternalMenuSection</span>(\n    title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.generalInfo,\n    items: [<span class="hljs-type">InternalMenuDescriptionItemViewModel</span>(title: appVersion)]\n)\n</code></pre>\n<p data-nodeid="2488">我们可以使用枚举类型<code data-backticks="1" data-nodeid="2617">L10n</code>来取出相应的常量字符串。<code data-backticks="1" data-nodeid="2619">L10n</code>的扩展方法 （Extension method）会根据当前用户的语言选择来读取相应的 Localizable.strings 文件，并返回对应语言的字符串来显示给用户。<br>\n下面是 Moments App 在英文语言和中文语言环境下的显示。</p>\n<p data-nodeid="2489"><img src="https://s0.lgstatic.com/i/image6/M01/2A/AB/CioPOWBi0EqAUJMbAAZDN5VTllQ225.png" alt="Drawing 6.png" data-nodeid="2625"></p>\n<h3 data-nodeid="2490">总结</h3>\n<p data-nodeid="3040">这一讲，我介绍了如何使用<code data-backticks="1" data-nodeid="3043">.strings</code>文件和 SwiftGen 来快速设置多语言支持。有了<code data-backticks="1" data-nodeid="3045">.strings</code>文件，支持新的语言变得非常简单，甚至可以在没有程序员的情况下，由翻译人员来翻译并发布新的语言。另外，有了 SwiftGen 所生成的常量字符串，我们不会再把错误的 Key 传递给<code data-backticks="1" data-nodeid="3047">NSLocalizedString</code>，从而提高了代码的质量。可以说，这个设置是一本万利，哪怕目前你的 App 还没有支持多个语言，我还是建议你花一丁点时来设置多语言支持。</p>\n<p data-nodeid="3041" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/2B/B1/CioPOWBkJqWAECB2AAgeL26iQbI826.png" alt="思维导图+二维码.png" data-nodeid="3051"></p>\n\n\n<p data-nodeid="2493">思考题</p>\n<blockquote data-nodeid="2494">\n<p data-nodeid="2495">请问你们的 App 支持多种语言吗？通过怎样的方法来支持的？有没有什么经验可以分享给大家？</p>\n</blockquote>\n<p data-nodeid="2496"><strong data-nodeid="2642">源码地址：</strong></p>\n<blockquote data-nodeid="2497">\n<p data-nodeid="2498" class="">swiftgen.yml文件<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/swiftgen.yml?fileGuid=zudKfgEPTlY6FdyY" data-nodeid="2647">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/swiftgen.yml</a></p>\n</blockquote>',
          },
          {
            theme: '13 | 功能组件：如何设置动态字体，提升视力辅助功能？',
            id: 25,
            content:
              '<p data-nodeid="880" class="">如今在 App 开发当中，支持动态字体已成为标配。 2019 年 Airbnb 统计，有 30% 的 iOS 用户没有使用默认的字体大小。这说明什么呢？说明越来越多的用户更喜欢依据自己的习惯来设置字体的大小来符合他们的阅读习惯。</p>\n<p data-nodeid="881">那什么是动态字体（Dynamic Type）呢？<strong data-nodeid="938">动态字体</strong>实际上就是允许用户选择屏幕上显示文本内容的大小。它能帮助一些用户把字体变大来提高可读性，也能方便一些用户把字体变小，使得屏幕能显示更多内容。</p>\n<p data-nodeid="882"><img src="https://s0.lgstatic.com/i/image6/M00/2C/CF/CioPOWBlluuATTq6AHGvASocShw754.gif" alt="13-01.gif" data-nodeid="941"></p>\n<p data-nodeid="883">以上就是动态字体的效果，一般在<strong data-nodeid="959">设置 App</strong>-&gt;<strong data-nodeid="960">辅助功能</strong>-&gt;<strong data-nodeid="961">显示与字体大小</strong>-&gt;<strong data-nodeid="962">更大字体</strong>里面通过拖动滑动条来改变系统字体的大小。</p>\n<p data-nodeid="884">目前流行的 App 都已经支持动态字体，假如我们的 App 不支持，当用户在不同 App 之间切换的时候就会感觉到很唐突，甚至会因为阅读体验的问题而直接删除。</p>\n<h3 data-nodeid="885">支持动态字体</h3>\n<p data-nodeid="886">那么怎样才能让 iOS App 支持动态字体呢？我们需要为显示文本的组件，例如<code data-backticks="1" data-nodeid="966">UILabel</code>，<code data-backticks="1" data-nodeid="968">UITextView</code>和<code data-backticks="1" data-nodeid="970">UIButton</code>指定能自动调整大小的字体。比如下面是为<code data-backticks="1" data-nodeid="972">UILabel</code>增加动态字体支持的代码。</p>\n<pre class="lang-swift" data-nodeid="887"><code data-language="swift">label.font = <span class="hljs-type">UIFont</span>.preferredFont(forTextStyle: .body)\nlabel.adjustsFontForContentSizeCategory = <span class="hljs-literal">true</span>\n</code></pre>\n<p data-nodeid="888">首先，我们使用了<code data-backticks="1" data-nodeid="975">UIFont.UITextStyle</code>的<code data-backticks="1" data-nodeid="977">.body</code>来创建一个<code data-backticks="1" data-nodeid="979">UIFont</code>的实例并赋值给 Label 的<code data-backticks="1" data-nodeid="981">font</code>属性。 然后把该 Label 的<code data-backticks="1" data-nodeid="983">adjustsFontForContentSizeCategory</code>设置为<code data-backticks="1" data-nodeid="985">true</code>来让它响应用户的动态字体设置。这个属性默认值就为<code data-backticks="1" data-nodeid="987">true</code>，假如我们不想让文本自动支持动态字体，可以把它设为<code data-backticks="1" data-nodeid="989">false</code>。</p>\n<p data-nodeid="889">目前，iOS 系统为我们提供了<strong data-nodeid="1008">Large Title</strong>，<strong data-nodeid="1009">Title 1</strong>和<strong data-nodeid="1010">Body</strong>等 11 种字体风格，你可以在苹果官方的 《Human Interface Guidelines 》文档里查看它们的具体规范。如下图所示，我从中截取当用户选择默认大小的情况下各种字体风格所对应的字体粗细和大小等信息。其中<strong data-nodeid="1011">Large Title</strong>的字号是 34pt，Title1 是 28pt，它们的字体粗细都是“Regular”。</p>\n<p data-nodeid="890"><img src="https://s0.lgstatic.com/i/image6/M00/2A/AB/CioPOWBi0LuAR4egAACHCIav2bU338.png" alt="Drawing 0.png" data-nodeid="1014"></p>\n<div data-nodeid="891"><p style="text-align:center">Dynamic Type Sizes（来源：Human Interface Guidelines）</p></div>\n<h3 data-nodeid="892">为第三方字体库加入动态字体支持</h3>\n<p data-nodeid="893">绝大多数情况下，我们应该使用 iOS 系统提供的内置字体库。但也有一些例外，例如使用自定义字体库来强调自身品牌，或者使用搞怪字体为游戏提供沉浸式体验。这个时候怎么办呢？我们可以使用第三方字体库，同时为它配置动态字体的支持。代码示例如下：</p>\n<pre class="lang-swift" data-nodeid="894"><code data-language="swift"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> customFont = <span class="hljs-type">UIFont</span>(name: <span class="hljs-string">"CustomFont"</span>, size: <span class="hljs-type">UIFont</span>.labelFontSize) <span class="hljs-keyword">else</span> {\n    <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"Failed to load the "</span><span class="hljs-type">CustomFont</span><span class="hljs-string">" font. Make sure the font file is included in the project and the font name is spelled correctly."</span>\n    )\n}\nlabel.font = <span class="hljs-type">UIFontMetrics</span>(forTextStyle: .headline).scaledFont(<span class="hljs-keyword">for</span>: customFont)\nlabel.adjustsFontForContentSizeCategory = <span class="hljs-literal">true</span>\n</code></pre>\n<p data-nodeid="895">第一步是通过传递字体库的名字，来加载并初始化类型为<code data-backticks="1" data-nodeid="1018">UIFont</code>的对象<code data-backticks="1" data-nodeid="1020">customFont</code>。<br>\n第二步是传入字体风格<code data-backticks="1" data-nodeid="1024">.headline</code>，来初始化一个<code data-backticks="1" data-nodeid="1026">UIFontMetrics</code>的对象。</p>\n<p data-nodeid="896">第三步是把<code data-backticks="1" data-nodeid="1029">customFont</code>传入<code data-backticks="1" data-nodeid="1031">scaledFont(for font: UIFont) -&gt; UIFont</code>方法，并把返回值赋给 Label 的<code data-backticks="1" data-nodeid="1033">font</code>。这样<code data-backticks="1" data-nodeid="1035">label</code>就能即使用第三方的字体库又能支持动态字体。</p>\n<h3 data-nodeid="897">Moments App 的字体定义</h3>\n<p data-nodeid="898">和大部分的 App 一样，我们没有在 Moments App 里使用第三方字体库。而是根据 07 讲的设计规范，在 DesignKit 组件里面实现了自定义的字体集合，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="899"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIFont</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> designKit = <span class="hljs-type">DesignKitTypography</span>()\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DesignKitTypography</span> </span>{\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> display1: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">42</span>, weight: .semibold), forTextStyle: .largeTitle, maximumFactor: <span class="hljs-number">1.5</span>)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> display2: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">36</span>, weight: .semibold), forTextStyle: .largeTitle, maximumFactor: <span class="hljs-number">1.5</span>)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> title1: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">24</span>, weight: .semibold), forTextStyle: .title1)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> title2: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">20</span>, weight: .semibold), forTextStyle: .title2)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> title3: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">18</span>, weight: .semibold), forTextStyle: .title3)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> title4: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">14</span>, weight: .regular), forTextStyle: .headline)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> title5: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">12</span>, weight: .regular), forTextStyle: .subheadline)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> bodyBold: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">16</span>, weight: .semibold), forTextStyle: .body)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> body: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">16</span>, weight: .light), forTextStyle: .body)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> captionBold: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">14</span>, weight: .semibold), forTextStyle: .caption1)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> caption: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">14</span>, weight: .light), forTextStyle: .caption1)\n        }\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> small: <span class="hljs-type">UIFont</span> {\n            scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">12</span>, weight: .light), forTextStyle: .footnote)\n        }\n    }\n}\n<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIFont</span>.<span class="hljs-title">DesignKitTypography</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(baseFont: UIFont, forTextStyle textStyle: UIFont.TextStyle = .body, maximumFactor: CGFloat? = <span class="hljs-literal">nil</span>)</span></span> -&gt; <span class="hljs-type">UIFont</span> {\n        <span class="hljs-keyword">let</span> fontMetrics = <span class="hljs-type">UIFontMetrics</span>(forTextStyle: textStyle)\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> maximumFactor = maximumFactor {\n            <span class="hljs-keyword">let</span> maximumPointSize = baseFont.pointSize * maximumFactor\n            <span class="hljs-keyword">return</span> fontMetrics.scaledFont(<span class="hljs-keyword">for</span>: baseFont, maximumPointSize: maximumPointSize)\n        }\n        <span class="hljs-keyword">return</span> fontMetrics.scaledFont(<span class="hljs-keyword">for</span>: baseFont)\n    }\n}\n</code></pre>\n<p data-nodeid="900">我们为<code data-backticks="1" data-nodeid="1040">UIFont</code>定义了一个类型扩展（Extension）。为了调用的时候具有命名空间，我们在这个扩展里面定义了一个名叫<code data-backticks="1" data-nodeid="1042">DesignKitTypography</code>的内嵌结构体（Nested struct），然后定义了一个静态属性来引用该结构体。</p>\n<p data-nodeid="901">根据之前设计规范里面的字体定义，我们在<code data-backticks="1" data-nodeid="1045">DesignKitTypography</code>结构体里面分别定义了<code data-backticks="1" data-nodeid="1047">display1</code>、<code data-backticks="1" data-nodeid="1049">display2</code>、<code data-backticks="1" data-nodeid="1051">title1</code>等一系列的字体属性。比如<code data-backticks="1" data-nodeid="1053">display1</code>用于页面唯一的大标题，<code data-backticks="1" data-nodeid="1055">title1</code>用于第一级段落标题，<code data-backticks="1" data-nodeid="1057">body</code>用于正文等等，它们都调用了同一个私有方法<code data-backticks="1" data-nodeid="1059">scaled(baseFont: UIFont, forTextStyle textStyle: UIFont.TextStyle = .body, maximumFactor: CGFloat? = nil)</code>来生成一个支持动态字体的<code data-backticks="1" data-nodeid="1061">UIFont</code>。这里的<code data-backticks="1" data-nodeid="1063">scaled</code>方法是怎样实现的呢？</p>\n<p data-nodeid="902">首先，该方法通过传递进来的<code data-backticks="1" data-nodeid="1066">textStyle</code>参数初始化一个<code data-backticks="1" data-nodeid="1068">UIFontMetrics</code>对象。这样能保证我们自定义的字体会以 iOS 自带的<code data-backticks="1" data-nodeid="1070">TextStyle</code>作为基准来进行缩放，然后判断<code data-backticks="1" data-nodeid="1072">maximumFactor</code>是否为空。</p>\n<p data-nodeid="903">如果不为空就计算出<code data-backticks="1" data-nodeid="1075">maximumPointSize</code>并调用<code data-backticks="1" data-nodeid="1077">scaledFont(for font: UIFont, maximumPointSize: CGFloat)</code>方法来返回一个<code data-backticks="1" data-nodeid="1079">UIFont</code>的实例。例如，为了大号的字体<code data-backticks="1" data-nodeid="1081">display1</code>和<code data-backticks="1" data-nodeid="1083">display2</code>不会无限放大，我们在生成它们的时候把<code data-backticks="1" data-nodeid="1085">maximumFactor</code>设置为<code data-backticks="1" data-nodeid="1087">1.5</code>。如果<code data-backticks="1" data-nodeid="1089">maximumFactor</code>为空，我们就调用<code data-backticks="1" data-nodeid="1091">scaledFont(for font: UIFont)</code>方法并直接返回<code data-backticks="1" data-nodeid="1093">UIFont</code>的实例。</p>\n<p data-nodeid="904">有了<code data-backticks="1" data-nodeid="1096">DesignKitTypography</code>结构体的定义，以后需要增加新的字体类型也非常简单，只需要定义新字体的名字、字体粗细和大小就可以了。例如在这里我新增<code data-backticks="1" data-nodeid="1098">caption2</code>的代码，它也使用了系统自带的字体库，并把字体大小设为<code data-backticks="1" data-nodeid="1100">10pt</code>，字体粗细设为细体，同时使用了<code data-backticks="1" data-nodeid="1102">.caption2</code>作为基准字体风格。 代码示例如下：</p>\n<pre class="lang-swift" data-nodeid="905"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> caption2: <span class="hljs-type">UIFont</span> {\n    scaled(baseFont: .systemFont(ofSize: <span class="hljs-number">10</span>, weight: .light), forTextStyle: .caption2)\n}\n</code></pre>\n<p data-nodeid="906">完成了这些字体集合的定义以后，我们可以在代码中很方便地使用它们。代码如下：</p>\n<pre class="lang-swift" data-nodeid="907"><code data-language="swift">label1.font = <span class="hljs-type">UIFont</span>.designKit.title1\nbutton.titleLabel?.font = <span class="hljs-type">UIFont</span>.designKit.bodyBold\n</code></pre>\n<p data-nodeid="908">我们可以通过<code data-backticks="1" data-nodeid="1106">UIFont.designKit</code>取出支持动态字体的<code data-backticks="1" data-nodeid="1108">UIFont</code>类型并赋值给对应的<code data-backticks="1" data-nodeid="1110">font</code>属性即可，例如<code data-backticks="1" data-nodeid="1112">UILabel</code>的<code data-backticks="1" data-nodeid="1114">font</code>属性以及<code data-backticks="1" data-nodeid="1116">UIButton</code>的<code data-backticks="1" data-nodeid="1118">titleLabel</code>。</p>\n<h3 data-nodeid="909">测试动态字体</h3>\n<p data-nodeid="910">当我们的 App 支持了动态字体以后，在开发过程中需要及时测试，否则可能会不小心引入 UI 的 Bug。幸运的是 Xcode 为我们带来一个名叫<strong data-nodeid="1126">Accessibility Inspector</strong>的工具来简化动态字体的测试流程。</p>\n<p data-nodeid="911">怎么使用它呢？请看下面的动图：</p>\n<p data-nodeid="912"><img src="https://s0.lgstatic.com/i/image6/M00/2C/C7/Cgp9HWBlmG2AV-tOANRTwrvGf2M853.gif" alt="13-02.gif" data-nodeid="1130"></p>\n<p data-nodeid="913">它使用方法很简单，我们可以在<strong data-nodeid="1136">Accessibility Inspector</strong>工具里选择运行 Moments App 的 Simulator，然后点击 Settings 按钮，接着拖动滑动条来改变 Font size 的大小，以此来测试 App 对动态字体的响应情况。</p>\n<h3 data-nodeid="914">总结</h3>\n<p data-nodeid="2960">这一讲我主要介绍了如何支持动态字体，同时以 Moments App 为例，介绍了如何实现自定义的字体集合。</p>\n<p data-nodeid="3564"><img src="https://s0.lgstatic.com/i/image6/M00/2D/9F/CioPOWBmv2aATYA_AAi8uvoxjMA746.png" alt="思维导图+二维码.png" data-nodeid="3568"></p>\n<p data-nodeid="3565">最后，结合我经验，在加入了动态字体支持后，建议你需要注意以下几点。</p>\n\n\n\n\n\n\n<ol data-nodeid="916">\n<li data-nodeid="917">\n<p data-nodeid="918">要经常使用<strong data-nodeid="1144">Accessibility Inspector</strong>工具来测试带文本内容的 UI，保证所有文本都能正常显示。</p>\n</li>\n<li data-nodeid="919">\n<p data-nodeid="920">不要硬编码文本组件所在容器的高度和宽度，容器的高度和宽度应该随着文本的大小而伸缩，否则当用户选择大字体的时候，可能导致部分文本被遮挡。</p>\n</li>\n<li data-nodeid="921">\n<p data-nodeid="922">除了特殊情况，不要硬编码<code data-backticks="1" data-nodeid="1147">UILable</code>组件文本显示的行数，否则可能导致文本显示不全。</p>\n</li>\n<li data-nodeid="923">\n<p data-nodeid="924">并不是所有文本都需要支持动态字体，例如 Tabbar 上的标题就需要指定静态的字体大小。</p>\n</li>\n</ol>\n<p data-nodeid="925">思考题：</p>\n<blockquote data-nodeid="926">\n<p data-nodeid="927">请结合前几讲所学的内容，实现下面视频中的功能，该功能会列举 iOS 系统自动的所有<strong data-nodeid="1156">TextStyle</strong>，并把它们在当前动态字体配置下的字体大小显示出来。</p>\n</blockquote>\n<p data-nodeid="928"><img src="https://s0.lgstatic.com/i/image6/M00/2C/D5/CioPOWBlnOOAcyBeAROK82r71hY801.gif" alt="13-03_1.gif" data-nodeid="1161"><br>\n这个练习能帮助你把所学的知识结合起来并灵活运用，你可以把实现的代码通过 PR 的方式来提交，有问题可以写到下面的留言区哦。我们下一讲将介绍如何定义语义色来支持深色模式。</p>\n<p data-nodeid="929"><strong data-nodeid="1167">源码地址：</strong></p>\n<blockquote data-nodeid="930">\n<p data-nodeid="931" class="">自定义字体集合的文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Frameworks/DesignKit/src/Font/UIFontExtensions.swift?fileGuid=UQqVEaxqs7oGSHOA" data-nodeid="1171">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Frameworks/DesignKit/src/Font/UIFontExtensions.swift</a></p>\n</blockquote>',
          },
          {
            theme: '14 | 功能组件：如何使用语义色，支持深色模式？',
            id: 26,
            content:
              '<p data-nodeid="24427" class="">从 iOS 13 开始，用户可以从系统级别来把外观模式改成深色模式（Dark mode）。与原有的浅色模式（Light mode）相比，使用深色模式具有以下几大优点：</p>\n<ol data-nodeid="24428">\n<li data-nodeid="24429">\n<p data-nodeid="24430">由于减少发光，使用深色模式能大幅减少电量的消耗，延长 iPhone 的续航能力；</p>\n</li>\n<li data-nodeid="24431">\n<p data-nodeid="24432">对视力不佳或者与对强光敏感的用户更为友好，为他们提供更好的可视性；</p>\n</li>\n<li data-nodeid="24433">\n<p data-nodeid="24434">在暗光环境下，让用户使用手机时更舒服。</p>\n</li>\n</ol>\n<p data-nodeid="24435">那么，我们的 App 怎样才能在支持深色模式呢？下面我将结合咱们的项目案例 Moments App 来介绍下。</p>\n<h3 data-nodeid="24436">iOS 语义色</h3>\n<p data-nodeid="24437">对于深色模式的支持，苹果推荐使用<strong data-nodeid="24496">语义化颜色</strong>（Semantic colors）来进行适配。什么叫语义化颜色呢？语义化颜色是我们根据用途来定义颜色的名称，例如使用在背景上的颜色定义为<code data-backticks="1" data-nodeid="24490">background</code>，主文本和副文本的颜色分别定义为<code data-backticks="1" data-nodeid="24492">primaryText</code>和<code data-backticks="1" data-nodeid="24494">secondaryText</code>。UI 可以通过语义色来灵活地适配用户所选择的外观模式，比如背景在浅色模式下显示为白色，而在深色模式下显示为黑色。</p>\n<p data-nodeid="24438">为了简化深色模式的适配过程，苹果公司提供了具有<strong data-nodeid="24506">语义的系统色</strong>（System colors）和<strong data-nodeid="24507">动态系统色</strong>（Dynamic system colors）供我们使用。</p>\n<p data-nodeid="24439"><img src="https://s0.lgstatic.com/i/image6/M01/32/20/CioPOWBtbFCAc4E2AADtEG1CRbc357.png" alt="Drawing 0.png" data-nodeid="24510"></p>\n<div data-nodeid="24440"><p style="text-align:center">iOS 系统色 （来源：developer.apple.com）</p></div>\n<p data-nodeid="24441">上图是苹果开发者网站提供的一个 iOS 系统色，有蓝色、绿色、靛蓝、橙色、黄色等，它们在浅色模式和深色模式下会使用到不同的颜色值。比如蓝色，在浅色模式下，它的 RGB 分别是 0、122、255，在深色模式下则分别为 10、132、255。这样就能保证系统蓝色在不同的外观模式的背景颜色上都能清晰显示。</p>\n<p data-nodeid="24442"><img src="https://s0.lgstatic.com/i/image6/M01/32/20/CioPOWBtbF6AHsamAACvBohqBt8079.png" alt="Drawing 1.png" data-nodeid="24514"></p>\n<div data-nodeid="24443"><p style="text-align:center">iOS 动态系统色 （来源：developer.apple.com）</p></div>\n<p data-nodeid="24444">上图显示是 iOS 系统提供的动态系统色的定义。它们都是通过用途来定义各种颜色的名称。例如 <strong data-nodeid="24524">Label</strong> 用于主标签文字的颜色，而 <strong data-nodeid="24525">Secondary label</strong>用于副标签文字的颜色，使用它们就能自动支持不同的外观模式了。</p>\n<h3 data-nodeid="24445">Moments App 的语义色</h3>\n<p data-nodeid="24446">为了增强品牌效果，我们一般都会为 App 单独定义一组语义色。下面以 Moments App 为例看看如何在代码中定义语义色。</p>\n<p data-nodeid="24447">根据 07 讲的设计规范，我们在 DesignKit 组件里面自定义了一组语义色，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="24448"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIColor</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> designKit = <span class="hljs-type">DesignKitPalette</span>.<span class="hljs-keyword">self</span>\n    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DesignKitPalette</span> </span>{\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> primary: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x0770e3</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x6d9feb</span>))\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> background: <span class="hljs-type">UIColor</span> = dynamicColor(light: .white, dark: .black)\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> secondaryBackground: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0xf1f2f8</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x1D1B20</span>))\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> tertiaryBackground: <span class="hljs-type">UIColor</span> = dynamicColor(light: .white, dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x2C2C2E</span>))\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> line: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0xcdcdd7</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x48484A</span>))\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> primaryText: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x111236</span>), dark: .white)\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> secondaryText: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x68697f</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x8E8E93</span>))\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> tertiaryText: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x8f90a0</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x8E8E93</span>))\n        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> quaternaryText: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0xb2b2bf</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x8E8E93</span>))\n        <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dynamicColor</span><span class="hljs-params">(light: UIColor, dark: UIColor)</span></span> -&gt; <span class="hljs-type">UIColor</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-type">UIColor</span> { $<span class="hljs-number">0</span>.userInterfaceStyle == .dark ? dark : light }\n        }\n    }\n}\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIColor</span> </span>{\n    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(hex: <span class="hljs-type">Int</span>) {\n        <span class="hljs-keyword">let</span> components = (\n                <span class="hljs-type">R</span>: <span class="hljs-type">CGFloat</span>((hex &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255</span>,\n                <span class="hljs-type">G</span>: <span class="hljs-type">CGFloat</span>((hex &gt;&gt; <span class="hljs-number">08</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255</span>,\n                <span class="hljs-type">B</span>: <span class="hljs-type">CGFloat</span>((hex &gt;&gt; <span class="hljs-number">00</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255</span>\n        )\n        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(red: components.<span class="hljs-type">R</span>, green: components.<span class="hljs-type">G</span>, blue: components.<span class="hljs-type">B</span>, alpha: <span class="hljs-number">1</span>)\n    }\n}\n</code></pre>\n<p data-nodeid="24449">我们为<code data-backticks="1" data-nodeid="24530">UIColor</code>定义了一个类型扩展（Extension）。为了调用时具有命名空间，我们在这个扩展里定义了一个名叫<code data-backticks="1" data-nodeid="24532">DesignKitPalette</code>的内嵌枚举类型（Nested enum），然后定义了一个静态属性来引用该枚举。<br>\n首先，我们一起看看<code data-backticks="1" data-nodeid="24536">DesignKitPalette</code>两个公用的方法。第一个是<code data-backticks="1" data-nodeid="24538">func dynamicColor(light: UIColor, dark: UIColor) -&gt; UIColor</code>，在该方法里面，我们根据用户当前选择的<code data-backticks="1" data-nodeid="24540">userInterfaceStyle</code>来返回对应的深色或者浅色。</p>\n<p data-nodeid="24450">第二个方法是通过类型扩展来为<code data-backticks="1" data-nodeid="24543">UIColor</code>类型添加了一个初始化函数（构造函数）。该初始化函数接收一个<code data-backticks="1" data-nodeid="24545">Int</code>类型的参数，这个参数保存了一个十六进制的值。函数内部从<code data-backticks="1" data-nodeid="24547">hex</code>里面取出分别表示红色、绿色和蓝色的<code data-backticks="1" data-nodeid="24549">R</code>、<code data-backticks="1" data-nodeid="24551">G</code>和<code data-backticks="1" data-nodeid="24553">B</code>的值，例如传入的<code data-backticks="1" data-nodeid="24555">hex</code>是<code data-backticks="1" data-nodeid="24557">0x0770e3</code>，那么<code data-backticks="1" data-nodeid="24559">R</code>、<code data-backticks="1" data-nodeid="24561">G</code>和<code data-backticks="1" data-nodeid="24563">B</code>的值是分别是<code data-backticks="1" data-nodeid="24565">07</code>、<code data-backticks="1" data-nodeid="24567">70</code>和<code data-backticks="1" data-nodeid="24569">e3</code>, 然后把这些值传递给原有的<code data-backticks="1" data-nodeid="24571">init(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)</code>初始化函数来生成一个<code data-backticks="1" data-nodeid="24573">UIColor</code>的实例。</p>\n<p data-nodeid="24451">有了这两个函数以后，我们就可以很方便地定义设计规范里面的各种颜色了。具体来说，只需要把浅色和深色传递给语义色的属性就可。比如，我们的语义色<code data-backticks="1" data-nodeid="24576">primary</code>所对应的浅色和深色的十六进制分别是<code data-backticks="1" data-nodeid="24578">0x0770e3</code>和<code data-backticks="1" data-nodeid="24580">0x6d9feb</code>，那么我们就可以通过这两个值来生成一个支持动态颜色的 UIColor 对象，代码如下所示。</p>\n<pre class="lang-swift" data-nodeid="24452"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> primary: <span class="hljs-type">UIColor</span> = dynamicColor(light: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x0770e3</span>), dark: <span class="hljs-type">UIColor</span>(hex: <span class="hljs-number">0x6d9feb</span>))\n</code></pre>\n<p data-nodeid="24453">有了这些定义以后，我们可以在代码中很方便地使用它们。代码如下：</p>\n<pre class="lang-swift" data-nodeid="24454"><code data-language="swift">label.textColor = <span class="hljs-type">UIColor</span>.designKit.primaryText\nview.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background\n</code></pre>\n<p data-nodeid="24455">可以看到，我们可以通过<code data-backticks="1" data-nodeid="24584">UIColor.designKit</code>取出相应的语义色并赋值给类型为<code data-backticks="1" data-nodeid="24586">UIColor</code>的属性即可。</p>\n<h3 data-nodeid="24456">测试语义色</h3>\n<p data-nodeid="24457">当我们的 App 使用了语义色以后，要经常在浅色和深色模式之间来回切换，加以测试，及时发现问题解决问题。要不然在开发过程中可能会因为不小心引入影响可读性的 Bug ，从而降低用户体验。幸运的是，iOS 的 Simulator 为我们提供了一组快捷键<strong data-nodeid="24594">Command + Shift + A</strong>来快速切换外观模式。下面是 Moments App 在不同外观模式下运行的效果。</p>\n<p data-nodeid="24458">从视频上你可以看到，当我按下快捷键<strong data-nodeid="24600">Command + Shift + A</strong>的时候 Moments App 在浅色和深色模式之间自动来回切换。这样能帮我们快速检查界面上文本的可读性。</p>\n<h3 data-nodeid="24459">总结</h3>\n<p data-nodeid="24650" class="te-preview-highlight">在这一讲中我介绍了如何通过语义色来灵活支持不同的外观模式，同时以 Moments App 为例子介绍了如何通过<code data-backticks="1" data-nodeid="24652">UIColor</code>的扩展来自定义语义色。</p>\n\n<p data-nodeid="24461">当我们的 App 使用了语义色以后，还需要注意以下几点。</p>\n<ol data-nodeid="24462">\n<li data-nodeid="24463">\n<p data-nodeid="24464">不要把深色模式等于黑夜模式或者夜间模式，支持深色模式的 App 在正常光线的环境下也要为用户提供良好的视觉舒适度。</p>\n</li>\n<li data-nodeid="24465">\n<p data-nodeid="24466">App 应该从系统设置里面读取外观模式的信息，而不是让用户在 App 里面进行单独配置。</p>\n</li>\n<li data-nodeid="24467">\n<p data-nodeid="24468">在开发过程中，要经常切换外观模式来测试 App。</p>\n</li>\n<li data-nodeid="24469">\n<p data-nodeid="24470">要在<strong data-nodeid="24630">设置 App</strong>-&gt;<strong data-nodeid="24631">辅助功能</strong>-&gt;<strong data-nodeid="24632">显示与字体大小</strong>页面中修改<strong data-nodeid="24633">降低透明度</strong>和<strong data-nodeid="24634">增强对比度</strong>开关，检查深色内容在黑色背景下的可读性。</p>\n</li>\n</ol>\n<p data-nodeid="24471">思考题：</p>\n<blockquote data-nodeid="24472">\n<p data-nodeid="24473">除了上述通过代码的方式以外，我们还可以在资源目录（Asset Catalog）中添加语义色。请问这两种办法各有什么优缺点？</p>\n</blockquote>\n<p data-nodeid="24474">可以把你的想法和答案写到下面的留言区哦，我们下一讲将介绍如何通过 BFF 设计跨平台的系统架构。</p>\n<p data-nodeid="24475"><strong data-nodeid="24641">源码地址：</strong></p>\n<blockquote data-nodeid="24476">\n<p data-nodeid="24477">定义语义色的文件地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Frameworks/DesignKit/src/Color/UIColorExtensions.swift?fileGuid=nKuAZ5IZkV8MwDpv" data-nodeid="24646">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Frameworks/DesignKit/src/Color/UIColorExtensions.swift</a></p>\n</blockquote>\n<p data-nodeid="24478" class=""><img src="https://s0.lgstatic.com/i/image6/M00/32/18/Cgp9HWBtbMaAReZYAAgQoLEBfco091.png" alt="202147-16245.png" data-nodeid="24649"></p>',
          },
        ],
      },
      {
        sectionName: '模块三：架构与实现',
        sectionId: 3,
        courseList: [
          {
            theme: '15 | 跨平台架构：如何设计 BFF 架构系统？',
            id: 30,
            content:
              '<p data-nodeid="2116" class="">上一模块，我和你介绍了iOS 工程化实践中的基础组件设计， 接下来这部分，我们将进入核心内容：移动端系统架构的设计与实现。</p>\n<p data-nodeid="2117">首先请你想一想：如果没有一套灵活的可扩展的系统架构，结果会怎样？</p>\n<p data-nodeid="2118">这方面我深有感触，在我们的 App 没有良好的系统架构之前，每一个微小的改动都需要“大动干戈”。具体来说，由于强耦合性，每次改动我们都需要和各个业务部门商讨详细的技术方案；功能开发完毕后，又要协调各个部门进行功能回归测试。整个过程下来，不仅耗费太多精力和时间，还容易在跨部门、跨团队沟通之间生出许多事来。</p>\n<p data-nodeid="2119">而<strong data-nodeid="2198">一套良好的系统架构，不仅仅是一款 App 的基石，也是整套代码库的规范</strong>。有了良好的系统架构，业务功能开发者就能做到有据可依，团队之间的沟通变成十分顺畅；各个功能团队之间也能并行开发，保证彼此快速迭代，提高效率。</p>\n<p data-nodeid="2120">因此，我们在推动工程化实践的同时也需要不断优化系统架构。在2017 年，我和公司同事就设计与实现了一套基于原生技术的跨平台系统架构，能让所有开发者同时在 iOS 和 Android 平台上工作。</p>\n<p data-nodeid="2121">如今这套架构经过不断改进，依然在使用。我们现在开发的 Moments App ，它所用的跨平台系统架构，正是我吸取了当初的经验与教训，使用 BFF 和 MVVM 重新架构与实现的。</p>\n<p data-nodeid="2122">这一讲，我们主要先聊聊如何使用 BFF（backend for frontend，服务于前端的后端）来设计跨平台的系统架构，以提高可重用性，进而提升开发效率。MVVM 的设计与实现，我会在后面几讲详细介绍。</p>\n<h3 data-nodeid="2123">为什么使用 BFF ？</h3>\n<p data-nodeid="2124">我们的 Moments App 是一款类朋友圈的 App，随着功能的不断完善，目前几乎所有 App 的数据源都由多个微服务所支持。在 Moments App 中，后台微服务包括：用于用户管理与鉴权的用户服务，用于记录朋友关系的朋友关系服务，用于拉黑管理的黑名单服务，用于记录每条朋友圈信息的信息服务，用于头像管理的头像服务，用于点赞管理的点赞服务等等。</p>\n<p data-nodeid="2125"><img src="https://s0.lgstatic.com/i/image6/M00/36/5D/CioPOWBzrh-AFb9xAAoKvFaZKJU686.png" alt="Drawing 0.png" data-nodeid="2206"></p>\n<p data-nodeid="2126">当我们需要呈现朋友圈界面时，App 需要给各个微服务发送请求，然后把返回的信息整理，合并和转换成我们所需要的信息进行呈现。</p>\n<p data-nodeid="2127">这些网络请求的顺序和逻辑非常复杂。有些请求需要串行处理，例如只有完成了用户服务的请求以后，才能继续其他请求；而有些请求却可以并行发送，比如在得到信息服务的返回结果以后，可以同时向头像服务和点赞服务发送请求。</p>\n<p data-nodeid="2128">接着，在得到了所有结果以后，App 需要整理和合并数据的逻辑也非常复杂，如果请求返回结果的顺序不一致，往往会导致程序出错。于是，为了解决这一系列的问题，我们引入了 BFF 服务。</p>\n<p data-nodeid="2129"><img src="https://s0.lgstatic.com/i/image6/M00/36/54/Cgp9HWBzrieAVW9VAApF2Xu_P4M715.png" alt="Drawing 1.png" data-nodeid="2212"></p>\n<p data-nodeid="2130">BFF 是一个服务于不同前端的后台服务，所有的前端（比如 iOS， Android 和 Web） 都依赖它。而且 BFF 是一个整合服务，它负责把前端的请求统一分发到各个具体的微服务上，然后把返回数据整合在一起统一返回给前端。</p>\n<p data-nodeid="2131">可以说，有了 BFF，我们的 App 就不再需要往多个微服务发送请求，也不再需要处理复杂的并发请求，这样就有效减低了复杂度，避免竞态条件等非预期情况发生。除此以外， 使用BFF 还有以下好处。</p>\n<p data-nodeid="2132">首先，App 仅需依赖一个 BFF微服务，就能有效地管理 App 对微服务的依赖。众所周知，当 App 版本发布以后，我们没有办法强迫用户更新他们设备上的 App，如果我们需要变动某个微服务的地址，原有的 App 将无法访问新的微服务地址，但是有了 BFF 以后，我们可以通过 BFF 统一路由到新的微服务去。</p>\n<p data-nodeid="2133">第二，不同的微服务可能提供不一样的数据传输方式，例如有的提供 RESI API，有的提供 gRPC，而有的提供 GraphQL。在没有 BFF 的情况下，App 端必须实现各个技术栈来访问各个微服务。一旦有了 BFF 以后，App 只需要支持一种传输方式，极大减轻移动端开发和维护成本。</p>\n<p data-nodeid="2134">第三，由于 BFF 统一处理所有的数据，iOS 和 Android 两端都可以得到由 BFF 清理并转换好的数据，无须在各端重复开发一样的数据处理代码。这极大减少了工作量，让我们可以把重心放在提高用户体验上。</p>\n<p data-nodeid="2135"><img src="https://s0.lgstatic.com/i/image6/M00/36/54/Cgp9HWBzrjCALKwqAABbDn2yVs4507.png" alt="Drawing 2.png" data-nodeid="2220"></p>\n<p data-nodeid="2136">第四，BFF 在提升整套系统安全性的同时，提高整体性能。</p>\n<p data-nodeid="2137">具体来说，因为我们的 App 是通过公网连接到后台微服务的，所有微服务都需要公开给所有外部系统进行访问。这就会面临隐私信息暴露等安全问题，比如用户会通过 App 获得本来不应该公开的黑名单信息。</p>\n<p data-nodeid="2138">但我们引入 BFF 以后，可以为微服务配置安全规则（如 AWS 上的 Security Group）只允许 BFF 能访问，例如上述的黑名单管理服务，就可以设置除了 BFF 以外不允许任何其他外部系统（包括我们的 App）直接访问，从而有效保证了隐私信息与公网的隔离。</p>\n<p data-nodeid="2139">与此同时， BFF 还可以同步访问多个不同的数据源，统一管理数据缓存，这无疑能有效提升整套系统的性能。</p>\n<p data-nodeid="2140"><img src="https://s0.lgstatic.com/i/image6/M00/36/5D/CioPOWBzrjeAPTzGAAp_52nZbQQ085.png" alt="Drawing 3.png" data-nodeid="2227"></p>\n<h3 data-nodeid="2141">BFF 的技术选型——GraphQL</h3>\n<p data-nodeid="2142">既然 BFF 那么好用，那应该怎样实现一个 BFF 服务呢？我经过多个项目的实践总结发现，GraphQL 是目前实现 BFF 架构的最优方案。</p>\n<p data-nodeid="2143">具体来说，和 REST API，gRPC 以及 SOAP 相比， GraphQL 架构有以下几大优点。</p>\n<ul data-nodeid="2144">\n<li data-nodeid="2145">\n<p data-nodeid="2146">GraphQL 允许客户端按自身的需要通过 Query 来请求不同数据集，而不像 REST API 和gRPC 那样每次都是返回全部数据，这样能有效减轻网络负载。</p>\n</li>\n<li data-nodeid="2147">\n<p data-nodeid="2148">GraphQL能减轻为各客户端开发单独 Endpoint 的工作量。比如当我们开发 App Clip 的时候，App Clip 可以在 Query 中以指定子数据集的方式来使用和主 App 相同的 Query，而无须重新开发新 Endpoint。</p>\n</li>\n<li data-nodeid="2149">\n<p data-nodeid="2150">GraphQL 服务能根据客户端的 Query 来按需请求数据源，避免无必要的数据请求，减轻服务端的负载。</p>\n</li>\n</ul>\n<p data-nodeid="2151">下面我们以一个例子来看看GraphQL 是怎样处理不同的 Query 的。</p>\n<p data-nodeid="2152">假设我们要开发一个显示某大 V 朋友圈的 App Clip，当用户使用 App Clip 时不需要鉴权，不必查看黑名单，就直接可以看到该大 V 的朋友圈信息，那么我们在访问 GraphQL 的流程会就简化了（如下图所示）。</p>\n<p data-nodeid="2153"><img src="https://s0.lgstatic.com/i/image6/M00/36/5D/CioPOWBzrkGALUcIAAF_IygeIJY591.png" alt="Drawing 4.png" data-nodeid="2238"></p>\n<p data-nodeid="2154">和我们的主 App 请求相比，App Clip 不需要显示点赞信息，返回的结果就可以精简了。而且由于不需要进行鉴权，也不需要查询朋友关系、黑名单和点赞等信息，BFF 也无须向这些微服务发起请求，从而有效减轻了 BFF 服务的负载。</p>\n<p data-nodeid="2155">另外一方面，和 REST API 相比，GraphQL 的数据交换都由 Schema 统一管理，能有效减少由于数据类型和可空类型不匹配所导致的问题。</p>\n<p data-nodeid="2156">除此之外，GraphQL 还能减轻版本管理的工作量。因为 GraphQL 能支持返回不同数据集，从而无须像 REST API 那样为每个新功能不断地更新 Endpoint 的版本号。</p>\n<h3 data-nodeid="2157">如何使用 GraphQL 实现 BFF</h3>\n<p data-nodeid="2158">既然我们确定了 GraphQL，那需要选择一个服务框架来帮我们实现。具体怎么实现呢？为了方便演示，我选择了 Apollo Serve。</p>\n<p data-nodeid="2159">Apollo Serve 是基于 Node.js 的 GraphQL 服务器，目前非常流行。使用它，可以很方便地结合 Express 等 Web 服务，而且还可以部署到亚马逊 Lambda，微软 Azure Functions 等 Serverless 服务上。</p>\n<p data-nodeid="2160">再加上 Apollo Serve 在我们公司的生产环境上使用多年，一直稳定地支撑着 App 正常运行，因为比较熟悉，所以我就选了它。</p>\n<p data-nodeid="2161">下面一起看看具体怎么做。</p>\n<p data-nodeid="2162"><strong data-nodeid="2251">第一步，使用 GraphQL，我们先要为前后端传递的数据定义 schema。</strong> 在这里我写了 Moment 类型的部分 Schema 定义。比如在 Moment 类型里，我定义了 id，type，title 和 user details 等属性，其中 user details 属性的类型是 User Details，它定义了 name 和 avatar 等属性。其的代码示例如下所示。</p>\n<pre class="lang-java" data-nodeid="2163"><code data-language="java">enum MomentType {\n  URL\n  PHOTOS\n}\ntype Moment {\n  id: ID!\n  userDetails: UserDetails!\n  type: MomentType!\n  title: String # nullable\n  photos: [String!]! # non-nullable but can be empty\n}\ntype UserDetails {\n  id: ID!\n  name: String!\n  avatar: String!\n  backgroundImage: String!\n}\n</code></pre>\n<p data-nodeid="2164">如果你想要查看完整定义，可以点击<a href="https://github.com/JakeLin/moments-api?fileGuid=alwlHWvZK8AhMGre" data-nodeid="2255">拉勾教育的仓库中</a>查看。</p>\n<p data-nodeid="2165">GraphQL 支持枚举类型，比如上面的<code data-backticks="1" data-nodeid="2258">MomentType</code>就是一个枚举类型，它只有两个值<code data-backticks="1" data-nodeid="2260">URL</code>和<code data-backticks="1" data-nodeid="2262">PHOTOS</code>，在数据传输过程中，它们是通过字符串传送给前端的。</p>\n<p data-nodeid="2166"><code data-backticks="1" data-nodeid="2264">Moment</code>是一个类型定义，在 Swift 中可以对应成<code data-backticks="1" data-nodeid="2266">struct</code>，而在 Kotlin 中则对应为<code data-backticks="1" data-nodeid="2268">data class</code>。这个类型有<code data-backticks="1" data-nodeid="2270">id</code>、<code data-backticks="1" data-nodeid="2272">userDetails</code>等属性。这些属性可以是基础数据类型，如<code data-backticks="1" data-nodeid="2274">String</code>、<code data-backticks="1" data-nodeid="2276">ID</code>、<code data-backticks="1" data-nodeid="2278">Int</code>等；也可以是自定义类型，如自定义的<code data-backticks="1" data-nodeid="2280">UserDetails</code>。</p>\n<p data-nodeid="2167">当数据类型后面有<code data-backticks="1" data-nodeid="2283">!</code>时，表示该属性不能为<code data-backticks="1" data-nodeid="2285">null</code>。这其中需要注意一点，那就是<code data-backticks="1" data-nodeid="2287">!</code>在数组定义里面的使用。比如<code data-backticks="1" data-nodeid="2289">photos: [String!]!</code>，表示该数组不能为<code data-backticks="1" data-nodeid="2291">null</code>，而且不能存放值为<code data-backticks="1" data-nodeid="2293">null</code>的数据。而<code data-backticks="1" data-nodeid="2295">photos: [String!]</code>则表示<code data-backticks="1" data-nodeid="2297">photos</code>数组自身可能为<code data-backticks="1" data-nodeid="2299">null</code>，但还是不能存放值为<code data-backticks="1" data-nodeid="2301">null</code>的数据 。再来看<code data-backticks="1" data-nodeid="2303">photos: [String]!</code>，这表示<code data-backticks="1" data-nodeid="2305">photos</code>数组自己不可以为<code data-backticks="1" data-nodeid="2307">null</code>, 但是可以放值为<code data-backticks="1" data-nodeid="2309">null</code>的数据。</p>\n<p data-nodeid="2168"><strong data-nodeid="2314">第二步，有了 Schema 的定义以后，接下来我们可以定义 Query 和 Mutation，以便为 App 提供查询和更新的接口。</strong></p>\n<pre class="lang-plain" data-nodeid="2169"><code data-language="plain">type Query {\n  getMomentsDetailsByUserID(userID: ID!): MomentsDetails!\n}\n</code></pre>\n<p data-nodeid="2170">这表示该 GraphQL 服务提供一个名叫<code data-backticks="1" data-nodeid="2316">getMomentsDetailsByUserID</code>的 Query，该 Query 接受<code data-backticks="1" data-nodeid="2318">userID</code>作为入口参数，并返回<code data-backticks="1" data-nodeid="2320">MomentsDetails</code>。</p>\n<p data-nodeid="2171">一般 Query 只能用于查询，如果要更新，则需要使用 Mutation，下面是一个 Mutation 的定义。</p>\n<pre class="lang-plain" data-nodeid="2172"><code data-language="plain">type Mutation {\n  updateMomentLike(momentID: ID!, userID: ID!, isLiked: Boolean!): MomentsDetails!\n}\n</code></pre>\n<p data-nodeid="2173">其实 Mutation 是一个会更新状态的 Query，因为在更新后还是可以返回数据的。例如上例中<code data-backticks="1" data-nodeid="2324">updateMomentLike</code>接受了<code data-backticks="1" data-nodeid="2326">momentID</code>、<code data-backticks="1" data-nodeid="2328">userID</code>和<code data-backticks="1" data-nodeid="2330">isLiked</code>作为入口参数，在更新状态后也可以返回<code data-backticks="1" data-nodeid="2332">MomentsDetails</code>。</p>\n<p data-nodeid="2174"><strong data-nodeid="2337">第三步，有了以上的定义以后，我们可以借助 resolver 来查询或者更新数据。</strong></p>\n<pre class="lang-java" data-nodeid="2175"><code data-language="java"><span class="hljs-keyword">const</span> resolvers = {\n  Query: {\n    getMomentsDetailsByUserID: (_, {userID}) =&gt; momentsDetails,\n  },\n  Mutation: {\n    updateMomentLike: (_, {momentID, userID, isLiked}) =&gt; {\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i in momentsDetails.moments) {\n        <span class="hljs-keyword">if</span> (momentsDetails.moments[i].id === momentID) {\n          <span class="hljs-keyword">if</span> (momentsDetails.moments[i].isLiked === isLiked) {\n            <span class="hljs-keyword">break</span>\n          }\n          momentsDetails.moments[i].isLiked = isLiked;\n          <span class="hljs-keyword">if</span> (isLiked) {\n            <span class="hljs-keyword">const</span> likedUserDetails = getUserDetailsByID(userID)\n            momentsDetails.moments[i].likes.push(likedUserDetails);\n          } <span class="hljs-keyword">else</span> {\n            <span class="hljs-comment">// remove the item for that user</span>\n            momentsDetails.moments[i].likes = momentsDetails.moments[i].likes.filter((item) =&gt; item.id !== userID);\n          }\n          <span class="hljs-keyword">break</span>;\n        }\n      }\n      <span class="hljs-keyword">return</span> momentsDetails;\n    }\n  }\n};\n</code></pre>\n<p data-nodeid="2176"><code data-backticks="1" data-nodeid="2338">resolvers</code>的大致逻辑是，在 get Moments Details By User ID 查询里面，直接把 momentsDetails 的数据返回。在 update moment like 更新里面，我们更新了 momentsDetails 的 is Liked 属性来表示用户是否点赞。在 Moments App 的 BFF 中，我们维护了一个内存数据库，而在真实生产环境中，可以访问 MySQL、MongoDB 来直接存储数据，或者通过其他微服务来桥接数据库的访问。</p>\n<p data-nodeid="2177">到此为止，我们就通过 GraphQL 实现了一个 BFF。 注意，这只是一个例子，并不是每个 BFF 都必须通过 Apollo Server 以及 Node.js 来实现。你可以根据所做团队成员的技能来挑选适合你们的技术栈。</p>\n<p data-nodeid="2178">比如，Kotlin 是一个不错的选择，因为大部分 Android 开发者都熟悉 Kotlin 语言，而且 Kotlin 还可以完美兼容 JVM。特别 JVM 生态非常发达，我们可以利用 Kotlin 和基于 JVM 的开源库构建稳定的 BFF 方案。</p>\n<h3 data-nodeid="2179">总结</h3>\n<p data-nodeid="2180">这一讲我介绍了如何使用 BFF 来设计跨平台的系统架构，以及如何使用 GraphQL 实现 BFF。虽然 GraphQL 有众多优点，但并非十全十美，甚至可以说，世界上并没有完美的技术。所以，在使用 GraphQL 过程中，我们需要注意以下两点。</p>\n<ol data-nodeid="2181">\n<li data-nodeid="2182">\n<p data-nodeid="2183">在定义 Schema 的过程中，需要前后台开发者共同协商沟通，特别要注意<code data-backticks="1" data-nodeid="2345">nullable</code>类型的处理，如果前端定义有误，很容易引起 App 的崩溃。</p>\n</li>\n<li data-nodeid="2184">\n<p data-nodeid="2185">GraphQL 通常使用 HTTP POST 请求，但有些 CDN （content delivery network，内容分发网络）对 POST 缓存支持不好，当我们把 GraphQL 的请求换成 GET 时，整个 Query 会变成 JSON-encoded 字符串并放在 Query String 里面进行发送。此时，要特别注意该 Query String 的长度不要超过 CDN 所支持的长度限制（比如 Akamai 支持最长的 URL 是 8892 字节），否则请求将会失败。</p>\n</li>\n</ol>\n<p data-nodeid="2186">思考题：</p>\n<blockquote data-nodeid="2187">\n<p data-nodeid="2188">在这里，我们使用 BFF 和 MVVM 来架构跨平台方案，请问你在跨平台方面，使用的是那种方案，原因是什么？</p>\n</blockquote>\n<p data-nodeid="2189" class="te-preview-highlight">可以把回答写到下面的留言区哦。这一讲我们介绍了 BFF 服务端，从下一讲开始，我将开始介绍跨平台系统架构的另一个核心 MVVM 模式。这其中，我会先聊聊如何在iOS 移动端使用 MVVM 模式进行架构设计。</p>',
          },
          {
            theme: '16 | 架构模式：为什么要选择 MVVM 模式？',
            id: 31,
            content:
              '<p data-nodeid="973" class="">作为 iOS 开发者，我们都很熟悉 MVC 模式。根据苹果官方的解释， MVC 表示 Model-View-Controller， 也就是模型、视图和控制器。但是业界一直把 MVC 戏称为 Massive ViewController（臃肿的视图控制器）。因为当我们使用 MVC 的时候，随着功能越来越丰富， ViewController 往往变得臃肿和繁杂，而且模块之间相互耦合，难以维护。下图显示了苹果的 MVC 模式。</p>\n<p data-nodeid="974"><img src="https://s0.lgstatic.com/i/image6/M00/36/5D/CioPOWBzrr2ASdn0AAB7aYkrITU199.png" alt="Drawing 0.png" data-nodeid="1038"></p>\n<p data-nodeid="975">其中，Controller 通常指 ViewController ，是 MVC 的核心，ViewController 通过Target-Action、DataSource 和 Delegate 来接收来自 View 的用户事件，并通过 Outlet 来更新 View。同时 ViewController 还通过 Notification 和 KVO 来接收来自 Model 的通知，并通过变量来更新 Model。</p>\n<p data-nodeid="976">除了与 View 和 Model 进行交互以外，ViewController 还负责导航、网络访问、数据缓存、错误处理以及 Model 对象的 Encode 和 Decode。由于 ViewController 承担多项责任，往往导致代码量极大，且由于强耦合，对 ViewController 的一点点改动都需要进行手工回归测试，费时费力。那么，有没有什么好的办法来解决这些问题呢？</p>\n<h3 data-nodeid="977">MVVM 及其优点</h3>\n<p data-nodeid="4580">经过多年实践证明，MVVM 模式是目前解决臃肿 ViewController 问题的有效方法。MVVM 全称 Model-View-ViewModel （模型-视图-视图模型）。与 MVC 相比，它引入了一个名叫 ViewModel 的新概念。如下图所示。</p>\n<p data-nodeid="4581" class=""><img src="https://s0.lgstatic.com/i/image6/M01/37/48/Cgp9HWB2p8iAJEKQAAIqLJKlDBM196.png" alt="图片3.png" data-nodeid="4585"></p>\n\n\n<p data-nodeid="980">MVVM 由三层组成：</p>\n<ul data-nodeid="981">\n<li data-nodeid="982">\n<p data-nodeid="983" class="te-preview-highlight"><strong data-nodeid="1051">Model</strong>，用于保存数据的模型对象，通常定义为只有数据并没有方法的结构体（Struct）；</p>\n</li>\n<li data-nodeid="984">\n<p data-nodeid="985"><strong data-nodeid="1056">View</strong>，用于呈现 UI（用户界面）并响应用户的事件，通常是 ViewController 和 View；</p>\n</li>\n<li data-nodeid="986">\n<p data-nodeid="987"><strong data-nodeid="1061">ViewModel</strong>，用于桥接 Model 和 View 两层，把 Model 转换成 View 呈现 UI 所需的数据，并把 View 层的用户输入数据更新到 Model 中。</p>\n</li>\n</ul>\n<p data-nodeid="988">那么，和 MVC 相比，MVVM 模式具有什么优点呢？具体有以下几个。</p>\n<ul data-nodeid="989">\n<li data-nodeid="990">\n<p data-nodeid="991">能效减低代码的复杂性，即 MVVM 模式能有效简化 ViewController 的逻辑，使得 ViewController 的代码只处理 UI 相关的逻辑。</p>\n</li>\n<li data-nodeid="992">\n<p data-nodeid="993">能提高代码的可测试性，由于 ViewModel 明确负责 Modle 与 View 之间的数据转换，而且不负责 View 的生命周期管理，我们可以很方便地测试 ViewModel 的代码逻辑，提高代码的健壮性。</p>\n</li>\n<li data-nodeid="994">\n<p data-nodeid="995">能够减低代码耦合性。在 MVVM 模式下，每一层都明确分工，这样可以减少代码耦合性，提高代码的可维护性和可重用性。</p>\n</li>\n<li data-nodeid="996">\n<p data-nodeid="997">减轻移动团队的开发门槛，方便知识的共享。前两年谷歌公司为 Android 引入了一个基于 MVVM 模式的新框架 Architecture Components，使用 MVVM 模式能方便开发者同时在 iOS 和 Android 两个平台开发功能。</p>\n</li>\n</ul>\n<h3 data-nodeid="998">基于 MVVM 的架构设计</h3>\n<p data-nodeid="3617">如今，经过多年的实践，我们已经能够成功地使用 MVVM 模式在 iOS 和 Android 上实现了一套风格一致的架构设计。 比如，在 Moments App 里面，我就进行了优化并重新实现了一套基于 MVVM 模式的架构，具体如下图所示：</p>\n<p data-nodeid="3618" class=""><img src="https://s0.lgstatic.com/i/image6/M01/37/48/Cgp9HWB2p72ADAbnAAJKuBdBnmc620.png" alt="图片2.png" data-nodeid="3623"></p>\n<div data-nodeid="3619"><p style="text-align:center">Moments App 的架构图</p></div>\n\n\n\n\n<h4 data-nodeid="1002">Moments App 的架构详解</h4>\n<p data-nodeid="1003">以上是我们 Moments App 的架构图，下面我把每一层进行分解和介绍下。</p>\n<p data-nodeid="1004"><strong data-nodeid="1077">View 层</strong></p>\n<p data-nodeid="1005">View 层由<code data-backticks="1" data-nodeid="1079">UIViewController</code>以及<code data-backticks="1" data-nodeid="1081">UIView</code>所组成，负责呈现 UI 和响应用户事件。由于 MVVM 模式相当灵活，我们在后面第 32 讲会介绍如何在保持其他模块完全不变的情况下把 View 层换成 SwiftUI 来实现。</p>\n<p data-nodeid="1006"><strong data-nodeid="1086">ViewModel 层</strong></p>\n<p data-nodeid="1007">它是 MVVM 模式的核心，主要任务是连接 View 和 Model 层，为 View 层准备呈现 UI 所需的数据，并且响应 View 层所提供的用户事件。同时它还负责处理路由和发送用户行为数据。由于 ViewModel 层的责任还是很重，因此我们把它进一步细分为各个模块，大致包括<strong data-nodeid="1091">ViewModel、Routing、Tracking、Repository、Networking、DataStore。</strong></p>\n<p data-nodeid="1008">其中，<strong data-nodeid="1101">ViewModel</strong>扮演一个协助者的角色，负责准备 View 层所需的数据，并响应 View 层的用户事件。ViewModel 与上层的<code data-backticks="1" data-nodeid="1097">UIViewController</code>和<code data-backticks="1" data-nodeid="1099">UIView</code>之间通过响应式编程的方式来通知对方，而上层 UI 组件通过数据绑定的方式，来监听 ViewModel 的数据变化，并及时更新 UI。</p>\n<p data-nodeid="1009"><strong data-nodeid="1106">Routing</strong>是负责路由和导航的模块，ViewModel 在响应 View 的请求时（如打开新页面），会调用 Routing 模块进行导航。</p>\n<p data-nodeid="1010"><strong data-nodeid="1111">Tracking</strong>则负责统计分析数据的模块，ViewModel 在响应 View 的请求时（如用户点击了点赞按钮），会调用 Tracking 模块来发送用户行为的数据。</p>\n<p data-nodeid="1011"><strong data-nodeid="1116">Repository</strong>是数据层，作为唯一信息来源（Single source of truth）维护着 App 所使用的 Model 数据。当 ViewModel 需要访问数据的时候，会调用 Repository 模块，然后 Repository 会根据需要通过 Networking 来访问网络的后台数据，或者调用 DataStore 来获取本地缓存的数据。ViewModel 和 Repository 的接口也是响应式编程的方式，主要由 ViewModel 给 Repository 发起请求，然后监听 Repository 来获取数据所发生的变化。</p>\n<p data-nodeid="1012"><strong data-nodeid="1121">Networking</strong>是网络层，负责访问 BFF，然后把 BFF 返回的 JSON 数据 Decode 成 Model 数据。Repository 与 Networking 的接口也是响应式编程的方式。Repository 会给 Networking 发起请求，并监听 Networking 的返回。</p>\n<p data-nodeid="1013"><strong data-nodeid="1126">DataStore</strong>为数据存储层，用于把数据缓存到 App 里面使得用户在不需等待网络请求的情况下可以快速看到 UI。Repository 与 DataStore 的接口也是响应式编程的方式。Repository 监听 DataStore 的数据变化。</p>\n<p data-nodeid="1014"><strong data-nodeid="1130">Model 层</strong></p>\n<p data-nodeid="1015">最后一层是 Model 层，它比较简单，都是一些用于存放数据的模型对象，这些对象能用于存放网络请求使用的数据，也可用于存放本地缓存的数据。</p>\n<h4 data-nodeid="1016">朋友圈模块的架构设计</h4>\n<p data-nodeid="2653">有了上述的架构设计，我就可以把 MVVM 模式应用到各个业务模块里面。比如，在这里我以 Moments App 的朋友圈模块作为例，和你介绍下它的具体的架构。下面是我为该模块所绘制的类型关系图。</p>\n<p data-nodeid="2654" class=""><img src="https://s0.lgstatic.com/i/image6/M01/37/48/Cgp9HWB2p7CAYGJyAALj6KlRJ98450.png" alt="图片1.png" data-nodeid="2659"></p>\n<div data-nodeid="2655"><p style="text-align:center">Moments App 朋友圈模块的类型关系图</p></div>\n\n\n\n\n\n\n\n\n<p data-nodeid="1020" class="">View 层用于显示 UI，<code data-backticks="1" data-nodeid="1138">MomentsViewTimelineViewController</code>用于显示朋友圈界面，这个页面里面使用了一个 TableView 来显示各种不同的 Cell。这些 Cell 都通过 UIView 来显示，其中<code data-backticks="1" data-nodeid="1140">UserProfileListItemView</code>用于显示用户个人的信息，而<code data-backticks="1" data-nodeid="1142">MomentListItemView</code>显示一条朋友圈的信息。</p>\n<p data-nodeid="1021"><strong data-nodeid="1156">ViewModel 层</strong>由多个组件所组成。其核心是<code data-backticks="1" data-nodeid="1148">MomentsTimelineViewModel</code>，它为<code data-backticks="1" data-nodeid="1150">MomentsViewTimelineViewController</code>准备呈现 UI 的数据，并处理用户的事件。各个 UI 子组件也对应着各个子 ViewModel。例如<code data-backticks="1" data-nodeid="1152">UserProfileListItemView</code>对应了<code data-backticks="1" data-nodeid="1154">UserProfileListItemViewModel</code>。</p>\n<p data-nodeid="1022">当<code data-backticks="1" data-nodeid="1158">MomentsTimelineViewModel</code>要发送统计分析数据的时候会调用<code data-backticks="1" data-nodeid="1160">TrackingRepo</code>，进而把用户行为数据发送到分析数据的后台。当<code data-backticks="1" data-nodeid="1162">MomentsTimelineViewModel</code>要导航到其他页面的时候会调用<code data-backticks="1" data-nodeid="1164">AppRouter</code>，而<code data-backticks="1" data-nodeid="1166">AppRouter</code>会调用路由模块来导航到相应的页面去。</p>\n<p data-nodeid="1023">当<code data-backticks="1" data-nodeid="1169">MomentsTimelineViewModel</code>需要读取或者更新数据的时候，会给<code data-backticks="1" data-nodeid="1171">MomentsRepoo</code>发起请求。该 Repo 负责发送网络请求并把朋友圈数据缓存到本地文件系统中。这个 Repo 还是所有朋友圈信息的数据中心，App 里面任何页面需要朋友圈信息的数据，都可以从该 Repo 中进行读取。</p>\n<p data-nodeid="1024">为了进一步解耦，我们把数据缓存和网络请求模块从 Repo 中独立出来，分成 DataStore 和 Networking 两个模块。例如当<code data-backticks="1" data-nodeid="1174">MomentsRepoo</code>需要读写缓存的时候，会调用<code data-backticks="1" data-nodeid="1176">UserDefaultsPersistentDataStore</code>，DataStore 模块负责把模型数据保存到<strong data-nodeid="1182">UserDefaults</strong>里面。</p>\n<p data-nodeid="1025">而当<code data-backticks="1" data-nodeid="1184">MomentsRepoo</code>需要从网络上取出朋友圈信息时会调用<code data-backticks="1" data-nodeid="1186">GetMomentsByUserIDSession</code>。<code data-backticks="1" data-nodeid="1188">GetMomentsByUserIDSession</code>会从 BFF 里读取当前用户所有的朋友圈信息。当<code data-backticks="1" data-nodeid="1190">MomentsRepoo</code>需要更新朋友圈信息时（如更新点赞的状态），会调用<code data-backticks="1" data-nodeid="1192">UpdateMomentLikeSession</code>来对 BFF 发起更新的请求。</p>\n<p data-nodeid="1026"><strong data-nodeid="1206">Model 层</strong>相对比较简单，只有一个用于保存朋友圈信息的模型数据：<code data-backticks="1" data-nodeid="1198">MomentsDetails</code>。其中<code data-backticks="1" data-nodeid="1200">UserDefaultsPersistentDataStore</code>使用它来进行本地缓存的读取，而<code data-backticks="1" data-nodeid="1202">GetMomentsByUserIDSession</code>和<code data-backticks="1" data-nodeid="1204">UpdateMomentLikeSession</code>会使用它来存放网络请求的 JSON 数据。</p>\n<p data-nodeid="1027">上面就是 Moments App 基于 MVVM 模式的架构设计，我们会在后面几讲中详细介绍各个层的架构与具体实现方式。</p>\n<h3 data-nodeid="1028">总结</h3>\n<p data-nodeid="1029">这一讲我们结合 Moments App 介绍了一套可行的 MVVM 架构模式。通过它，我们可以有效降低各个模块之间的耦合度，提高可重用性，再加上由于每个模块有了明确的责任与分工，我们在实现新功能时，也能降低沟通成本，提高开发效率。所以有关这个架构模式，你一定要重视起来哦。</p>\n<p data-nodeid="1030">另外，结合 BFF 的后端服务，我们还可以在 iOS 和 Android 两端同样使用 MVVM 模式来进行架构设计，并保持一致的代码风格，以便于开发者能同时在两个平台进行开发。</p>\n<p data-nodeid="1031">思考题</p>\n<blockquote data-nodeid="1032">\n<p data-nodeid="1033">请问你们的 App 使用了怎样的架构模式？你觉得有什么优缺点可以分享给大家？</p>\n</blockquote>\n<p data-nodeid="1034" class="">你可以把自己的思考写到下面的留言区哦，这一讲就介绍到这里，下一讲我将介绍如何使用 RxSwift 来实现响应式编程。</p>',
          },
          {
            theme: '17 | 响应式编程：如何保证程序状态自动更新？',
            id: 32,
            content:
              '<p data-nodeid="10292" class="">在 iOS 开发中，随着 App 功能不断增强，处理各种异步事件，保持程序状态实时更新，也变得越来越困难。</p>\n<p data-nodeid="10293"><img src="https://s0.lgstatic.com/i/image6/M01/39/F5/Cgp9HWB9VNqAdUpJAAelf-Mqcao388.png" alt="图片1.png" data-nodeid="10419"></p>\n<p data-nodeid="10294">以 ViewController 来为例，我们需要处理许多异步事件，比如来自 Delegate 和 DataSource 的回调，来自 NotificationCenter 的通知消息，来自 View 的 Target-Action 事件，等等。</p>\n<p data-nodeid="10295">由于它们随机发生且可能来自不同的线程，本身就会比较复杂，再加上其他新事件的引入，代码处理的逻辑会呈指数式增长。那么，怎样才能从根本上解决这些问题呢？这一讲我们所介绍的<strong data-nodeid="10426">响应式编程就可以解决</strong>。</p>\n<h3 data-nodeid="10296">响应式编程与 RxSwift</h3>\n<p data-nodeid="10297">所谓<strong data-nodeid="10433">响应式编程</strong>,就是使用异步数据流（Asynchronous data streams）进行编程。在传统的指令式编程语言里，代码不仅要告诉程序做什么，还要告诉程序什么时候做。而在响应式编程里，我们只需要处理各个事件，程序会自动响应状态的更新。而且，这些事件可以单独封装，能有效提高代码复用性并简化错误处理的逻辑。</p>\n<p data-nodeid="10298">现在，响应式编程已慢慢成为主流的编程范式，比如 Android 平台的 Architecture Components 提供了支持响应式编程的 LiveData， SwiftUI 也配套了 Combine 框架。在 Moments App 中，我采用的也是响应式编程模式。</p>\n<p data-nodeid="10299">目前比较流行的响应式编程框架有 ReactiveKit、ReactiveSwift 和 Combine。在这里，我们推荐使用<strong data-nodeid="10440">RxSwift</strong>。因为 RxSwift 遵循了 ReactiveX 的 API 标准，由于 ReactiveX 提供了多种语言的实现，学会 RxSwift 能有效把知识迁移到其他平台。还有 RxSwift 项目非常活跃，也比较成熟。更重要的是，RxSwift 提供的 RxCocoa 能帮助我们为 UIKit 扩展响应式编程的能力，而 Combine 所对应的 CombineCocoa 还不成熟。</p>\n<p data-nodeid="10300"><img src="https://s0.lgstatic.com/i/image6/M01/39/F5/Cgp9HWB9VOOAEzp4AAKF1WzKJBs733.png" alt="图片2.png" data-nodeid="10443"></p>\n<p data-nodeid="10301">为了让 App 可以自动更新状态，我们在 Moments App 里面使用 RxSwift 把 MVVM 各层连接起来。</p>\n<p data-nodeid="10302">从上图可以看出，当用户打开朋友圈页面，App 会使用<strong data-nodeid="10470">后台排程器</strong>向 BFF 发起一个网络请求，Networking 模块把返回结果通过<strong data-nodeid="10471">Observable 序列</strong>发送给 Repository 模块。Repository 模块订阅接收后，把数据发送到<strong data-nodeid="10472">Subject</strong>里面，然后经过<strong data-nodeid="10473">map 操作符</strong>转换，原先的 Model 类型转换成了 ViewModel 类型。 ViewModel 模块订阅经过操作符转换的数据，发送给下一个<strong data-nodeid="10474">Subject</strong>，之后，这个数据被 ViewController 订阅，并通过<strong data-nodeid="10475">主排程器</strong>更新了 UI。</p>\n<p data-nodeid="10303">整个过程中，Repository 模块、 ViewModel模块、ViewController 都是订阅者，分别接收来自前一层的信息。就这样，当 App 得到网络返回数据时，就能自动更新每一层的状态信息，也能实时更新 UI 显示。</p>\n<p data-nodeid="10304">这其中的 Observable 序列、订阅者、Subject 、操作符、排程器属于&nbsp;RxSwift 中的关键概念，它们该如何理解，如何使用呢？接下来我就一一介绍下。</p>\n<h3 data-nodeid="10305">异步数据序列 Observable</h3>\n<p data-nodeid="10306">为了保证程序状态的同步，我们需要把各种异步事件都发送到异步数据流里，供响应式编程发挥作用。在 RxSwfit 中，异步数据流称为 Observable 序列，它表示可观察的异步数据序列，也可以理解为消息发送序列。</p>\n<p data-nodeid="10307">在实际应用中，我们通常使用 Observable 序列作为入口，把外部事件连接到响应式编程框架里面。比如在 Moments App ，我通过 Observable 把网络请求的结果连接进 MVVM 架构中。</p>\n<p data-nodeid="10308">那么怎样创建 Observable 序列呢？为方便我们生成 Observable 序列， RxSwfit 的<code data-backticks="1" data-nodeid="10482">Observable</code>类型提供了如下几个工厂方法：</p>\n<ul data-nodeid="10309">\n<li data-nodeid="10310">\n<p data-nodeid="10311"><code data-backticks="1" data-nodeid="10484">just</code>方法，用于生成只有一个事件的 Observable 序列；</p>\n</li>\n<li data-nodeid="10312">\n<p data-nodeid="10313"><code data-backticks="1" data-nodeid="10486">of</code>方法，生成包含多个事件的 Observable 序列；</p>\n</li>\n<li data-nodeid="10314">\n<p data-nodeid="10315"><code data-backticks="1" data-nodeid="10488">from</code>方法，和<code data-backticks="1" data-nodeid="10490">of</code>方法一样，<code data-backticks="1" data-nodeid="10492">from</code>方法也能生成包含多个事件的 Observable 序列，但它只接受数组为入口参数。</p>\n</li>\n</ul>\n<p data-nodeid="10316">以下是相关代码示例。</p>\n<pre class="lang-swift" data-nodeid="10317"><code data-language="swift"><span class="hljs-keyword">let</span> observable1: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Observable</span>.just(<span class="hljs-number">1</span>) <span class="hljs-comment">// 序列包含 1</span>\n<span class="hljs-keyword">let</span> observable2: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 序列包含&nbsp;1, 2, 3 </span>\n<span class="hljs-keyword">let</span> observable3: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Observable</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// 序列包含&nbsp;1, 2, 3</span>\n<span class="hljs-keyword">let</span> observable4: <span class="hljs-type">Observable</span>&lt;[<span class="hljs-type">Int</span>]&gt; = <span class="hljs-type">Observable</span>.of([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">//&nbsp;序列包含&nbsp;[1, 2, 3]</span>\n</code></pre>\n<p data-nodeid="10318">当你需要生成只有一个事件的 Observable 序列时，可以使用<code data-backticks="1" data-nodeid="10496">just</code>方法，如<code data-backticks="1" data-nodeid="10498">observable1</code>只包含了<code data-backticks="1" data-nodeid="10500">1</code>。</p>\n<p data-nodeid="10319">当需要生成包含多个事件的 Observable 序列时，可以使用<code data-backticks="1" data-nodeid="10503">of</code>或者<code data-backticks="1" data-nodeid="10505">from</code>方法。它们的区别是，<code data-backticks="1" data-nodeid="10507">of</code>接收多个参数而<code data-backticks="1" data-nodeid="10509">from</code>只接收一个数组。如上所示，我们分别使用了<code data-backticks="1" data-nodeid="10511">of</code>和<code data-backticks="1" data-nodeid="10513">from</code>方法来生成<code data-backticks="1" data-nodeid="10515">observable2</code>和<code data-backticks="1" data-nodeid="10517">observable3</code>，它们都包含了 1、2 和 3 三个事件。</p>\n<p data-nodeid="10320">这里需要注意，<code data-backticks="1" data-nodeid="10520">of</code>方法也能接收数组作为参数的。与<code data-backticks="1" data-nodeid="10522">from</code>方法会拆分数组为独立元素的做法不同，<code data-backticks="1" data-nodeid="10524">of</code>方法只是把这个数组当成唯一的事件，例如<code data-backticks="1" data-nodeid="10526">observable4</code>只包含值为<code data-backticks="1" data-nodeid="10528">[1, 2, 3]</code>的一个事件。</p>\n<p data-nodeid="10321">在开发当中，Observable 序列不仅仅存放数值，比如 Moments App 的异步数据流就需要存放朋友圈信息来更新 UI，<code data-backticks="1" data-nodeid="10531">Observable</code>也支持存放任意类型的数据。像在下面的例子中，<code data-backticks="1" data-nodeid="10533">peopleObservable</code>就存放了两条类型为<code data-backticks="1" data-nodeid="10535">Person</code>的数据，其中 Jake 的收入是 10 而 Ken 的收入是 20。</p>\n<pre class="lang-swift" data-nodeid="10322"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> </span>{\n    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> income: <span class="hljs-type">Int</span>\n}\n<span class="hljs-keyword">let</span> peopleObservable = <span class="hljs-type">Observable</span>.of(<span class="hljs-type">Person</span>(name: <span class="hljs-string">"Jake"</span>, income: <span class="hljs-number">10</span>), <span class="hljs-type">Person</span>(name: <span class="hljs-string">"Ken"</span>, income: <span class="hljs-number">20</span>))\n</code></pre>\n<h3 data-nodeid="10323">订阅者</h3>\n<p data-nodeid="10324">在响应式编程模式里，订阅者是一个重要的角色。在 Moments App 里面，上层模块都担任订阅者角色，主要订阅下层模块的 Observable 序列。那订阅者怎样才能订阅和接收数据呢？</p>\n<p data-nodeid="10325">在 RxSwift 中，订阅者可以调用<code data-backticks="1" data-nodeid="10540">Observable</code>对象的<code data-backticks="1" data-nodeid="10542">subscribe</code>方法来订阅。如下所示。</p>\n<pre class="lang-swift" data-nodeid="10326"><code data-language="swift"><span class="hljs-keyword">let</span> observable = <span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)\nobservable.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(event)\n}\n</code></pre>\n<p data-nodeid="10327">订阅者调用<code data-backticks="1" data-nodeid="10545">subscribe</code>方法订阅<code data-backticks="1" data-nodeid="10547">observable</code>，并接收事件，当程序执行时会打印以下信息：</p>\n<pre class="lang-java" data-nodeid="10328"><code data-language="java">next(<span class="hljs-number">1</span>)\nnext(<span class="hljs-number">2</span>)\nnext(<span class="hljs-number">3</span>)\ncompleted\n</code></pre>\n<p data-nodeid="10329">你可能会问上面的<code data-backticks="1" data-nodeid="10550">next</code>和<code data-backticks="1" data-nodeid="10552">completed</code>是什么呢？其实它们都是事件，用来表示异步数据流上的一条信息。RxSwift 使用了<code data-backticks="1" data-nodeid="10554">Event</code>枚举来表示事件，定义如下。</p>\n<pre class="lang-swift" data-nodeid="10330"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Event</span>&lt;<span class="hljs-title">Element</span>&gt; </span>{\n    <span class="hljs-comment">/// Next element is produced.</span>\n    <span class="hljs-keyword">case</span> next(<span class="hljs-type">Element</span>)\n    <span class="hljs-comment">/// Sequence terminated with an error.</span>\n    <span class="hljs-keyword">case</span> error(<span class="hljs-type">Swift</span>.<span class="hljs-type">Error</span>)\n    <span class="hljs-comment">/// Sequence completed successfully.</span>\n    <span class="hljs-keyword">case</span> completed\n}\n</code></pre>\n<ul data-nodeid="10331">\n<li data-nodeid="10332">\n<p data-nodeid="10333"><code data-backticks="1" data-nodeid="10556">.next(value: T)</code>：用于装载数据的事件。当 Observable 序列发送数据时，订阅者会收到<code data-backticks="1" data-nodeid="10558">next</code>事件，我们可以从该事件中取出实际的数据。</p>\n</li>\n<li data-nodeid="10334">\n<p data-nodeid="10335"><code data-backticks="1" data-nodeid="10560">.error(error: Error)</code>：用于装载错误事件。当发生错误的时候，Observable 序列会发出<code data-backticks="1" data-nodeid="10562">error</code>事件并关闭该序列，订阅者一旦收到<code data-backticks="1" data-nodeid="10564">error</code>事件后就无法接收其他事件了。</p>\n</li>\n<li data-nodeid="10336">\n<p data-nodeid="10337"><code data-backticks="1" data-nodeid="10566">.completed</code>：用于正常关闭序列的事件。当 Observable 序列发出<code data-backticks="1" data-nodeid="10568">completed</code>事件时就会关闭自己，订阅者在收到<code data-backticks="1" data-nodeid="10570">completed</code>事件以后就无法收到任何其他事件了。</p>\n</li>\n</ul>\n<p data-nodeid="10338">怎么理解呢？下面我通过两个例子来介绍下。由于之前讲过的<code data-backticks="1" data-nodeid="10573">of</code>和<code data-backticks="1" data-nodeid="10575">from</code>等方法都不能发出<code data-backticks="1" data-nodeid="10577">error</code>和<code data-backticks="1" data-nodeid="10579">completed</code>事件 ，在这里我就使用了<code data-backticks="1" data-nodeid="10581">create</code>方法来创建 Observable 序列。</p>\n<p data-nodeid="10339">首先我们看一下发送<code data-backticks="1" data-nodeid="10584">error</code>事件的例子。</p>\n<pre class="lang-swift" data-nodeid="10340"><code data-language="swift"><span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Int</span>&gt;.create { observer <span class="hljs-keyword">in</span>\n    observer.onNext(<span class="hljs-number">1</span>)\n    observer.onNext(<span class="hljs-number">2</span>)\n    observer.onError(<span class="hljs-type">MyError</span>.anError)\n    observer.onNext(<span class="hljs-number">3</span>)\n    <span class="hljs-keyword">return</span> <span class="hljs-type">Disposables</span>.create()\n}.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(event)\n}\n</code></pre>\n<p data-nodeid="10341">在这个例子中，我们调用了<code data-backticks="1" data-nodeid="10587">create</code>方法来生成一个 Observable 序列，该 Observable 发出<code data-backticks="1" data-nodeid="10589">next(1)</code>、<code data-backticks="1" data-nodeid="10591">next(2)</code>、<code data-backticks="1" data-nodeid="10593">error</code>和<code data-backticks="1" data-nodeid="10595">next(3)</code>事件。由于<code data-backticks="1" data-nodeid="10597">next(3)</code>事件在错误事件之后，因此订阅者无法接收到<code data-backticks="1" data-nodeid="10599">next(3)</code>事件。程序执行时会打印下面的日志。</p>\n<pre class="lang-java" data-nodeid="10342"><code data-language="java">next(<span class="hljs-number">1</span>)\nnext(<span class="hljs-number">2</span>)\nerror(anError)\n</code></pre>\n<p data-nodeid="10343">接着我们看一下发送<code data-backticks="1" data-nodeid="10602">completed</code>事件的例子。</p>\n<pre class="lang-swift" data-nodeid="10344"><code data-language="swift"><span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Int</span>&gt;.create { observer <span class="hljs-keyword">in</span>\n    observer.onNext(<span class="hljs-number">1</span>)\n    observer.onCompleted()\n    observer.onNext(<span class="hljs-number">2</span>)\n    observer.onNext(<span class="hljs-number">3</span>)\n    <span class="hljs-keyword">return</span> <span class="hljs-type">Disposables</span>.create()\n}.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(event)\n}\n</code></pre>\n<p data-nodeid="10345">在这里，我调用<code data-backticks="1" data-nodeid="10605">create</code>方法来生成一个 Observable 序列，该 Observable 发出了<code data-backticks="1" data-nodeid="10607">next(1)</code>、<code data-backticks="1" data-nodeid="10609">completed</code>、<code data-backticks="1" data-nodeid="10611">next(2)</code>和<code data-backticks="1" data-nodeid="10613">next(3)</code>事件。因为<code data-backticks="1" data-nodeid="10615">next(2)</code>和<code data-backticks="1" data-nodeid="10617">next(3)</code>都在完成事件之后发出的，所以订阅者也无法接收它们，程序执行时会打印如下的日志。</p>\n<pre class="lang-java" data-nodeid="10346"><code data-language="java">next(<span class="hljs-number">1</span>)\ncompleted\n</code></pre>\n<p data-nodeid="10347">在现实生活中，当我们订阅了报刊时可以自己选择退订，却无法让发行方停刊。在 RxSwift 里面也一样，订阅者无法强行让 Observable 序列发出<code data-backticks="1" data-nodeid="10620">completed</code>事件来关闭数据流。那订阅者该怎样取消订阅呢？</p>\n<p data-nodeid="10348">如果你仔细观察就会发现，<code data-backticks="1" data-nodeid="10623">subscribe</code>方法返回的类型为<code data-backticks="1" data-nodeid="10625">Disposable</code>的对象，我们可以通过调用该对象的<code data-backticks="1" data-nodeid="10627">dispose</code>方法来取消订阅。</p>\n<p data-nodeid="10349">为了更好地理解<code data-backticks="1" data-nodeid="10630">dispose</code>方法的作用和触发时机，我通过<code data-backticks="1" data-nodeid="10632">subscribe()</code>方法来打印出各个事件，如下所示。</p>\n<pre class="lang-swift" data-nodeid="10350"><code data-language="swift"><span class="hljs-keyword">let</span> disposable = <span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).subscribe { element <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(element) <span class="hljs-comment">// next event</span>\n} onError: { error <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(error)\n} onCompleted: {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Completed"</span>)\n} onDisposed: {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Disposed"</span>)\n}\ndisposable.dispose()\n</code></pre>\n<p data-nodeid="10351">我们在<code data-backticks="1" data-nodeid="10635">onNext</code>闭包里面处理<code data-backticks="1" data-nodeid="10637">next</code>事件；在<code data-backticks="1" data-nodeid="10639">onError</code>闭包里处理<code data-backticks="1" data-nodeid="10641">error</code>事件；在<code data-backticks="1" data-nodeid="10643">onCompleted</code>闭包里处理<code data-backticks="1" data-nodeid="10645">completed</code>事件；而在<code data-backticks="1" data-nodeid="10647">onDisposed</code>闭包里处理退订事件。</p>\n<p data-nodeid="10352">在这里，我们调用<code data-backticks="1" data-nodeid="10650">subscribe</code>方法后，它又马上调用了<code data-backticks="1" data-nodeid="10652">dispose</code>方法，因此程序会在调用<code data-backticks="1" data-nodeid="10654">onCompleted</code>之后立刻调用<code data-backticks="1" data-nodeid="10656">onDisposed</code>。其执行效果如下：</p>\n<pre class="lang-java" data-nodeid="10353"><code data-language="java"><span class="hljs-number">1</span>\n<span class="hljs-number">2</span>\nCompleted\nDisposed\n</code></pre>\n<p data-nodeid="10354">假如我在订阅前调用<code data-backticks="1" data-nodeid="10659">delay</code>方法，那么所有的事件都会延时两秒钟后才通知订阅者，代码如下：</p>\n<pre class="lang-swift" data-nodeid="10355"><code data-language="swift"><span class="hljs-keyword">let</span> disposableWithDelay = <span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).delay(.seconds(<span class="hljs-number">2</span>), scheduler: <span class="hljs-type">MainScheduler</span>.instance).subscribe { element <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(element) <span class="hljs-comment">// next event</span>\n} onError: { error <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(error)\n} onCompleted: {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Completed"</span>)\n} onDisposed: {\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Disposed"</span>)\n}\ndisposableWithDelay.dispose()\n</code></pre>\n<p data-nodeid="10356">和上面没有延时的例子一样，我们在调用<code data-backticks="1" data-nodeid="10662">subscribe</code>方法以后马上调用了<code data-backticks="1" data-nodeid="10664">dispose</code>方法，由于 Observable 序列上所有事件还在延时等待中，程序会直接调用<code data-backticks="1" data-nodeid="10666">onDisposed</code>并退订了<code data-backticks="1" data-nodeid="10668">disposableWithDelay</code>序列，因此没办法再收到两秒钟后所发出的<code data-backticks="1" data-nodeid="10670">next(1)</code>、<code data-backticks="1" data-nodeid="10672">next(2)</code>和<code data-backticks="1" data-nodeid="10674">completed</code>事件了。 其执行效果如下：</p>\n<pre class="lang-java" data-nodeid="10357"><code data-language="java">Disposed\n</code></pre>\n<p data-nodeid="10358">在很多时候，订阅后马上退订并不是我们想要的结果，我们希望订阅者一直监听事件直到自身消亡的时候才取消订阅。那有什么好的办法能做到这一点呢？</p>\n<p data-nodeid="10359">RxSwift 为我们提供了<code data-backticks="1" data-nodeid="10678">DisposeBag</code>类型，方便存放和管理各个<code data-backticks="1" data-nodeid="10680">Disposable</code>对象。其用法也非常简单，只需调用<code data-backticks="1" data-nodeid="10682">Disposable</code>的<code data-backticks="1" data-nodeid="10684">disposed(by:)</code>方法即可。代码如下：</p>\n<pre class="lang-swift" data-nodeid="10360"><code data-language="swift"><span class="hljs-keyword">let</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()\n<span class="hljs-type">Observable</span>.just(<span class="hljs-number">1</span>).subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(event)\n}.disposed(by: disposeBag)\n<span class="hljs-type">Observable</span>.of(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>).subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(event)\n}.disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="10361">代码中的<code data-backticks="1" data-nodeid="10687">disposeBag</code>存放了两个<code data-backticks="1" data-nodeid="10689">Disposable</code>对象。当订阅者调用其<code data-backticks="1" data-nodeid="10691">deinit</code>方法时，同时也会调用<code data-backticks="1" data-nodeid="10693">disposeBag</code>的<code data-backticks="1" data-nodeid="10695">deinit</code>方法。在这时候，<code data-backticks="1" data-nodeid="10697">disposeBag</code>会取出存放的所有<code data-backticks="1" data-nodeid="10699">Disposable</code>对象，并调用它们的<code data-backticks="1" data-nodeid="10701">dispose</code>方法来取消所有订阅。</p>\n<p data-nodeid="10362">在实际情况下，我建议只需为一个订阅者定义一个<code data-backticks="1" data-nodeid="10704">disposeBag</code>即可。例如 Repository 模块同时订阅了 Networking 模块和 DataStore 模块，但它只定义了一个<code data-backticks="1" data-nodeid="10706">disposeBag</code>来管理所有的订阅。</p>\n<h4 data-nodeid="10363">事件中转 Subject</h4>\n<p data-nodeid="10364">以上是如何生成、订阅和退订 Observable 序列。使用<code data-backticks="1" data-nodeid="10710">Observable</code>的工厂方法所生成的对象都是“只读”，一旦生成，就无法添加新的事件。但很多时候，我们需要往 Observable 序列增加事件，比如要把用户点击 UI 的事件添加到 Observable 中，或者把底层模块的事件加工并添加到上层模块的序列中。</p>\n<p data-nodeid="10365">那么，有什么好办法能为异步数据序列添加新的事件呢？RxSwift 为我们提供的 Subject 及其<code data-backticks="1" data-nodeid="10713">onNext</code>方法可以完成这项操作。</p>\n<p data-nodeid="10366">具体来说，<strong data-nodeid="10720">Subject</strong>作为一种特殊的 Observable 序列，它既能接收又能发送，我们一般用它来做事件的中转。在 Moments App 的 MVVM 架构里面，我们就大量使用 Subject 发挥这一作用。 比如，当 Repository 模块从 Networking 模块中接收到事件时，会把该事件转送到自身的 Subject 来通知 ViewModel，从而保证 ViewModel 的状态同步。</p>\n<p data-nodeid="10367">那么，都有哪些常见的 Subject 呢？一般有 PublishSubject、BehaviorSubject 和 ReplaySubject。它们的区别在于订阅者能否收到订阅前的事件。</p>\n<ul data-nodeid="10368">\n<li data-nodeid="10369">\n<p data-nodeid="10370"><strong data-nodeid="10726">PublishSubject</strong>：如果你想订阅者只收到订阅后的事件，可以使用 PublishSubject。</p>\n</li>\n<li data-nodeid="10371">\n<p data-nodeid="10372"><strong data-nodeid="10731">BehaviorSubject</strong>：如果你想订阅者在订阅时能收到订阅前最后一条事件，可以使用 BehaviorSubject。</p>\n</li>\n<li data-nodeid="10373">\n<p data-nodeid="10374"><strong data-nodeid="10744">ReplaySubject</strong>：如果你想订阅者在订阅<del data-nodeid="10745">的</del>时<del data-nodeid="10746">候</del>能收到订阅前的 N 条事件，那么可以使用 ReplaySubject。</p>\n</li>\n</ul>\n<p data-nodeid="10375">在订阅以后，它们的行为都是一致的，当 Subject 发出<code data-backticks="1" data-nodeid="10748">error</code>或者<code data-backticks="1" data-nodeid="10750">completed</code>事件以后，订阅者将无法接收到新的事件。与之相关的详细的内容，我会在第 19 讲数据层架构里展开介绍。</p>\n<h3 data-nodeid="10376">操作符</h3>\n<p data-nodeid="10377">操作符（Operator）是 RxSwift 另外一个重要的概念，它能帮助订阅者在接收事件之前把 Observable 序列中的事件进行过滤、转换或者合并。</p>\n<p data-nodeid="15114" class="te-preview-highlight">例如在 Moments App 里面，我们使用 map 操作符把 Model 数据转换成 ViewModel 类型来更新 UI。这里的 map 操作符就属于<strong data-nodeid="15120">转换操作符</strong>，能帮助我们从一种数据类型转变成另外一种类型。除了map ，compactMap 和 flapMap 也属于转换操作符。</p>\n\n\n\n\n\n\n<p data-nodeid="10379">此外还有 filter 和 distinctUntilChanged等<strong data-nodeid="10771">过滤操作符，<strong data-nodeid="10770">我们可以使用过滤操作符把订阅者不关心的事件给过滤掉。还有</strong>合并操作符</strong>如 startWith，concat，merge，combineLatest 和 zip，可用于组装与合并多个 Observable 序列。</p>\n<p data-nodeid="10380">除了上面提到过的常用操作符，RxSwift 还为我们提供了 50 多个操作符，那怎样才能学会它们呢？我推荐你到 rxmarbles.com 或者到 App Store 下载 RxMarbles App，然后打开各个操作符并修改里面的参数，通过输入的事件和执行的结果来理解这些操作的作用。在之后的第 20 讲，我也会详细介绍一些常用的操作符的用法，到时候可以留意哦。</p>\n<h3 data-nodeid="10381">排程器</h3>\n<p data-nodeid="10382">保持程序状态自动更新之所以困难，很大原因在于处理并发的异步事件是一件烦琐的事情。为了方便处理来自不同线程的并发异步事件，RxSwift 为我们提供了排程器。它可以帮我们把繁重的任务调度到后台排程器完成，并能指定其运行方式（如是串行还是并发），也能保证 UI 的任务都在主线程上执行。</p>\n<p data-nodeid="10383">比如在 Moments App 里面，Networking 和 DataStore 模块都在后台排程器上执行，而 View 模块都在主排程器上执行。</p>\n<p data-nodeid="10384">根据串行或者并发来归类，我们可以把排程器分成两大类<strong data-nodeid="10781">串行的排程器和并发的排程器</strong>。</p>\n<p data-nodeid="10385">串行的排程器包括 CurrentThreadScheduler、MainScheduler、SerialDispatchQueueScheduler。</p>\n<p data-nodeid="10386">其中，<strong data-nodeid="10800">CurrentThreadScheduler</strong>可以把任务安排在当前的线程上执行，这是默认的排程器。当我们不指定排程器的时候，RxSwift 都会使用 CurrentThreadScheduler 把任务放在当前线程里串行执行；<strong data-nodeid="10801">MainScheduler</strong>是把任务调度到主线程<code data-backticks="1" data-nodeid="10792">MainThread</code>里并马上执行，它主要用于执行 UI 相关的任务；而<strong data-nodeid="10802">SerialDispatchQueueScheduler</strong>则会把任务放在<code data-backticks="1" data-nodeid="10798">dispatch_queue_t</code>里面并串行执行。</p>\n<p data-nodeid="10387">并发的排程器包括 ConcurrentDispatchQueueScheduler 和 OperationQueueScheduler。</p>\n<p data-nodeid="10388">其中，<strong data-nodeid="10815">ConcurrentDispatchQueueScheduler</strong>把任务安排到<code data-backticks="1" data-nodeid="10809">dispatch_queue_t</code>里面，且以并发的方式执行。该排程器一般用于执行后台任务，例如网络访问和数据缓存等等。在创建的时候，我们可以指定<code data-backticks="1" data-nodeid="10811">DispatchQueue</code>的类型，例如使用<code data-backticks="1" data-nodeid="10813">ConcurrentDispatchQueueScheduler(qos: .background)</code>来指定使用后台线程执行任务。</p>\n<p data-nodeid="10389"><strong data-nodeid="10824">OperationQueueScheduler</strong>是把任务放在<code data-backticks="1" data-nodeid="10820">NSOperationQueue</code>里面，以并发的方式执行。这个排程器一般用于执行繁重的后台任务，并通过设置<code data-backticks="1" data-nodeid="10822">maxConcurrentOperationCount</code>来控制所执行并发任务的最大数量。它可以用于下载大文件。</p>\n<p data-nodeid="10390">那么，如何用排程器进行调度，处理好不同线程的并发异步事件呢？请看下面的代码实现。</p>\n<pre class="lang-swift" data-nodeid="10391"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)\n    .subscribeOn(<span class="hljs-type">ConcurrentDispatchQueueScheduler</span>(qos: .background))\n    .dumpObservable()\n    .<span class="hljs-built_in">map</span> { <span class="hljs-string">"\\(getThreadName()): \\($0)"</span> }\n    .observeOn(<span class="hljs-type">MainScheduler</span>.instance)\n    .dumpObserver()\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="10392">首先我们传入<code data-backticks="1" data-nodeid="10827">ConcurrentDispatchQueueScheduler(qos: .background)</code>来调用<code data-backticks="1" data-nodeid="10829">subscribeOn</code>方法，把 Observable 序列发出事件的执行代码都调度到后台排程器去执行。然后通过传入<code data-backticks="1" data-nodeid="10831">MainScheduler.instance</code>来调用<code data-backticks="1" data-nodeid="10833">observeOn</code>，把订阅者执行的逻辑都调度主排程器去执行。</p>\n<p data-nodeid="10393">这是一种常用的模式，我们通常使用后台排程器来进行网络访问并处理返回数据，然后通过主排程器把数据呈现到 UI 中去。</p>\n<p data-nodeid="10394">由于后台线程不能保证执行的顺序，其执行效果如下，当你执行的时候可能会有点变化。</p>\n<pre class="lang-java" data-nodeid="10395"><code data-language="java">[Observable] <span class="hljs-number">1</span> emitted on Unnamed Thread\n[Observable] <span class="hljs-number">2</span> emitted on Unnamed Thread\n[Observer] Unnamed Thread: <span class="hljs-number">1</span> received on Main Thread\n[Observable] <span class="hljs-number">3</span> emitted on Unnamed Thread\n[Observer] Unnamed Thread: <span class="hljs-number">2</span> received on Main Thread\n[Observable] <span class="hljs-number">4</span> emitted on Unnamed Thread\n[Observer] Unnamed Thread: <span class="hljs-number">3</span> received on Main Thread\n[Observer] Unnamed Thread: <span class="hljs-number">4</span> received on Main Thread\n</code></pre>\n<h3 data-nodeid="10396">总结</h3>\n<p data-nodeid="10397">在这一讲中我们介绍了 RxSwift 的五个关键概念：Observable 序列、订阅者、Subject、操作符以及排程器。我把本讲的代码都放在 Moments App 项目中的<strong data-nodeid="10843">RxSwift Playground 文件</strong>里面，希望你能多练习，把五个概念融会贯通。</p>\n<p data-nodeid="10398">以下是我在实际工作中使用 RxSwift 的一些经验总结，希望能帮助到你。</p>\n<ol data-nodeid="10399">\n<li data-nodeid="10400">\n<p data-nodeid="10401">当我们拿到需求的时候，先把任务进行分解，找出哪个部分是事件<strong data-nodeid="10854">发布者</strong>，哪部分是事件<strong data-nodeid="10855">订阅者</strong>，例如一个新功能页面，网络请求部分一般是事件发布者，当得到网络请求的返回结果时会发出事件，而 UI 部分一般为事件订阅者，通过订阅事件来保持 UI 的自动更新。</p>\n</li>\n<li data-nodeid="10402">\n<p data-nodeid="10403">找到事件发布者以后，要分析事件发布的频率与间隔。如果只是发布一次，可以使用<strong data-nodeid="10865">Obervable</strong>；如果需要多次发布，可以使用<strong data-nodeid="10866">Subject</strong>；如果需要缓存之前多个事件，可以使用 ReplaySubject。</p>\n</li>\n<li data-nodeid="10404">\n<p data-nodeid="10405">当我们有了事件发布者和订阅者以后，接着可以分析发送和订阅事件的类型差异，选择合适的<strong data-nodeid="10872">操作符</strong>来进行转换。我们可以先使用本讲中提到的常用操作符，如果它们还不能解决你的问题，可以查看 RxMarbles 来寻找合适的操作符。</p>\n</li>\n<li data-nodeid="10406">\n<p data-nodeid="10407">最后，我们可以根据事件发布者和订阅者所执行的任务性质，通过<strong data-nodeid="10878">排程器</strong>进行调度。例如把网络请求和数据缓存任务都安排在后台排程器，而 UI 更新任务放在主排程器。</p>\n</li>\n</ol>\n<p data-nodeid="10408">我在后面几讲中会详细介绍如何把 RxSwift 应用到在 MVVM 架构来保证程序状态信息的自动更新。希望能帮助你把今天所学知识灵活应用到真实场景中。</p>\n<p data-nodeid="10409"><strong data-nodeid="10883">思考题</strong></p>\n<blockquote data-nodeid="10410">\n<p data-nodeid="10411">据我所知，很多 iOS 开发者都想学习响应式编程和 RxSwift，但也不少人最终放弃了，如何你也曾经学习过并放弃了，请分享一下你的经验，哪一部分使你放弃学习和使用 RxSwift 呢？</p>\n</blockquote>\n<p data-nodeid="10412">可以把你的想法写得留言区哦，下一讲我将介绍如何设计网络访问与 JSON 数据解析。</p>\n<p data-nodeid="10413"><strong data-nodeid="10889">源码地址：</strong></p>\n<blockquote data-nodeid="10414">\n<p data-nodeid="10415" class="">RxSwift Playground 文件地址：https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift</p>\n</blockquote>',
          },
          {
            theme: '18 | 网络层架构：如何设计网络访问与 JSON 数据解析？',
            id: 33,
            content:
              '<p data-nodeid="1618" class="">为了存取服务器上的数据，并与其他用户进行通信，几乎所有的 iOS App 都会访问后台 API 。目前流行的后台 API 设计有几种方案： RESTful、gRPC、GraphQL 和 WebSocket。其中，gRPC 使用 Protobuf 进行数据传输， GraphQL 和 RESTful 往往使用 JSON 进行传输。</p>\n<p data-nodeid="1619">为了把访问后台 API 的网络传输细节给屏蔽掉，并为上层模块提供统一的访问接口，我们在架构 App 的时候，往往会把网络访问封装成一个独立的 Networking 模块。像我们的 Moments App 也不例外，它的这个模块负责访问 BFF，同时把返回的 JSON 数据进行解码。所以，这一讲，我主要介绍下 Networking 模块的架构设计与实现，以及如何使用 Swift 的 Codable 来解码返回的 JSON 数据。</p>\n<h3 data-nodeid="1620">Networking 模块架构</h3>\n<p data-nodeid="3227">下图是朋友圈功能 Networking 模块的具体架构。</p>\n<p data-nodeid="3228" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3A/82/Cgp9HWB_3o2AYfKOAAONWHcpJpI148.png" alt="图片2.png" data-nodeid="3232"></p>\n\n\n<p data-nodeid="1623" class="">从上面的图可以看到，作为 Networking 模块的使用者，Repository 模块位于 Networking 模块的上层。在朋友圈功能里面， Repository 模块负责统一管理所有朋友圈的数据，由<code data-backticks="1" data-nodeid="1720">MomentsRepo</code>和<code data-backticks="1" data-nodeid="1722">MomentsRepoType</code>所组成。</p>\n<p data-nodeid="1624" class="">其中<code data-backticks="1" data-nodeid="1725">MomentsRepoType</code>是用于定义接口的协议，实现的逻辑都在遵循了该协议的<code data-backticks="1" data-nodeid="1727">MomentsRepo</code>结构体里面。 当<code data-backticks="1" data-nodeid="1729">MomentsRepo</code>需要访问网络数据时，就需要使用到 Networking 模块的组件。</p>\n<p data-nodeid="1625">在朋友圈功能里面，<code data-backticks="1" data-nodeid="1732">MomentsRepo</code>使用了<code data-backticks="1" data-nodeid="1734">GetMomentsByUserIDSessionType</code>来获取朋友圈信息，并使用了<code data-backticks="1" data-nodeid="1736">UpdateMomentLikeSessionType</code>来更新点赞信息。</p>\n<p data-nodeid="1626"><code data-backticks="1" data-nodeid="1738">GetMomentsByUserIDSessionType</code>和<code data-backticks="1" data-nodeid="1740">UpdateMomentLikeSessionType</code>是 Networking 模块里的两个协议， 它们的实现类型分别是<code data-backticks="1" data-nodeid="1742">GetMomentsByUserIDSession</code>和<code data-backticks="1" data-nodeid="1744">UpdateMomentLikeSession</code>结构体。其中，<code data-backticks="1" data-nodeid="1746">GetMomentsByUserIDSession</code>通过访问 BFF 来读取朋友圈信息，而<code data-backticks="1" data-nodeid="1748">UpdateMomentLikeSession</code>通过 BFF 来更新点赞信息。当 BFF 返回时，它们都会使用<code data-backticks="1" data-nodeid="1750">JSONDecoder</code>来把返回的 JSON 数据解码成名为<code data-backticks="1" data-nodeid="1752">MomentsDetails</code>的 Model 数据。</p>\n<p data-nodeid="1627">那为什么<code data-backticks="1" data-nodeid="1755">MomentsRepo</code>依赖<code data-backticks="1" data-nodeid="1757">GetMomentsByUserIDSessionType</code>协议而不是<code data-backticks="1" data-nodeid="1759">GetMomentsByUserIDSession</code>结构体？因为这样能使<code data-backticks="1" data-nodeid="1761">MomentsRepo</code>依赖于抽象的接口，而不是具体实现，在 Swift 中，这种模式叫作面对协议编程（Protocol Oriented Programming）。使用了这种模式以后，我们可以很灵活地替换具体的实现类型，提高架构的可扩展性和灵活性。</p>\n<p data-nodeid="5381">目前，我们把访问 GraphQL 的技术细节封装在<code data-backticks="1" data-nodeid="5384">GetMomentsByUserIDSession</code>里面。假如以后需要把后台改成 gRPC API，在 Moments App 中可以实现另一个结构体来遵循<code data-backticks="1" data-nodeid="5386">GetMomentsByUserIDSessionType</code>协议，比如命名为<code data-backticks="1" data-nodeid="5388">GetMomentsByUserIDSessionGRPC</code>，然后把所有访问的 gRPC 的操作都封装在里面（如下图所示），这样我们在不改变<code data-backticks="1" data-nodeid="5390">MomentsRepo</code>的情况下就支持了新的网络 API。</p>\n<p data-nodeid="5382" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3A/82/Cgp9HWB_3pmAR0JMAAGYfVaC1qI931.png" alt="图片1.png" data-nodeid="5394"></p>\n\n\n<h3 data-nodeid="1630">Networking 模块实现</h3>\n<p data-nodeid="1631">有了架构设计以后我们一起看看 Networking 模块的实现。首先，我会先介绍下底层 HTTP 网络通信模块，然后以 Moments App 朋友圈信息的网络请求为例，为你介绍下怎样开发一个网络请求模块，以及解码 JSON 返回数据。</p>\n<h4 data-nodeid="1632">底层 HTTP 网络通信模块</h4>\n<p data-nodeid="1633">为了方便访问支持 RESTFul 和 GraphQL 的 API， 在 Moments App 中，我们开发了一个底层 HTTP 网络通信模块，该模块把所有 HTTP 请求封装起来，核心是<code data-backticks="1" data-nodeid="1779">APISession</code>协议。下面是它的定义。</p>\n<pre class="lang-swift" data-nodeid="1634"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">APISession</span> </span>{\n   <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">ReponseType</span>: <span class="hljs-type">Codable</span>\n   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-number">_</span> path: String, parameters: Parameters?, headers: HTTPHeaders)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">ReponseType</span>&gt;\n}\n</code></pre>\n<p data-nodeid="1635"><code data-backticks="1" data-nodeid="1781">APISession</code>定义了<code data-backticks="1" data-nodeid="1783">post(_ path: String, parameters: Parameters?, headers: HTTPHeaders) -&gt; Observable&lt;ReponseType&gt;</code>方法来发起 HTTP POST 请求，然后返回<code data-backticks="1" data-nodeid="1785">Observable&lt;ReponseType&gt;</code>。有了 Observable 序列，我们就能把网络返回数据引进到以 RxSwift 所连接的 MVVM 框架中。</p>\n<p data-nodeid="1636">你可能问，为什么<code data-backticks="1" data-nodeid="1788">Observable</code>存放的是<code data-backticks="1" data-nodeid="1790">ReponseType</code>类型呢？由于<code data-backticks="1" data-nodeid="1792">APISession</code>并不知道每一个网络请求返回数据的具体类型，因此使用<code data-backticks="1" data-nodeid="1794">associatedtype</code>来定义<code data-backticks="1" data-nodeid="1796">ReponseType</code>，以迫使所有遵循它的实现类型都必须指定<code data-backticks="1" data-nodeid="1798">ReponseType</code>的具体数据类型。</p>\n<p data-nodeid="1637">例如在<code data-backticks="1" data-nodeid="1801">GetMomentsByUserIDSession</code>里面的<code data-backticks="1" data-nodeid="1803">Session</code>结构体，我们使用<code data-backticks="1" data-nodeid="1805">typealias</code>来指定<code data-backticks="1" data-nodeid="1807">ReponseType</code>的具体类型为<code data-backticks="1" data-nodeid="1809">Response</code>，其代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1638"><code data-language="swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">ReponseType</span> = <span class="hljs-type">Response</span>\n</code></pre>\n<p data-nodeid="1639">为了方便共享 HTTP 网络请求的功能，我们为<code data-backticks="1" data-nodeid="1812">APISession</code>定义了协议扩展，并给<code data-backticks="1" data-nodeid="1814">post(_ path: String, parameters: Parameters?, headers: HTTPHeaders) -&gt; Observable&lt;ReponseType&gt;</code>方法提供默认的实现。具体代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1640"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">APISession</span> </span>{\n   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-number">_</span> path: String, headers: HTTPHeaders = [:], parameters: Parameters? = <span class="hljs-literal">nil</span>)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">ReponseType</span>&gt; {\n       <span class="hljs-keyword">return</span> request(path, method: .post, headers: headers, parameters: parameters, encoding: <span class="hljs-type">JSONEncoding</span>.<span class="hljs-keyword">default</span>)\n   }\n}\n</code></pre>\n<p data-nodeid="1641">为了提高代码的可重用性，我们定义了名叫<code data-backticks="1" data-nodeid="1817">request(_ path: String, method: HTTPMethod, headers: HTTPHeaders, parameters: Parameters?, encoding: ParameterEncoding) -&gt; Observable&lt;ReponseType&gt;</code>的私有方法，来支持 HTTP 的其他 Method，代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1642"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-number">_</span> path: String, method: HTTPMethod, headers: HTTPHeaders, parameters: Parameters?, encoding: ParameterEncoding)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">ReponseType</span>&gt; {\n       <span class="hljs-keyword">let</span> url = baseUrl.appendingPathComponent(path)\n       <span class="hljs-keyword">let</span> allHeaders = <span class="hljs-type">HTTPHeaders</span>(defaultHeaders.dictionary.merging(headers.dictionary) { $<span class="hljs-number">1</span> })\n       <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.create { observer -&gt; <span class="hljs-type">Disposable</span> <span class="hljs-keyword">in</span>\n           <span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"moments.app.api"</span>, qos: .background, attributes: .concurrent)\n           <span class="hljs-keyword">let</span> request = <span class="hljs-type">AF</span>.request(url, method: method, parameters: parameters, encoding: encoding, headers: allHeaders, interceptor: <span class="hljs-literal">nil</span>, requestModifier: <span class="hljs-literal">nil</span>)\n               .validate()\n               .responseJSON(queue: queue) { response <span class="hljs-keyword">in</span>\n                   <span class="hljs-comment">// 处理返回的 JSON 数据</span>\n               }\n           <span class="hljs-keyword">return</span> <span class="hljs-type">Disposables</span>.create {\n               request.cancel()\n           }\n       }\n   }\n</code></pre>\n<p data-nodeid="1643">有了<code data-backticks="1" data-nodeid="1820">request()</code>方法，我们就可以支持不同的 HTTP Method 了。如果需要支持 HTTP GET 请求的时候，只需把<code data-backticks="1" data-nodeid="1822">HTTPMethod.get</code>传递给该方法就可以了。</p>\n<p data-nodeid="1644"><code data-backticks="1" data-nodeid="1824">request()</code>方法的核心逻辑是怎么样的呢？在该方法里面，我们首先使用<code data-backticks="1" data-nodeid="1826">Observable.create()</code>方法来创建一个 Observable 序列并返回给调用者，然后在<code data-backticks="1" data-nodeid="1828">create()</code>方法的封包里使用 Alamofire 的<code data-backticks="1" data-nodeid="1830">request()</code>方法发起网络请求。为了不阻挡 UI 的响应，我们把该请求安排到后台队列中执行。当我们得到返回的 JSON 以后，会使用下面的代码进行处理。</p>\n<pre class="lang-swift" data-nodeid="1645"><code data-language="swift"><span class="hljs-keyword">switch</span> response.result {\n<span class="hljs-keyword">case</span> .success:\n&nbsp; &nbsp; <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> data = response.data <span class="hljs-keyword">else</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// if no error provided by Alamofire return .noData error instead.</span>\n&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(response.error ?? <span class="hljs-type">APISessionError</span>.noData)\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class="hljs-keyword">do</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">ReponseType</span>.<span class="hljs-keyword">self</span>, from: data)\n&nbsp; &nbsp; &nbsp; &nbsp; observer.onNext(model)\n&nbsp; &nbsp; &nbsp; &nbsp; observer.onCompleted()\n&nbsp; &nbsp; } <span class="hljs-keyword">catch</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(error)\n&nbsp; &nbsp; }\n<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):\n&nbsp; &nbsp; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> statusCode = response.response?.statusCode {\n&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(<span class="hljs-type">APISessionError</span>.networkError(error: error, statusCode: statusCode))\n&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(error)\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="1646">其逻辑是，当网络请求成功了，就把返回的 JSON 数据通过<code data-backticks="1" data-nodeid="1833">JSONDecoder</code>解码成<code data-backticks="1" data-nodeid="1835">ReponseType</code>类型，并通过<code data-backticks="1" data-nodeid="1837">onNext</code>方法发送到 Observable 序列中，接着调用<code data-backticks="1" data-nodeid="1839">onCompleted</code>方法来关闭数据流；如果发生网络错误，就通过<code data-backticks="1" data-nodeid="1841">onError</code>方法来发送错误事件。</p>\n<h4 data-nodeid="1647">请求朋友圈信息模块</h4>\n<p data-nodeid="1648">有了底层 HTTP 网络通信模块以后，我们来看看怎样开发一个网络请求模块。</p>\n<p data-nodeid="1649">在 Moments App 中，为了分离责任和方便管理，我们为每一个网络请求都定义了一个协议以及对应的实现结构体。在我们的例子中，它们分别是<code data-backticks="1" data-nodeid="1846">GetMomentsByUserIDSessionType</code>协议和<code data-backticks="1" data-nodeid="1848">GetMomentsByUserIDSession</code>结构体。</p>\n<p data-nodeid="1650">其中<code data-backticks="1" data-nodeid="1851">GetMomentsByUserIDSessionType</code>协议的定义如下。</p>\n<pre class="lang-swift" data-nodeid="1651"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">GetMomentsByUserIDSessionType</span> </span>{\n   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;\n}\n</code></pre>\n<p data-nodeid="1652">该协议只定义了一个<code data-backticks="1" data-nodeid="1854">getMoments(userID: String) -&gt; Observable&lt;MomentsDetails&gt;</code>方法来提供访问朋友圈信息的接口。因为每个用户的朋友圈信息都不一样，我们需要把用户 ID 传递给该方法，并返回包含了<code data-backticks="1" data-nodeid="1856">MomentsDetails</code>的 Observable 序列。</p>\n<p data-nodeid="1653">接下来看看<code data-backticks="1" data-nodeid="1859">GetMomentsByUserIDSession</code>结构体的实现。因为<code data-backticks="1" data-nodeid="1861">GetMomentsByUserIDSession</code>遵循了<code data-backticks="1" data-nodeid="1863">etMomentsByUserIDSessionType</code>协议，因此必须实现来自该协议的<code data-backticks="1" data-nodeid="1865">getMoments(userID: String) -&gt; Observable&lt;MomentsDetails&gt;</code>方法。具体实现如下所示。</p>\n<pre class="lang-swift" data-nodeid="1654"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; {\n    <span class="hljs-keyword">let</span> session = <span class="hljs-type">Session</span>(userID: userID)\n    <span class="hljs-keyword">return</span> sessionHandler(session).<span class="hljs-built_in">map</span> { \n        $<span class="hljs-number">0</span>.data.getMomentsDetailsByUserID }\n}\n</code></pre>\n<p data-nodeid="1655">该方法通过<code data-backticks="1" data-nodeid="1868">sessionHandler</code>来获取网络请求的结果。其中<code data-backticks="1" data-nodeid="1870">sessionHandler</code>是一个封包，它接收了类型为<code data-backticks="1" data-nodeid="1872">Session</code>的入口参数，我们可以在<code data-backticks="1" data-nodeid="1874">init</code>方法里面看到<code data-backticks="1" data-nodeid="1876">sessionHandler</code>的具体实现，如下所示：</p>\n<pre class="lang-swift" data-nodeid="1656"><code data-language="swift"><span class="hljs-keyword">init</span>(togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span> = <span class="hljs-type">InternalTogglesDataStore</span>.shared, sessionHandler: @escaping (<span class="hljs-type">Session</span>) -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Response</span>&gt; = {\n&nbsp; &nbsp; $<span class="hljs-number">0</span>.post($<span class="hljs-number">0</span>.path, headers: $<span class="hljs-number">0</span>.headers, parameters: $<span class="hljs-number">0</span>.parameters)\n}) {\n&nbsp; &nbsp; <span class="hljs-keyword">self</span>.togglesDataStore = togglesDataStore\n&nbsp; &nbsp; <span class="hljs-keyword">self</span>.sessionHandler = sessionHandler\n}\n</code></pre>\n<p data-nodeid="1657">其中<code data-backticks="1" data-nodeid="1879">$0</code>表示入口参数<code data-backticks="1" data-nodeid="1881">Session</code>的对象， 由于<code data-backticks="1" data-nodeid="1883">Session</code>遵循了<code data-backticks="1" data-nodeid="1885">APISession</code>协议，它可以直接调用<code data-backticks="1" data-nodeid="1887">APISession</code>的扩展方法<code data-backticks="1" data-nodeid="1889">post</code>来发起 HTTP POST 请求，并获取类型为<code data-backticks="1" data-nodeid="1891">Response</code>的返回值。</p>\n<p data-nodeid="1658">那返回值<code data-backticks="1" data-nodeid="1894">Response</code>的类型是怎样定义出来的呢？其实它的定义来自 BFF 返回值 JSON 的数据结构，该 JSON 包含了<code data-backticks="1" data-nodeid="1896">data</code>属性，<code data-backticks="1" data-nodeid="1898">data</code>下有一个<code data-backticks="1" data-nodeid="1900">getMomentsDetailsByUserID</code>属性，具体数据结构如下。</p>\n<pre class="lang-javascript" data-nodeid="1659"><code data-language="javascript">{\n <span class="hljs-string">"data"</span>: {\n   <span class="hljs-string">"getMomentsDetailsByUserID"</span>: {\n     <span class="hljs-comment">// MomentsDetails object</span>\n     <span class="hljs-string">"userDetails"</span>: {...},\n&nbsp; &nbsp; &nbsp; <span class="hljs-string">"moments"</span>: [...]\n   }\n }\n}\n</code></pre>\n<p data-nodeid="1660">我们可以根据 JSON 的数据结构来定义 Swift 的<code data-backticks="1" data-nodeid="1903">Response</code>类型，它也有类型为<code data-backticks="1" data-nodeid="1905">Data</code>的<code data-backticks="1" data-nodeid="1907">data</code>属性。在<code data-backticks="1" data-nodeid="1909">Data</code>类型下还包含了类型为<code data-backticks="1" data-nodeid="1911">MomentsDetails</code>的<code data-backticks="1" data-nodeid="1913">getMomentsDetailsByUserID</code>属性。</p>\n<pre class="lang-swift" data-nodeid="1661"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Response</span>: <span class="hljs-title">Codable</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> data: <span class="hljs-type">Data</span>\n&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span>: <span class="hljs-title">Codable</span> </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> getMomentsDetailsByUserID: <span class="hljs-type">MomentsDetails</span>\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="1662">为了把 Observable 序列的类型从<code data-backticks="1" data-nodeid="1916">Response</code>转换成<code data-backticks="1" data-nodeid="1918">MomentsDetails</code>类型，我们在<code data-backticks="1" data-nodeid="1920">getMoments</code>方法里调用了转换操作符<code data-backticks="1" data-nodeid="1922">map { $0.data.getMomentsDetailsByUserID }</code>从<code data-backticks="1" data-nodeid="1924">Response</code>里抽出<code data-backticks="1" data-nodeid="1926">getMomentsDetailsByUserID</code>进行返回。</p>\n<p data-nodeid="1663">接着我们看看<code data-backticks="1" data-nodeid="1929">Session</code>结构体的具体实现。 该结构体负责准备 GraphQL 请求的数据，这些数据包括 URL 路径、HTTP 头和参数。URL 路径比较简单，是一个值为<code data-backticks="1" data-nodeid="1931">/graphql</code>的常量。HTTP 头也是一个默认的<code data-backticks="1" data-nodeid="1933">HTTPHeaders</code>对象。最重要的数据是类型为<code data-backticks="1" data-nodeid="1935">Parameters</code>的<code data-backticks="1" data-nodeid="1937">parameters</code>属性。我们通过<code data-backticks="1" data-nodeid="1939">init</code>方法来看看该属性是怎样进行初始化的。它的实现代码如下所示。</p>\n<pre class="lang-swift" data-nodeid="1664"><code data-language="swift"><span class="hljs-keyword">init</span>(userID: <span class="hljs-type">String</span>) {\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> variables: [<span class="hljs-type">AnyHashable</span>: <span class="hljs-type">Encodable</span>] = [<span class="hljs-string">"userID"</span>: userID]\n&nbsp; &nbsp; parameters = [<span class="hljs-string">"query"</span>: <span class="hljs-type">Self</span>.query,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-string">"variables"</span>: variables]\n}\n</code></pre>\n<p data-nodeid="1665">首先我们把传递进来的<code data-backticks="1" data-nodeid="1942">userID</code>存放到类型为<code data-backticks="1" data-nodeid="1944">[AnyHashable: Encodable]</code>的<code data-backticks="1" data-nodeid="1946">variables</code>变量里面，然后把它与<code data-backticks="1" data-nodeid="1948">query</code>属性一同赋值给<code data-backticks="1" data-nodeid="1950">parameters</code>。</p>\n<p data-nodeid="1666">那么<code data-backticks="1" data-nodeid="1953">query</code>是怎样来的呢？因为所有的 GraphQL 的请求都需要发送 Query，在朋友圈信息请求的例子也不例外，<code data-backticks="1" data-nodeid="1955">query</code>属性就是用于定义要发送的 Query 的，其定义如下。</p>\n<pre class="lang-swift" data-nodeid="1667"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> query = <span class="hljs-string">"""\n    query getMomentsDetailsByUserID($userID: ID!) {\n      getMomentsDetailsByUserID(userID: $userID) {\n        userDetails {\n          id\n          name\n          avatar\n          backgroundImage\n        }\n        moments {\n          id\n          userDetails {\n            name\n            avatar\n          }\n          type\n          title\n          photos\n          createdDate\n        }\n      }\n    }\n"""</span>\n}\n</code></pre>\n<p data-nodeid="8661">在该 Query 定义中，我们定义了类型为<code data-backticks="1" data-nodeid="8664">ID!</code>的入口参数<code data-backticks="1" data-nodeid="8666">$userID</code>，同时定义了返回值的数据结构，例如返回<code data-backticks="1" data-nodeid="8668">getMomentsDetailsByUserID</code>，在它里面包含<code data-backticks="1" data-nodeid="8670">userDetails</code>和<code data-backticks="1" data-nodeid="8672">moments</code>两个属性。在开发过程中我们往往要经常调试 Query，你可以使用 GraphiQL 工具来进行调试。你可以在 Moments App 的 <a href="http://momentsapi.herokuapp.com/playground?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="8676">BFF</a>来尝试调试上面的 Query，执行效果如下。</p>\n<p data-nodeid="10314" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3A/82/Cgp9HWB_3tuABbZnAAUdSISnc44399.png" alt="图片10.png" data-nodeid="10317"><br>\n在此，我们已经讲完<code data-backticks="1" data-nodeid="10320">Session</code>的实现了，有了 URL 路径，HTTP 头和参数。<code data-backticks="1" data-nodeid="10322">sessionHandler</code>就可以使用它来发起 HTTP POST 请求。具体调用如下所示。</p>\n\n\n\n\n\n\n\n\n<pre class="lang-swift" data-nodeid="1671"><code data-language="swift">session.post(session.path, headers: session.headers, parameters: session.parameters)\n</code></pre>\n<h4 data-nodeid="1672">解码 JSON 返回数据</h4>\n<p data-nodeid="1673">当我们从 BFF 取得 JSON 返回数据的时候，需要把它解析为 Swift Model 来引入 MVVM 架构里面。那怎样才能把 JSON 数据解码成 Model 类型<code data-backticks="1" data-nodeid="1982">MomentsDetails</code>呢？</p>\n<p data-nodeid="1674">这要从返回 JSON 的数据结构入手。JSON 返回结果是由上面的 Query 定义所决定的，在<code data-backticks="1" data-nodeid="1985">getMomentsDetailsByUserID</code>对象里面包含了<code data-backticks="1" data-nodeid="1987">userDetails</code>和<code data-backticks="1" data-nodeid="1989">moments</code>属性，具体的 JSON 如下。</p>\n<pre class="lang-javascript" data-nodeid="1675"><code data-language="javascript">{\n <span class="hljs-string">"userDetails"</span>: {\n   <span class="hljs-string">"id"</span>: <span class="hljs-string">"0"</span>,\n   <span class="hljs-string">"name"</span>: <span class="hljs-string">"Jake Lin"</span>,\n   <span class="hljs-string">"avatar"</span>: <span class="hljs-string">"https://avatar-url"</span>,\n   <span class="hljs-string">"backgroundImage"</span>: <span class="hljs-string">"https://background-image-url"</span>\n },\n <span class="hljs-string">"moments"</span>: [\n   {\n     <span class="hljs-string">"id"</span>: <span class="hljs-string">"0"</span>,\n     <span class="hljs-string">"userDetails"</span>: {\n       <span class="hljs-string">"name"</span>: <span class="hljs-string">"Taylor Swift"</span>,\n       <span class="hljs-string">"avatar"</span>: <span class="hljs-string">"https://another-avatar-url"</span>\n     },\n     <span class="hljs-string">"type"</span>: <span class="hljs-string">"PHOTOS"</span>,\n     <span class="hljs-string">"title"</span>: <span class="hljs-literal">null</span>,\n     <span class="hljs-string">"photos"</span>: [\n       <span class="hljs-string">"https://photo-url"</span>\n     ],\n     <span class="hljs-string">"createdDate"</span>: <span class="hljs-string">"1615899003"</span>\n   }\n ]\n}\n</code></pre>\n<p data-nodeid="1676">有了 JSON 数据结构，我们就可以定义一个 Swift 的 Model 来进行映射，例如把该 Model 命名为<code data-backticks="1" data-nodeid="1992">MomentsDetails</code>。它也包含了<code data-backticks="1" data-nodeid="1994">userDetails</code>和<code data-backticks="1" data-nodeid="1996">moments</code>两个属性，但我们没办法从 JSON 中看出来，所幸 GraphQL 为我们提供了 Schema ，它可以描述各个数据的具体类型。</p>\n<p data-nodeid="1677">下面是<code data-backticks="1" data-nodeid="1999">MomentsDetails</code>及其子类型的 Schema 定义。其中<code data-backticks="1" data-nodeid="2001">MomentsDetails</code>包含了<code data-backticks="1" data-nodeid="2003">userDetails</code>和<code data-backticks="1" data-nodeid="2005">moments</code>两个属性 ，<code data-backticks="1" data-nodeid="2007">userDetails</code>为非空的<code data-backticks="1" data-nodeid="2009">UserDetails</code>类型。而<code data-backticks="1" data-nodeid="2011">moments</code>的类型是包含非空的<code data-backticks="1" data-nodeid="2013">Moment</code>数组，同样地，该数组自己也不能为空。具体定义如下所示。</p>\n<pre class="lang-typescript" data-nodeid="1678"><code data-language="typescript"><span class="hljs-keyword">type</span> MomentsDetails {\n userDetails: UserDetails!\n moments: [Moment!]!\n}\n<span class="hljs-keyword">type</span> Moment {\n id: ID!\n userDetails: UserDetails!\n <span class="hljs-keyword">type</span>: MomentType!\n title: <span class="hljs-built_in">String</span>\n url: <span class="hljs-built_in">String</span>\n photos: [<span class="hljs-built_in">String</span>!]!\n createdDate: <span class="hljs-built_in">String</span>!\n}\n<span class="hljs-keyword">type</span> UserDetails {\n&nbsp; id: ID!\n&nbsp; name: <span class="hljs-built_in">String</span>!\n&nbsp; avatar: <span class="hljs-built_in">String</span>!\n&nbsp; backgroundImage: <span class="hljs-built_in">String</span>!\n}\n<span class="hljs-keyword">enum</span> MomentType {\n URL\n PHOTOS\n}\n</code></pre>\n<p data-nodeid="1679">有了上面的 GraphQL Schema，加上 JSON 数据结构，我们可以完成<code data-backticks="1" data-nodeid="2016">MomentsDetails</code>的映射。</p>\n<pre class="lang-swift" data-nodeid="1680"><code data-language="swift"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MomentsDetails</span>: <span class="hljs-title">Codable</span> </span>{\n   <span class="hljs-keyword">let</span> userDetails: <span class="hljs-type">UserDetails</span>\n   <span class="hljs-keyword">let</span> moments: [<span class="hljs-type">Moment</span>]\n}\n</code></pre>\n<p data-nodeid="1681">具体做法是把 GraphQL 中的<code data-backticks="1" data-nodeid="2019">type</code>映射成<code data-backticks="1" data-nodeid="2021">struct</code>，然后每个属性都使用<code data-backticks="1" data-nodeid="2023">let</code>来定义成常量。在 GraphQL 中,<code data-backticks="1" data-nodeid="2025">!</code>符合表示非空类型，因此在 Swift 中也使用非空类型。在我们的例子中<code data-backticks="1" data-nodeid="2027">userDetails</code>属性的类型为非空的<code data-backticks="1" data-nodeid="2029">UserDetails</code>，而<code data-backticks="1" data-nodeid="2031">moments</code>是<code data-backticks="1" data-nodeid="2033">Moment</code>类型的数组。下面是<code data-backticks="1" data-nodeid="2035">UserDetails</code>类型的定义，它有<code data-backticks="1" data-nodeid="2037">id</code>,<code data-backticks="1" data-nodeid="2039">name</code>等属性。</p>\n<pre class="lang-swift" data-nodeid="1682"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserDetails</span>: <span class="hljs-title">Codable</span> </span>{\n    <span class="hljs-keyword">let</span> id: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> avatar: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> backgroundImage: <span class="hljs-type">String</span>\n}\n</code></pre>\n<p data-nodeid="1683">接着我们看看<code data-backticks="1" data-nodeid="2042">Moment</code>类型定义。</p>\n<pre class="lang-swift" data-nodeid="1684"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Moment</span>: <span class="hljs-title">Codable</span> </span>{\n    <span class="hljs-keyword">let</span> id: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> userDetails: <span class="hljs-type">MomentUserDetails</span>\n    <span class="hljs-keyword">let</span> type: <span class="hljs-type">MomentType</span>\n    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String?</span>\n    <span class="hljs-keyword">let</span> url: <span class="hljs-type">String?</span>\n    <span class="hljs-keyword">let</span> photos: [<span class="hljs-type">String</span>]\n    <span class="hljs-keyword">let</span> createdDate: <span class="hljs-type">String</span>\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MomentUserDetails</span>: <span class="hljs-title">Codable</span> </span>{\n        <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>\n        <span class="hljs-keyword">let</span> avatar: <span class="hljs-type">String</span>\n    }\n    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MomentType</span>: <span class="hljs-title">String</span>, <span class="hljs-title">Codable</span> </span>{\n        <span class="hljs-keyword">case</span> url = <span class="hljs-string">"URL"</span>\n        <span class="hljs-keyword">case</span> photos = <span class="hljs-string">"PHOTOS"</span>\n    }\n}\n</code></pre>\n<p data-nodeid="1685"><code data-backticks="1" data-nodeid="2044">Moment</code>类型包含了<code data-backticks="1" data-nodeid="2046">id</code>,<code data-backticks="1" data-nodeid="2048">title</code>,<code data-backticks="1" data-nodeid="2050">userDetails</code>和<code data-backticks="1" data-nodeid="2052">type</code>等属性。其中<code data-backticks="1" data-nodeid="2054">title</code>在 GraphQL 中 Schema 里面没有定义为<code data-backticks="1" data-nodeid="2056">!</code>，表示这个属性可能为空，当我们映射成 Swift 类型时使用了<code data-backticks="1" data-nodeid="2058">?</code>来表示这个属性是可空类型（Optional）。<br>\n<code data-backticks="1" data-nodeid="2061">userDetails</code>属性的类型是一个嵌套类型<code data-backticks="1" data-nodeid="2063">MomentUserDetails</code>，我推荐把所有的子类型都内嵌到父类型里面，这样能把所有的类型定义统一封装在<code data-backticks="1" data-nodeid="2065">MomentsDetails</code>里面，访问的时候就有命名空间。</p>\n<p data-nodeid="1686">最后我们看一下<code data-backticks="1" data-nodeid="2068">type</code>属性，它在 GraphQL 里的定义是一个枚举。我们把它映射为类型是<code data-backticks="1" data-nodeid="2070">MomentType</code>的一个枚举。由于 GraphQL 会通过字符串来传输<code data-backticks="1" data-nodeid="2072">enum</code>，当我们在 Swift 中映射成枚举类型时，需要把该<code data-backticks="1" data-nodeid="2074">enum</code>定义为字符串类型，并为每一个<code data-backticks="1" data-nodeid="2076">case</code>都指定需要映射的字符串值。例如我们给<code data-backticks="1" data-nodeid="2078">url</code>指定为<code data-backticks="1" data-nodeid="2080">"URL"</code>。</p>\n<p data-nodeid="1687">为了让 Swift 帮我们进行自动的解码与编码，我们把所有所有类型都遵守了<code data-backticks="1" data-nodeid="2083">Codable</code>协议，下面是<code data-backticks="1" data-nodeid="2085">Codable</code>协议的定义。</p>\n<pre class="lang-swift" data-nodeid="1688"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">Codable</span> = <span class="hljs-type">Decodable</span> &amp; <span class="hljs-type">Encodable</span>\n</code></pre>\n<p data-nodeid="12472"><code data-backticks="1" data-nodeid="12474">Codable</code>其实是<code data-backticks="1" data-nodeid="12476">Decodable</code>和<code data-backticks="1" data-nodeid="12478">Encodable</code>两个协议合体，一个类型遵循了<code data-backticks="1" data-nodeid="12480">Codable</code>表示该类型同时遵循<code data-backticks="1" data-nodeid="12482">Decodable</code>和<code data-backticks="1" data-nodeid="12484">Encodable</code>两个协议。如下图所示，因为 BFF 返回的是 JSON 数据，我们可以使用<code data-backticks="1" data-nodeid="12486">JSONDecoder</code>把 JSON 数据解码成 Swift 的 Model 类型，反过来，我们可以使用<code data-backticks="1" data-nodeid="12488">JSONEncoder</code>把 Swift 的 Model 编码成 JSON 数据。</p>\n<p data-nodeid="12473" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3A/8A/CioPOWB_3yGAbcmbAAT0CvLwTTw986.png" alt="图片11.png" data-nodeid="12492"></p>\n\n\n<p data-nodeid="1691">在 Swift 4 之前，我们需要使用<code data-backticks="1" data-nodeid="2107">JSONSerialization</code>来反序列化 JSON 数据，然后把每一个属性单独转换成所需的类型。后来出现 SwiftyJSON 等库，帮我们减轻了一部分 JSON 转型工作，但还是需要大量手工编码来完成映射。</p>\n<p data-nodeid="1692">Swift 4 以后，出现了<code data-backticks="1" data-nodeid="2110">Codable</code>协议，我们只需要把所定义的 Model 类型遵守该协议，Swift 在调用<code data-backticks="1" data-nodeid="2112">JSONDecoder</code>的<code data-backticks="1" data-nodeid="2114">decode</code>方法时就能自动完成转型。这样既能减少编写代码的数量，还能获得原生的性能。以下是<code data-backticks="1" data-nodeid="2116">APISession</code>里面转换 JSON 到 Model 类型的代码：</p>\n<pre class="lang-swift" data-nodeid="1693"><code data-language="swift"><span class="hljs-keyword">let</span> model = <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">ReponseType</span>.<span class="hljs-keyword">self</span>, from: data)\n</code></pre>\n<p data-nodeid="1694">我们只需要把转换的 Model 类型告诉<code data-backticks="1" data-nodeid="2119">decode</code>方法即可。为了处理转换失败的情况，我们使用了<code data-backticks="1" data-nodeid="2121">try</code>语句。当转型失败时，它会返回<code data-backticks="1" data-nodeid="2123">nil</code>，使得我们的程序不会崩溃。</p>\n<p data-nodeid="1695">这里有一个技巧，假如你在开发中转型失败了，可以把 Model 定义的一部分属性先注释起来，找出引起转型失败的那个属性；然后，通过 GraphQL Schema 来检查该属性的数据类型，并判断该属性能否为空，最后根据 Schema 的定义来修改转型失败的属性。</p>\n<h3 data-nodeid="1696">总结</h3>\n<p data-nodeid="1697">至此，我们就有了一个开发网络模块的模板，下面我来总结一下开发网络模块的具体流程。</p>\n<ol data-nodeid="1698">\n<li data-nodeid="1699">\n<p data-nodeid="1700">根据 BFF 返回的 JSON 数据以及 GraphQL 的 Schema ，定义 Model 的数据类型，请记住所有类型都需要遵循<code data-backticks="1" data-nodeid="2129">Codable</code>协议。</p>\n</li>\n<li data-nodeid="1701">\n<p data-nodeid="1702">定义一个网络请求的协议，并提供一个请求的方法，该方法需要接收请求所需的所有参数，并返回包含 Model 类型的 Observable 序列。这样上层模块就能使用响应式编程的方式来处理网络请求的结果了。</p>\n</li>\n<li data-nodeid="1703">\n<p data-nodeid="1704">遵循上述的协议并实现一个网络请求的结构体。在该结构体里定义一个遵循了<code data-backticks="1" data-nodeid="2133">APISession</code>协议的<code data-backticks="1" data-nodeid="2135">Session</code>结构体，并在<code data-backticks="1" data-nodeid="2137">Session</code>结构体内定义发送给 GraphQL 的<code data-backticks="1" data-nodeid="2139">query</code>属性，我们可以通过 GraphiQL 工具来测试 Query 的定义。</p>\n</li>\n</ol>\n<p data-nodeid="1705">思考题：</p>\n<blockquote data-nodeid="1706">\n<p data-nodeid="1707">请问在你们项目中是如何解析网络返回的 JSON 数据呢？能否分享一下经验。</p>\n</blockquote>\n<p data-nodeid="1708">可以把你的答案写得留言区哦，下一讲我将介绍如何使用仓库模式设计数据存储层。</p>\n<p data-nodeid="1709" class=""><strong data-nodeid="2147">源码地址：</strong></p>\n<blockquote data-nodeid="1710">\n<p data-nodeid="1711" class="">底层 HTTP 网络通信模块：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Networking?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2151">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Networking</a><br>\n请求朋友圈信息模块:<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Networking?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2156">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Networking</a></p>\n</blockquote>',
          },
          {
            theme: '19 | 数据层架构：如何使用仓库模式设计数据存储层？',
            id: 34,
            content:
              '<p data-nodeid="1321" class="">数据是 App 的血液，没有了数据，App 就没办法工作了。但是要保持数据的一致性，并不是一件简单的事情。因为在 App 中多个页面共享同一份数据的情况经常出现。比如，朋友圈时间轴列表页面和朋友圈详情页都共享了朋友圈数据，当我们在详情页点了赞，怎样让时间轴页面同步状态数据呢？如果有多于两个页面，它们之间又怎样保持同步呢？</p>\n<p data-nodeid="1322">目前比较流行的方案是使用<strong data-nodeid="1418">Repository（数据仓库）模式</strong>。 例如 Android Architecture Components 就推荐使用该模式。在 Moments App 中，我也使用 Repository 模式维护唯一数据源，通过<strong data-nodeid="1419">RxSwift 的 Subject</strong>保证数据的自动更新。为了与具体的数据库进行解耦并提高程序的灵活性，我还使用了<strong data-nodeid="1420">DataStore 模块</strong>来抽象本地数据存储与访问。这一讲我就和你介绍下我是怎么做的。</p>\n<h3 data-nodeid="1323">Repository 模式的架构</h3>\n<p data-nodeid="1324">所谓 Repository 模式，就是为数据访问提供抽象的接口，数据使用者在读写数据时，只调用相关的接口函数，并不关心数据到底存放在网络还是本地，也不用关心本地数据库的具体实现。使用 Repository 模式有以下几大优势：</p>\n<ol data-nodeid="1325">\n<li data-nodeid="1326">\n<p data-nodeid="1327">Repository 模块作为唯一数据源统一管理所有数据，能有效保证整个 App 数据的一致性；</p>\n</li>\n<li data-nodeid="1328">\n<p data-nodeid="1329">Repository 模块封装了所有数据访问的细节，可提高程序的可扩展性和灵活性，例如，在不改变接口的情况下，把本地存储替换成其他的数据库；</p>\n</li>\n<li data-nodeid="1330">\n<p data-nodeid="1331">结合 RxSwift 的 Subject， Repository 模块能自动更新 App 的数据与状态。</p>\n</li>\n</ol>\n<p data-nodeid="2633">我们以朋友圈功能为例，看看如何使用 Repository 模式。下面是 Repository 模块的架构图。</p>\n<p data-nodeid="2634" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/C1/CioPOWCGgkOAFlCeAANesZhJjDM002.png" alt="图片2.png" data-nodeid="2638"></p>\n\n\n<p data-nodeid="1334"><strong data-nodeid="1442">ViewModel 模块</strong>是 Repository 模块的上层数据使用者，在朋友圈功能里面,<code data-backticks="1" data-nodeid="1434">MomentsTimelineViewModel</code>和<code data-backticks="1" data-nodeid="1436">MomentListItemViewModel</code>都通过<code data-backticks="1" data-nodeid="1438">MomentsRepoType</code>的<code data-backticks="1" data-nodeid="1440">momentsDetails</code>Subject 来订阅数据的更新。</p>\n<p data-nodeid="1335"><strong data-nodeid="1447">Repository 模块分成两大部分： Repo 和 DataStore</strong>。其中 Repo 负责统一管理数据（如访问网络的数据、读写本地数据），并通过 Subject 来为订阅者分发新的数据。</p>\n<p data-nodeid="1336">Repo 由<code data-backticks="1" data-nodeid="1449">MomentsRepoType</code>协议和遵循该协议的<code data-backticks="1" data-nodeid="1451">MomentsRepo</code>结构体所组成。<code data-backticks="1" data-nodeid="1453">MomentsRepoType</code>协议用于定义接口，而<code data-backticks="1" data-nodeid="1455">MomentsRepo</code>封装具体的实现，当<code data-backticks="1" data-nodeid="1457">MomentsRepo</code>需要读取和更新 BFF 的数据时，会调用 Networking 模块的组件，这方面我在上一讲已经详细介绍过了。而当<code data-backticks="1" data-nodeid="1459">MomentsRepo</code>需要读取和更新本地数据时，会使用到 DataStore。</p>\n<p data-nodeid="1337">DataStore 负责本地数据的存储，它由<code data-backticks="1" data-nodeid="1462">PersistentDataStoreType</code>协议和<code data-backticks="1" data-nodeid="1464">UserDefaultsPersistentDataStore</code>结构体所组成。其中，<code data-backticks="1" data-nodeid="1466">PersistentDataStoreType</code>协议用于定义本地数据读写的接口。而<code data-backticks="1" data-nodeid="1468">UserDefaultsPersistentDataStore</code>结构体是其中一种实现。从名字可以看到，该实现使用了 iOS 系统所提供的 UserDefaults 来存储数据。</p>\n<p data-nodeid="1338">假如我们需要支持 Core Data，那么可以提供另外一个结构体来遵循<code data-backticks="1" data-nodeid="1471">PersistentDataStoreType</code>协议，比如把该结构体命名为<code data-backticks="1" data-nodeid="1473">CoreDataPersistentDataStore</code>，并使用它来封装所有 Core Data 的访问细节。有了 DataStore 的接口，我们可以很方便地替换不同的本地数据库。</p>\n<h3 data-nodeid="1339">Repository 模式的实现</h3>\n<p data-nodeid="1340">看完 Repository 模式的架构设计，我们一起了解下 Repo 和 DataStore 的具体实现。</p>\n<p data-nodeid="1341">首先我们看一下 DataStore 模块，下面是<code data-backticks="1" data-nodeid="1478">PersistentDataStoreType</code>协议的定义。</p>\n<pre class="lang-swift" data-nodeid="1342"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">PersistentDataStoreType</span> </span>{\n    <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; { <span class="hljs-keyword">get</span> }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span>\n}\n</code></pre>\n<p data-nodeid="1343">该协议提供了<code data-backticks="1" data-nodeid="1481">momentsDetails</code>属性来给数据使用者读取朋友圈数据，并提供了<code data-backticks="1" data-nodeid="1483">save(momentsDetails: MomentsDetails)</code>方法来保存朋友圈信息。</p>\n<p data-nodeid="1344">在 Moments App 里面，我们为<code data-backticks="1" data-nodeid="1486">PersistentDataStoreType</code>协议提供一个封装了 UserDefaults 的实现，其具体代码如下。</p>\n<pre class="lang-swift" data-nodeid="1345"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserDefaultsPersistentDataStore</span>: <span class="hljs-title">PersistentDataStoreType</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">UserDefaultsPersistentDataStore</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; = .create(bufferSize: <span class="hljs-number">1</span>)\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> disposeBage: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> defaults = <span class="hljs-type">UserDefaults</span>.standard\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> momentsDetailsKey = <span class="hljs-type">String</span>(describing: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>)\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() {\n        defaults.rx\n            .observe(<span class="hljs-type">Data</span>.<span class="hljs-keyword">self</span>, momentsDetailsKey)\n            .<span class="hljs-built_in">compactMap</span> { $<span class="hljs-number">0</span> }\n            .<span class="hljs-built_in">compactMap</span> { <span class="hljs-keyword">try</span>? <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>, from: $<span class="hljs-number">0</span>) }\n            .subscribe(momentsDetails)\n            .disposed(by: disposeBage)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span> {\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> encodedData = <span class="hljs-keyword">try</span>? <span class="hljs-type">JSONEncoder</span>().encode(momentsDetails) {\n            defaults.<span class="hljs-keyword">set</span>(encodedData, forKey: momentsDetailsKey)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1346">因为<code data-backticks="1" data-nodeid="1489">UserDefaultsPersistentDataStore</code>遵循了<code data-backticks="1" data-nodeid="1491">PersistentDataStoreType</code>协议，因此需要实现<code data-backticks="1" data-nodeid="1493">momentsDetails</code>属性和<code data-backticks="1" data-nodeid="1495">save()</code>方法。<br>\n其中<code data-backticks="1" data-nodeid="1499">momentsDetails</code>属性为 RxSwfit 的<code data-backticks="1" data-nodeid="1501">ReplaySubject</code>类型。它负责把数据的更新事件发送给订阅者。在<code data-backticks="1" data-nodeid="1503">init()</code>方法中，我们通过了 Key 来订阅 UserDefaults 里的数据更新，一旦与该 Key 相关联的数据发生了变化，我们就使用<code data-backticks="1" data-nodeid="1505">JSONDecoder</code>来把更新的数据解码成<code data-backticks="1" data-nodeid="1507">MomentsDetails</code>类型，然后发送给<code data-backticks="1" data-nodeid="1509">momentsDetails</code>Subject 属性。这样<code data-backticks="1" data-nodeid="1511">momentsDetails</code>属性就可以把数据事件中转给外部的订阅者了。</p>\n<p data-nodeid="1347"><code data-backticks="1" data-nodeid="1513">save(momentsDetails: MomentsDetails)</code>方法用于保存数据，首先把传递进来的<code data-backticks="1" data-nodeid="1515">momentsDetails</code>对象通过<code data-backticks="1" data-nodeid="1517">JSONEncoder</code>来编码，并把编码后的数据写入 UserDefaults 中。这里需要注意，我们在读写 UserDefaults 时，提供的 Key 必须保持一致。为了保证这一点，我们使用了同一个私有属性<code data-backticks="1" data-nodeid="1519">momentsDetailsKey</code>来进行读写。</p>\n<p data-nodeid="1348">接着来看 Repo 模块，下面是<code data-backticks="1" data-nodeid="1522">MomentsRepoType</code>协议的定义。</p>\n<pre class="lang-swift" data-nodeid="1349"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MomentsRepoType</span> </span>{\n    <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; { <span class="hljs-keyword">get</span> }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt;\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLike</span><span class="hljs-params">(isLiked: Bool, momentID: String, fromUserID userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt;\n}\n</code></pre>\n<p data-nodeid="1350">在该协议中，<code data-backticks="1" data-nodeid="1525">momentsDetails</code>属性用来为订阅者发送朋友圈数据的更新事件。<code data-backticks="1" data-nodeid="1527">getMoments(userID: String) -&gt; Observable&lt;Void&gt;</code>方法用于获取朋友圈信息数据，而<code data-backticks="1" data-nodeid="1529">updateLike(isLiked: Bool, momentID: String, fromUserID userID: String) -&gt; Observable&lt;Void&gt;</code>方法用于更新点赞信息。</p>\n<p data-nodeid="1351">因为<code data-backticks="1" data-nodeid="1532">MomentsRepo</code>结构体遵循了<code data-backticks="1" data-nodeid="1534">MomentsRepoType</code>协议，它也实现了<code data-backticks="1" data-nodeid="1536">momentsDetails</code>属性以及<code data-backticks="1" data-nodeid="1538">getMoments()</code>和<code data-backticks="1" data-nodeid="1540">updateLike()</code>方法。</p>\n<p data-nodeid="1352"><code data-backticks="1" data-nodeid="1542">momentsDetails</code>属性是一个<code data-backticks="1" data-nodeid="1544">ReplaySubject</code>的对象，用于转发朋友圈数据的更新事件，我们可以从<code data-backticks="1" data-nodeid="1546">init()</code>方法里面看到它是怎样转发数据的。</p>\n<pre class="lang-swift" data-nodeid="1353"><code data-language="swift"><span class="hljs-keyword">init</span>(persistentDataStore: <span class="hljs-type">PersistentDataStoreType</span>,\n             getMomentsByUserIDSession: <span class="hljs-type">GetMomentsByUserIDSessionType</span>,\n             updateMomentLikeSession: <span class="hljs-type">UpdateMomentLikeSessionType</span>) {\n    <span class="hljs-keyword">self</span>.persistentDataStore = persistentDataStore\n    <span class="hljs-keyword">self</span>.getMomentsByUserIDSession = getMomentsByUserIDSession\n    <span class="hljs-keyword">self</span>.updateMomentLikeSession = updateMomentLikeSession\n    persistentDataStore\n        .momentsDetails\n        .subscribe(momentsDetails)\n        .disposed(by: disposeBag)\n}\n</code></pre>\n<p data-nodeid="1354">其核心代码是订阅<code data-backticks="1" data-nodeid="1549">persistentDataStore</code>的<code data-backticks="1" data-nodeid="1551">momentsDetails</code>属性，然后把接收到所有事件都转发到自己的<code data-backticks="1" data-nodeid="1553">momentsDetails</code>属性。</p>\n<p data-nodeid="1355">然后我们来看<code data-backticks="1" data-nodeid="1556">getMoments()</code>和<code data-backticks="1" data-nodeid="1558">updateLike()</code>方法。 其代码如下。</p>\n<pre class="lang-swift" data-nodeid="1356"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n&nbsp; &nbsp; <span class="hljs-keyword">return</span> getMomentsByUserIDSession\n&nbsp; &nbsp; &nbsp; &nbsp; .getMoments(userID: userID)\n&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })\n&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }\n&nbsp; &nbsp; &nbsp; &nbsp; .catchErrorJustReturn(())\n}\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLike</span><span class="hljs-params">(isLiked: Bool, momentID: String, fromUserID userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n&nbsp; &nbsp; <span class="hljs-keyword">return</span> updateMomentLikeSession\n&nbsp; &nbsp; &nbsp; &nbsp; .updateLike(isLiked, momentID: momentID, fromUserID: userID)\n&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })\n&nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }\n&nbsp; &nbsp; &nbsp; &nbsp; .catchErrorJustReturn(())\n}\n</code></pre>\n<p data-nodeid="1357"><code data-backticks="1" data-nodeid="1560">getMoments()</code>方法通过请求 BFF 来获取朋友圈信息，因为 Repository 模块所有的网络请求操作都通过调用 Networking 模块来完成。在这个方法里面，我们调用了<code data-backticks="1" data-nodeid="1562">getMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="1564">getMoments()</code>方法来发起 BFF 的网络请求。当我们得到朋友圈数据时，就会调用<code data-backticks="1" data-nodeid="1566">persistentDataStore</code>的<code data-backticks="1" data-nodeid="1568">save()</code>方法，把返回数据保存到本地。<br>\n<code data-backticks="1" data-nodeid="1571">updateLike()</code>方法通过访问 BFF 来更新点赞信息。在这个方法里面，我们调用了<code data-backticks="1" data-nodeid="1573">updateMomentLikeSession</code>的<code data-backticks="1" data-nodeid="1575">updateLike()</code>方法来发起更新请求。当我们得到更新后的朋友圈数据时，也会调用<code data-backticks="1" data-nodeid="1577">persistentDataStore</code>的<code data-backticks="1" data-nodeid="1579">save()</code>方法把数据保存到本地。</p>\n<p data-nodeid="1358">当其他模块，例如 ViewModel 模块想得到自动更新的朋友圈数据时，只需要订阅<code data-backticks="1" data-nodeid="1582">MomentsRepoType</code>的<code data-backticks="1" data-nodeid="1584">momentsDetails</code>Subject 属性即可。下面是<code data-backticks="1" data-nodeid="1586">MomentsTimelineViewModel</code>中的例子代码。</p>\n<pre class="lang-swift" data-nodeid="1359"><code data-language="swift">momentsRepo.momentsDetails.subscribe(onNext: {\n    <span class="hljs-comment">// 接收并处理朋友圈数据更新</span>\n}).disposed(by: disposeBag)\n</code></pre>\n<h3 data-nodeid="1360">RxSwift Subject</h3>\n<p data-nodeid="1361">你可以看到，在 Repository 模块里面，我大量使用了 RxSwift 的 Subject 来中转数据事件。 在 RxSwift 里面，常见的 Subject 有<strong data-nodeid="1594">PublishSubject、BehaviorSubject 和 ReplaySubject</strong>。它们的区别在于订阅者能否收到订阅前的事件。那么，在程序代码中它们是如何工作的呢？接下来我就为你一一介绍下。</p>\n<h4 data-nodeid="1362">PublishSubject</h4>\n<p data-nodeid="1363">首先看一下 PublishSuject。顾名思义，PublishSuject 用于发布（Publish）事件，它的特点是订阅者只能接收订阅后的事件。下面是 PublishSuject 的例子代码。</p>\n<pre class="lang-swift" data-nodeid="1364"><code data-language="swift"><span class="hljs-keyword">let</span> publishSubject = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">Int</span>&gt;()\npublishSubject.onNext(<span class="hljs-number">1</span>)\n<span class="hljs-keyword">let</span> observer1 = publishSubject.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer1: \\(event)"</span>)\n}\nobserver1.disposed(by: disposeBag)\npublishSubject.onNext(<span class="hljs-number">2</span>)\n<span class="hljs-keyword">let</span> observer2 = publishSubject.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer2: \\(event)"</span>)\n}\nobserver2.disposed(by: disposeBag)\npublishSubject.onNext(<span class="hljs-number">3</span>)\npublishSubject.onCompleted()\npublishSubject.onNext(<span class="hljs-number">4</span>)\n</code></pre>\n<p data-nodeid="1365">首先，我们生成一个名叫<code data-backticks="1" data-nodeid="1598">publishSubject</code>的对象，并发出<code data-backticks="1" data-nodeid="1600">onNext(1)</code>事件，接着通过<code data-backticks="1" data-nodeid="1602">subscribe</code>方法来生成一个名叫<code data-backticks="1" data-nodeid="1604">observer1</code>的订阅者。由于<code data-backticks="1" data-nodeid="1606">publishSubject</code>的订阅者只能收到订阅以后的事件，因此<code data-backticks="1" data-nodeid="1608">observer1</code>无法收到之前的<code data-backticks="1" data-nodeid="1610">onNext(1)</code>的事件。</p>\n<p data-nodeid="1366">当<code data-backticks="1" data-nodeid="1613">publishSubject</code>发出<code data-backticks="1" data-nodeid="1615">onNext(2)</code>事件时，<code data-backticks="1" data-nodeid="1617">observer1</code>就会收到该事件。在此之后，我们又生成了第二个订阅者<code data-backticks="1" data-nodeid="1619">observer2</code>，该订阅者也没法接收到以前的事件。当<code data-backticks="1" data-nodeid="1621">publishSubject</code>发出<code data-backticks="1" data-nodeid="1623">onNext(3)</code>和<code data-backticks="1" data-nodeid="1625">completed</code>事件的时候，两个订阅者都能接收到。因为<code data-backticks="1" data-nodeid="1627">completed</code>事件把该 Subject 关闭了，之后所有订阅者都不能接收到<code data-backticks="1" data-nodeid="1629">onNext(4)</code>事件。</p>\n<p data-nodeid="1367">下面是整段程序的执行效果。</p>\n<pre class="lang-java" data-nodeid="1368"><code data-language="java">observer1: next(<span class="hljs-number">2</span>)\nobserver1: next(<span class="hljs-number">3</span>)\nobserver2: next(<span class="hljs-number">3</span>)\nobserver1: completed\nobserver2: completed\n</code></pre>\n<p data-nodeid="1369">PublishSubject 很适合发送新的事件，但有时候，消息发送者需要比订阅者先进行初始化，此时订阅者就无法接收到原有事件。例如在 Moments App 里面，<code data-backticks="1" data-nodeid="1633">UserDefaultsPersistentDataStore</code>就先于<code data-backticks="1" data-nodeid="1635">MomentsRepo</code>进行初始化并立刻读取 UserDefaults 里缓存的数据，假如我们使用 PublishSubject，<code data-backticks="1" data-nodeid="1637">MomentsRepo</code>将无法读取到第一条的朋友圈数据。</p>\n<p data-nodeid="1370">那怎样解决这样的问题呢？RxSwift 提供了 BehaviorSubject 和 ReplaySubject 来帮助我们读取在 Subject 里缓存的数据。</p>\n<h4 data-nodeid="1371">BehaviorSubject</h4>\n<p data-nodeid="1372">BehaviorSubject 用于缓存一个事件，当订阅者订阅 BehaviorSubject 时，会马上收到该 Subject 里面最后一个事件。我们通过例子来看看 BehaviorSubject 是怎样工作的。</p>\n<pre class="lang-swift" data-nodeid="1373"><code data-language="swift"><span class="hljs-keyword">let</span> behaviorSubject = <span class="hljs-type">BehaviorSubject</span>&lt;<span class="hljs-type">Int</span>&gt;(value: <span class="hljs-number">1</span>)\n<span class="hljs-keyword">let</span> observer1 = behaviorSubject.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer1: \\(event)"</span>)\n}\nobserver1.disposed(by: disposeBag)\nbehaviorSubject.onNext(<span class="hljs-number">2</span>)\n<span class="hljs-keyword">let</span> observer2 = behaviorSubject.subscribe { event <span class="hljs-keyword">in</span>\n    <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer2: \\(event)"</span>)\n}\nobserver2.disposed(by: disposeBag)\nbehaviorSubject.onNext(<span class="hljs-number">3</span>)\nbehaviorSubject.onCompleted()\nbehaviorSubject.onNext(<span class="hljs-number">4</span>)\n</code></pre>\n<p data-nodeid="1374">因为 BehaviorSubject 要给订阅者提供订阅前的最后一条事件，我们需要传递初始值来生成BehaviorSubject。在上面的代码中可以看到，我们传递了<code data-backticks="1" data-nodeid="1643">1</code>来新建<code data-backticks="1" data-nodeid="1645">behaviorSubject</code>对象，当<code data-backticks="1" data-nodeid="1647">observer1</code>订阅时马上就能接收到<code data-backticks="1" data-nodeid="1649">next(1)</code>事件。而<code data-backticks="1" data-nodeid="1651">observer2</code>订阅的时候只能接收到前一个<code data-backticks="1" data-nodeid="1653">next(2)</code>事件。接着，它们都能收到<code data-backticks="1" data-nodeid="1655">next(3)</code>事件。当收到<code data-backticks="1" data-nodeid="1657">completed</code>事件后，<code data-backticks="1" data-nodeid="1659">observer1</code>和<code data-backticks="1" data-nodeid="1661">observer2</code>都停止接收其他事件了。其运行效果如下：</p>\n<pre class="lang-java" data-nodeid="1375"><code data-language="java">observer1: next(<span class="hljs-number">1</span>)\nobserver1: next(<span class="hljs-number">2</span>)\nobserver2: next(<span class="hljs-number">2</span>)\nobserver1: next(<span class="hljs-number">3</span>)\nobserver2: next(<span class="hljs-number">3</span>)\nobserver1: completed\nobserver2: completed\n</code></pre>\n<h4 data-nodeid="1376">ReplaySubject</h4>\n<p data-nodeid="1377">BehaviorSubject 只能缓存一个事件，当我们需要缓存 N 个事件时，就可以使用 ReplaySubject。例如我们需要统计最后三天的天气信息，那么可以把 N 设置为 3，当订阅者开始订阅时，就可以得到前三天的天气信息。以下是 ReplaySubject 工作的大致过程。</p>\n<pre class="lang-swift" data-nodeid="1378"><code data-language="swift"><span class="hljs-keyword">let</span> replaySubject = <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">Int</span>&gt;.create(bufferSize: <span class="hljs-number">2</span>)\nreplaySubject.onNext(<span class="hljs-number">1</span>)\nreplaySubject.onNext(<span class="hljs-number">2</span>)\n<span class="hljs-keyword">let</span> observer1 = replaySubject.subscribe { event <span class="hljs-keyword">in</span>\n&nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer1: \\(event)"</span>)\n}\nobserver1.disposed(by: disposeBag)\nreplaySubject.onNext(<span class="hljs-number">3</span>)\n<span class="hljs-keyword">let</span> observer2 = replaySubject.subscribe { event <span class="hljs-keyword">in</span>\n&nbsp; &nbsp; <span class="hljs-built_in">print</span>(<span class="hljs-string">"observer2: \\(event)"</span>)\n}\nobserver2.disposed(by: disposeBag)\nreplaySubject.onNext(<span class="hljs-number">4</span>)\nreplaySubject.onCompleted()\nreplaySubject.onNext(<span class="hljs-number">5</span>)\n</code></pre>\n<p data-nodeid="1379">为了看出与 BehaviorSubject 的不同之处，在这里我把 N 设置为 “2”。首先我们把 2 传入<code data-backticks="1" data-nodeid="1666">bufferSize</code>来创建一个<code data-backticks="1" data-nodeid="1668">replaySubject</code>对象，然后发出两个<code data-backticks="1" data-nodeid="1670">next</code>事件，当<code data-backticks="1" data-nodeid="1672">observer1</code>订阅时会马上得到<code data-backticks="1" data-nodeid="1674">1</code>和<code data-backticks="1" data-nodeid="1676">2</code>两个值。</p>\n<p data-nodeid="1380">接着<code data-backticks="1" data-nodeid="1679">replaySubject</code>再发出一个<code data-backticks="1" data-nodeid="1681">next(3)</code>事件。当<code data-backticks="1" data-nodeid="1683">observer2</code>订阅的时候会接收到最近的两个值<code data-backticks="1" data-nodeid="1685">2</code>和<code data-backticks="1" data-nodeid="1687">3</code>。在此以后<code data-backticks="1" data-nodeid="1689">observer1</code>和<code data-backticks="1" data-nodeid="1691">observer2</code>会不断接收<code data-backticks="1" data-nodeid="1693">replaySubject</code>的事件，直到收到<code data-backticks="1" data-nodeid="1695">completed</code>事件后停止。其运行效果如下：</p>\n<pre class="lang-java" data-nodeid="1381"><code data-language="java">observer1: next(<span class="hljs-number">1</span>)\nobserver1: next(<span class="hljs-number">2</span>)\nobserver1: next(<span class="hljs-number">3</span>)\nobserver2: next(<span class="hljs-number">2</span>)\nobserver2: next(<span class="hljs-number">3</span>)\nobserver1: next(<span class="hljs-number">4</span>)\nobserver2: next(<span class="hljs-number">4</span>)\nobserver1: completed\nobserver2: completed\n</code></pre>\n<p data-nodeid="1382">除了能缓存更多的数据以外，还有一情况我们会选择使用 ReplaySubject 而不是BehaviorSubject。</p>\n<p data-nodeid="1383">在初始化 BehaviorSubject 的时候，我们必须提供一个初始值。如果我没办法提供，只能把存放的类型定义为 Optional （可空）类型。但是我们可以使用 ReplaySubject 来避免这种情况。这就是为什么我们把<code data-backticks="1" data-nodeid="1699">UserDefaultsPersistentDataStore</code>和<code data-backticks="1" data-nodeid="1701">MomentsRepo</code>的<code data-backticks="1" data-nodeid="1703">momentsDetails</code>Subject 属性都定义为 ReplaySubject 而不是 BehaviorSubject 的原因。</p>\n<p data-nodeid="1384">除了上面的三个 Subject 以外，RxSwift 还为我们提供了两个特殊的 Subject：<strong data-nodeid="1716">PublishRelay 和 BehaviorRelay</strong>，它们的名字和 BehaviorSubject 和 ReplaySubject 非常类似，区别是 Relay 只中继<code data-backticks="1" data-nodeid="1710">next</code>事件，我们并不能往 Relay 里发送<code data-backticks="1" data-nodeid="1712">completed</code>或<code data-backticks="1" data-nodeid="1714">error</code>事件。</p>\n<h3 data-nodeid="1385">总结</h3>\n<p data-nodeid="1386">在这一讲中，我们介绍了 Repository 模式的架构与实现，然后通过例子来解释各种 Subject 的区别。我把本讲 Subject 的例子代码都放在项目中的<strong data-nodeid="1723">RxSwift Playground 文件</strong>里面，希望你能多练习，灵活运用。</p>\n<p data-nodeid="1387">下面是一些在项目场景中使用 Subject 的经验，希望对你有帮助。</p>\n<ol data-nodeid="1388">\n<li data-nodeid="1389">\n<p data-nodeid="1390">如果需要把 Subject 传递给其他类型发送消息，例如在朋友圈时间轴列表页面把 Subject 传递给各个朋友圈子组件，然后接收来自子组件的事件。 这种情况我们一般会传递 PublishSubject，因为在传递前在主页面（如例子中的朋友圈时间轴页面）已经订阅了该 PublishSubject，子组件所发送事件，主页面都能收到。</p>\n</li>\n<li data-nodeid="1391">\n<p data-nodeid="1392">BehaviorSubject 可用于状态管理，例如管理页面的加载状态，开始时可以把 BehaviorSubject 初始化为加载状态，一旦得到返回数据就可以转换为成功状态。</p>\n</li>\n<li data-nodeid="1393">\n<p data-nodeid="1394">因为 BehaviorSubject 必须赋予初始值，但有些情况下，我们并没有初始化，如果使用 BehaviorSubject 必须把其存放的类型定义为 Optional 类型。为了避免使用 Optional，我们可以使用 bufferSize 为 1 的 ReplaySubject 来代替 BehaviorSubject。</p>\n</li>\n<li data-nodeid="1395">\n<p data-nodeid="1396">Subject 和 Relay 都能用于中转事件，当中转的事件中没有<code data-backticks="1" data-nodeid="1729">completed</code>或<code data-backticks="1" data-nodeid="1731">error</code>时，我们都选择 Relay。</p>\n</li>\n</ol>\n<p data-nodeid="1397"><strong data-nodeid="1736">思考题</strong></p>\n<blockquote data-nodeid="1398">\n<p data-nodeid="1399">请问你们的 App 使用本地数据库吗？使用的是哪一款数据库，有没有试过替换数据库的情况，能分享一下这方面的经验吗？</p>\n</blockquote>\n<p data-nodeid="1400">请把你的想法写到留言区哦，下一讲我将介绍如何使用 ViewModel 模式来为 UI 层的准备呈现的数据。</p>\n<p data-nodeid="1401"><strong data-nodeid="1742">源码地址：</strong></p>\n<blockquote data-nodeid="1402">\n<p data-nodeid="1403" class="">RxSwift Playground 文件地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1747">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift</a><br>\nRepo 源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/Moments/Features/Moments/Repositories/Moments?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1753">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/Moments/Features/Moments/Repositories/Moments</a>Repo.swift<br>\nDataStore 源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/DataStore?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1760">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/DataStore</a></p>\n</blockquote>',
          },
          {
            theme: '20 | View Model 架构：如何准备 UI 层的数据？',
            id: 35,
            content:
              '<p data-nodeid="1552" class="">UI 是 App 的重要组成部分，因为所有 App 都必须呈现 UI，并接收用户的事件。为了让 UI 能正确显示，我们需要把 Model 数据进行转换。例如，当我们显示图片的时候，需要把字符串类型的 URL 转换成 iOS 所支持 URL 类型；当显示时间信息时，需要把 UTC 时间值转换成设备所在的时区。</p>\n<p data-nodeid="1553">不过存在一个问题，如果我们把所有类型转换的逻辑都放在 UI/View 层里面，作为 View 层的 View Controller 往往会变得越来越臃肿。 为了避免这一情况，我使用了 MVVM 模式和 RxSwift 来架构 Moments App。MVVM 模式的核心部分是 ViewModel 模块，主要用于把 Model 转换成 UI/View 层所需的数据。为了简化转换的工作，我使用了 RxSwift 的操作符（Operator）。</p>\n<p data-nodeid="1554">所以，在这一讲中，我会和你介绍下 ViewModel 模式是怎样工作的，以及如何使用 RxSwift 里常用的操作符。</p>\n<h3 data-nodeid="1555">ViewModel 模式的架构</h3>\n<p data-nodeid="1556">首先我们以朋友圈功能为例，看看 ViewModel 模式的架构图。</p>\n<p data-nodeid="1557"><img src="https://s0.lgstatic.com/i/image6/M00/3C/0F/CioPOWCH7COAXcMTAAPT7Gr7yvg197.png" alt="Drawing 1.png" data-nodeid="1669"></p>\n<p data-nodeid="1558"><strong data-nodeid="1676">View 模块</strong>负责呈现 UI，并接收用户的事件。在朋友圈功能中，<code data-backticks="1" data-nodeid="1674">MomentsTimelineViewController</code>负责呈现朋友圈的时间轴列表。为了正确显示该页面，我们需要为它准备好一些的数据，例如朋友的名字，朋友头像的 URL 等等，那些数据可以从 ViewModel 模块中读取。</p>\n<p data-nodeid="1559"><strong data-nodeid="1691">ViewModel 模块</strong>是 MVVM 模式的核心，该模块由两个重要的协议所组成：<code data-backticks="1" data-nodeid="1681">ListViewModel</code>和<code data-backticks="1" data-nodeid="1683">ListItemViewModel</code>。其中<code data-backticks="1" data-nodeid="1685">ListViewModel</code>协议用于定义列表页面所需的 ViewModel，而<code data-backticks="1" data-nodeid="1687">ListItemViewModel</code>用于定义每一条列表项所需的 ViewModel。当他们需要读写数据时，会调用 Repository 模块。比如在朋友圈功能里面，它们都调用<code data-backticks="1" data-nodeid="1689">MoomentsRepoType</code>来读写数据。</p>\n<h3 data-nodeid="1560">ViewModel 模式的实现</h3>\n<p data-nodeid="1561">有了上述的架构图，我们就可以看看 ViewModel 模块是怎样实现的。首先看一下<code data-backticks="1" data-nodeid="1694">ListViewModel</code>协议的定义。</p>\n<pre class="lang-swift" data-nodeid="1562"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListViewModel</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">var</span> hasContent: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Bool</span>&gt; { <span class="hljs-keyword">get</span> }\n&nbsp; &nbsp; <span class="hljs-keyword">var</span> hasError: <span class="hljs-type">BehaviorSubject</span>&lt;<span class="hljs-type">Bool</span>&gt; { <span class="hljs-keyword">get</span> }\n&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackScreenviews</span><span class="hljs-params">()</span></span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadItems</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt;\n    <span class="hljs-keyword">var</span> listItems: <span class="hljs-type">BehaviorSubject</span>&lt;[<span class="hljs-type">SectionModel</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">ListItemViewModel</span>&gt;]&gt; { <span class="hljs-keyword">get</span> }\n}\n</code></pre>\n<p data-nodeid="1563">下面我们逐一介绍该协议的各个属性与方法。<code data-backticks="1" data-nodeid="1697">hasContent</code>属性用于通知 UI 是否有内容。例如，当 BFF 没有返回数据时，我们可以在页面上提示用户“目前还没有朋友圈信息，可以添加好友来查看更多的朋友圈信息”。</p>\n<p data-nodeid="1564">为了代码共享，我们为<code data-backticks="1" data-nodeid="1700">hasContent</code>属性提供了一个默认的实现，代码如下。</p>\n<pre class="lang-swift" data-nodeid="1565"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ListViewModel</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">var</span> hasContent: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Bool</span>&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> listItems\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .<span class="hljs-built_in">map</span>(\\.isEmpty)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .distinctUntilChanged()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .asObservable()\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="1566">这个方法使用<code data-backticks="1" data-nodeid="1703">map</code>和<code data-backticks="1" data-nodeid="1705">distinctUntilChanged</code>操作符来把<code data-backticks="1" data-nodeid="1707">listItems</code>转换成 Bool 类型的<code data-backticks="1" data-nodeid="1709">hasContent</code>。其中<code data-backticks="1" data-nodeid="1711">map</code>用于提取<code data-backticks="1" data-nodeid="1713">listItems</code>里的数组并检查是否为空，<code data-backticks="1" data-nodeid="1715">distinctUntilChanged</code>用来保证只有在值发生改变时才发送新事件。</p>\n<p data-nodeid="1567"><code data-backticks="1" data-nodeid="1717">hasError</code>属性是一个<code data-backticks="1" data-nodeid="1719">BehaviorSubject</code>，其初始值为<code data-backticks="1" data-nodeid="1721">false</code>。它用于通知 UI 是否需要显示错误信息。</p>\n<p data-nodeid="1568"><code data-backticks="1" data-nodeid="1723">trackScreenviews()</code>方法用于发送用户行为数据。而<code data-backticks="1" data-nodeid="1725">loadItems() -&gt; Observable&lt;Void&gt;</code>方法用于读取数据。</p>\n<p data-nodeid="1569">最后看一下<code data-backticks="1" data-nodeid="1728">listItems</code>属性。 该属性用于准备 TableView 所需的数据，其存放了类型为<code data-backticks="1" data-nodeid="1730">ListItemViewModel</code>的数据。<code data-backticks="1" data-nodeid="1732">ListItemViewModel</code>能为 TableView 的各个 Cell 提供所需数据。该协议只定义一个名为<code data-backticks="1" data-nodeid="1734">reuseIdentifier</code>的静态属性 ，如下所示。</p>\n<pre class="lang-swift" data-nodeid="1570"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemViewModel</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> reuseIdentifier: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }\n}\n<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ListItemViewModel</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> reuseIdentifier: <span class="hljs-type">String</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-type">String</span>(describing: <span class="hljs-keyword">self</span>)\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="1571"><code data-backticks="1" data-nodeid="1736">reuseIdentifier</code>属性作为 TableView Cell 的唯一标示，为了重用，我们通过协议扩展来为该属性提供一个默认的实现并把类型的名字作为字符串进行返回。<br>\n上述就是<code data-backticks="1" data-nodeid="1740">ListViewModel</code>协议的定义，接下来看它的实现结构体<code data-backticks="1" data-nodeid="1742">MomentsTimelineViewModel</code>。</p>\n<p data-nodeid="1572">由于<code data-backticks="1" data-nodeid="1745">MomentsTimelineViewModel</code>遵循了<code data-backticks="1" data-nodeid="1747">ListViewModel</code>协议，因此需要实现了该协议中<code data-backticks="1" data-nodeid="1749">listItems</code>和<code data-backticks="1" data-nodeid="1751">hasError</code>属性以及<code data-backticks="1" data-nodeid="1753">loadItems()</code>和<code data-backticks="1" data-nodeid="1755">trackScreenviews()</code>方法。我们首先看一下<code data-backticks="1" data-nodeid="1757">loadItems()</code>方法的实现。</p>\n<pre class="lang-swift" data-nodeid="1573"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadItems</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n    <span class="hljs-keyword">return</span> momentsRepo.getMoments(userID: userID)\n}\n</code></pre>\n<p data-nodeid="1574">当 ViewModel 需要读取数据的时候，会调用 Repository 模块的组件，在朋友圈功能中，我们调用了<code data-backticks="1" data-nodeid="1760">MomentsRepoType</code>的<code data-backticks="1" data-nodeid="1762">getMoments()</code>方法来读取数据。</p>\n<p data-nodeid="1575">接着看看<code data-backticks="1" data-nodeid="1765">trackScreenviews()</code>方法的实现。在该方法里面，我们调用了<code data-backticks="1" data-nodeid="1767">TrackingRepoType</code>的<code data-backticks="1" data-nodeid="1769">trackScreenviews()</code>方法来发送用户的行为数据，具体实现如下。</p>\n<pre class="lang-swift" data-nodeid="1576"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackScreenviews</span><span class="hljs-params">()</span></span> {\n    trackingRepo.trackScreenviews(<span class="hljs-type">ScreenviewsTrackingEvent</span>(screenName: <span class="hljs-type">L10n</span>.<span class="hljs-type">Tracking</span>.momentsScreen, screenClass: <span class="hljs-type">String</span>(describing: <span class="hljs-keyword">self</span>)))\n }\n</code></pre>\n<p data-nodeid="1577"><strong data-nodeid="1775">ViewModel 模块的一个核心功能，是把 Model 数据转换为用于 UI 呈现所需的 ViewModel 数据</strong>，我通过下面代码看它是怎样转换的。</p>\n<pre class="lang-swift" data-nodeid="1578"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupBindings</span><span class="hljs-params">()</span></span> {\n momentsRepo.momentsDetails\n     .<span class="hljs-built_in">map</span> {\n         [<span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: $<span class="hljs-number">0</span>.userDetails)]\n             + $<span class="hljs-number">0</span>.moments.<span class="hljs-built_in">map</span> { <span class="hljs-type">MomentListItemViewModel</span>(moment: $<span class="hljs-number">0</span>) }\n     }\n     .subscribe(onNext: {\n         listItems.onNext([<span class="hljs-type">SectionModel</span>(model: <span class="hljs-string">""</span>, items: $<span class="hljs-number">0</span>)])\n     }, onError: { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>\n         hasError.onNext(<span class="hljs-literal">true</span>)\n     })\n     .disposed(by: disposeBag)\n}\n</code></pre>\n<p data-nodeid="1579">从代码中你可以发现，我们订阅了<code data-backticks="1" data-nodeid="1777">momentsRepo</code>的<code data-backticks="1" data-nodeid="1779">momentsDetails</code>属性，接收来自 Model 的数据更新。因为该属性的类型是<code data-backticks="1" data-nodeid="1781">MomentsDetails</code>，而 View 层用所需的数据类型为<code data-backticks="1" data-nodeid="1783">ListItemViewModel</code>。我们通过 map 操作符来进行类型转换，在转换成功后，调用<code data-backticks="1" data-nodeid="1785">listItems</code>的<code data-backticks="1" data-nodeid="1787">onNext()</code>方法把准备好的 ViewModel 数据发送给 UI。如果发生错误，就通过<code data-backticks="1" data-nodeid="1789">hasError</code>属性发送出错信息。</p>\n<p data-nodeid="1580">在 map 操作符的转换过程中，我们分别使用了<code data-backticks="1" data-nodeid="1792">UserProfileListItemViewModel</code>和<code data-backticks="1" data-nodeid="1794">MomentListItemViewModel</code>结构体来转换用户简介信息和朋友圈条目信息。这两个结构体都遵循了<code data-backticks="1" data-nodeid="1796">ListItemViewModel</code>协议。</p>\n<p data-nodeid="1581">接下来是它们的实现，首先看一下<code data-backticks="1" data-nodeid="1799">UserProfileListItemViewModel</code>。</p>\n<pre class="lang-swift" data-nodeid="1582"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserProfileListItemViewModel</span>: <span class="hljs-title">ListItemViewModel</span> </span>{\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> avatarURL: <span class="hljs-type">URL?</span>\n&nbsp; &nbsp; <span class="hljs-keyword">let</span> backgroundImageURL: <span class="hljs-type">URL?</span>\n&nbsp; &nbsp; <span class="hljs-keyword">init</span>(userDetails: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-type">UserDetails</span>) {\n&nbsp; &nbsp; &nbsp; &nbsp; name = userDetails.name\n&nbsp; &nbsp; &nbsp; &nbsp; avatarURL = <span class="hljs-type">URL</span>(string: userDetails.avatar)\n&nbsp; &nbsp; &nbsp; &nbsp; backgroundImageURL = <span class="hljs-type">URL</span>(string: userDetails.backgroundImage)\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="1583">该结构体只包含了三个属性：<code data-backticks="1" data-nodeid="1802">name</code>、<code data-backticks="1" data-nodeid="1804">avatarURL</code>和<code data-backticks="1" data-nodeid="1806">backgroundImageURL</code>。</p>\n<p data-nodeid="1584">其中，由于<code data-backticks="1" data-nodeid="1809">name</code>属性的类型与<code data-backticks="1" data-nodeid="1811">MomentsDetails.UserDetails</code>中<code data-backticks="1" data-nodeid="1813">name</code>属性的类型都是字符串，我们只需要直接赋值就可以了。</p>\n<p data-nodeid="1585">而<code data-backticks="1" data-nodeid="1816">avatarURL</code>和<code data-backticks="1" data-nodeid="1818">backgroundImageURL</code>用于在 UI 上显示图片。因为 BFF 返回的 URL 值都是字符串类型，我们需要把字符串转换成<code data-backticks="1" data-nodeid="1820">URL</code>类型。所有的转换工作我都放在<code data-backticks="1" data-nodeid="1822">init(userDetails: MomentsDetails.UserDetails)</code>方法里面完成，我们只需要调用<code data-backticks="1" data-nodeid="1824">URL</code>的初始化函数即可。</p>\n<p data-nodeid="1586">接着看一下<code data-backticks="1" data-nodeid="1827">MomentListItemViewModel</code>结构体，它也是负责把 Model 的数据类型转换成用于 View 层显示 UI 的 ViewModel 数据。其转换的逻辑也封装在<code data-backticks="1" data-nodeid="1829">init()</code>方法中，我们一起看看该方法是如何工作的。</p>\n<pre class="lang-swift" data-nodeid="1587"><code data-language="swift"><span class="hljs-keyword">init</span>(moment: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-type">Moment</span>, now: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>(), relativeDateTimeFormatter: <span class="hljs-type">RelativeDateTimeFormatterType</span> = <span class="hljs-type">RelativeDateTimeFormatter</span>()) {\n&nbsp; &nbsp; userAvatarURL = <span class="hljs-type">URL</span>(string: moment.userDetails.avatar)\n&nbsp; &nbsp; userName = moment.userDetails.name\n&nbsp; &nbsp; title = moment.title\n\n&nbsp; &nbsp; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> firstPhoto = moment.photos.first {\n&nbsp; &nbsp; &nbsp; &nbsp; photoURL = <span class="hljs-type">URL</span>(string: firstPhoto)\n&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; photoURL = <span class="hljs-literal">nil</span>\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class="hljs-keyword">var</span> formatter = relativeDateTimeFormatter\n&nbsp; &nbsp; formatter.unitsStyle = .full\n&nbsp; &nbsp; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> timeInterval = <span class="hljs-type">TimeInterval</span>(moment.createdDate) {\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> createdDate = <span class="hljs-type">Date</span>(timeIntervalSince1970: timeInterval)\n&nbsp; &nbsp; &nbsp; &nbsp; postDateDescription = formatter.localizedString(<span class="hljs-keyword">for</span>: createdDate, relativeTo: now)\n&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {\n&nbsp; &nbsp; &nbsp; &nbsp; postDateDescription = <span class="hljs-literal">nil</span>\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p data-nodeid="1588"><code data-backticks="1" data-nodeid="1831">userName</code>和<code data-backticks="1" data-nodeid="1833">title</code>属性都是字符串类型，只需要简单的赋值就可以了。而<code data-backticks="1" data-nodeid="1835">userAvatarURL</code>和<code data-backticks="1" data-nodeid="1837">photoURL</code>属性需要把字符串转换为<code data-backticks="1" data-nodeid="1839">URL</code>类型来呈现图片。</p>\n<p data-nodeid="1589"><code data-backticks="1" data-nodeid="1841">postDateDescription</code>属性相对复杂些，它的用途是显示一个相对的时间值，例如 “5 分钟前”“2 小时前”等。我们需要把朋友圈信息生成的时间与当前时间进行对比，然后根据手机上的语言配置来显示相对时间值。</p>\n<h3 data-nodeid="1590">RxSwift 操作符</h3>\n<p data-nodeid="1591">ViewModel 的核心功能是把 Model 数据转换为用于 UI 呈现所需的数据。其实<strong data-nodeid="1849">RxSwift 的操作符就是负责转换的，使用合适的操作符能帮我们减少代码量并提高生产力</strong>。因此我建议你把 RxSwift 所提供的所有操作符都看一遍，然后在实际工作再挑选合适的来满足业务需求。</p>\n<p data-nodeid="1592">在这里，我着重介绍下过<strong data-nodeid="1855">滤操作符，转换操作符和合并操作符</strong>中常用的 filter、distinctUntilChanged、map 和 combineLatest 等用法。</p>\n<h4 data-nodeid="1593">过滤操作符</h4>\n<p data-nodeid="1594">过滤操作符用于过滤事件，我们可以使用过滤操作符把订阅者不关心的事件给过滤掉。常用的过滤操作符有 filter 和 distinctUntilChanged。</p>\n<p data-nodeid="1595"><strong data-nodeid="1862">filter</strong>操作符常用于通过规则过滤不需要的事件，例如在朋友圈功能里面，可以把发布时间早于一天前的信息过滤掉不显示。为了方便理解，我就以几个数字来解释下。如下所示，有 2、23、5、60、1、31，我想把小于 10 的数过滤掉，就可以通过 filter 设置过滤规则，然后打印出来的数字就是 23、 60、31。代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1596"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-number">2</span>, <span class="hljs-number">23</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, <span class="hljs-number">1</span>, <span class="hljs-number">31</span>)\n  &nbsp; .<span class="hljs-built_in">filter</span> { $<span class="hljs-number">0</span> &gt; <span class="hljs-number">10</span> }\n  &nbsp; .subscribe(onNext: {\n  &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n  &nbsp; })\n  &nbsp; .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1597"><img src="https://s0.lgstatic.com/i/image6/M01/3C/06/Cgp9HWCH7E6AcOAxAAD0m4P1ZAs382.png" alt="Drawing 3.png" data-nodeid="1865"></p>\n<div data-nodeid="1598"><p style="text-align:center">过滤操作符 filter 的效果</p></div>\n<p data-nodeid="1599"><strong data-nodeid="1870">distinctUntilChanged</strong>用于把相同的事件过滤掉。如下面例子中的第二个 1 和第四个 2，使用distinctUntilChanged 就可以把它们给过滤掉，然后打印出 1、 2、 1。代码和图例如下所示。</p>\n<pre class="lang-swift" data-nodeid="1600"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)\n    .distinctUntilChanged()\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1601"><img src="https://s0.lgstatic.com/i/image6/M01/3C/06/Cgp9HWCH7Q-AVcVjAAEFCx3nsK4458.png" alt="Drawing 5.png" data-nodeid="1873"></p>\n<div data-nodeid="1602"><p style="text-align:center">过滤操作符 distinctUntilChanged 的效果</p></div>\n<p data-nodeid="1603">除了相同的事件，我们还可以使用操作符<strong data-nodeid="1879">distinctUntilChanged</strong>过滤掉相同的状态，从而避免频繁更新 UI。例如，我们先使用本地缓存数据呈现 UI，然后发起网络请求。当请求成功以后可以把结果数据与缓存进行对比，如果数据一致就没必要再次更新 UI。</p>\n<h4 data-nodeid="1604">转换操作符</h4>\n<p data-nodeid="1605">转换操作符非常实用，能帮助我们从一种数据类型转变成另外一种类型，例如我们可以把用于数据传输和存储的 Model 类型转换成用于 UI 呈现的 ViewModel 类型。在这里，我就以几个常用的转换操作符 map，compactMap 和 flapMap 来介绍下如何使用它们。</p>\n<p data-nodeid="1606"><strong data-nodeid="1894">map</strong>是一个十分常用的操作符，可用于从一种类型转换成另外一种类型，例如下面的例子，我把数值类型转换成字符串。程序执行的时候会打印 "String: 1" 和 "String: 2"。代码和图例如下所示。</p>\n<pre class="lang-swift" data-nodeid="1607"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n    .<span class="hljs-built_in">map</span> { <span class="hljs-string">"String: "</span> + <span class="hljs-type">String</span>($<span class="hljs-number">0</span>) }\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1608"><img src="https://s0.lgstatic.com/i/image6/M01/3C/07/Cgp9HWCH7R6ASEB0AAD5Z_BYeoQ092.png" alt="Drawing 7.png" data-nodeid="1897"></p>\n<div data-nodeid="1609"><p style="text-align:center">转换操作符 map 的效果</p></div>\n<p data-nodeid="1610"><strong data-nodeid="1906">compactMap</strong>常用于过滤掉值为<code data-backticks="1" data-nodeid="1902">nil</code>的操作符，你可以把 compactMap 理解为同时使用 filter 和 map 的两个操作符。filter 把<code data-backticks="1" data-nodeid="1904">nil</code>的值过滤掉，而 map 把非空的值进行转换。</p>\n<p data-nodeid="1611">例如下面的例子中，我把字符串的值转换为数值类型，并把转换不成功的值过滤掉。由于 "not-a-number" 不能转换成数值类型，因此被过滤掉了，执行的时候会打印 1 和 2。代码示例如下所示：</p>\n<pre class="lang-swift" data-nodeid="1612"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-string">"1"</span>, <span class="hljs-string">"not-a-number"</span>, <span class="hljs-string">"2"</span>)\n    .<span class="hljs-built_in">compactMap</span> { <span class="hljs-type">Int</span>($<span class="hljs-number">0</span>) }\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1613"><img src="https://s0.lgstatic.com/i/image6/M01/3C/0F/CioPOWCH7SeAfVeYAAEfEP1ULSY822.png" alt="Drawing 9.png" data-nodeid="1914"></p>\n<div data-nodeid="1614"><p style="text-align:center">转换操作符 compactMap 效果</p></div>\n<p data-nodeid="1615"><strong data-nodeid="1919">flatMap</strong>用于把两层的 Observable 序列合并到一层。我们通过一个例子来解析到底怎样合并。</p>\n<p data-nodeid="1616">请看代码示例：</p>\n<pre class="lang-swift" data-nodeid="1617"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TemperatureSensor</span> </span>{\n  <span class="hljs-keyword">let</span> temperature: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Int</span>&gt;\n}\n<span class="hljs-keyword">let</span> sensor1 = <span class="hljs-type">TemperatureSensor</span>(temperature: <span class="hljs-type">Observable</span>.of(<span class="hljs-number">21</span>, <span class="hljs-number">23</span>))\n<span class="hljs-keyword">let</span> sensor2 = <span class="hljs-type">TemperatureSensor</span>(temperature: <span class="hljs-type">Observable</span>.of(<span class="hljs-number">22</span>, <span class="hljs-number">25</span>))\n<span class="hljs-type">Observable</span>.of(sensor1, sensor2)\n    .flatMap { $<span class="hljs-number">0</span>.temperature }\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1618">在这个例子中，我定义一个叫作<code data-backticks="1" data-nodeid="1922">TemperatureSensor</code>的结构体，用来表示收集温度的传感器，该结构体包含了一个类型为<code data-backticks="1" data-nodeid="1924">Observable</code>的<code data-backticks="1" data-nodeid="1926">temperature</code>的属性。</p>\n<p data-nodeid="1619">假如天气站有多个这样的传感器，我们要把它们的温度信息合并到一个单独的 Observable 序列中方便统计，此时就可以使用 flatMap 来完成这项任务。</p>\n<p data-nodeid="1620">具体来说，我们在<code data-backticks="1" data-nodeid="1930">flatMap</code>方法的闭包里面返回<code data-backticks="1" data-nodeid="1932">temperature</code>属性，由于该属性是一个<code data-backticks="1" data-nodeid="1934">Observable</code>对象，因此<code data-backticks="1" data-nodeid="1936">flatMap</code>方法会把这些序列统一合并到一个单独的 Observable 序列里面，并打印出 21、23、22、25。</p>\n<p data-nodeid="1621"><img src="https://s0.lgstatic.com/i/image6/M01/3C/0F/CioPOWCH7TKAWC3hAAEPlMCt_uM223.png" alt="Drawing 11.png" data-nodeid="1940"></p>\n<div data-nodeid="1622"><p style="text-align:center">转换操作符 flatMap 的效果</p></div>\n<h4 data-nodeid="1623">合并操作符</h4>\n<p data-nodeid="1624">合并操作符用于组装与合并多个 Observable 序列。我们通过 startWith，concat 和 merge 等几个常用的合并操作符，来看看它们是怎样运作的。</p>\n<p data-nodeid="1625"><strong data-nodeid="1949">startWith</strong>可以使订阅者在接收到 Observable 序列的事件前，先收到传给 startWith 方法的事件。它的使用非常简单，例如在下面的例子中，我们把 3 和 4 传递给<code data-backticks="1" data-nodeid="1947">startWith</code>。那么在执行过程中，会先把 3 和 4 事件发送给订阅者，其运行效果为 3、4、1、2。代码示例如下：</p>\n<pre class="lang-swift" data-nodeid="1626"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n    .startWith(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1627"><img src="https://s0.lgstatic.com/i/image6/M01/3C/0F/CioPOWCH7USAKIvoAADtwXiN318148.png" alt="Drawing 13.png" data-nodeid="1952"></p>\n<div data-nodeid="1628"><p style="text-align:center">合并操作符 startWith 效果</p></div>\n<p data-nodeid="1629"><strong data-nodeid="1961">日常中我们可以通过</strong><code data-backticks="1" data-nodeid="1956">startWith</code>方法，把加载事件插入网络数据事件之前，以此<strong data-nodeid="1962">来保持 UI 状态的自动更新。</strong></p>\n<p data-nodeid="1630"><strong data-nodeid="1967">concat</strong>能把多个 Observable 序列按顺序合并在一起。例如，在下面的例子中我们合并了两个 Observable 序列，第一个包含 1 和 2，第二个包含 3 和 4，那么执行的时候会打印 1、2、3、4。代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1631"><code data-language="swift"><span class="hljs-type">Observable</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n    .concat(<span class="hljs-type">Observable</span>.of(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\n</code></pre>\n<p data-nodeid="1632"><img src="https://s0.lgstatic.com/i/image6/M00/3C/0F/CioPOWCH7VeAeMD5AACnQDe-5Nk532.png" alt="Drawing 15.png" data-nodeid="1970"></p>\n<div data-nodeid="1633"><p style="text-align:center">合并操作符 concat  效果</p></div>\n<p data-nodeid="1634"><strong data-nodeid="1975">merge</strong>，常用于合并多个 Observable 序列的操作符，和 concat 不一样的地方是它能保持原来事件的顺序。我们可以通过一个例子来看看，它是怎样合并 Observable 序列的。代码示例如下：</p>\n<pre class="lang-swift" data-nodeid="1635"><code data-language="swift"><span class="hljs-keyword">let</span> first = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">Int</span>&gt;()\n<span class="hljs-keyword">let</span> second = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">Int</span>&gt;()\n<span class="hljs-type">Observable</span>.of(first, second)\n    .merge()\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\nfirst.onNext(<span class="hljs-number">1</span>)\nfirst.onNext(<span class="hljs-number">2</span>)\nsecond.onNext(<span class="hljs-number">11</span>)\nfirst.onNext(<span class="hljs-number">3</span>)\nsecond.onNext(<span class="hljs-number">12</span>)\nsecond.onNext(<span class="hljs-number">13</span>)\nfirst.onNext(<span class="hljs-number">4</span>)\n</code></pre>\n<p data-nodeid="1636">我们调用<code data-backticks="1" data-nodeid="1977">merge</code>方法把两个 PublishSubject 合并在一起，然后不同的 PublishSubject 会分别发出不同的<code data-backticks="1" data-nodeid="1979">next</code>事件，订阅者根据事件发生的顺序来接收到相关事件。如下图所示，程序执行时会打印 1、2、11、3、12、13、4。<br>\n<img src="https://s0.lgstatic.com/i/image6/M00/3C/0F/CioPOWCH7W6AOGypAAEmk4CaMh0083.png" alt="Drawing 17.png" data-nodeid="1984"></p>\n<div data-nodeid="1637"><p style="text-align:center">合并操作符 merge 的效果</p></div>\n<p data-nodeid="1638"><strong data-nodeid="1989">combineLatest</strong>会把两个 Observable 序列里最后的事件合并起来，代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1639"><code data-language="swift"><span class="hljs-keyword">let</span> first = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">String</span>&gt;()\n<span class="hljs-keyword">let</span> second = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">String</span>&gt;()\n<span class="hljs-type">Observable</span>.combineLatest(first, second) { $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span> }\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\nfirst.onNext(<span class="hljs-string">"1"</span>)\nsecond.onNext(<span class="hljs-string">"a"</span>)\nfirst.onNext(<span class="hljs-string">"2"</span>)\nsecond.onNext(<span class="hljs-string">"b"</span>)\nsecond.onNext(<span class="hljs-string">"c"</span>)\nfirst.onNext(<span class="hljs-string">"3"</span>)\nfirst.onNext(<span class="hljs-string">"4"</span>)\n</code></pre>\n<p data-nodeid="1640">在程序执行过程中，当其中一个 PublishSubject 发出<code data-backticks="1" data-nodeid="1991">next</code>事件时，就会从另外一个 PublishSubject 取出其最后一个事件，然后调用<code data-backticks="1" data-nodeid="1993">combineLatest</code>方法的闭包，把这两个事件合并起来并通知订阅者。上述的例子在执行时会打印 1a、2a、2b、2c、3c、4c。</p>\n<p data-nodeid="1641"><img src="https://s0.lgstatic.com/i/image6/M00/3C/0F/CioPOWCH7X6AJXQvAAEo9AcsIGo039.png" alt="Drawing 19.png" data-nodeid="1997"></p>\n<div data-nodeid="1642"><p style="text-align:center">合并操作符 combineLatest</p></div>\n<p data-nodeid="1643">在实际开发中，<code data-backticks="1" data-nodeid="1999">combineLatest</code>方法非常实用。我们可以用它来监听多个 Observable 序列，然后组合起来统一更新状态。例如在一个登录页面里面，我们可以同时监听用户名和密码两个输入框，当它们同时有值的时候才激活登录按钮。</p>\n<p data-nodeid="1644"><strong data-nodeid="2005">zip</strong>也能用于合并两个 Observable 序列，和 combineLatest 不一样的地方是， zip 只会把两个 Observable 序列的事件配对合并。就像两队小朋友，排在前头的手牵手来到一个新队列。一旦出来就不再留在原有队列了。</p>\n<p data-nodeid="1645">为了方便理解 zip 与 combineLatest 的区别，我在下面例子中也使用了一样的数据并保持事件发送的顺序。</p>\n<pre class="lang-swift" data-nodeid="1646"><code data-language="swift"><span class="hljs-keyword">let</span> first = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">String</span>&gt;()\n<span class="hljs-keyword">let</span> second = <span class="hljs-type">PublishSubject</span>&lt;<span class="hljs-type">String</span>&gt;()\n<span class="hljs-type">Observable</span>.<span class="hljs-built_in">zip</span>(first, second) { $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span> }\n    .subscribe(onNext: {\n        <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)\n    })\n    .disposed(by: disposeBag)\nfirst.onNext(<span class="hljs-string">"1"</span>)\nsecond.onNext(<span class="hljs-string">"a"</span>)\nfirst.onNext(<span class="hljs-string">"2"</span>)\nsecond.onNext(<span class="hljs-string">"b"</span>)\nsecond.onNext(<span class="hljs-string">"c"</span>)\nfirst.onNext(<span class="hljs-string">"3"</span>)\nfirst.onNext(<span class="hljs-string">"4"</span>)\n</code></pre>\n<p data-nodeid="3066">在上述的例子中，有两个 PublishSubject，其中<code data-backticks="1" data-nodeid="3070">first</code>发出 1、2、3、4，而<code data-backticks="1" data-nodeid="3072">second</code>发出 a、b、c。<code data-backticks="1" data-nodeid="3074">zip</code>方法会返回它们的合并事件 1a、2b、3c。由于<code data-backticks="1" data-nodeid="3076">first</code>所发出<code data-backticks="1" data-nodeid="3078">next("4")</code>事件没有在<code data-backticks="1" data-nodeid="3080">second</code>里面找到对应的事件，所以合并后的 Observable 序列只有三个事件。</p>\n<p data-nodeid="4099" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3C/9B/Cgp9HWCLocCASVLAAAEE-3Z6-aU135.png" alt="图片5.png" data-nodeid="4102"></p><p style="text-align:center">合并操作符 zip 的效果</p><p></p>\n\n\n\n\n\n\n<p data-nodeid="1650" class="">上面是常用的操作符，灵活使用它们，我们可以完成绝大部分的任务了。</p>\n<h3 data-nodeid="1651" class="">总结</h3>\n<p data-nodeid="1652">在这一讲中，我们介绍了 ViewModel 模式的架构与实现和 RxSwift 的操作符。有了 ViewModel，我们可以把业务逻辑从 View 层抽离出来，甚至把 View 层进行替换，例如把 UIKit 替换成 SwiftUI。而 UI 所需的数据，可以通过 ViewModel 模块把 Model 数据转换出来。至于转换工作，我们可以借助操作符来完成。</p>\n<p data-nodeid="1653">有关本讲操作符的例子代码，我都放在项目中的<strong data-nodeid="2031">RxSwift Playground 文件</strong>里面，希望你能多练习，灵活运用。</p>\n<p data-nodeid="1654">RxSwift 为我们提供了 50 多个操作符，我建议你到 rxmarbles.com 或者到 App Store 下载 RxMarbles App，并在 App 中替换各种参数来观察执行的结果，这样能帮助你学会所有的操作符，在现实工作中能选择合适的操作符来简化大量的开发工作。</p>\n<p data-nodeid="1655"><strong data-nodeid="2036">思考题</strong></p>\n<blockquote data-nodeid="1656">\n<p data-nodeid="1657">请问你会把所有逻辑都编写在 ViewController 里面吗？如果没有，使用了怎样模式与架构来解耦呢？能分享一下这方面的经验吗？</p>\n</blockquote>\n<p data-nodeid="1658">请把你的想法写到留言区哦，下一讲我将介绍如何开发统一并且灵活的 UI。</p>\n<p data-nodeid="1659"><strong data-nodeid="2042">源码地址：</strong></p>\n<blockquote data-nodeid="1660">\n<p data-nodeid="1661" class="">RxSwift Playground 文件地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2047">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift</a><br>\nViewModel 协议定义的源码地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/ViewModels?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2052">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/ViewModels</a><br>\n朋友圈功能 ViewModel 实现的源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/ViewModels?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2058">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/ViewModels</a></p>\n</blockquote>',
          },
          {
            theme: '21 | UI 层架构：如何开发统一并且灵活的 UI？',
            id: 36,
            content:
              '<p data-nodeid="1522" class="">作为 iOS 开发者，我们每天都花大量的时间来开发和调试 UI，那有没有什么办法帮助我们把繁杂的 UI 开发工作简化成有章可循的步骤，从而提高开发的效率呢？在这一讲中，我就和你聊聊，如何架构和开发一套灵活的 UI 框架。</p>\n<h3 data-nodeid="1523">通用列表 UI 模块的架构与实现</h3>\n<p data-nodeid="1524">列表 UI 是 App 最为常用的 UI 页面，它可以帮我们通过滚动的方式支持无限的内容。为了简化大量的重复性劳动，我在 Moments App 架构实现了一个通用的列表 UI 模块。下面是这个模块的架构图。</p>\n<p data-nodeid="1525"><img src="https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1DiANqbhAAMguDPxTIw094.png" alt="图片1.png" data-nodeid="1641"><br>\n这个框架使用了<code data-backticks="1" data-nodeid="1644">UIViewController</code>和<code data-backticks="1" data-nodeid="1646">UITableView</code>来封装列表页面。其核心是<code data-backticks="1" data-nodeid="1648">BaseTableViewController</code>。<code data-backticks="1" data-nodeid="1650">BaseTableViewController</code>继承于<code data-backticks="1" data-nodeid="1652">BaseViewController</code>，而<code data-backticks="1" data-nodeid="1654">BaseViewController</code>继承自<code data-backticks="1" data-nodeid="1656">UIViewController</code>。</p>\n<p data-nodeid="1526">我们先看看<code data-backticks="1" data-nodeid="1659">BaseViewController</code>的具体实现，代码示例如下。</p>\n<pre class="lang-swift" data-nodeid="1527"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewController</span>: <span class="hljs-title">UIViewController</span> </span>{\n    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">init</span>() {\n      <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)\n    }\n    <span class="hljs-meta">@available</span>(*, unavailable, message: <span class="hljs-string">"We don\'t support init view controller from a nib."</span>)\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(nibName nibNameOrNil: <span class="hljs-type">String?</span>, bundle nibBundleOrNil: <span class="hljs-type">Bundle?</span>) {\n        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n    }\n    <span class="hljs-meta">@available</span>(*, unavailable, message: <span class="hljs-string">"We don\'t support init view controller from a nib."</span>)\n    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>?(coder: <span class="hljs-type">NSCoder</span>) {\n        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorInitCoderNotImplemented)\n    }\n}\n</code></pre>\n<p data-nodeid="1528">因为 Moments App 是使用纯代码的方式来编写 UI，所以<code data-backticks="1" data-nodeid="1662">BaseViewController</code>重写了<code data-backticks="1" data-nodeid="1664">init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code>和<code data-backticks="1" data-nodeid="1666">init?(coder: NSCoder)</code>两个方法，并直接抛出异常。这样做使得所有继承<code data-backticks="1" data-nodeid="1668">BaseViewController</code>的子类，都没办法通过 Storyboard 或者 Xib 文件来生成 ViewController 的实例。因为我们使用 RxSwift，<code data-backticks="1" data-nodeid="1670">BaseViewController</code>还定义了一个<code data-backticks="1" data-nodeid="1672">disposeBag</code>属性来方便管理所有 Obervable 序列的订阅。</p>\n<p data-nodeid="1529"><code data-backticks="1" data-nodeid="1674">BaseTableViewController</code>继承了<code data-backticks="1" data-nodeid="1676">BaseViewController</code>，并使用<code data-backticks="1" data-nodeid="1678">UITableView</code>来封装一个通用的列表页面。我们一起看看它是怎样实现的。</p>\n<p data-nodeid="1530">在 MVVM 模式里，View 依赖于 ViewModel。作为 View 的<code data-backticks="1" data-nodeid="1681">BaseTableViewController</code>依赖于 ViewModel 层的<code data-backticks="1" data-nodeid="1683">ListViewModel</code>协议，这使得<code data-backticks="1" data-nodeid="1685">BaseTableViewController</code>只依赖于接口而不是具体的类型，从而提高了程序的可扩展性。</p>\n<p data-nodeid="1531">同时，<code data-backticks="1" data-nodeid="1688">BaseTableViewController</code>还定义了三个属性来显示 UI 控件：</p>\n<ul data-nodeid="1532">\n<li data-nodeid="1533">\n<p data-nodeid="1534"><code data-backticks="1" data-nodeid="1690">tableView</code>属性用于显示一个 TableView；</p>\n</li>\n<li data-nodeid="1535">\n<p data-nodeid="1536"><code data-backticks="1" data-nodeid="1692">activityIndicatorView</code>属性用于显示俗称小菊花的加载器；</p>\n</li>\n<li data-nodeid="1537">\n<p data-nodeid="1538"><code data-backticks="1" data-nodeid="1694">errorLabel</code>用于显示出错信息的标签控件。</p>\n</li>\n</ul>\n<p data-nodeid="1539">以下是属性定义的代码示例。</p>\n<pre class="lang-swift" data-nodeid="1540"><code data-language="swift"><span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">ListViewModel!</span>\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> tableView: <span class="hljs-type">UITableView</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.separatorStyle = .<span class="hljs-keyword">none</span>\n    $<span class="hljs-number">0</span>.rowHeight = <span class="hljs-type">UITableView</span>.automaticDimension\n    $<span class="hljs-number">0</span>.estimatedRowHeight = <span class="hljs-number">100</span>\n    $<span class="hljs-number">0</span>.contentInsetAdjustmentBehavior = .never\n    $<span class="hljs-number">0</span>.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background\n}\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> activityIndicatorView: <span class="hljs-type">UIActivityIndicatorView</span> = configure(.<span class="hljs-keyword">init</span>(style: .large)) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n}\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> errorLabel: <span class="hljs-type">UILabel</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.isHidden = <span class="hljs-literal">true</span>\n    $<span class="hljs-number">0</span>.textColor = <span class="hljs-type">UIColor</span>.designKit.primaryText\n    $<span class="hljs-number">0</span>.text = <span class="hljs-type">L10n</span>.<span class="hljs-type">MomentsList</span>.errorMessage\n}\n</code></pre>\n<p data-nodeid="1541">为了方便初始化 UIKit 的控件，我写了一个公共的<code data-backticks="1" data-nodeid="1698">configure()</code>方法，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="1542"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">configure</span>&lt;T: AnyObject&gt;<span class="hljs-params">(<span class="hljs-number">_</span> object: T, closure: <span class="hljs-params">(T)</span></span></span> -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">T</span> {\n    closure(object)\n    <span class="hljs-keyword">return</span> object\n}\n</code></pre>\n<p data-nodeid="1543">有了该方法，我们就可以把所有初始化操作都放在一个闭包（Closure）里面，方便代码的维护。</p>\n<p data-nodeid="1544">接着我们看一下<code data-backticks="1" data-nodeid="1702">setupUI()</code>方法的代码实现。</p>\n<pre class="lang-swift" data-nodeid="1545"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {\n    view.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background\n    tableViewCellsToRegister.forEach {\n        tableView.register($<span class="hljs-number">0</span>.value, forCellReuseIdentifier: $<span class="hljs-number">0</span>.key)\n    }\n    [tableView, activityIndicatorView, errorLabel].forEach {\n        view.addSubview($<span class="hljs-number">0</span>)\n    }\n}\n</code></pre>\n<p data-nodeid="1546">该方法负责设置 UI 的样式，例如设置背景颜色，注册 TableView Cell 和添加子控件。</p>\n<p data-nodeid="1547">配置完 UI 的样式以后，下一步是配置自动布局的约束（Auto Layout Constraint）。当使用 UIKit 作为 View 层的时候，我推荐使用苹果公司所推荐的<strong data-nodeid="1710">自动布局</strong>来排版 UI 页面。</p>\n<p data-nodeid="1548">自动布局能帮助我们支持不同分辨率和屏幕对比率的页面，而且苹果公司每年都在不断优化自动布局引擎的性能。不过，它也有一个缺点，那就是手写自动布局的约束代码会十分冗长，为此我使用一个名叫<strong data-nodeid="1718">SnapKit 的库</strong>来进行简化。下面我们就通过<code data-backticks="1" data-nodeid="1716">setupConstraints()</code>的代码，来看看 SnapKit 的威力。</p>\n<pre class="lang-swift" data-nodeid="1549"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {\n    tableView.snp.makeConstraints {\n        $<span class="hljs-number">0</span>.edges.equalToSuperview()\n    }\n    activityIndicatorView.snp.makeConstraints {\n        $<span class="hljs-number">0</span>.center.equalToSuperview()\n    }\n    errorLabel.snp.makeConstraints {\n        $<span class="hljs-number">0</span>.center.equalToSuperview()\n    }\n}\n</code></pre>\n<p data-nodeid="1550">如上述代码所示，当使用 SnapKit 来配置自动布局的约束时，我们需要调用它的扩展方法<code data-backticks="1" data-nodeid="1720">makeConstraints</code>，然后把所有约束的配置都放到闭包里面。在这里，我是通过<code data-backticks="1" data-nodeid="1722">edges.equalToSuperview()</code>把<code data-backticks="1" data-nodeid="1724">tableView</code>延伸到它的父组件（也就是<code data-backticks="1" data-nodeid="1726">BaseTableViewController</code>的<code data-backticks="1" data-nodeid="1728">view</code>）中，然后通过<code data-backticks="1" data-nodeid="1730">center.equalToSuperview()</code>方法把<code data-backticks="1" data-nodeid="1732">activityIndicatorView</code>和<code data-backticks="1" data-nodeid="1734">errorLabel</code>都分别居中。</p>\n<p data-nodeid="1551">假如不使用 SnapKit，要完成延伸<code data-backticks="1" data-nodeid="1737">tableView</code>的操作，就需要以下的代码。</p>\n<pre class="lang-swift" data-nodeid="1552"><code data-language="swift"><span class="hljs-type">NSLayoutConstraint</span>.activate([\n    tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n    tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor),\n    tableView.topAnchor.constraint(equalTo: view.topAnchor),\n    tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)\n])\n</code></pre>\n<p data-nodeid="1553">我们不得不分别配置每一个约束，并放进一个数组里面，然后传递给静态方法<code data-backticks="1" data-nodeid="1740">NSLayoutConstraint.activate</code>。 所以你看，使用 SnapKit 多么方便。</p>\n<p data-nodeid="1554">完成了 UI 的布局以后，我们看一下数据绑定。Moments App 使用了 RxSwift 把 ViewModel 层和 View 层进行绑定，绑定的代码在<code data-backticks="1" data-nodeid="1743">setupBindings()</code>函数里，具体如下。</p>\n<pre class="lang-swift" data-nodeid="1555"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupBindings</span><span class="hljs-params">()</span></span> {\n    tableView.refreshControl = configure(<span class="hljs-type">UIRefreshControl</span>()) {\n        <span class="hljs-keyword">let</span> refreshControl = $<span class="hljs-number">0</span>\n        $<span class="hljs-number">0</span>.rx.controlEvent(.valueChanged)\n            .<span class="hljs-built_in">filter</span> { refreshControl.isRefreshing }\n            .bind { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>?.loadItems() }\n            .disposed(by: disposeBag)\n    }\n    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="hljs-type">SectionModel</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">ListItemViewModel</span>&gt;&gt;(configureCell: { <span class="hljs-number">_</span>, tableView, indexPath, item <span class="hljs-keyword">in</span>\n        <span class="hljs-keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type">String</span>(describing: type(of: item)), <span class="hljs-keyword">for</span>: indexPath)\n        (cell <span class="hljs-keyword">as</span>? <span class="hljs-type">ListItemCell</span>)?.update(with: item)\n        <span class="hljs-keyword">return</span> cell\n    })\n    viewModel.listItems\n        .bind(to: tableView.rx.items(dataSource: dataSource))\n        .disposed(by: disposeBag)\n    viewModel.hasError\n        .<span class="hljs-built_in">map</span> { !$<span class="hljs-number">0</span> }\n        .bind(to: errorLabel.rx.isHidden)\n        .disposed(by: disposeBag)\n}\n</code></pre>\n<p data-nodeid="1556">这个函数由三部分组成，第一部分是通过 RxSwift 和 RxCocoa ，把<code data-backticks="1" data-nodeid="1746">UIRefreshControl</code>控件里的<code data-backticks="1" data-nodeid="1748">isRefreshing</code>事件和<code data-backticks="1" data-nodeid="1750">loadItems()</code>函数绑定起来。当用户下拉刷新控件的时候会调用<code data-backticks="1" data-nodeid="1752">loadItems()</code>函数来刷新列表的数据。</p>\n<p data-nodeid="1557">第二部分是把 TableView Cell 控件与 ViewModel 的<code data-backticks="1" data-nodeid="1755">listItems</code>Subject 属性绑定起来，当<code data-backticks="1" data-nodeid="1757">listItems</code>发出新的事件时，我们会调用<code data-backticks="1" data-nodeid="1759">ListItemCell</code>的<code data-backticks="1" data-nodeid="1761">update(with viewModel: ListItemViewModel)</code>方法来更新 UI。<strong data-nodeid="1766">经过了这一绑定，UI 就能随着 ViewModel 的数据变化而自动更新。</strong></p>\n<p data-nodeid="1558">第三部分与第二部分类似，都是把 ViewModel 与 View 层的控件进行绑定。在这里，我们把 ViewModel 的<code data-backticks="1" data-nodeid="1768">hasError</code>Subject 属性绑定到<code data-backticks="1" data-nodeid="1770">errorLabel.rx.isHidden</code>属性来控制<code data-backticks="1" data-nodeid="1772">errorLabel</code>是否可见。</p>\n<p data-nodeid="1559">你可能注意到在<code data-backticks="1" data-nodeid="1775">errorLabel</code>后面有<code data-backticks="1" data-nodeid="1777">.rx</code>属性，这是 RxCocoa 为<code data-backticks="1" data-nodeid="1779">UILabel</code>控件所提供的一个扩展，它为<code data-backticks="1" data-nodeid="1781">isHidden</code>属性提供了响应式编程的功能。有了这一功能，它就可以与 ViewModel 的 Subject 属性进行绑定，从而实现自动更新。</p>\n<p data-nodeid="1560">数据绑定以后，我们一起看看<code data-backticks="1" data-nodeid="1784">loadItems()</code>函数的实现。</p>\n<pre class="lang-swift" data-nodeid="1561"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadItems</span><span class="hljs-params">()</span></span> {\n    viewModel.hasError.onNext(<span class="hljs-literal">false</span>)\n    viewModel.loadItems()\n        .observeOn(<span class="hljs-type">MainScheduler</span>.instance)\n        .<span class="hljs-keyword">do</span>(onDispose: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>\n            <span class="hljs-keyword">self</span>?.activityIndicatorView.rx.isAnimating.onNext(<span class="hljs-literal">false</span>)\n            <span class="hljs-keyword">self</span>?.tableView.refreshControl?.endRefreshing()\n        })\n        .<span class="hljs-built_in">map</span> { <span class="hljs-literal">false</span> }\n        .startWith(<span class="hljs-literal">true</span>)\n        .distinctUntilChanged()\n        .bind(to: activityIndicatorView.rx.isAnimating)\n        .disposed(by: disposeBag)\n}\n</code></pre>\n<p data-nodeid="1562"><code data-backticks="1" data-nodeid="1786">loadItems()</code>方法用于加载数据。当我们第一次进入朋友圈页面的时候，或者用户下拉刷新控件的时候，就会调用该方法来重新加载数据。</p>\n<p data-nodeid="1563">该方法主要做两项工作，第一项是调用<code data-backticks="1" data-nodeid="1789">viewModel.hasError.onNext(false)</code>来更新 ViewModel 的<code data-backticks="1" data-nodeid="1791">hasError</code>属性， 它能让 UI 上的错误标签信息消失。</p>\n<p data-nodeid="1564">从代码中你可以看到，尽管我们想更新 UI 层的<code data-backticks="1" data-nodeid="1794">errorLabel</code>控件，却没有直接通过<code data-backticks="1" data-nodeid="1796">errorLabel.isHidden = true</code>的方式来更新，而是通过 ViewModel 的<code data-backticks="1" data-nodeid="1798">hasError</code>属性来完成。这是因为我要保证 View/UI 层都是由 ViewModel 驱动，通过单方向的数据流来减少 Bug ，从而提高代码的可维护性。</p>\n<p data-nodeid="1565"><code data-backticks="1" data-nodeid="1800">loadItems()</code>方法的第二项工作，是让 ViewModel 去加载数据并绑定到<code data-backticks="1" data-nodeid="1802">activityIndicatorView</code>控件的<code data-backticks="1" data-nodeid="1804">isAnimating</code>属性上。因为我们需要在主排程器上执行 UI 任务，因此调用了<code data-backticks="1" data-nodeid="1806">.observeOn(MainScheduler.instance)</code>，把所有任务都安排到主排程器上。</p>\n<p data-nodeid="1566">当 ViewModel 的<code data-backticks="1" data-nodeid="1809">loadItems()</code>方法开始执行的时候，先通过<code data-backticks="1" data-nodeid="1811">.startWith(true)</code>来让<code data-backticks="1" data-nodeid="1813">activityIndicatorView</code>启动动画效果。当 ViewModel 的<code data-backticks="1" data-nodeid="1815">loadItems()</code>方法返回数据时，把结果数据通过<code data-backticks="1" data-nodeid="1817">.map { false }</code>方法来返回<code data-backticks="1" data-nodeid="1819">false</code>，从而使得<code data-backticks="1" data-nodeid="1821">activityIndicatorView</code>停止动画效果。</p>\n<p data-nodeid="1567">假如用户在调用 ViewModel 的<code data-backticks="1" data-nodeid="1824">loadItems()</code>方法的过程中，退出列表页面，我们通过<code data-backticks="1" data-nodeid="1826">.do(onDispose:{})</code>方法来停止<code data-backticks="1" data-nodeid="1828">activityIndicatorView</code>和<code data-backticks="1" data-nodeid="1830">refreshControl</code>两个控件的刷新动画。</p>\n<p data-nodeid="1568">到此为止，我们已经知道<code data-backticks="1" data-nodeid="1833">BaseTableViewController</code>是如何通过 TableView 来实现列表 UI 的了。</p>\n<p data-nodeid="1569">为了显现不同的 TableView Cell，接下来我们了解下通用的 Cell 是如何实现的。</p>\n<p data-nodeid="1570">这部分由四个类型所组成，分别是<code data-backticks="1" data-nodeid="1837">ListItemCell</code>协议及其子结构体<code data-backticks="1" data-nodeid="1839">BaseTableViewCell</code>，以及<code data-backticks="1" data-nodeid="1841">ListItemView</code>协议及其子结构体<code data-backticks="1" data-nodeid="1843">BaseListItemView</code>。</p>\n<p data-nodeid="1571"><code data-backticks="1" data-nodeid="1845">ListItemCell</code>协议的定义非常简单，如下所示。</p>\n<pre class="lang-swift" data-nodeid="1572"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemCell</span>: <span class="hljs-title">class</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span>\n}\n</code></pre>\n<p data-nodeid="1573">该协议只包含了一个<code data-backticks="1" data-nodeid="1848">update(with viewModel: ListItemViewModel)</code>方法来让其子类型根据<code data-backticks="1" data-nodeid="1850">ListItemViewModel</code>的数据进行更新。</p>\n<p data-nodeid="1574">其子类型<code data-backticks="1" data-nodeid="1853">BaseTableViewCell</code>的具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="1575"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTableViewCell</span>&lt;<span class="hljs-title">V</span>: <span class="hljs-title">BaseListItemView</span>&gt;: <span class="hljs-title">UITableViewCell</span>, <span class="hljs-title">ListItemCell</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> view: <span class="hljs-type">V</span>\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(style: <span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">CellStyle</span>, reuseIdentifier: <span class="hljs-type">String?</span>) {\n        view = .<span class="hljs-keyword">init</span>()\n        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)\n        selectionStyle = .<span class="hljs-keyword">none</span>\n        contentView.addSubview(view)\n        view.snp.makeConstraints {\n            $<span class="hljs-number">0</span>.edges.equalToSuperview()\n        }\n    }\n    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>?(coder: <span class="hljs-type">NSCoder</span>) {\n        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorInitCoderNotImplemented)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {\n        view.update(with: viewModel)\n    }\n}\n</code></pre>\n<p data-nodeid="1576"><code data-backticks="1" data-nodeid="1855">BaseTableViewCell</code>是一个<code data-backticks="1" data-nodeid="1857">UITableViewCell</code>的子类，并遵循了<code data-backticks="1" data-nodeid="1859">ListItemCell</code>协议，因此它需要实现<code data-backticks="1" data-nodeid="1861">update(with viewModel: ListItemViewModel)</code>方法。在该方法里面，它直接调用<code data-backticks="1" data-nodeid="1863">view</code>属性的<code data-backticks="1" data-nodeid="1865">update(with viewModel: ListItemViewModel)</code>来更新<code data-backticks="1" data-nodeid="1867">BaseListItemView</code>组件的 UI。</p>\n<p data-nodeid="1577">那为什么我们不把所有 UI 子控件都直接写在 Cell 里，而使用一个额外的<code data-backticks="1" data-nodeid="1870">BaseListItemView</code>呢？因为这样做可以把<code data-backticks="1" data-nodeid="1872">BaseListItemView</code>复用到<code data-backticks="1" data-nodeid="1874">UICollectionView</code>等其他容器中。</p>\n<p data-nodeid="1578">接下来我们一起看看<code data-backticks="1" data-nodeid="1877">BaseListItemView</code>及其所遵循的<code data-backticks="1" data-nodeid="1879">ListItemView</code>协议的代码。</p>\n<pre class="lang-swift" data-nodeid="1579"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemView</span>: <span class="hljs-title">class</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span>\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseListItemView</span>: <span class="hljs-title">UIView</span>, <span class="hljs-title">ListItemView</span> </span>{\n    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {\n        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorSubclassToImplement)\n    }\n}\n</code></pre>\n<p data-nodeid="1580"><code data-backticks="1" data-nodeid="1881">ListItemView</code>协议只定义了<code data-backticks="1" data-nodeid="1883">update(with viewModel: ListItemViewModel)</code>接口来通过 ViewModel 更新 UI。因为每个 UI 组件的布局与呈现都可能不一样，因此，<code data-backticks="1" data-nodeid="1885">BaseListItemView</code>在实现<code data-backticks="1" data-nodeid="1887">update(with viewModel: ListItemViewModel)</code>方法时，直接抛出了异常，这样能迫使其子类重写该方法。</p>\n<p data-nodeid="1581">上面就是通用列表 UI 模块的架构与实现，有了这一个框架，我们就能快速实现不同的列表页面，下面以朋友圈功能作为例子来看看如何实现一个朋友圈时间轴页面。</p>\n<h3 data-nodeid="1582">朋友圈时间轴页面的实现</h3>\n<p data-nodeid="1583">首先我们一起看看朋友圈时间轴页面的架构图。</p>\n<p data-nodeid="1584"><img src="https://s0.lgstatic.com/i/image6/M00/3C/B1/CioPOWCL09mAbIiFAAIX3-W1eco290.png" alt="图片2.png" data-nodeid="1894"><br>\n<code data-backticks="1" data-nodeid="1896">MomentsTimelineViewController</code>用于显示朋友圈时间轴页面，其具体代码如下。</p>\n<pre class="lang-swift" data-nodeid="1585"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsTimelineViewController</span>: <span class="hljs-title">BaseTableViewController</span> </span>{\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() {\n        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()\n        viewModel = <span class="hljs-type">MomentsTimelineViewModel</span>(userID: <span class="hljs-type">UserDataStore</span>.current.userID)\n    }\n    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidAppear</span><span class="hljs-params">(<span class="hljs-number">_</span> animated: Bool)</span></span> {\n        <span class="hljs-keyword">super</span>.viewDidAppear(animated)\n        viewModel.trackScreenviews()\n    }\n    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> tableViewCellsToRegister: [<span class="hljs-type">String</span> : <span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">Type</span>] {\n        <span class="hljs-keyword">return</span> [\n            <span class="hljs-type">UserProfileListItemViewModel</span>.reuseIdentifier: <span class="hljs-type">BaseTableViewCell</span>&lt;<span class="hljs-type">UserProfileListItemView</span>&gt;.<span class="hljs-keyword">self</span>,\n            <span class="hljs-type">MomentListItemViewModel</span>.reuseIdentifier: <span class="hljs-type">BaseTableViewCell</span>&lt;<span class="hljs-type">MomentListItemView</span>&gt;.<span class="hljs-keyword">self</span>\n        ]\n    }\n}\n</code></pre>\n<p data-nodeid="1586">因为<code data-backticks="1" data-nodeid="1899">BaseViewController</code>已经封装好绝大部分的 UI 处理逻辑，作为子类，<code data-backticks="1" data-nodeid="1901">MomentsTimelineViewController</code>的实现变得非常简单，只需三部分。</p>\n<p data-nodeid="3060" class="">首先是初始化<code data-backticks="1" data-nodeid="3062">viewModel</code>。因为<code data-backticks="1" data-nodeid="3064">BaseViewController</code>通过<code data-backticks="1" data-nodeid="3066">var viewModel: ListViewModel!</code>来定义<code data-backticks="1" data-nodeid="3068">viewModel</code>属性，作为子类的<code data-backticks="1" data-nodeid="3070">MomentsTimelineViewController</code>也必须初始化<code data-backticks="1" data-nodeid="3072">viewModel</code>属性，否则程序会崩溃。具体来说，我们只需创建一个<code data-backticks="1" data-nodeid="3074">MomentsTimelineViewModel</code>对象来完成初始化即可。它的实现我在上一讲已经介绍过了，你可以再留意下。</p>\n\n\n\n<p data-nodeid="1589">然后，我在<code data-backticks="1" data-nodeid="1919">func viewDidAppear(_ animated: Bool)</code>方法里面调用<code data-backticks="1" data-nodeid="1921">viewModel.trackScreenviews()</code>来让 ViewModel 发送用户行为数据。</p>\n<p data-nodeid="1590">为了帮<code data-backticks="1" data-nodeid="1924">BaseViewController</code>提供需要注册的 TableView Cell ，最后我重写了<code data-backticks="1" data-nodeid="1926">tableViewCellsToRegister</code>属性。该属性存放<code data-backticks="1" data-nodeid="1928">BaseTableViewCell</code>的实例。<code data-backticks="1" data-nodeid="1930">BaseTableViewCell</code>使用范型（generic）来存放<code data-backticks="1" data-nodeid="1932">BaseListItemView</code>的子类，这些子类包括<code data-backticks="1" data-nodeid="1934">UserProfileListItemView</code>和<code data-backticks="1" data-nodeid="1936">MomentListItemView</code>。</p>\n<p data-nodeid="1591">你可以从下图中看到它们所呈现的 UI 组件。</p>\n<p data-nodeid="1592"><img src="https://s0.lgstatic.com/i/image6/M01/3C/B3/CioPOWCL3JKAWyl6AAalmHPesaU548.png" alt="图片4.png" data-nodeid="1941"></p>\n<p data-nodeid="1593"><code data-backticks="1" data-nodeid="1942">MomentsTimelineViewController</code>我们已介绍完毕了，下面咱们以<code data-backticks="1" data-nodeid="1944">UserProfileListItemView</code>为例，看一下开发子控件的步骤与实现。</p>\n<p data-nodeid="1594"><code data-backticks="1" data-nodeid="1946">UserProfileListItemView</code>用于显示用户自己的资料，例如用户名字，头像和背景图。因为有了通用和统一的 UI 开发框架，每次开发 UI 页面的步骤都是一致的，具体我分为以下几步完成：</p>\n<ol data-nodeid="1595">\n<li data-nodeid="1596">\n<p data-nodeid="1597">初始化 UI 控件的属性；</p>\n</li>\n<li data-nodeid="1598">\n<p data-nodeid="1599">配置 UI 控件的样式；</p>\n</li>\n<li data-nodeid="1600">\n<p data-nodeid="1601">设置自动布局的约束；</p>\n</li>\n<li data-nodeid="1602">\n<p data-nodeid="1603">重写<code data-backticks="1" data-nodeid="1952">update(with viewModel: ListItemViewModel)</code>方法，根据 ViewModel 的数据来更新 UI。</p>\n</li>\n</ol>\n<p data-nodeid="1604">先看一下初始化 UI 控件属性的代码。</p>\n<pre class="lang-swift" data-nodeid="1605"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> backgroundImageView: <span class="hljs-type">UIImageView</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.contentMode = .scaleAspectFill\n    $<span class="hljs-number">0</span>.accessibilityIgnoresInvertColors = <span class="hljs-literal">true</span>\n}\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> avatarImageView: <span class="hljs-type">UIImageView</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.asAvatar(cornerRadius: <span class="hljs-number">8</span>)\n    $<span class="hljs-number">0</span>.contentMode = .scaleAspectFill\n    $<span class="hljs-number">0</span>.accessibilityIgnoresInvertColors = <span class="hljs-literal">true</span>\n}\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> nameLabel: <span class="hljs-type">UILabel</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.font = <span class="hljs-type">UIFont</span>.designKit.title3\n    $<span class="hljs-number">0</span>.textColor = .white\n    $<span class="hljs-number">0</span>.numberOfLines = <span class="hljs-number">1</span>\n}\n</code></pre>\n<p data-nodeid="1606">我们分别调用<code data-backticks="1" data-nodeid="1956">configure()</code>函数来初始化三个 UI 控件的属性，<code data-backticks="1" data-nodeid="1958">backgroundImageView</code>用于显示背景图，<code data-backticks="1" data-nodeid="1960">avatarImageView</code>用于显示用户头像，而<code data-backticks="1" data-nodeid="1962">nameLabel</code>用于显示用户名字。</p>\n<p data-nodeid="1607">你可以根据下图，看到它们分别使用在哪里。</p>\n<p data-nodeid="1608"><img src="https://s0.lgstatic.com/i/image6/M01/3C/B3/CioPOWCL3LGAfuNrABZKzpfsijg925.png" alt="图片5.png" data-nodeid="1967"></p>\n<p data-nodeid="1609">接着来看在第二步中如何配置 UI 控件的样式，我用<code data-backticks="1" data-nodeid="1969">setupUI()</code>方法来实现。</p>\n<pre class="lang-swift" data-nodeid="1610"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {\n    backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background\n    [backgroundImageView, avatarImageView, nameLabel].forEach {\n        addSubview($<span class="hljs-number">0</span>)\n    }\n}\n</code></pre>\n<p data-nodeid="1611">在这里，我使用了 DesignKit 来设置了背景颜色，并把子控件添加到当前 View 里面。</p>\n<p data-nodeid="1612">然后看第三步如何设置自动布局的约束，其实现代码如下。</p>\n<pre class="lang-swift" data-nodeid="1613"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {\n    backgroundImageView.snp.makeConstraints {\n        $<span class="hljs-number">0</span>.top.leading.trailing.equalToSuperview()\n        $<span class="hljs-number">0</span>.bottom.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)\n        $<span class="hljs-number">0</span>.height.equalTo(backgroundImageView.snp.width).multipliedBy(<span class="hljs-number">0.8</span>).priority(<span class="hljs-number">999</span>)\n    }\n    avatarImageView.snp.makeConstraints {\n        $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)\n        $<span class="hljs-number">0</span>.bottom.equalToSuperview()\n        $<span class="hljs-number">0</span>.height.equalTo(<span class="hljs-number">80</span>)\n        $<span class="hljs-number">0</span>.width.equalTo(<span class="hljs-number">80</span>)\n    }\n    nameLabel.snp.makeConstraints {\n        $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalTo(<span class="hljs-keyword">self</span>.avatarImageView.snp.<span class="hljs-keyword">left</span>).offset(-<span class="hljs-type">Spacing</span>.medium)\n        $<span class="hljs-number">0</span>.centerY.equalTo(<span class="hljs-keyword">self</span>.avatarImageView.snp.centerY)\n    }\n}\n</code></pre>\n<p data-nodeid="1614">其中<code data-backticks="1" data-nodeid="1974">backgroundImageView</code>的顶部和两边都延展到父控件，因为底部需要留白来显示用户头像，因此添加了<code data-backticks="1" data-nodeid="1976">medium</code>作为间距。背景图片的长宽比是 5:4。</p>\n<p data-nodeid="1615"><code data-backticks="1" data-nodeid="1978">avatarImageView</code>位于父控件的右下角，并设定长度和宽度都为 80pt。<code data-backticks="1" data-nodeid="1980">nameLabel</code>位于<code data-backticks="1" data-nodeid="1982">avatarImageView</code>的左边，并与之水平。这样我们就使用 SnapKit 完成用户资料 UI 的布局了。<br>\n最后一部分是调用<code data-backticks="1" data-nodeid="1986">update()</code>方法来更新 UI，其代码如下。</p>\n<pre class="lang-swift" data-nodeid="1616"><code data-language="swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {\n    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> viewModel = viewModel <span class="hljs-keyword">as</span>? <span class="hljs-type">UserProfileListItemViewModel</span> <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span>\n    }\n    backgroundImageView.kf.setImage(with: viewModel.backgroundImageURL)\n    avatarImageView.kf.setImage(with: viewModel.avatarURL)\n    nameLabel.text = viewModel.name\n}\n</code></pre>\n<p data-nodeid="4088">因为<code data-backticks="1" data-nodeid="4091">UserProfileListItemViewModel</code>已经为<code data-backticks="1" data-nodeid="4093">UserProfileListItemView</code>准备好呈现所需的所有数据，因此，只要简单的赋值就可以更新 UI 了。</p>\n<p data-nodeid="4089"><code data-backticks="1" data-nodeid="4095">MomentListItemView</code>的代码结构和<code data-backticks="1" data-nodeid="4097">UserProfileListItemView</code>基本一样，你可以到拉勾教育的代码仓库进行查看。</p>\n\n<h3 data-nodeid="1618">总结</h3>\n<p data-nodeid="1619">在这一讲中，我为你介绍了如何架构和实现一个通用的列表 UI 模块，有了这个模块，我们按照以下这几个步骤就可以完成 UI 的开发了。</p>\n<ol data-nodeid="1620">\n<li data-nodeid="1621">\n<p data-nodeid="1622">初始化 UI 控件的属性，把 UI 分解成不同的子控件，然后通过<code data-backticks="1" data-nodeid="2001">configure()</code>来初始化各个控件属性。</p>\n</li>\n<li data-nodeid="1623">\n<p data-nodeid="1624">配置 UI 控件的样式，如配置背景颜色等，并把各个子控件添加到父控件里面。</p>\n</li>\n<li data-nodeid="1625">\n<p data-nodeid="1626">设置自动布局的约束，推荐使用 SnapKit 来简化配置约束的工作。</p>\n</li>\n<li data-nodeid="1627">\n<p data-nodeid="1628">重写<code data-backticks="1" data-nodeid="2006">update(with viewModel: ListItemViewModel)</code>方法，根据 ViewModel 的数据来更新 UI。如果有数据绑定，那么使用 RxSwift 和 RxCocoa 把 ViewModel 的 Subject 属性绑定到 UI 控件上。如果不需要数据绑定，只需把 ViewModel 准备好的值赋给 UI 控件即可。</p>\n</li>\n</ol>\n<p data-nodeid="1629"><strong data-nodeid="2011">思考题</strong></p>\n<blockquote data-nodeid="1630">\n<p data-nodeid="1631">请问你们使用苹果提供的自动布局吗？如果是，是使用原生语法还是类似 SnapKit 那种库呢？或者说使用 Texture 等其他非苹果的框架进行布局？能分享你的使用经验吗？</p>\n</blockquote>\n<p data-nodeid="1632">可以把你的思考写到留言区哦，下一讲，我会介绍如何使用现有架构添加点赞功能。</p>\n<p data-nodeid="1633"><strong data-nodeid="2017">源码地址</strong></p>\n<blockquote data-nodeid="1634">\n<p data-nodeid="1635" class="">通用列表 UI 的源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Views?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2022">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Views</a><br>\n朋友圈时间轴页面实现的源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Views?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2028">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Views</a></p>\n</blockquote>',
          },
          {
            theme: '22 | 功能实战：如何使用现有架构添加点赞功能？',
            id: 37,
            content:
              '<p data-nodeid="23743" class="">你有没有遇到过接手一份新的代码却不知道如何下手的情况？其实，一套良好的开发框架就能有效地解决这种问题。规范的架构与框架不仅具有良好的可扩展性，例如，可以灵活地替换网络层、数据库甚至 UI 层的实现，而且还为开发者提供了统一的开发步骤与规范，方便新功能的快速迭代。</p>\n<p data-nodeid="23744">我们的 Moments App 使用了 MVVM 架构来支持快速开发，在这一讲中，我们再以<strong data-nodeid="23851">添加点赞功能</strong>为例来看看如何一步一步去开发一个新功能。</p>\n<p data-nodeid="26812">如下面的动图所示，我们可以摇动手机来打开内部功能菜单页面，在该页面内点击<strong data-nodeid="26819">开启点赞按钮</strong>来启动点赞功能。当重启 App 以后，我们就能在朋友圈页面里看到点赞按钮了。</p>\n<p data-nodeid="26813" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/B3/CioPOWCL3CuAMBOkASZnzg1UurI778.gif" alt="21-01.gif" data-nodeid="26822"></p>\n\n\n<p data-nodeid="23747" class="">根据组件间的依赖关系，我们可以按照以下五个步骤来进行开发：</p>\n<ul data-nodeid="23748">\n<li data-nodeid="23749">\n<p data-nodeid="23750"><strong data-nodeid="23863">增加“添加点赞功能”的功能开关；</strong></p>\n</li>\n<li data-nodeid="23751">\n<p data-nodeid="23752"><strong data-nodeid="23867">开发网络层来更新 BFF 的点赞信息；</strong></p>\n</li>\n<li data-nodeid="23753">\n<p data-nodeid="23754"><strong data-nodeid="23871">开发 Repository 层来存储数据；</strong></p>\n</li>\n<li data-nodeid="23755">\n<p data-nodeid="23756"><strong data-nodeid="23875">开发 ViewModel 层来准备 UI 所需的数据；</strong></p>\n</li>\n<li data-nodeid="23757">\n<p data-nodeid="23758"><strong data-nodeid="23879">开发 UI/View 层呈现点赞按钮和点赞朋友列表。</strong></p>\n</li>\n</ul>\n<p data-nodeid="23759">下面我们就来详细说明这每一个步骤。</p>\n<h3 data-nodeid="23760">增加功能开关</h3>\n<p data-nodeid="23761">当我们开发一个周期比较长的新功能时，通常会使用功能开关。</p>\n<p data-nodeid="23762">如果没有功能开关，当开发周期超过一周以上时，我们就不得不把开发中的功能放在一个“长命”功能分支下，直到整个功能完成后才合并到主分支，这往往会增加合并分支的难度。</p>\n<p data-nodeid="23763">另一种方法是延迟发布的时间，在功能完整开发出来后才进行发布。假如有多个团队一直在开发新功能，那么发布计划就可能一直在延迟。但如果我们使用了功能开关，就可以把未完成的功能一直隐藏着，直到通过完整的测试和产品验证后才把开关启动并进行发布。总之，<strong data-nodeid="23889">有了功能开关，我们可以支持多个团队并行开发，并在此期间随时发布新版本的 App</strong>。</p>\n<p data-nodeid="23764">下面我们看看如何为<strong data-nodeid="23895">添加点赞功能</strong>增加一个功能开关，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="23765"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InternalToggle</span>: <span class="hljs-title">String</span>, <span class="hljs-title">ToggleType</span> </span>{\n    <span class="hljs-keyword">case</span> isLikeButtonForMomentEnabled\n}\n</code></pre>\n<p data-nodeid="23766">首先，我们为枚举类型<code data-backticks="1" data-nodeid="23897">InternalToggle</code>添加<code data-backticks="1" data-nodeid="23899">isLikeButtonForMomentEnabled</code>来表示<strong data-nodeid="23905">启动点赞功能</strong>的功能开关。</p>\n<p data-nodeid="23767">接着在<code data-backticks="1" data-nodeid="23907">InternalTogglesDataStore</code>里把该值初始化为<code data-backticks="1" data-nodeid="23909">false</code>表示默认关闭该功能，这样就能保证 App Store 版本的 App 都看不到这个功能，代码如下：</p>\n<pre class="lang-swift" data-nodeid="23768"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InternalTogglesDataStore</span>: <span class="hljs-title">TogglesDataStoreType</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>(userDefaults: <span class="hljs-type">UserDefaults</span>) {\n        <span class="hljs-keyword">self</span>.userDefaults.register(defaults: [\n            <span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled.rawValue: <span class="hljs-literal">false</span>\n            ])\n    }\n}\n</code></pre>\n<p data-nodeid="23769">最后一步是通过<code data-backticks="1" data-nodeid="23912">isLikeButtonForMomentEnabled</code>初始化<code data-backticks="1" data-nodeid="23914">InternalMenuFeatureToggleItemViewModel</code>，并添加到<code data-backticks="1" data-nodeid="23916">InternalMenuViewModel</code>的<code data-backticks="1" data-nodeid="23918">sections</code>属性里面 ，代码如下：</p>\n<pre class="lang-swift" data-nodeid="23770"><code data-language="swift"><span class="hljs-keyword">let</span> featureTogglesSection = <span class="hljs-type">InternalMenuSection</span>(\n    title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.featureToggles,\n    items: [\n        <span class="hljs-type">InternalMenuFeatureToggleItemViewModel</span>(title: <span class="hljs-type">L10n</span>.<span class="hljs-type">InternalMenu</span>.likeButtonForMomentEnabled, toggle: <span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled)\n    ])\nsections = .just([\n&nbsp; &nbsp; featureTogglesSection,\n&nbsp; &nbsp; ... <span class="hljs-comment">// other sections</span>\n])\n</code></pre>\n<p data-nodeid="23771">这样子就为内部隐藏菜单增加了<strong data-nodeid="23925">启动点赞功能</strong>的功能开关。功能开关是其他模块的基础，你会看到我们在其他模块中也都会使用到该开关。</p>\n<h3 data-nodeid="23772">开发网络层</h3>\n<p data-nodeid="23773">Moments App 使用了 BFF 来读取朋友圈信息，那我们也把点赞信息存储在 BFF 里面。因为 Moments App 的 BFF 使用了 GraphQL，要更新 BFF 上的数据，我们就需要使用 Mutation。和 Restful API 的 Post 操作不一样，在 GraphQL 的 Mutation 不仅能更新数据，还可以返回数据。</p>\n<p data-nodeid="23774">下面我们就来一起看看网络层的实现，首先定义一个名叫<code data-backticks="1" data-nodeid="23929">UpdateMomentLikeSessionType</code>的协议来<strong data-nodeid="23935">提供更新点赞信息的接口</strong>，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="23775"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">UpdateMomentLikeSessionType</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLike</span><span class="hljs-params">(<span class="hljs-number">_</span> isLiked: Bool, momentID: String, fromUserID userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;\n}\n</code></pre>\n<p data-nodeid="23776">该协议只定义了一个<code data-backticks="1" data-nodeid="23937">updateLike()</code>方法，该方法会接收以下的入口参数，并返回类型为<code data-backticks="1" data-nodeid="23939">MomentsDetails</code>的 Observable 序列。</p>\n<ul data-nodeid="23777">\n<li data-nodeid="23778">\n<p data-nodeid="23779"><code data-backticks="1" data-nodeid="23941">isLiked</code>是一个布尔类型，用于表示是否点赞了。</p>\n</li>\n<li data-nodeid="23780">\n<p data-nodeid="23781" class="te-preview-highlight"><code data-backticks="1" data-nodeid="23943">momentID</code>表示被点赞的那条朋友圈的 ID。</p>\n</li>\n<li data-nodeid="23782">\n<p data-nodeid="23783"><code data-backticks="1" data-nodeid="23945">userID</code>表示点赞的用户 ID。</p>\n</li>\n</ul>\n<p data-nodeid="23784">接着我们定义了一个遵循<code data-backticks="1" data-nodeid="23948">UpdateMomentLikeSessionType</code>协议的结构体，它名叫<code data-backticks="1" data-nodeid="23950">UpdateMomentLikeSession</code>。<code data-backticks="1" data-nodeid="23952">UpdateMomentLikeSession</code>的实现方法和<code data-backticks="1" data-nodeid="23954">GetMomentsByUserIDSession</code>代码基本一致，我们已经在《18 | 网络层架构：如何设计网络访问与 JSON 数据解析？》那一讲中详细讲述了<code data-backticks="1" data-nodeid="23958">GetMomentsByUserIDSession</code>的实现，如有需要你可以回去复习一下。</p>\n<p data-nodeid="23785">不同的地方是在<code data-backticks="1" data-nodeid="23961">query</code>属性的定义里，<code data-backticks="1" data-nodeid="23963">UpdateMomentLikeSession</code>使用了<code data-backticks="1" data-nodeid="23965">mutation</code>而不是<code data-backticks="1" data-nodeid="23967">query</code>，具体定义如下：</p>\n<pre class="lang-swift" data-nodeid="23786"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> query = <span class="hljs-string">"""\n   mutation updateMomentLike($momentID: ID!, $userID: ID!, $isLiked: Boolean!) { \n       // the response for updateMomentLike \n   }\n"""</span>\n</code></pre>\n<p data-nodeid="23787">这样子，我们就能往 BFF 发送一个 Mutation 请求并接收更新后的<code data-backticks="1" data-nodeid="23970">MomentsDetails</code>信息了。</p>\n<p data-nodeid="23788">除了<strong data-nodeid="23983">更新点赞信息</strong>以外，我们还要修改<code data-backticks="1" data-nodeid="23977">GetMomentsByUserIDSession</code>来<strong data-nodeid="23984">读取点赞朋友的列表信息</strong>。</p>\n<p data-nodeid="23789">不过，点赞信息只有在功能开关开启的时候才能看到，因此在读取朋友圈信息的时候需要进行检查。要检查内部功能开关，需要使用到一个<code data-backticks="1" data-nodeid="23986">InternalTogglesDataStore</code>的实例，因此我们在初始化<code data-backticks="1" data-nodeid="23988">GetMomentsByUserIDSession</code>的时候可以将<code data-backticks="1" data-nodeid="23990">InternalTogglesDataStore.shared</code>传递进去，代码如下：</p>\n<pre class="lang-swift" data-nodeid="23790"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span>\n<span class="hljs-keyword">init</span>(togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span> = <span class="hljs-type">InternalTogglesDataStore</span>.shared, sessionHandler: ...) {\n    <span class="hljs-keyword">self</span>.togglesDataStore = togglesDataStore\n}\n</code></pre>\n<p data-nodeid="23791">当<code data-backticks="1" data-nodeid="23993">GetMomentsByUserIDSession</code>接收到<code data-backticks="1" data-nodeid="23995">InternalTogglesDataStore</code>的实例时，可以直接保存到<code data-backticks="1" data-nodeid="23997">togglesDataStore</code>属性里面，这样我们就能使用<code data-backticks="1" data-nodeid="23999">togglesDataStore</code>属性来检查点赞功能是否开启了。下面代码展示的是内嵌<code data-backticks="1" data-nodeid="24001">Session</code>结构体的<code data-backticks="1" data-nodeid="24003">init()</code>方法：</p>\n<pre class="lang-swift" data-nodeid="23792"><code data-language="swift"><span class="hljs-keyword">init</span>(userID: <span class="hljs-type">String</span>, togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span>) {\n    <span class="hljs-keyword">let</span> variables: [<span class="hljs-type">AnyHashable</span>: <span class="hljs-type">Encodable</span>] = [<span class="hljs-string">"userID"</span>: userID,\n                                               <span class="hljs-string">"withLikes"</span>: togglesDataStore.isToggleOn(<span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled)]\n}\n</code></pre>\n<p data-nodeid="23793">我们通过调用<code data-backticks="1" data-nodeid="24006">togglesDataStore.isToggleOn(InternalToggle.isLikeButtonForMomentEnabled)</code>来判断是否开启了点赞功能，如果是，就把<code data-backticks="1" data-nodeid="24008">withLikes</code>属性赋值为<code data-backticks="1" data-nodeid="24010">true</code>，否则赋为<code data-backticks="1" data-nodeid="24012">false</code>。这样就可以在 Query 里面使用<code data-backticks="1" data-nodeid="24014">withLikes</code>属性了，代码如下：</p>\n<pre class="lang-swift" data-nodeid="23794"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> query = <span class="hljs-string">"""\n   query getMomentsDetailsByUserID($userID: ID!, $withLikes: Boolean!) {\n     getMomentsDetailsByUserID(userID: $userID) {\n         // other fields\n         createdDate\n         isLiked @include(if: $withLikes)\n         likes @include(if: $withLikes) {\n           id\n           avatar\n         }\n       }\n     }\n   }\n"""</span>\n</code></pre>\n<p data-nodeid="23795">在定义<code data-backticks="1" data-nodeid="24017">query</code>属性的地方，我们把<code data-backticks="1" data-nodeid="24019">withLikes</code>传递给<code data-backticks="1" data-nodeid="24021">getMomentsDetailsByUserID</code>Query，然后通过<code data-backticks="1" data-nodeid="24023">@include</code>来控制是否读取<code data-backticks="1" data-nodeid="24025">isLiked</code>和<code data-backticks="1" data-nodeid="24027">likes</code>属性，从而保证只有当<code data-backticks="1" data-nodeid="24029">isLikeButtonForMomentEnabled</code>开关开启时，才需要读取这两个属性。</p>\n<p data-nodeid="23796">到此为止，网络层的开发就完成了，下面我们再来看看 Repository 层的开发。</p>\n<h3 data-nodeid="23797">开发 Repository 层</h3>\n<p data-nodeid="23798">在朋友圈功能里面，Respository 层的关键组件是<code data-backticks="1" data-nodeid="24034">MomentsRepo</code>。当它要更新点赞信息时，就会用<code data-backticks="1" data-nodeid="24036">UpdateMomentLikeSessionType</code>协议，因此我们在初始化的时候也注入对该协议的依赖，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="23799"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> updateMomentLikeSession: <span class="hljs-type">UpdateMomentLikeSessionType</span>\n<span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">MomentsRepo</span> = {\n    <span class="hljs-keyword">return</span> <span class="hljs-type">MomentsRepo</span>(..., \n        updateMomentLikeSession: <span class="hljs-type">UpdateMomentLikeSession</span>()\n    )\n}()\n<span class="hljs-keyword">init</span>(..., updateMomentLikeSession: <span class="hljs-type">UpdateMomentLikeSessionType</span>) {\n    <span class="hljs-keyword">self</span>.updateMomentLikeSession = updateMomentLikeSession\n}\n</code></pre>\n<p data-nodeid="23800">我们把<code data-backticks="1" data-nodeid="24039">UpdateMomentLikeSession</code>结构体的实例赋值给<code data-backticks="1" data-nodeid="24041">updateMomentLikeSession</code>属性，当需要访问网络层时就可以使用该属性的方法，接着看一下<code data-backticks="1" data-nodeid="24043">updateLike()</code>方法的实现：</p>\n<pre class="lang-swift" data-nodeid="23801"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLike</span><span class="hljs-params">(isLiked: Bool, momentID: String, fromUserID userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n    <span class="hljs-keyword">return</span> updateMomentLikeSession\n        .updateLike(isLiked, momentID: momentID, fromUserID: userID)\n        .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })\n        .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }\n        .catchErrorJustReturn(())\n}\n</code></pre>\n<p data-nodeid="23802">我们通过调用<code data-backticks="1" data-nodeid="24046">updateMomentLikeSession</code>属性的<code data-backticks="1" data-nodeid="24048">updateLike()</code>方法来更新点赞信息，然后把返回的结果通过<code data-backticks="1" data-nodeid="24050">persistentDataStore</code>的<code data-backticks="1" data-nodeid="24052">save()</code>方法保存到本地数据存储中。</p>\n<p data-nodeid="23803">到这里，Repository 层的开发也完成了，我们接着修改 ViewModel 层的代码来支持点赞功能。</p>\n<h3 data-nodeid="23804">开发 ViewModel 层</h3>\n<p data-nodeid="23805">因为点赞功能只使用在 UI 层的<code data-backticks="1" data-nodeid="24057">MomentListItemView</code>里面，所以我们只需要更新该 View 所对应的 ViewModel<code data-backticks="1" data-nodeid="24059">MomentListItemViewModel</code>即可。为此，我们<strong data-nodeid="24069">增加了两个属性</strong>：第一个是<code data-backticks="1" data-nodeid="24065">isLiked</code>属性，用于表示用户是否已经点赞了该朋友圈信息；第二个是<code data-backticks="1" data-nodeid="24067">likes</code>属性，用于显示点赞了朋友的头像列表。</p>\n<p data-nodeid="23806">有了这两个属性，我们就可以在<code data-backticks="1" data-nodeid="24071">init()</code>方法里面把<code data-backticks="1" data-nodeid="24073">MomentsDetails.Moment</code>数据映射到这两个属性中去，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="23807"><code data-language="swift">isLiked = moment.isLiked ?? <span class="hljs-literal">false</span>\nlikes = moment.likes?.<span class="hljs-built_in">compactMap</span> { <span class="hljs-type">URL</span>(string: $<span class="hljs-number">0</span>.avatar) } ?? []\n</code></pre>\n<p data-nodeid="23808"><code data-backticks="1" data-nodeid="24075">isLiked</code>属性的映射比较简单，只是简单的赋值即可。而<code data-backticks="1" data-nodeid="24077">likes</code>属性则需要我们把 BFF 返回的 URL 字符串转换为用于呈现图片的<code data-backticks="1" data-nodeid="24079">URL</code>类型。</p>\n<p data-nodeid="23809">当用户在页面中点击点赞按钮后，我们就需要调用<code data-backticks="1" data-nodeid="24082">MomentListItemViewModel</code>来完成具体的操作，因此我们在<code data-backticks="1" data-nodeid="24084">MomentListItemViewModel</code>也定义了两个方法，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="23810"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">like</span><span class="hljs-params">(from userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n    <span class="hljs-keyword">return</span> momentsRepo.updateLike(isLiked: <span class="hljs-literal">true</span>, momentID: momentID, fromUserID: userID)\n}\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unlike</span><span class="hljs-params">(from userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n    <span class="hljs-keyword">return</span> momentsRepo.updateLike(isLiked: <span class="hljs-literal">false</span>, momentID: momentID, fromUserID: userID)\n}\n</code></pre>\n<p data-nodeid="23811">可以看到，<code data-backticks="1" data-nodeid="24087">like(from userID: String)</code>和<code data-backticks="1" data-nodeid="24089">unlike(from userID: String)</code>方法都调用了<code data-backticks="1" data-nodeid="24091">momentsRepo.updateLike()</code>方法来更新点赞信息。至此，ViewModel 层也开发完毕了。</p>\n<h3 data-nodeid="23812">开发 UI/View 层</h3>\n<p data-nodeid="25052">其他模块开发完毕以后，最后就是更新 UI/View 层了。因为点赞按钮在每一条朋友圈信息里面，所以我们只需要修改<code data-backticks="1" data-nodeid="25055">MomentListItemView</code>就可以了。你可以从下面的这个示例图看到新加的组件：</p>\n<p data-nodeid="25053" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3C/AB/Cgp9HWCL3BeAUoLnAArqYZDfnS4379.png" alt="图片3.png" data-nodeid="25059"></p>\n\n\n<p data-nodeid="23815">从示例图可以看到，新加的组件主要有以下三个。</p>\n<ul data-nodeid="23816">\n<li data-nodeid="23817">\n<p data-nodeid="23818"><code data-backticks="1" data-nodeid="24101">likesStakeView</code>用于存放点赞朋友的列表。</p>\n</li>\n<li data-nodeid="23819">\n<p data-nodeid="23820"><code data-backticks="1" data-nodeid="24103">likesContainerView</code>是一个用来存放<code data-backticks="1" data-nodeid="24105">likesStakeView</code>的容器视图，我们还可以使用它来设置背景颜色和配置圆角效果。</p>\n</li>\n<li data-nodeid="23821">\n<p data-nodeid="23822"><code data-backticks="1" data-nodeid="24107">favoriteButton</code>表示点赞按钮。</p>\n</li>\n</ul>\n<p data-nodeid="23823">这些 UI 组件的属性定义如下：</p>\n<pre class="lang-swift" data-nodeid="23824"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> likesContainerView: <span class="hljs-type">UIView</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.secondaryBackground\n    $<span class="hljs-number">0</span>.layer.cornerRadius = <span class="hljs-number">4</span>\n}\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> likesStakeView: <span class="hljs-type">UIStackView</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.spacing = <span class="hljs-type">Spacing</span>.twoExtraSmall\n}\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> favoriteButton: <span class="hljs-type">UIButton</span> = configure(.<span class="hljs-keyword">init</span>()) {\n    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>\n    $<span class="hljs-number">0</span>.asHeartFavoriteButton()\n}\n</code></pre>\n<p data-nodeid="23825">有了这些属性以后，我们还需要把它们添加到 UI 里面，下面是<code data-backticks="1" data-nodeid="24111">setupUI()</code>方法的代码：</p>\n<pre class="lang-swift" data-nodeid="23826"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {\n    <span class="hljs-keyword">if</span> togglesDataStore.isToggleOn(<span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled) {\n        likesContainerView.addSubview(likesStakeView)\n        verticalStackView.addArrangedSubview(likesContainerView)\n        addSubview(favoriteButton)\n    }\n}\n</code></pre>\n<p data-nodeid="23827">从上面的代码可以看到，只有当<code data-backticks="1" data-nodeid="24114">isLikeButtonForMomentEnabled</code>开关开启时，才需要添加新的组件。添加新组件的逻辑相对比较简单，我们把<code data-backticks="1" data-nodeid="24116">likesStakeView</code>添加到<code data-backticks="1" data-nodeid="24118">likesContainerView</code>里面，然后把<code data-backticks="1" data-nodeid="24120">likesContainerView</code>添加到<code data-backticks="1" data-nodeid="24122">verticalStackView</code>，这样就可以把点赞的朋友列表放在父视图的底部，最后再把<code data-backticks="1" data-nodeid="24124">favoriteButton</code>放到父视图里面。</p>\n<p data-nodeid="23828">接着我们为新的组件配置自动布局的约束条件，这就一起来看看<code data-backticks="1" data-nodeid="24127">setupConstraints()</code>方法的实现：</p>\n<pre class="lang-swift" data-nodeid="23829"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {\n    <span class="hljs-keyword">if</span> togglesDataStore.isToggleOn(<span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled) {\n        likesStakeView.snp.makeConstraints {\n            $<span class="hljs-number">0</span>.top.leading.equalToSuperview().offset(<span class="hljs-type">Spacing</span>.twoExtraSmall)\n            $<span class="hljs-number">0</span>.bottom.trailing.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.twoExtraSmall)\n        }\n        favoriteButton.snp.makeConstraints {\n            $<span class="hljs-number">0</span>.bottom.trailing.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="23830">Moments App 使用了 SnapKit 库来配置约束。在这个例子中，我们通过调用<code data-backticks="1" data-nodeid="24130">equalToSuperview().offset(Spacing.twoExtraSmall)</code>为<code data-backticks="1" data-nodeid="24132">likesStakeView</code>添加填充（padding），然后把<code data-backticks="1" data-nodeid="24134">favoriteButton</code>放置在父视图的右下角。</p>\n<p data-nodeid="23831"><strong data-nodeid="24140">配置好布局以后，我们通过绑定的方式来处理点赞按钮的点击事件</strong>，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="23832"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupBindings</span><span class="hljs-params">()</span></span> {\n    <span class="hljs-keyword">if</span> togglesDataStore.isToggleOn(<span class="hljs-type">InternalToggle</span>.isLikeButtonForMomentEnabled) {\n        favoriteButton.rx.tap\n            .bind(onNext: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>\n                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }\n                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.favoriteButton.isSelected {\n                    <span class="hljs-keyword">self</span>.viewModel?.like(from: <span class="hljs-keyword">self</span>.userDataStore.userID).subscribe().disposed(by: <span class="hljs-keyword">self</span>.disposeBag)\n                } <span class="hljs-keyword">else</span> {\n                    <span class="hljs-keyword">self</span>.viewModel?.unlike(from: <span class="hljs-keyword">self</span>.userDataStore.userID).subscribe().disposed(by: <span class="hljs-keyword">self</span>.disposeBag)\n                }\n            })\n            .disposed(by: disposeBag)\n    }\n}\n</code></pre>\n<p data-nodeid="23833">同样地，在进行绑定前，我们先检查<code data-backticks="1" data-nodeid="24142">isLikeButtonForMomentEnabled</code>开关是否开启。当开关开启了，我们就使用 RxCocoa 中<code data-backticks="1" data-nodeid="24144">UIButton</code>的<code data-backticks="1" data-nodeid="24146">.rx.tap</code>扩展属性来绑定<code data-backticks="1" data-nodeid="24148">favoriteButton</code>的点击事件。当用户点击了点赞按钮时，就会调用<code data-backticks="1" data-nodeid="24150">viewModel</code>的<code data-backticks="1" data-nodeid="24152">like()</code>或者<code data-backticks="1" data-nodeid="24154">unlike()</code>方法来更新点赞状态。</p>\n<p data-nodeid="23834">到此为止，我们已经开发了一个完整的点赞功能。</p>\n<h3 data-nodeid="23835">总结</h3>\n<p data-nodeid="23836">在这一讲中，我们以<strong data-nodeid="24163">添加点赞功能</strong>为例讲解了如何快速开发一个新功能。因为 Moments App 使用了 MVVM 和 RxSwift 来进行架构，这就保证了每一层都有明确的责任与分工。</p>\n<p data-nodeid="23837">当你开发新功能时，就可以按照我今天讲解的这些步骤一层层来进行开发：<strong data-nodeid="24169">添加功能开关，开发网络层、Repository 层、ViewModel 层和 View 层</strong>。这样能大大减低代码接手的难度，使得整个团队都遵循统一的步骤与规范，从而降低沟通成本，并同时保证代码的质量。</p>\n<p data-nodeid="23838">思考题</p>\n<blockquote data-nodeid="23839">\n<p data-nodeid="23840">你可能已经注意到，当一个类型需要依赖其他类型时，例如当 GetMomentsByUserIDSession 使用 TogglesDataStoreType 时，我们都是通过 init() 方法进行注入的。那为什么我们不在 GetMomentsByUserIDSession 定义 togglesDataStore 属性时直接初始化呢？</p>\n</blockquote>\n<p data-nodeid="23841">你可以把自己的思考写到下面的留言区哦，这一讲就介绍到这里了，下一讲我将介绍如何使用 TDD 来保证功能模块的高质量。</p>\n<p data-nodeid="23842"><strong data-nodeid="24176">源码地址</strong></p>\n<blockquote data-nodeid="23843">\n<p data-nodeid="23844" class="">朋友圈点赞功能的源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="24181">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments</a></p>\n</blockquote>',
          },
          {
            theme: '23 | TDD 与单元测试：如何保证功能模块的高质量？',
            id: 38,
            content:
              '<p data-nodeid="86083">如果一个 App 有很多的 Bug 或者崩溃率非常高，我们往往就需要花大量的时间和精力去不断查错和“救火”。那怎样才能提高代码的质量，让我们可以把有效的时间专注于产品功能的迭代上呢？经过多年实践经验的总结，我们发现<strong data-nodeid="86089">测试驱动开发</strong>，也叫作 TDD（Test-Driven Development），是一种行而有效的方法实践。</p>\n\n\n<p data-nodeid="84435"><strong data-nodeid="84542">TDD 的核心是编写单元测试</strong>。单元测试能方便我们模拟不同的测试场景，覆盖不同的边界条件，从而提高代码的质量并减少 Bug 的数量。同时，使用 TDD 所开发的代码能降低模块间的耦合度，提高模块的灵活性和可扩展性。</p>\n<p data-nodeid="84436">下面我们以 Moments App 作为例子来看看如何通过编写单元测试来进行 TDD。这里主要讲述测试代码的步骤与结构，以及如何为网络层、Repository 层和 ViewModel 层编写单元测试。</p>\n<h3 data-nodeid="84437">测试代码的步骤与结构</h3>\n<p data-nodeid="84438">在编写测试代码时候，我们一般遵守 AAA 步骤，所谓<strong data-nodeid="84550">AAA 就是 Arrange、Act 和 Assert</strong>。</p>\n<ul data-nodeid="84439">\n<li data-nodeid="84440">\n<p data-nodeid="84441">Arrange：用于搭建测试案例，例如，初始化测试对象及其依赖。</p>\n</li>\n<li data-nodeid="84442">\n<p data-nodeid="84443">Act：表示执行测试，例如，调用测试对象的方法。</p>\n</li>\n<li data-nodeid="84444">\n<p data-nodeid="84445">Assert：用于检验测试的结果。</p>\n</li>\n</ul>\n<p data-nodeid="84446">那怎样才能按照 AAA 步骤来编写测试代码呢？为了简化编写测试的工作，并提高代码的结构性与可读性，我们在 Moments App 中使用了 Quick 和 Nimble 库。下面我以<code data-backticks="1" data-nodeid="84555">MomentsTimelineViewModelTests</code>为例子给你讲述一种实用的测试代码结构：</p>\n<pre class="lang-swift" data-nodeid="84447"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsTimelineViewModelTests</span>: <span class="hljs-title">QuickSpec</span> </span>{\n    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spec</span><span class="hljs-params">()</span></span> {\n        describe(<span class="hljs-string">"MomentsTimelineViewModel"</span>) {\n            <span class="hljs-keyword">var</span> testSubject: <span class="hljs-type">MomentsTimelineViewModel!</span>\n            beforeEach {\n                testSubject = <span class="hljs-type">MomentsTimelineViewModel</span>() <span class="hljs-comment">// Arrange</span>\n            }\n            context(<span class="hljs-string">"loadItems()"</span>) {\n                beforeEach {\n                    testSubject.loadItems() <span class="hljs-comment">// Act</span>\n                }\n                it(<span class="hljs-string">"call `momentsRepo.getMoments` with the correct parameters"</span>) {\n                    expect(mockMomentsRepo.getMomentsHasBeenCalled).to(beTrue()) <span class="hljs-comment">// Assert</span>\n                }\n                it(<span class="hljs-string">"check another assertion"</span>) { }\n            }\n            context(<span class="hljs-string">"anotherMethod()"</span>) { }\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="84448"><strong data-nodeid="84579">首先是测试类的定义</strong>。我们定义了一个继承于<code data-backticks="1" data-nodeid="84561">QuickSpec</code>的测试类，测试类通常以<code data-backticks="1" data-nodeid="84563">&lt;需要测试的类型&gt;Tests</code>的规范来命名。在上面的例子中，我们需要测试<code data-backticks="1" data-nodeid="84565">MomentsTimelineViewModel</code>，因此把测试类定义为<code data-backticks="1" data-nodeid="84567">MomentsTimelineViewModelTests</code>。然后在类里面重写<code data-backticks="1" data-nodeid="84569">spec()</code>方法来封装所有测试案例。接着在<code data-backticks="1" data-nodeid="84571">spec()</code>方法里面通过<code data-backticks="1" data-nodeid="84573">describe()</code>方法来进行分组，我的做法是一个测试类型只有一个<code data-backticks="1" data-nodeid="84575">describe()</code>方法，并把要测试类型的名称传递给该方法，在例子中就写成<code data-backticks="1" data-nodeid="84577">describe("MomentsTimelineViewModel")</code>，这样能保证在批量执行测试案例时可以快速定位出错的测试类。</p>\n<p data-nodeid="84449"><strong data-nodeid="84612">接下来是执行 AAA 中的 Arrange 步骤来搭建测试案例所需的对象</strong>。在<code data-backticks="1" data-nodeid="84584">describe()</code>方法里，我们先定义一个名叫<code data-backticks="1" data-nodeid="84586">testSubject</code>的测试对象，它的类型为需要测试的类型，在我们的例子中，<code data-backticks="1" data-nodeid="84588">testSubject</code>的类型是<code data-backticks="1" data-nodeid="84590">MomentsTimelineViewModel!</code>。你可能注意到，我们定义<code data-backticks="1" data-nodeid="84592">testSubject</code>时使用了<code data-backticks="1" data-nodeid="84594">!</code>来表示该对象不会为<code data-backticks="1" data-nodeid="84596">nil</code>。不过，这里需要提醒一下，在生产代码中，我们绝对不使用<code data-backticks="1" data-nodeid="84598">!</code>来定义属性，因为一旦该属性为<code data-backticks="1" data-nodeid="84600">nil</code>时，调用该属性的方法就会导致程序崩溃。那为什么在测试代码中反而使用<code data-backticks="1" data-nodeid="84602">!</code>呢？因为我们希望在执行每一个测试案例之前都重新生成一个新的<code data-backticks="1" data-nodeid="84604">testSubject</code>对象来保证每个案例都是无状态的，所以我们需要把初始化操作放到<code data-backticks="1" data-nodeid="84606">beforeEach()</code>方法里面，如果<code data-backticks="1" data-nodeid="84608">testSubject</code>不是定义为<code data-backticks="1" data-nodeid="84610">!</code>，就会有编译错误。</p>\n<p data-nodeid="84450"><strong data-nodeid="84629">然后是执行 AAA 里面的 Act 步骤</strong>。测试类型中的每一个公共的方法和属性都需要测试，因此，我们需要把它们的测试案例进行分组。为此，我会使用到<code data-backticks="1" data-nodeid="84617">context()</code>方法。例如，当我们要测试<code data-backticks="1" data-nodeid="84619">loadItems()</code>方法时，就把方法名字传递给<code data-backticks="1" data-nodeid="84621">context()</code>方法，写成<code data-backticks="1" data-nodeid="84623">context("loadItems()")</code>，并在该 context 下的<code data-backticks="1" data-nodeid="84625">beforeEach()</code>方法里调用测试方法<code data-backticks="1" data-nodeid="84627">loadItems()</code>，这样就执行 Act 步骤了。</p>\n<p data-nodeid="84451"><strong data-nodeid="84646">最后看一下如何执行 AAA 里面的 Assert 步骤</strong>。我们可以通过<code data-backticks="1" data-nodeid="84634">it()</code>方法来检验每个测试案例的执行结果。为了使得测试更加容易读，我通常把测试的预期行为都写在<code data-backticks="1" data-nodeid="84636">it()</code>方法里面，示例中的<code data-backticks="1" data-nodeid="84638">it("call momentsRepo.getMoments()with the correct parameters")</code>表示当我们调用<code data-backticks="1" data-nodeid="84640">loadItems()</code>方法时就必须调用<code data-backticks="1" data-nodeid="84642">momentsRepo</code>属性的<code data-backticks="1" data-nodeid="84644">getMoments()</code>函数。</p>\n<p data-nodeid="84452">至此，编写单元测试代码的步骤与框架就讲完了。下面我们再结合真实的例子来看看如何为网络层、Repository 层和 ViewModel 层编写测试代码。</p>\n<h3 data-nodeid="84453">网络层的测试</h3>\n<p data-nodeid="84454">我们以<code data-backticks="1" data-nodeid="84650">GetMomentsByUserIDSessionTests</code>为例子看看如何为网络层编写单元测试的代码。因为我们使用了 RxSwift，在测试的时候可以引用<strong data-nodeid="84656">RxTest 库</strong>来简化测试的流程。</p>\n<p data-nodeid="84455">首先，我们在<code data-backticks="1" data-nodeid="84658">describe("GetMomentsByUserIDSession")</code>函数里定义需要初始化的变量，代码如下：</p>\n<pre class="lang-swift" data-nodeid="84456"><code data-language="swift"><span class="hljs-keyword">var</span> testSubject: <span class="hljs-type">GetMomentsByUserIDSession!</span>\n<span class="hljs-keyword">var</span> testScheduler: <span class="hljs-type">TestScheduler!</span>\n<span class="hljs-keyword">var</span> testObserver: <span class="hljs-type">TestableObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;!\n<span class="hljs-keyword">var</span> mockResponseEvent: <span class="hljs-type">Recorded</span>&lt;<span class="hljs-type">Event</span>&lt;<span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>&gt;&gt;!\n</code></pre>\n<ul data-nodeid="84457">\n<li data-nodeid="84458">\n<p data-nodeid="84459"><code data-backticks="1" data-nodeid="84660">testSubject</code>是测试的对象，在这个例子中是我们需要测试的<code data-backticks="1" data-nodeid="84662">GetMomentsByUserIDSession</code>。</p>\n</li>\n<li data-nodeid="84460">\n<p data-nodeid="84461"><code data-backticks="1" data-nodeid="84664">testScheduler</code>的类型是来自 RxTest 的<code data-backticks="1" data-nodeid="84666">TestScheduler</code>，是一个用于测试的排程器。</p>\n</li>\n<li data-nodeid="84462">\n<p data-nodeid="84463"><code data-backticks="1" data-nodeid="84668">testObserver</code>的类型是 RxTest 的<code data-backticks="1" data-nodeid="84670">TestableObserver</code>，用来订阅 Observable 序列里的事件，并通过接收到的事件来检查测试的结果。</p>\n</li>\n<li data-nodeid="84464">\n<p data-nodeid="84465"><code data-backticks="1" data-nodeid="84672">mockResponseEvent</code>是<code data-backticks="1" data-nodeid="84674">Recorded</code>类型，也是来自 RxTest，用于模拟事件的发送，例如模拟成功接收到网络数据事件或者错误事件。</p>\n</li>\n</ul>\n<p data-nodeid="84466">所需的变量定义完毕以后，可以在<code data-backticks="1" data-nodeid="84677">beforeEach()</code>方法里面初始化<code data-backticks="1" data-nodeid="84679">testScheduler</code>和<code data-backticks="1" data-nodeid="84681">testObserver</code>，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="84467"><code data-language="swift">beforeEach {\n    testScheduler = <span class="hljs-type">TestScheduler</span>(initialClock: <span class="hljs-number">0</span>)\n    testObserver = testScheduler.createObserver(<span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>)\n}\n</code></pre>\n<p data-nodeid="87186">因为初始化操作都在<code data-backticks="1" data-nodeid="87189">beforeEach()</code>方法里面，所以每个测试案例执行前都会重新初始化这两个变量。</p>\n<p data-nodeid="87187">初始化完毕后，我们就可以测试<code data-backticks="1" data-nodeid="87192">GetMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="87194">getMoments()</code>方法了，具体代码如下：</p>\n\n<pre class="lang-swift" data-nodeid="84469"><code data-language="swift">context(<span class="hljs-string">"getMoments(userID:)"</span>) {\n    context(<span class="hljs-string">"when response status code 200 with valid response"</span>) {\n        beforeEach {\n            mockResponseEvent = .next(<span class="hljs-number">100</span>, <span class="hljs-type">TestData</span>.successResponse)\n            getMoments(mockEvent: mockResponseEvent)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="84470">我们使用<code data-backticks="1" data-nodeid="84693">context("getMoments(userID:)")</code>把<code data-backticks="1" data-nodeid="84695">getMoments(userID:)</code>所有的测试案例都组织在一起。先看成功的测试案例，该案例封装在<code data-backticks="1" data-nodeid="84697">context("when response status code 200 with valid response")</code>函数里面，表示网络成功返回有效数据时的情况。在<code data-backticks="1" data-nodeid="84699">beforeEach()</code>方法里做了两件事情，第一件执行 Arrange 步骤，让<code data-backticks="1" data-nodeid="84701">mockResponseEvent</code>发出一个<code data-backticks="1" data-nodeid="84703">.next</code>事件，该事件里面包含了类型为<code data-backticks="1" data-nodeid="84705">GetMomentsByUserIDSession.Response</code>的数据对象<code data-backticks="1" data-nodeid="84707">successResponse</code>。下面是这个数据对象的定义：</p>\n<pre class="lang-swift" data-nodeid="84471"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestData</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> successResponse: <span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span> = {\n        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">try</span>! <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>.<span class="hljs-keyword">self</span>,\n                                               from: <span class="hljs-type">TestData</span>.successjson.data(using: .utf8)!)\n        <span class="hljs-keyword">return</span> response\n    }()\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> successjson = <span class="hljs-string">"""\n    {\n      "data": { ... } // JSON 数据\n    }\n    """</span>\n}\n</code></pre>\n<p data-nodeid="84472">代码中的私有结构体<code data-backticks="1" data-nodeid="84710">TestData</code>用于配置测试数据，它提供了一个名叫<code data-backticks="1" data-nodeid="84712">successResponse</code>的静态属性来返回类型为<code data-backticks="1" data-nodeid="84714">GetMomentsByUserIDSession.Response</code>的测试数据。在这个属性里，我们使用了<code data-backticks="1" data-nodeid="84716">JSONDecoder().decode()</code>方法来解码 JSON 字符串。在开发的过程，我们可以从 BFF 的返回值中拷贝该 JSON 字符串。通过这个测试案例，我们可以快速地测试<code data-backticks="1" data-nodeid="84718">GetMomentsByUserIDSession</code>结构体的映射是否正确。这种做法比通过修改后台来返回测试数据要方便很多。</p>\n<p data-nodeid="84473"><code data-backticks="1" data-nodeid="84720">beforeEach()</code>方法里第二件事情是执行 Act 步骤，可以通过调用<code data-backticks="1" data-nodeid="84722">getMoments(mockEvent: mockResponseEvent)</code>方法来完成这一任务。该方法是一个私有方法，其定义如下：</p>\n<pre class="lang-swift" data-nodeid="84474"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(mockEvent: Recorded&lt;Event&lt;GetMomentsByUserIDSession.Response&gt;&gt;)</span></span> {\n    <span class="hljs-keyword">let</span> testableObservable = testScheduler.createHotObservable([mockEvent])\n    testSubject = <span class="hljs-type">GetMomentsByUserIDSession</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> testableObservable.asObservable() }\n    testSubject.getMoments(userID: <span class="hljs-string">"0"</span>).subscribe(testObserver).disposed(by: disposeBag)\n    testScheduler.start()\n}\n</code></pre>\n<p data-nodeid="84475">首先我们把模拟数据传递给<code data-backticks="1" data-nodeid="84725">testScheduler.createHotObservable()</code>方法来生成一个新的<code data-backticks="1" data-nodeid="84727">testableObservable</code>对象，然后把该对象注入<code data-backticks="1" data-nodeid="84729">GetMomentsByUserIDSession</code>的初始化方法里并生成新的测试对象<code data-backticks="1" data-nodeid="84731">testSubject</code>，接着调用测试对象的<code data-backticks="1" data-nodeid="84733">getMoments(userID:)</code>方法，最后通过调用<code data-backticks="1" data-nodeid="84735">testScheduler.start()</code>方法来启动排程器，模拟一个异步网络请求的过程。</p>\n<p data-nodeid="84476">执行完 Act 步骤以后，我们还需要执行 Assert 步骤来检验测试的结果，验证的代码都放在<code data-backticks="1" data-nodeid="84738">it("should complete and map the response correctly")</code>方法里面，如下所示：</p>\n<pre class="lang-swift" data-nodeid="84477"><code data-language="swift">it(<span class="hljs-string">"should complete and map the response correctly"</span>) {\n    <span class="hljs-keyword">let</span> expectedMomentsDetails = <span class="hljs-type">TestFixture</span>.momentsDetails\n    <span class="hljs-keyword">let</span> actualMomentsDetails = testObserver.events.first!.value.element!\n    expect(actualMomentsDetails).toEventually(<span class="hljs-built_in">equal</span>(expectedMomentsDetails))\n}\n</code></pre>\n<p data-nodeid="84478">我们从<code data-backticks="1" data-nodeid="84741">testObserver</code>里取出它接收到的第一个事件，然后调用<code data-backticks="1" data-nodeid="84743">expect()</code>方法来比较实际数据和预期数据。因为网络的数据是异步返回的，所以我们在比较过程时使用了<code data-backticks="1" data-nodeid="84745">toEventually()</code>方法，该方法会等待结果返回以后才进行比较。</p>\n<p data-nodeid="84479">成功案例已经测试完毕，接下来我们看一个失败的案例。下面的代码模拟了网络访问失败的情况：</p>\n<pre class="lang-swift" data-nodeid="84480"><code data-language="swift">context(<span class="hljs-string">"when response status code non-200"</span>) {\n    <span class="hljs-keyword">let</span> networkError: <span class="hljs-type">APISessionError</span> = .networkError(error: <span class="hljs-type">MockError</span>(), statusCode: <span class="hljs-number">500</span>)\n    beforeEach {\n        mockResponseEvent = .error(<span class="hljs-number">100</span>, networkError, <span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>.<span class="hljs-keyword">self</span>)\n        getMoments(mockEvent: mockResponseEvent)\n    }\n    it(<span class="hljs-string">"should throw a network error"</span>) {\n        <span class="hljs-keyword">let</span> actualError = testObserver.events.first!.value.error <span class="hljs-keyword">as</span>! <span class="hljs-type">APISessionError</span>\n        expect(actualError).toEventually(<span class="hljs-built_in">equal</span>(networkError))\n    }\n}\n</code></pre>\n<p data-nodeid="84481">你可以看到，测试代码的结构和成功案例是一致的，不同的地方是我们让<code data-backticks="1" data-nodeid="84749">mockResponseEvent</code>返回一个错误的事件，在检验的过程中，我们从<code data-backticks="1" data-nodeid="84751">testObserver</code>取出<code data-backticks="1" data-nodeid="84753">error</code>来进行对比，而不是<code data-backticks="1" data-nodeid="84755">element</code>。</p>\n<p data-nodeid="84482">网络测试的代码就讲到这里，你可以打开拉勾教育网的代码仓库来查看更多网络层的测试案例。</p>\n<h3 data-nodeid="84483">Repository 层的测试</h3>\n<p data-nodeid="84484">下面我们以<code data-backticks="1" data-nodeid="84760">MomentsRepoTests</code>为例子看一下如何测试 Repository 层。</p>\n<p data-nodeid="84485"><code data-backticks="1" data-nodeid="84762">MomentsRepoTests</code>用于测试<code data-backticks="1" data-nodeid="84764">MomentsRepo</code>。我们在《19 | 数据层架构：如何使用仓库模式设计数据存储层？》中描述过，<code data-backticks="1" data-nodeid="84766">MomentsRepo</code>依赖了<code data-backticks="1" data-nodeid="84768">PersistentDataStoreType</code>来读取本地数据，并且依赖了<code data-backticks="1" data-nodeid="84770">GetMomentsByUserIDSessionType</code>从 BFF 读取朋友圈信息。那我们测试<code data-backticks="1" data-nodeid="84772">MomentsRepo</code>的时候是不是也一同测试两个类型的实现呢？答案是否定的，因为<strong data-nodeid="84788">所谓单元测试就是只单独测试某个类型的具体实现，而不测试它的依赖类型</strong>。回到<code data-backticks="1" data-nodeid="84778">MomentsRepoTests</code>的例子，它仅仅测试<code data-backticks="1" data-nodeid="84780">MomentsRepo</code>的实现。也就是说，哪怕我们替换了<code data-backticks="1" data-nodeid="84782">PersistentDataStoreType</code>和<code data-backticks="1" data-nodeid="84784">GetMomentsByUserIDSessionType</code>的实现，在不修改<code data-backticks="1" data-nodeid="84786">MomentsRepoTests</code>的情况下，所有测试案例都必须通过验证。</p>\n<p data-nodeid="84486">那怎样才能使得<code data-backticks="1" data-nodeid="84790">MomentsRepoTests</code>只测试<code data-backticks="1" data-nodeid="84792">MomentsRepo</code>的实现，而不测试其他任何的依赖类型呢？我们可以通过 Mock 类型来达到这一目的。下面是 Mock 类型的示例代码：</p>\n<pre class="lang-swift" data-nodeid="84487"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockUserDefaultsPersistentDataStore</span>: <span class="hljs-title">PersistentDataStoreType</span> </span>{\n    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; = .create(bufferSize: <span class="hljs-number">1</span>)\n    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> savedMomentsDetails: <span class="hljs-type">MomentsDetails?</span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span> {\n        savedMomentsDetails = momentsDetails\n    }\n}\n<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockGetMomentsByUserIDSession</span>: <span class="hljs-title">GetMomentsByUserIDSessionType</span> </span>{\n    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> getMomentsHasbeenCalled = <span class="hljs-literal">false</span>\n    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> passedUserID: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; {\n        passedUserID = userID\n        getMomentsHasbeenCalled = <span class="hljs-literal">true</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.just(<span class="hljs-type">TestFixture</span>.momentsDetails)\n    }\n}\n</code></pre>\n<p data-nodeid="84488">我们分别定义了两个 Mock 类型来遵循<code data-backticks="1" data-nodeid="84795">PersistentDataStoreType</code>和<code data-backticks="1" data-nodeid="84797">GetMomentsByUserIDSessionType</code>协议，这些 Mock 类型只是把传递的参数保存在属性中，并不进行具体的操作，例如不会读写本地数据库和访问网络。</p>\n<p data-nodeid="84489">有了这些 Mock 类型以后，我们就可以把它们注入测试对象<code data-backticks="1" data-nodeid="84800">testSubject</code>中，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="84490"><code data-language="swift">beforeEach {\n    mockUserDefaultsPersistentDataStore = <span class="hljs-type">MockUserDefaultsPersistentDataStore</span>()\n    mockGetMomentsByUserIDSession = <span class="hljs-type">MockGetMomentsByUserIDSession</span>()\n    testSubject = <span class="hljs-type">MomentsRepo</span>(persistentDataStore: mockUserDefaultsPersistentDataStore, getMomentsByUserIDSession: mockGetMomentsByUserIDSession)\n}\n</code></pre>\n<p data-nodeid="84491">在上一讲的思考题中我提问过：为什么保存依赖的属性都是通过<code data-backticks="1" data-nodeid="84803">init()</code>方法来注入，而不是在内部进行初始化？<strong data-nodeid="84817">一个重要的原因是我们可以在执行单元测试时把 Mock 类型注入进来</strong>。例如在生产代码中，我们为<code data-backticks="1" data-nodeid="84809">MomentsRepo</code>的<code data-backticks="1" data-nodeid="84811">persistentDataStore</code>属性注入<code data-backticks="1" data-nodeid="84813">UserDefaultsPersistentDataStore.shared</code>来访问 iOS 系统的 UserDefaults。UserDefaults 上的数据在程序退出以后还会保留，而单元测试的案例是无状态的，因此所有测试都不应该读写 UserDefaults 上的数据。我们可以在测试代码中，通过注入<code data-backticks="1" data-nodeid="84815">MockUserDefaultsPersistentDataStore</code>的对象来避免访问 UserDefaults。</p>\n<p data-nodeid="84492">依赖注入是面向抽象编程中一种有效的实践方式，不但方便我们编写测试代码，使得测试不依赖于任何的具体环境，同时还能帮我们很容易地替换某个模块的具体实现，例如，当我们决定使用 CoreData 来替换 UserDefaults 作为本地数据存储时，只需在生产代码中注入<code data-backticks="1" data-nodeid="84819">CoreDataPersistentDataStore.shared</code>即可。</p>\n<p data-nodeid="84493">有了 Mock 类型以后，我们看一下如何测试<code data-backticks="1" data-nodeid="84822">MomentsRepo</code>的<code data-backticks="1" data-nodeid="84824">momentsDetails</code>属性，其中 Arrange 和 Act 步骤的代码如下：</p>\n<pre class="lang-swift" data-nodeid="84494"><code data-language="swift">context(<span class="hljs-string">"momentsDetails"</span>) {\n    <span class="hljs-keyword">var</span> testObserver: <span class="hljs-type">TestObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;!\n    beforeEach {\n        testObserver = <span class="hljs-type">TestObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;() <span class="hljs-comment">// Arrange</span>\n        testSubject.momentsDetails.subscribe(testObserver).disposed(by: disposeBag) <span class="hljs-comment">// Act</span>\n    }\n}\n</code></pre>\n<p data-nodeid="84495">首先，初始化了一个<code data-backticks="1" data-nodeid="84827">TestObserver</code>对象来帮助测试 RxSwift 的代码。<code data-backticks="1" data-nodeid="84829">TestObserver</code>是我们自定义的一个类，定义如下：</p>\n<pre class="lang-swift" data-nodeid="84496"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObserver</span>&lt;<span class="hljs-title">ElementType</span>&gt;: <span class="hljs-title">ObserverType</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastEvent: <span class="hljs-type">Event</span>&lt;<span class="hljs-type">ElementType</span>&gt;?\n    <span class="hljs-keyword">var</span> lastElement: <span class="hljs-type">ElementType?</span> {\n        <span class="hljs-keyword">return</span> lastEvent?.element\n    }\n    <span class="hljs-keyword">var</span> lastError: <span class="hljs-type">Error?</span> {\n        <span class="hljs-keyword">return</span> lastEvent?.error\n    }\n    <span class="hljs-keyword">var</span> isCompleted: <span class="hljs-type">Bool</span> {\n        <span class="hljs-keyword">return</span> lastEvent?.isCompleted ?? <span class="hljs-literal">false</span>\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">on</span><span class="hljs-params">(<span class="hljs-number">_</span> event: Event&lt;ElementType&gt;)</span></span> {\n        lastEvent = event\n    }\n}\n</code></pre>\n<p data-nodeid="84497"><code data-backticks="1" data-nodeid="84831">TestObserver</code>定义了<code data-backticks="1" data-nodeid="84833">on(_ event: Event&lt;ElementType&gt;)</code>方法来接收事件，并提供了<code data-backticks="1" data-nodeid="84835">lastElement</code>、<code data-backticks="1" data-nodeid="84837">lastError</code>和<code data-backticks="1" data-nodeid="84839">isCompleted</code>属性来检查最后一条事件的类型。有了<code data-backticks="1" data-nodeid="84841">testObserver</code>对象，我们可以把它传递给<code data-backticks="1" data-nodeid="84843">subscribe()</code>方法来订阅<code data-backticks="1" data-nodeid="84845">momentsDetails</code>属性的事件，然后通过它来验证 RxSwift 代码的测试结果，下面是 Assert 步骤的代码：</p>\n<pre class="lang-swift" data-nodeid="84498"><code data-language="swift">it(<span class="hljs-string">"should be `nil` by default"</span>) {\n    expect(testObserver.lastElement).to(beNil()) <span class="hljs-comment">// Assert</span>\n}\ncontext(<span class="hljs-string">"when persistentDataStore has new data"</span>) {\n    beforeEach {\n        mockUserDefaultsPersistentDataStore.momentsDetails.onNext(<span class="hljs-type">TestFixture</span>.momentsDetails)\n    }\n    it(<span class="hljs-string">"should notify a next event with the new data"</span>) {\n        expect(testObserver.lastElement).toEventually(<span class="hljs-built_in">equal</span>(<span class="hljs-type">TestFixture</span>.momentsDetails)) <span class="hljs-comment">// Assert</span>\n    }\n}\n</code></pre>\n<p data-nodeid="84499">在开始的时候，<code data-backticks="1" data-nodeid="84848">testObserver</code>不应该接收到任何事件，所以它的<code data-backticks="1" data-nodeid="84850">lastElement</code>属性返回<code data-backticks="1" data-nodeid="84852">nil</code>。当我们往 Mock 类型<code data-backticks="1" data-nodeid="84854">mockUserDefaultsPersistentDataStore</code>的<code data-backticks="1" data-nodeid="84856">momentsDetails</code>属性发出一个<code data-backticks="1" data-nodeid="84858">next</code>事件后，<code data-backticks="1" data-nodeid="84860">testObserver</code>会接收到该事件，我们可以调用<code data-backticks="1" data-nodeid="84862">toEventually()</code>方法来进行检查。</p>\n<p data-nodeid="84500">下面我们再看看<code data-backticks="1" data-nodeid="84865">getMoments(userID:)</code>方法的测试。具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="84501"><code data-language="swift">context(<span class="hljs-string">"getMoments(userID:)"</span>) {\n    beforeEach {\n        testSubject.getMoments(userID: <span class="hljs-string">"1"</span>).subscribe().disposed(by: disposeBag)\n    }\n    it(<span class="hljs-string">"should call `GetMomentsByUserIDSessionType.getMoments`"</span>) {\n        expect(mockGetMomentsByUserIDSession.getMomentsHasbeenCalled).to(beTrue())\n        expect(mockGetMomentsByUserIDSession.passedUserID).to(be(<span class="hljs-string">"1"</span>))\n    }\n    it(<span class="hljs-string">"should save a `MomentsDetails` object"</span>) {\n        expect(mockUserDefaultsPersistentDataStore.savedMomentsDetails).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">TestFixture</span>.momentsDetails))\n    }\n}\n</code></pre>\n<p data-nodeid="84502">我们在<code data-backticks="1" data-nodeid="84868">beforeEach()</code>方法中执行了 Act 步骤来调用<code data-backticks="1" data-nodeid="84870">getMoments(userID:)</code>方法，这里首先复习一下《第 19 讲| 数据层架构：如何使用仓库模式设计数据存储层？》里讲过的<code data-backticks="1" data-nodeid="84872">MomentsRepo</code>方法的实现。</p>\n<pre class="lang-swift" data-nodeid="84503"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {\n    <span class="hljs-keyword">return</span> getMomentsByUserIDSession\n        .getMoments(userID: userID)\n        .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })\n        .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }\n        .catchErrorJustReturn(())\n}\n</code></pre>\n<p data-nodeid="84504">在该方法实现中，我们会调用<code data-backticks="1" data-nodeid="84875">getMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="84877">getMoments(userID:)</code>来读取网络数据，并调用<code data-backticks="1" data-nodeid="84879">persistentDataStore</code>的<code data-backticks="1" data-nodeid="84881">save(momentsDetails:)</code>方法把网络返回结果保存到本地数据库中。在测试过程中，我们已经为这两个依赖项分别注入了不同的 Mock 对象，因此在检验结果的时候，我们可以通过比较 Mock 对象的属性就能验证测试是否正确执行。例如，我们检查<code data-backticks="1" data-nodeid="84883">mockGetMomentsByUserIDSession.passedUserID</code>来验证<code data-backticks="1" data-nodeid="84885">getMomentsByUserIDSession</code>的执行结果，然后检查<code data-backticks="1" data-nodeid="84887">mockUserDefaultsPersistentDataStore.savedMomentsDetails</code>来验证<code data-backticks="1" data-nodeid="84889">persistentDataStore</code>的执行结果。</p>\n<h3 data-nodeid="84505">ViewModel 层的测试</h3>\n<p data-nodeid="84506">完成 Repository 层的测试以后，我们再一起看看如何测试 ViewModel 层的代码。</p>\n<p data-nodeid="84507">朋友圈功能的 ViewModel 层由三个 ViewModel 类型所组成，其中<code data-backticks="1" data-nodeid="84894">MomentsTimelineViewModel</code>类型的测试方式与<code data-backticks="1" data-nodeid="84896">MomentsRepo</code>是一样的，<strong data-nodeid="84902">都是通过注入 Mock 类型类来测试 RxSwift 返回的结果</strong>。你可以在拉勾教育网的代码仓库查看详细的代码实现。</p>\n<p data-nodeid="84508">因为<code data-backticks="1" data-nodeid="84904">UserProfileListItemViewModel</code>的责任是把 Model 类型的数据转换成 UI 呈现所需的 ViewModel 类型，那么作为其测试类型，<code data-backticks="1" data-nodeid="84906">UserProfileListItemViewModelTests</code>的工作就是验证这些数据转换的逻辑是否正确。我们一起看看<code data-backticks="1" data-nodeid="84908">UserProfileListItemViewModelTests</code>的实现代码，首先是成功的测试案例，如下所示：</p>\n<pre class="lang-swift" data-nodeid="84509"><code data-language="swift">context(<span class="hljs-string">"init(userDetails:)"</span>) {\n    context(<span class="hljs-string">"when all data provided"</span>) {\n        beforeEach {\n            testSubject = <span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: <span class="hljs-type">TestFixture</span>.userDetails)\n        }\n        it(<span class="hljs-string">"should initialize the properties correctly"</span>) {\n            expect(testSubject.name).to(<span class="hljs-built_in">equal</span>(<span class="hljs-string">"Jake Lin"</span>))\n            expect(testSubject.avatarURL).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://avatars-url.com"</span>)))\n            expect(testSubject.backgroundImageURL).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://background-image-url.com"</span>)))\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="84510">因为所有的转换逻辑都封装在<code data-backticks="1" data-nodeid="84911">UserProfileListItemViewModel</code>的<code data-backticks="1" data-nodeid="84913">init(userDetails:)</code>方法里面，所以我们可以通过测试该<code data-backticks="1" data-nodeid="84915">init()</code>方法来验证数据转换的逻辑。上面的例子中，我们把预先准备好的 Model 数据<code data-backticks="1" data-nodeid="84917">TestFixture.userDetails</code>传递给<code data-backticks="1" data-nodeid="84919">UserProfileListItemViewModel</code>来初始化<code data-backticks="1" data-nodeid="84921">testSubject</code>，然后在<code data-backticks="1" data-nodeid="84923">it("should initialize the properties correctly")</code>方法里检验各个属性的转换结果，例如<code data-backticks="1" data-nodeid="84925">name</code>等于 “Jake Lin”，而<code data-backticks="1" data-nodeid="84927">avatarURL</code>和<code data-backticks="1" data-nodeid="84929">backgroundImageURL</code>都正确地从字符串转换成 URL 类型。</p>\n<p data-nodeid="84511">下面是转换错误时的情况，代码如下：</p>\n<pre class="lang-swift" data-nodeid="84512"><code data-language="swift">context(<span class="hljs-string">"when `userDetails.avatar` is not a valid URL"</span>) {\n    beforeEach {\n        testSubject = <span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-type">UserDetails</span>(id: <span class="hljs-string">"1"</span>, name: <span class="hljs-string">"name"</span>, avatar: <span class="hljs-string">"this is not a valid URL"</span>, backgroundImage: <span class="hljs-string">"https://background-image-url.com"</span>))\n    }\n    it(<span class="hljs-string">"`avatarURL` should be nil"</span>) {\n        expect(testSubject.avatarURL).to(beNil())\n    }\n}\n</code></pre>\n<p data-nodeid="84513">当我们把无效的 URL 字符串传递给<code data-backticks="1" data-nodeid="84933">avatar</code>属性时，转换后的<code data-backticks="1" data-nodeid="84935">testSubject.avatarURL</code>就会变成<code data-backticks="1" data-nodeid="84937">nil</code>。</p>\n<p data-nodeid="84514">其他转换错误的案例与上面的例子类似，你可以在拉勾教育的代码仓库里进行查看。</p>\n<p data-nodeid="84515">到此为止，我们已经讲完如何为 MVVM 架构开发单元测试了。</p>\n<h3 data-nodeid="84516">总结</h3>\n<p data-nodeid="84517">在这一讲，我们以朋友圈功能作为例子，讲述如何通过 AAA 方法一步步地为网络层、Repository 层和 ViewModel 层编写单元测试。<strong data-nodeid="84947">通过 TDD 方式所开发的代码会迫使我们定义良好的接口，并使用依赖注入的方式来管理所有依赖项，因此，通过 TDD 方法所开发的模块都具备强内聚、弱耦合、可扩展等特性</strong>。同时，单元测试能帮助我们便捷地模拟不同的测试案例，从而提高代码的质量，减少 Bug 和 App 的崩溃率。希望你在工作中也可以推动 TDD，根据我的经验，编写单元测试所花费的时间远比以后修改 Bug 所需时间要少很多。</p>\n<p data-nodeid="84518">现在，“架构与实现”模块我们已经讲述完毕了。在这个模块中，我们讲述了如何使用 BFF 设计跨平台的系统架构，然后分析了如何使用 RxSwift 来设计一套根据数据流自动更新的 MVVM 框架，并详细介绍了 MVVM 每一层的具体实现。</p>\n<p data-nodeid="84519">在结束这一模块前，我还想再分享一下我个人对 App 架构与实现的理解，希望对你有所帮助。</p>\n<p data-nodeid="84520">苹果公司所提供的 MVC 模式并没有很好地解决 App 架构的问题，iOS 开发社区在探索的过程中形成了多种架构，例如，使用 MVC 加上 Coordinator 的 MVCC 模式，还有 MVP、VIPER 以及文章中讲述的 MVVM 架构等。尽管它们的架构与实现可能不一样，但是它们的目的都是解决臃肿的 MVC 问题。除此之外，它们在设计过程中都遵循一些通用的原则，例如单一责任原则（每一个组件只完成单独的一个功能）和开闭原则（通过抽象的协议来封闭具体的实现，但同时开放对类型的扩展），等等。</p>\n<p data-nodeid="84521">基于这些通用的设计原则，并结合多年的经验与教训，<strong data-nodeid="84960">我为 Moments App 重新架构和实现了一套基于 RxSwift 的 MVVM 架构</strong>。通过这一模块的学习，想必你已经见识到这套框架的威力了，但并不代表这就是默认的或者标准的 MVVM 实现方式，甚至可以说在软件架构领域根本就没有什么一成不变的标准方案，<strong data-nodeid="84961">一套好的方案应该可以根据需求的变化而不断地迭代与改进</strong>。</p>\n<p data-nodeid="84522">当你想使用这套框架的时候，可以结合自己的项目，遵循通用的设计原则来慢慢改进，例如，把所有的网络层逻辑都封装到一个独立的模块中，其他模块必须通过网络层模块来访问网络，或者把所有数据访问都放到 Repository 模块中，UI 需要访问数据时都通过 Repository 来存取。又例如，当一个模块需要依赖于其他模块时，都在初始化方法中进行依赖注入，这样能方便我们以后替换具体实现，提高架构的可扩展性。</p>\n<p data-nodeid="88292" class="te-preview-highlight">还有一点我想强调一下，写代码是一门手艺活。这个模块的代码实现比较多，我建议你从 GitHub 上把代码下载下来，并对照文章的内容一同学习，然后通过实现新功能来加深理解。<strong data-nodeid="88298">任何架构能力都是建立在代码能力之上的，要提高架构能力首先需要不断提高编写高质量代码的能力。</strong> 编写高质量代码通常需要灵活运用各种软件设计的原则，当能熟练使用这些原则时，架构 App 也就变成水到渠成的事情了。</p>\n\n<p data-nodeid="84524"><strong data-nodeid="84971">思考题</strong></p>\n<blockquote data-nodeid="84525">\n<p data-nodeid="84526">这是架构与实现模块的最后一篇，我建议你在朋友圈时间轴页面里添加分享文章的功能，并编写相关的单元测试。通过这个功能的开发，能让你从头到尾理解整个 MVVM 框架的核心思想。</p>\n</blockquote>\n<p data-nodeid="84527">如果你完成该功能，请提交一个 PR 哦。如果你有什么想法，也可以写到留言区。下一讲我们会讲述“如何统一管理 Certificates 和 Profiles”，这就进入下一个模块——上架与优化。</p>\n<p data-nodeid="84528"><strong data-nodeid="84977">源码地址</strong></p>\n<blockquote data-nodeid="84529">\n<p data-nodeid="84530">单元测试的源码地址：<br>\n<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/MomentsTests?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="84982">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/MomentsTests</a></p>\n</blockquote>',
          },
        ],
      },
      {
        sectionName: '模块四：上架与优化',
        sectionId: 4,
        courseList: [
          {
            theme: '24 | 解决打包痛点：如何统一管理 Certificates 和 Profiles？',
            id: 40,
            content:
              '<p data-nodeid="1279" class="">一个优秀的 iOS 开发者所需要做的工作不仅仅是编写代码那么简单，还要管理证书（Certificates）和 Provisioning Profile、打包和签名 App、上架与分发等。你如果做过这些操作的话应该知道，单纯通过手工的方式来完成，每个步骤都需要花费大量的时间，而且十分容易出错。</p>\n<p data-nodeid="1280">那有没有什么办法能帮我们节省这些手工操作的时间呢？答案当然是肯定的。我们可以<strong data-nodeid="1402">通过 fastlane 来自动化这些操作</strong>，所以，在这一讲中我们就来介绍下如何通过 fastlane 来统一管理证书和 Provisioning Profiles。</p>\n<h3 data-nodeid="1281">什么是证书和 Provisioning Profile</h3>\n<p data-nodeid="1282">刚接触 iOS 的开发者可能都会有一个疑惑：为什么在 iOS 开发过程中需要管理私钥、证书、Provisioning Profile 以及设备列表等信息呢？</p>\n<p data-nodeid="1283">这是因为<strong data-nodeid="1410">苹果要给 App 的终端用户提供安全和稳定的体验</strong>。而要达到这一效果，苹果就得要求所有开发者在用户安装之前必须为 App 进行打包和签名。有了这些签名，苹果就知道这些 App 到底是谁开发的，签名以后 App 是否被修改过。</p>\n<p data-nodeid="1284">这里的打包和签名操作就涉及私钥、证书和 Provisioning Profile 等组件，我们可以结合下面这张图看看这些组件之间的关系：</p>\n<p data-nodeid="1285"><img src="https://s0.lgstatic.com/i/image6/M00/3E/F6/Cgp9HWCbpROAFzsfAAbfDL-IX24841.png" alt="图片4.png" data-nodeid="1414"></p>\n<p data-nodeid="1286">那这些组件到底都有什么作用呢？下面我们来分别说明下。</p>\n<ul data-nodeid="1287">\n<li data-nodeid="1288">\n<p data-nodeid="1289"><strong data-nodeid="1420">苹果证书机构</strong>。世界上有好多证书机构（CA），但当我们通过 App Store Connect 发布 App 的时候，苹果公司只认它自己的证书机构。因为苹果证书机构归苹果公司所有，所以苹果公司对安装到设备上的所有 iOS App 都有最终的控制权。</p>\n</li>\n<li data-nodeid="1290">\n<p data-nodeid="1291"><strong data-nodeid="1425">私钥</strong>。这是生成签名证书所需的私钥文件，通常是一个后缀名为 .p12 的文件。私钥是证明我们身份的唯一信息源，假如丢失了这个私钥，那其他人就能伪装成我们了，非常不安全。当我们手工生成证书时，会通过 Keychain Access 程序生成一个后缀为 .certSigningRequest 的 Certificate Signing Request 文件和私钥文件，然后把 .certSigningRequest 文件上传到苹果开发者网站，苹果公司就可以通过这个请求，并使用苹果证书机构来为我们发行一个证书。</p>\n</li>\n<li data-nodeid="1292">\n<p data-nodeid="1293"><strong data-nodeid="1430">签名证书</strong>。签名证书是由苹果证书机构通过提供的 .certSigningRequest 文件所签发的，因此苹果公司知道这个证书的所有人。苹果公司会把这个证书作为签名主体。签名证书通常是一个后缀名为 .cer 的文件，该 .cer 文件包含了开发者 ID、团队 ID 和公钥信息。</p>\n</li>\n<li data-nodeid="1294">\n<p data-nodeid="1295"><strong data-nodeid="1435">发布渠道</strong>。我们可以把 App 通过不同渠道发布出去，目前支持的渠道有 Development、Ad Hoc、Enterprise 和 App Store。当我们在 Xcode 上把 App 部署到设备进行 Debug 时，一般会使用 Development 渠道。当我们把 App 分发给内部测试用户时，可以使用 Ad Hoc 渠道。如果开发企业内的 App，可以使用 Enterprise 渠道来发布。而对于要上传到 App Store 的 App，就必须使用 App Store 渠道了。</p>\n</li>\n<li data-nodeid="1296">\n<p data-nodeid="1297"><strong data-nodeid="1440">App ID</strong>。每个 App 都有唯一的 ID。根据不同的用途，我们为 Moments App 建立了三个 App ID，分别用于开发与调试、内部测试和上架 App Store。</p>\n</li>\n<li data-nodeid="1298">\n<p data-nodeid="1299"><strong data-nodeid="1445">设备列表</strong>。当我们通过 Ad Hoc 渠道来发布 App 时，要把需要安装 App 的设备添加到设备列表中，只有在设备列表中的设备才能安装 Ad Hoc 渠道的 App。</p>\n</li>\n<li data-nodeid="1300">\n<p data-nodeid="1301"><strong data-nodeid="1450">Provisioning Profile</strong>。有了证书以后，我们可以为不同的 App ID 以及不同的发布渠道来生成不同的 Provisioning profile，通常是一个后缀名为 .mobileprovision 或 .provisionprofile 的文件。该文件包含 App ID 所指向的 Entitlements 信息，以及发布渠道、团队 ID 和设备列表信息。我们通常为不同用途的 App 生成不同的 Provisioning Profile，例如我们为 Moments App 的 App Store 版本生成一个 Provisioning Profile，然后再为 Moments App 的 Internal 版本生成另外一个 Provisioning Profile。</p>\n</li>\n</ul>\n<h3 data-nodeid="1302">搭建管理证书和 Provisioning Profile 的环境</h3>\n<p data-nodeid="1303">假如你手工生成过私钥、证书和 Provisioning Profile 文件，并在苹果开发者网站上进行过上传、下载和安装的话，就知道这些操作过程有多麻烦。</p>\n<ul data-nodeid="1304">\n<li data-nodeid="1305">\n<p data-nodeid="1306">有些团队会为每个成员生成多个不同的证书来进行签名，这将导致大量证书和 Provisioning Profile 文件的出现，十分难管理。</p>\n</li>\n<li data-nodeid="1307">\n<p data-nodeid="1308">证书都是有期限的，每次延展期限都需要手工更新所有的 Provisioning Profiles。</p>\n</li>\n<li data-nodeid="1309">\n<p data-nodeid="1310">当添加新增设备时，也需要更新 Ad Hoc 的 Provisioning Profiles。</p>\n</li>\n<li data-nodeid="1311">\n<p data-nodeid="1312">当搭建 CI 的时候，又需要花大量时间来下载、安装私钥、证书和 Provisioning Profiles 文件。</p>\n</li>\n</ul>\n<p data-nodeid="1313">那有没有什么办法来简化证书和 Provisioning Profiles 的管理工作呢？幸运的是<strong data-nodeid="1462">fastlane 为我们提供了一个名叫 match 的 Action 来为整个团队统一管理并共享所有证书和 Provisioning Profile</strong>。</p>\n<p data-nodeid="1314">下面我们就来看一下如何使用 fastlane 的 match Action 搭建所需的环境吧。</p>\n<h4 data-nodeid="1315">建 GitHub 私有 Repo</h4>\n<p data-nodeid="1316">为了把证书共享给整个团队使用，fastlane match 需要把私钥和证书保存在云端的存储服务上。目前支持的云存储服务有亚马逊的 S3、谷歌云和微软的 Azure 等。但<strong data-nodeid="1470">我推荐使用 GitHub 私有 Repo 来存储私钥和证书，因为 GitHub 私有 Repo 是免费的，而且有详细的修改历史</strong>。Moments App 的证书就保存在 GitHub 的私有 Repo 里面，下面我们讲一下如何搭建 GitHub 私有 Repo。</p>\n<p data-nodeid="1317">我们可以点击 GitHub 网站右上角的加号（+）按钮，然后选择 New repository 菜单来新建私有 Repo。因为该 Repo 用于签名，所以我会以“&lt;项目名称&gt;-codesign”的方式来命名，例如叫 moments-codesign。具体页面情况如下图所示：</p>\n<p data-nodeid="1318"><img src="https://s0.lgstatic.com/i/image6/M00/3D/C3/CioPOWCWMc2ASbGgAAEeGAfOCoA064.png" alt="Drawing 1.png" data-nodeid="1476"></p>\n<p data-nodeid="1319">这里需要注意：<strong data-nodeid="1482">我们必须把 Repo 设置为 Private，因为该 Repo 保存了私钥等关键信息</strong>，一旦设置为 Public 的话，所有人都可以访问它了。</p>\n<h4 data-nodeid="1320">生成 GitHub Access Token</h4>\n<p data-nodeid="1321"><strong data-nodeid="1487">那怎样才能让整个团队都能访问这个私有 Repo 呢？答案是使用 GitHub Access Token。</strong></p>\n<p data-nodeid="1322">我推荐的做法是为每一个 App 新建一个 GitHub 账户，例如新建一个叫作 momentsci 的账户，然后把该账户添加到私有 Repo 的贡献者列表里面。如下图所示：</p>\n<p data-nodeid="1323"><img src="https://s0.lgstatic.com/i/image6/M00/3D/C3/CioPOWCWMdSAYvK7AADj0dRNEHo360.png" alt="Drawing 2.png" data-nodeid="1491"></p>\n<p data-nodeid="1324">这样子，momentsci 用户就能访问和更新该私有 Repo 了。</p>\n<p data-nodeid="1325">下一步是为 momentsci 用户生成 GitHub Access Token。当我们通过 momentsci 登录到 GitHub 以后，点击 Settings -&gt; Developer settings -&gt; Personal access tokens 来打开来配置页面，接着再点击 Generate new token 按钮，在 Note 输入框填写 Token 的用途，比如写上“用于 Moments App 的 CI”，然后在 Select scopes 选上 repo，如下图所示：</p>\n<p data-nodeid="1326"><img src="https://s0.lgstatic.com/i/image6/M00/3D/C3/CioPOWCWMdyAGRYeAAGmH0NcYDk620.png" alt="Drawing 3.png" data-nodeid="1496"></p>\n<p data-nodeid="1327">因为我们选择了 Full controll of private repositories（能完全控制所有私有 Repo），所以使用该 Token 的应用程序（例如 fastlane）就有权限访问 momentsci 用户所能访问的所有 Repo，并且能 push commit 到这些 Repo 去。当我们点击 Generate token 按钮以后就生成一个如下图所示的 Token：</p>\n<p data-nodeid="1328"><img src="https://s0.lgstatic.com/i/image6/M01/3E/F6/Cgp9HWCbpVKAIJRSAAQzSVGBgVk131.png" alt="图片5.png" data-nodeid="1500"></p>\n<p data-nodeid="1329">这里需要注意，我们<strong data-nodeid="1506">一定要好好保存这个 Token</strong>，因为一旦关闭该页面以后就无法再从 GitHub 上找到该 Token 了。为了使得团队所有人都可以使用到这个 Token，我推荐把它存放在团队密码共享服务里面，目前比较流行的密码共享服务有 LastPass、OnePassword 等。</p>\n<p data-nodeid="1330">有了这个 Token 以后，我们还需要生成一个 BASE64 字符串提供给 fastlane 使用，命令如下：</p>\n<pre class="lang-java" data-nodeid="1331"><code data-language="java">$&gt; echo -n your_github_username:your_personal_access_token | base64\n</code></pre>\n<p data-nodeid="1332">不过需要把 your_github_username 替换为 GitHub 用户名，例如 momentsci 用户，然后把 your_personal_access_token 替换成刚才所生成的 Token。</p>\n<p data-nodeid="1333">接着就可以在 Shell 里把 BASE64 赋值给环境变量<code data-backticks="1" data-nodeid="1520">MATCH_GIT_BASIC_AUTHORIZATION</code>，如下所示：</p>\n<pre class="lang-java" data-nodeid="1334"><code data-language="java">$&gt; export MATCH_GIT_BASIC_AUTHORIZATION=&lt;YOUR BASE64 KEY&gt;\n</code></pre>\n<p data-nodeid="1335">为了提高安全性，我们还可以配置环境变量<code data-backticks="1" data-nodeid="1523">MATCH_PASSWORD</code>来加密私钥、证书和 Provisioning Profile 文件。但是需要注意：<strong data-nodeid="1529">一定要记住这个密码，因为使用这些文件的机器都需要使用到该密码</strong>。</p>\n<pre class="lang-java" data-nodeid="1336"><code data-language="java">$&gt; export MATCH_PASSWORD=&lt;YOUR MATCH PASSWORD&gt;\n</code></pre>\n<h4 data-nodeid="1337">生成 App Store Connect API Key</h4>\n<p data-nodeid="1338">因为生成证书和 Provisioning Profile 的过程需要与苹果开发者网站进行交互，所以 fastlane 也需要具备访问苹果开发者网站的权限。</p>\n<p data-nodeid="1339">目前 fastlane 提供了几种办法来访问苹果开发者网站，例如，输入登录所需的用户名和密码等。但<strong data-nodeid="1537">我推荐使用 App Store Connect API Key 的方式</strong>，因为 API Key 既能有效控制访问权限，也可以随时让该 Key 失效。</p>\n<p data-nodeid="1340">我们可以在 App Store Connect 网站上生成该 Key，在网站上选择 Users and Access -&gt; Keys -&gt; App Store Connect API，然后点击加号（+）来生成 Key，会弹出下面的输入框：</p>\n<p data-nodeid="1341"><img src="https://s0.lgstatic.com/i/image6/M01/3E/F7/Cgp9HWCbpZiAbIChAAC_Yq3o-fE466.png" alt="图片7.png" data-nodeid="1541"></p>\n<p data-nodeid="1342">Key 的名称可以填写其用途，例如使用到 CI 上我们就填 “Moments CI”，然后在 Access 里选择 App Manager。需要注意：<strong data-nodeid="1547">必须选择 App Manager 以上的权限</strong>，因为使用 App Manager 以下的权限，fastlane 在执行过程中会出错。这是 fastlane 的一个已知的问题，假如以后解决了该问题，我们就可以选择 Developer 权限，原则上是该 Key 的 Access 权限越低就越安全。</p>\n<p data-nodeid="1343">当 Key 生成完毕后，我们需要把它保存起来，并在 Shell 里把该 Key 赋值给环境变量<code data-backticks="1" data-nodeid="1549">APP_STORE_CONNECT_API_CONTENT</code>，如下所示：</p>\n<pre class="lang-java" data-nodeid="1344"><code data-language="java">$&gt; export APP_STORE_CONNECT_API_CONTENT=&lt;App Store Connect API&gt;\n</code></pre>\n<p data-nodeid="1345">到这里，管理证书和 Provisioning Profile 的环境就配置完了。配置的步骤虽然有点多，但是<strong data-nodeid="1556">每个项目只需配置一次就好了，其他项目成员无须重复配置</strong>。为了进一步简化环境变量的赋值操作，我推荐在项目根目录下建立一个名叫 local.keys 的文件，然后把所有环境变量都放在该文件里面，如下所示：</p>\n<pre class="lang-java" data-nodeid="1346"><code data-language="java">APP_STORE_CONNECT_API_CONTENT=&lt;App Store Connect API <span class="hljs-keyword">for</span> an App Manager&gt;\nGITHUB_API_TOKEN=&lt;GitHub API token <span class="hljs-keyword">for</span> accessing the <span class="hljs-keyword">private</span> repo <span class="hljs-keyword">for</span> certificates and provisioning profiles&gt;\nMATCH_PASSWORD=&lt;Password <span class="hljs-keyword">for</span> certificates <span class="hljs-keyword">for</span> App signing on GitHub <span class="hljs-keyword">private</span> repo&gt;\n</code></pre>\n<p data-nodeid="1347">接着在根目录执行以下的命令：</p>\n<pre class="lang-java" data-nodeid="1348"><code data-language="java">$&gt; source ./scripts/export_env.sh\n</code></pre>\n<p data-nodeid="1349">这样就能把所有环境变量一次性导入当前的 Shell 里面，不过注意，这里需要使用<code data-backticks="1" data-nodeid="1559">source</code>命令，否则环境变量只会导出到子 Shell 里面。</p>\n<p data-nodeid="1350">这里还需要提醒一下，因为我们不应该把机密信息上传到 Git 服务器上，所以该 local.keys 文件需要配置到 .gitignore 文件里面。</p>\n<h3 data-nodeid="1351">使用 fastlane 管理证书和 Provisioning Profile</h3>\n<p data-nodeid="1352">有了上述的环境搭建与配置，我们就可以使用 fastlane 来统一管理证书和 Provisioning Profile 了。</p>\n<h4 data-nodeid="1353">生成证书和 Provisioning Profile</h4>\n<p data-nodeid="1354">第一步是生成证书和 Provisioning Profile，每个项目也只需执行一次这样的操作。</p>\n<p data-nodeid="1355">为了简化，我把生成证书和 Profile 的操作都封装在<code data-backticks="1" data-nodeid="1567">create_new_profiles</code>Lane 里面，只需要执行<code data-backticks="1" data-nodeid="1569">bundle exec fastlane create_new_profiles</code>命令即可，该 Lane 的具体代码如下：</p>\n<pre class="lang-ruby" data-nodeid="1356"><code data-language="ruby">desc <span class="hljs-string">"Create all new provisioning profiles managed by fastlane match"</span>\nlane <span class="hljs-symbol">:create_new_profiles</span> <span class="hljs-keyword">do</span>\n  api_key = get_app_store_connect_api_key\n  keychain_name = <span class="hljs-string">"TemporaryKeychain"</span>\n  keychain_password = <span class="hljs-string">"TemporaryKeychainPassword"</span>\n  create_keychain(\n    <span class="hljs-symbol">name:</span> keychain_name,\n    <span class="hljs-symbol">password:</span> keychain_password,\n    <span class="hljs-symbol">default_keychain:</span> <span class="hljs-literal">false</span>,\n    <span class="hljs-symbol">timeout:</span> <span class="hljs-number">3600</span>,\n    <span class="hljs-symbol">unlock:</span> <span class="hljs-literal">true</span>,\n  )\n  match(\n    <span class="hljs-symbol">type:</span> <span class="hljs-string">"adhoc"</span>,\n    <span class="hljs-symbol">keychain_name:</span> keychain_name,\n    <span class="hljs-symbol">keychain_password:</span> keychain_password,\n    <span class="hljs-symbol">storage_mode:</span> <span class="hljs-string">"git"</span>,\n    <span class="hljs-symbol">git_url:</span> <span class="hljs-string">"https://github.com/JakeLin/moments-codesign"</span>,\n    <span class="hljs-symbol">app_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments.internal"</span>,\n    <span class="hljs-symbol">team_id:</span> <span class="hljs-string">"6HLFCRTYQU"</span>,\n    <span class="hljs-symbol">api_key:</span> api_key\n  )\n  match(\n    <span class="hljs-symbol">type:</span> <span class="hljs-string">"appstore"</span>,\n    <span class="hljs-symbol">keychain_name:</span> keychain_name,\n    <span class="hljs-symbol">keychain_password:</span> keychain_password,\n    <span class="hljs-symbol">storage_mode:</span> <span class="hljs-string">"git"</span>,\n    <span class="hljs-symbol">git_url:</span> <span class="hljs-string">"https://github.com/JakeLin/moments-codesign"</span>,\n    <span class="hljs-symbol">app_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments"</span>,\n    <span class="hljs-symbol">team_id:</span> <span class="hljs-string">"6HLFCRTYQU"</span>,\n    <span class="hljs-symbol">api_key:</span> api_key\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1357">该 Lane 主要由三部分组成。</p>\n<p data-nodeid="1358">第一部分是调用<code data-backticks="1" data-nodeid="1573">create_keychain</code>Action 来生成 Keychain。因为 fastlane 所生成的私钥和证书都需要保存在 Keychain 里，所以我们要生成一个 Keychain 来保存它们。为了不影响默认的 Keychain，我们把<code data-backticks="1" data-nodeid="1575">false</code>传递给<code data-backticks="1" data-nodeid="1577">default_keychain</code>参数，表示生成的 Keychain 不是默认的 Keychain。</p>\n<p data-nodeid="1359">第二部分是通过指定 Ad Hoc 作为发布渠道来为 Internal App 生成证书和 Provisioning Profile，并把它们上传到 GitHub 私有 Repo，这样我们就能使用这个 Provisioning Profile 为 Internal App 进行签名和打包。</p>\n<p data-nodeid="1360">第三部分与第二部分非常类似，也是用于生成证书和 Provisioning Profile。不同的是它生成了发布渠道为 Appstore 类型的 Provisioning Profile，有了该 Provisioning Profile，我们就能为 AppStore 版本的 App 进行签名和打包。</p>\n<p data-nodeid="1361">你可能发现，我们调用了私有 Lane<code data-backticks="1" data-nodeid="1582">get_app_store_connect_api_key</code>来获取<code data-backticks="1" data-nodeid="1584">api_key</code>变量的值。该私有 Lane 的定义如下：</p>\n<pre class="lang-ruby" data-nodeid="1362"><code data-language="ruby">desc <span class="hljs-string">\'Get App Store Connect API key\'</span>\n  private_lane <span class="hljs-symbol">:get_app_store_connect_api_key</span> <span class="hljs-keyword">do</span>\n    key_content = ENV[<span class="hljs-string">"APP_STORE_CONNECT_API_CONTENT"</span>]\n    api_key = app_store_connect_api_key(\n      <span class="hljs-symbol">key_id:</span> <span class="hljs-string">"D9B979RR69"</span>,\n      <span class="hljs-symbol">issuer_id:</span> <span class="hljs-string">"69a6de7b-13fb-47e3-e053-5b8c7c11a4d1"</span>,\n      <span class="hljs-symbol">key_content:</span> <span class="hljs-string">"-----BEGIN EC PRIVATE KEY-----\\n"</span> + key_content + <span class="hljs-string">"\\n-----END EC PRIVATE KEY-----"</span>,\n      <span class="hljs-symbol">duration:</span> <span class="hljs-number">1200</span>,\n      <span class="hljs-symbol">in_house:</span> <span class="hljs-literal">false</span>\n    )\n    api_key \n  <span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1363">该私有 Lane 从环境变量中读取了<code data-backticks="1" data-nodeid="1587">APP_STORE_CONNECT_API_CONTENT</code>的值，然后通过调用<code data-backticks="1" data-nodeid="1589">app_store_connect_api_key</code>Action 来获取临时的 App Store Connect API Key。其中，<code data-backticks="1" data-nodeid="1591">key_id</code>和<code data-backticks="1" data-nodeid="1593">issuer_id</code>的值都可以在 App Store Connect 的 Keys 配置页面上找到。</p>\n<p data-nodeid="1364">如果你没有为 GitHub 配置全局的用户名和邮箱，那么在执行<code data-backticks="1" data-nodeid="1596">bundle exec fastlane create_new_profiles</code>命令时可能会出错。你可以通过下面的命令来解决这个问题，在命令执行完之后还可通过<code data-backticks="1" data-nodeid="1598">git config --global --edit</code>命令把这些配置删掉。</p>\n<pre class="lang-java" data-nodeid="1365"><code data-language="java">$&gt; git config --global user.email <span class="hljs-string">"MomentsCI@lagou.com"</span>\n$&gt; git config --global user.name <span class="hljs-string">"Moments CI"</span>\n</code></pre>\n<p data-nodeid="1366">当<code data-backticks="1" data-nodeid="1601">create_new_profiles</code>命令成功执行以后，你可以在私有 Repo 上看到两个新的文件夹，如下图所示：</p>\n<p data-nodeid="1367"><img src="https://s0.lgstatic.com/i/image6/M01/3E/F7/Cgp9HWCbpdWASXy9AAJKo3Mqtpg236.png" alt="图片8.png" data-nodeid="1605"></p>\n<p data-nodeid="1368">其中，<strong data-nodeid="1611">certs 文件夹用于保存私钥（.p12）和证书（.cer）文件，而 profiles 文件夹则用来保存 adhoc 和 appstore 两个 Provisioning Profile 文件</strong>。</p>\n<p data-nodeid="1369">你也可以在苹果开发者网站查看新的证书文件：</p>\n<p data-nodeid="1370"><img src="https://s0.lgstatic.com/i/image6/M01/3E/F7/Cgp9HWCbpfqAKc17AAFyb88k84o360.png" alt="图片9.png" data-nodeid="1615"></p>\n<p data-nodeid="1371">同时还可以看到 Provisioning Profile 文件：</p>\n<p data-nodeid="1372"><img src="https://s0.lgstatic.com/i/image6/M00/3E/FF/CioPOWCbpheAOxNSAAFxbPkMv1o580.png" alt="图片10.png" data-nodeid="1619"></p>\n<p data-nodeid="1373">除此之外，你还可以在 Keychain App 里面找到新增的私钥和证书，如下图所示：</p>\n<p data-nodeid="1374"><img src="https://s0.lgstatic.com/i/image6/M00/3D/C3/CioPOWCWMyeAQN7wAAOKWo3am2o738.png" alt="Drawing 9.png" data-nodeid="1623"></p>\n<h4 data-nodeid="1375">下载证书和 Provisioning Profile</h4>\n<p data-nodeid="1376">一个项目只需要执行一次生成证书和 Provisioning Profile 的操作，其他团队成员可通过<code data-backticks="1" data-nodeid="1626">bundle exec fastlane download_profiles</code>命令来下载证书和 Provisioning Profile。该 Lane 的代码如下：</p>\n<pre class="lang-ruby" data-nodeid="1377"><code data-language="ruby">desc <span class="hljs-string">"Download certificates and profiles"</span>\nlane <span class="hljs-symbol">:download_profiles</span> <span class="hljs-keyword">do</span>\n  keychain_name = <span class="hljs-string">"TemporaryKeychain"</span>\n  keychain_password = <span class="hljs-string">"TemporaryKeychainPassword"</span>\n  create_keychain(\n    <span class="hljs-symbol">name:</span> keychain_name,\n    <span class="hljs-symbol">password:</span> keychain_password,\n    <span class="hljs-symbol">default_keychain:</span> <span class="hljs-literal">false</span>,\n    <span class="hljs-symbol">timeout:</span> <span class="hljs-number">3600</span>,\n    <span class="hljs-symbol">unlock:</span> <span class="hljs-literal">true</span>,\n  )\n  match(\n    <span class="hljs-symbol">type:</span> <span class="hljs-string">"adhoc"</span>,\n    <span class="hljs-symbol">readonly:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">keychain_name:</span> keychain_name,\n    <span class="hljs-symbol">keychain_password:</span> keychain_password,\n    <span class="hljs-symbol">storage_mode:</span> <span class="hljs-string">"git"</span>,\n    <span class="hljs-symbol">git_url:</span> <span class="hljs-string">"https://github.com/JakeLin/moments-codesign"</span>,\n    <span class="hljs-symbol">app_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments.internal"</span>,\n    <span class="hljs-symbol">team_id:</span> <span class="hljs-string">"6HLFCRTYQU"</span>\n  )\n  match(\n    <span class="hljs-symbol">type:</span> <span class="hljs-string">"appstore"</span>,\n    <span class="hljs-symbol">readonly:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">keychain_name:</span> keychain_name,\n    <span class="hljs-symbol">keychain_password:</span> keychain_password,\n    <span class="hljs-symbol">storage_mode:</span> <span class="hljs-string">"git"</span>,\n    <span class="hljs-symbol">git_url:</span> <span class="hljs-string">"https://github.com/JakeLin/moments-codesign"</span>,\n    <span class="hljs-symbol">app_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments"</span>,\n    <span class="hljs-symbol">team_id:</span> <span class="hljs-string">"6HLFCRTYQU"</span>\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1378">你会发现<code data-backticks="1" data-nodeid="1629">download_profiles</code>和<code data-backticks="1" data-nodeid="1631">create_new_profiles</code>两个 Lane 的实现非常类似，都是由三部分组成，包括生成 Keychain、下载 Internal App 的证书和 Provisioning Profile 以及 AppStore 版本 App 的证书和 Provisioning Profile。不同的地方是<code data-backticks="1" data-nodeid="1633">download_profiles</code>Lane 不需要更新 App Store Connect，所以无须使用 App Store Connect 的 API Key；并且<code data-backticks="1" data-nodeid="1635">download_profiles</code>Lane 也不需要更新私有 Repo 的内容，所以在调用<code data-backticks="1" data-nodeid="1637">match</code>Action 时，我们会把<code data-backticks="1" data-nodeid="1639">true</code>传递给<code data-backticks="1" data-nodeid="1641">readonly</code>参数。</p>\n<h4 data-nodeid="1379">新增设备</h4>\n<p data-nodeid="1380">当我们通过 Ad Hoc 的方式来分发 App 时，必须把需要安装 App 的设备 ID 都添加到设备列表里面，你可以在苹果开发者网站的“Certificates, Identifiers &amp; Profiles”的 Devices 下查看所有设备信息。如下图所示：</p>\n<p data-nodeid="1381"><img src="https://s0.lgstatic.com/i/image6/M00/3E/FF/CioPOWCbpj2AYt-xAAFbLA-2M_0002.png" alt="图片11.png" data-nodeid="1649"></p>\n<p data-nodeid="1382">但是手工更新设备列表的操作比较麻烦，而且更新完以后还需要再更新 Provisioning Profile。幸运的是 fastlane 能帮我们自动化这些操作，我们把这些操作都封装在<code data-backticks="1" data-nodeid="1651">add_device</code>Lane 里面，具体代码如下：</p>\n<pre class="lang-ruby" data-nodeid="1383"><code data-language="ruby">desc <span class="hljs-string">"Add a new device to provisioning profile"</span>\nlane <span class="hljs-symbol">:add_device</span> <span class="hljs-keyword">do</span> <span class="hljs-params">|options|</span>\n  name = options[<span class="hljs-symbol">:name</span>]\n  udid = options[<span class="hljs-symbol">:udid</span>]\n  <span class="hljs-comment"># Add to App Store Connect</span>\n  api_key = get_app_store_connect_api_key\n  register_device(\n    <span class="hljs-symbol">name:</span> name,\n    <span class="hljs-symbol">udid:</span> udid,\n    <span class="hljs-symbol">team_id:</span> <span class="hljs-string">"6HLFCRTYQU"</span>,\n    <span class="hljs-symbol">api_key:</span> api_key\n  )\n  <span class="hljs-comment"># Update the profiles to Git private repo</span>\n  match(\n    <span class="hljs-symbol">type:</span> <span class="hljs-string">"adhoc"</span>,\n    <span class="hljs-symbol">force:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">storage_mode:</span> <span class="hljs-string">"git"</span>,\n    <span class="hljs-symbol">git_url:</span> <span class="hljs-string">"https://github.com/JakeLin/moments-codesign"</span>,\n    <span class="hljs-symbol">app_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments.internal"</span>,\n    <span class="hljs-symbol">team_id:</span> <span class="hljs-string">"6HLFCRTYQU"</span>,\n    <span class="hljs-symbol">api_key:</span> api_key\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1384">首先调用<code data-backticks="1" data-nodeid="1654">register_device</code>Action 把设备更新到苹果开发者网站上的设备列表里面，然后把<code data-backticks="1" data-nodeid="1656">true</code>传递给<code data-backticks="1" data-nodeid="1658">force</code>参数来调用<code data-backticks="1" data-nodeid="1660">match</code>Action，这个操作能强制更新 Ad Hoc 的 Provisioning Profile 并上传到私有 Repo 里。这样当其他机器在调用<code data-backticks="1" data-nodeid="1662">download_profiles</code>命令的时候，就能获取最新的 Provisioning Profile 了。</p>\n<h3 data-nodeid="1385">总结</h3>\n<p data-nodeid="1386">在这一讲中，我们讲述了如何使用 fastlane 的 match Action 来帮我们统一管理签名和打包所需的私钥、证书和 Provisioning Profile 文件。</p>\n<p data-nodeid="1387">在实际项目中，我们只需要<strong data-nodeid="1677">一次性完成搭建的任务</strong>，例如生成私钥 Repo、导出 Github Access Token 和 App Store Connect API Key，以及调用<code data-backticks="1" data-nodeid="1671">create_new_profiles</code>来生成所需的证书和 Provisioning Profile。其他团队成员和 CI 服务器就可以通过调用<code data-backticks="1" data-nodeid="1673">download_profiles</code>来下载证书。当需要为 Ad Hoc 发布渠道添加新设备时，只需要执行<code data-backticks="1" data-nodeid="1675">add_device</code>即可。</p>\n<p data-nodeid="14575" class="te-preview-highlight">有了<code data-backticks="1" data-nodeid="14577">download_profiles</code>和<code data-backticks="1" data-nodeid="14579">add_device</code>等命令，团队里任何人都可以轻松地下载打包和签名所需的私钥、证书和 Provisioning Profile 文件，无须手工使用 Keychain Access 程序来管理私钥，无须登录到苹果开发者网站下载和安装证书，无须到苹果开发者网站上手工添加设备，无须重新生成 Provisioning Profile 等。这样能减少大量无聊而且容易出错的手工操作工作，让我们把有效的时间都花在功能开发与迭代上。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="1389"><strong data-nodeid="1694">思考题</strong></p>\n<blockquote data-nodeid="1390">\n<p data-nodeid="1391">在 Moments App 中，我们为 Debug Target 使用了 Automatically manage signing 的方式来管理证书和 Provisioning Profile。这里请你思考一下，这样做有什么好处呢？</p>\n</blockquote>\n<p data-nodeid="1392">可以把你的答案写到留言区哦。下一讲我将介绍如何使用自动化构建来解决大量重复性工作的问题。</p>\n<p data-nodeid="1393"><strong data-nodeid="1700">源码地址</strong></p>\n<blockquote data-nodeid="1394">\n<p data-nodeid="1395" class="">Fastfile 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L72-L207?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1704">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L72-L207</a></p>\n</blockquote>',
          },
          {
            theme: '25 | 自动化构建：解决大量重复性人力工作神器',
            id: 41,
            content:
              '<p data-nodeid="1075" class="">在上一讲我们讲述了如何使用 fastlane 来自动管理私钥、证书和 Provisioning Profile 文件，相信你已经体会到自动化的威力了。其实，我们可以自动化几乎所有的 iOS 任务，包括编译、检查代码风格、执行测试、打包和签名、发布到分发渠道、上传到 App Store、发送发布通知等。<strong data-nodeid="1186">自动化是衡量一个团队成熟度的关键因素，也是推动项目工程化实践的基石</strong>，同时还有以下多个优点。</p>\n<ul data-nodeid="1076">\n<li data-nodeid="1077">\n<p data-nodeid="1078"><strong data-nodeid="1191">自动化能提高 App 的质量</strong>。通过自动执行代码风格检查和单元测试，能保证合并到主分支的代码都符合团队的代码规范，并通过质量检测。</p>\n</li>\n<li data-nodeid="1079">\n<p data-nodeid="1080"><strong data-nodeid="1196">自动化能保证工作流程的一致性</strong>。如果通过手工操作来打包和发布，一不小心就会丢三落四，例如忘记执行测试、使用错误的 Provisioning Profile 等。而自动化打包和发布就不会出现这样的问题，并且还能保证流程的一致性，因为所有操作和步骤都是由程序自动执行的，可以保证任何机器执行这些操作都能得到一模一样的结果。</p>\n</li>\n<li data-nodeid="1081">\n<p data-nodeid="1082"><strong data-nodeid="1201">自动化能提高发布频率</strong>。由于手工操作需要耗费大量的人力和时间成本，所以最后很可能我们不得不为了节省时间而延长发布周期。但有了自动化以后，我们就不需要任何人手来参与打包和发布过程，能做到主分支上任何 commit 都可以自动打包和发布。同时，频繁发布也有利于产品的快速迭代。</p>\n</li>\n<li data-nodeid="1083">\n<p data-nodeid="1084"><strong data-nodeid="1206">自动化能减低沟通成本</strong>。当测试人员和产品经理需要验证功能时，我们都可以随时自动打包和分发 App，这样能有效降低沟通成本，并提高团队的和谐性。</p>\n</li>\n<li data-nodeid="1085">\n<p data-nodeid="1086"><strong data-nodeid="1211">自动化能方便知识的共享</strong>。因为自动化的脚本都是源代码，所以我们可以很方便地把自动化的配置代码共享到多个项目中，提高效率并降低维护成本。</p>\n</li>\n<li data-nodeid="1087">\n<p data-nodeid="1088"><strong data-nodeid="1216">自动化能为持续集成打下基础</strong>。持续集成可以帮助我们把 GitHub 上的代码更新都自动打包和发布到 App Store。在持续集成过程中，CI 服务需要执行定义好的自动化脚本，可以说，没有自动化脚本就无法进行持续集成。</p>\n</li>\n</ul>\n<p data-nodeid="1089">既然自动化这么重要，那实现自动化的难度很高吗？其实不然，因为我们可以使用 fastlane 来实现几乎所有的任务。接下来我们就以 Moments App 为例子看看如何使用 fastlane 开发自动化脚本吧。</p>\n<p data-nodeid="1090">在前面<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6658&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1223">《05 | 自动化准备：如何使用 fastlane 管理自动化操作？》</a>里面，我们讲过如何搭建统一的 fastlane 环境，并介绍了如何开发检查和格式化代码等操作。其实除此以外，我们还可以完成编译与执行测试、打包与签名，以及上传到发布渠道等操作，下面我们就分别讲述这些操作是如何实现的。</p>\n<h3 data-nodeid="1091">编译与执行测试</h3>\n<p data-nodeid="1092">首先，我们看看编译的具体实现，如下所示：</p>\n<pre class="lang-ruby" data-nodeid="1093"><code data-language="ruby">desc <span class="hljs-string">"Build development app"</span>\nlane <span class="hljs-symbol">:build_dev_app</span> <span class="hljs-keyword">do</span>\n  puts(<span class="hljs-string">"Build development app"</span>)\n  gym(<span class="hljs-symbol">scheme:</span> <span class="hljs-string">"Moments"</span>,\n    <span class="hljs-symbol">workspace:</span> <span class="hljs-string">"Moments.xcworkspace"</span>,\n    <span class="hljs-symbol">export_method:</span> <span class="hljs-string">"development"</span>,\n    <span class="hljs-symbol">configuration:</span> <span class="hljs-string">"Debug"</span>,\n    <span class="hljs-symbol">xcargs:</span> <span class="hljs-string">"-allowProvisioningUpdates"</span>)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1094">我们调用了<code data-backticks="1" data-nodeid="1228">gym</code>Action 来编译 Debug 版本的 App。这里需要注意：我们把<code data-backticks="1" data-nodeid="1230">development</code>传递给<code data-backticks="1" data-nodeid="1232">export_method</code>参数。在上一讲的思考题里面，我问大家为什么 Moments App 的 Debug Target 使用了 Automatically manage signing，其实是因为 Automatically manage signing 是由 Xcode 自动管理签名证书，开发者无须任何额外的配置就能在设备上进行 Debug 操作。在<code data-backticks="1" data-nodeid="1234">build_dev_app</code>Lane 里，我们把<code data-backticks="1" data-nodeid="1236">development</code>传递给<code data-backticks="1" data-nodeid="1238">export_method</code>，这样能让 fastlane 也使用 Automatically manage signing 来进行自动签名。</p>\n<p data-nodeid="1095">接着看一下如何执行测试，具体实现代码如下所示：</p>\n<pre class="lang-ruby" data-nodeid="1096"><code data-language="ruby">desc <span class="hljs-string">"Run unit tests"</span>\nlane <span class="hljs-symbol">:tests</span> <span class="hljs-keyword">do</span>\n  puts(<span class="hljs-string">"Run the tests"</span>)\n  scan(\n    <span class="hljs-symbol">scheme:</span> <span class="hljs-string">"Moments"</span>, \n    <span class="hljs-symbol">output_directory:</span> <span class="hljs-string">"./fastlane/dist"</span>, \n    <span class="hljs-symbol">output_types:</span> <span class="hljs-string">"html"</span>, \n    <span class="hljs-symbol">buildlog_path:</span> <span class="hljs-string">"./fastlane/dist"</span>)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1097">我们可以调用<code data-backticks="1" data-nodeid="1242">scan</code>Action 来执行测试，同时还可以指定 Log 和报告的路径，当测试失败时，可以打开报告进行查看。在上面的例子中，我们生成了格式为 HTML 的报告。假如你需要自动分析测试报告，可以生成 JSON 格式的报告，然后读取 JSON 文件里的内容进行分析。</p>\n<h3 data-nodeid="1098">打包与签名</h3>\n<p data-nodeid="7910">只有进行过打包和签名的 App，才能安装到用户的设备上。那到底为什么需要签名呢？我们可以通过下面的示意图来看看原因。</p>\n<p data-nodeid="7911" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3F/EC/Cgp9HWCiSPyAYEIRAAUgbfbdYaM382.png" alt="图片3.png" data-nodeid="7915"><br>\n苹果公司为了给所有的 iOS 用户提供安全和一致的体验，便把所有的 App 都放在沙盒（Sandbox）里面运行，这样能保证 App 运行在一个受限和安全的空间里面。通常情况下，App 只能访问沙盒里面的文件系统。当 App 需要访问系统资源的时候，必须通过权限管理模块的授权。常用的<strong data-nodeid="7922">系统资源</strong>包括以下几类：</p>\n\n\n\n\n<ul data-nodeid="1102">\n<li data-nodeid="1103">\n<p data-nodeid="1104">照相机、麦克风以及传感器等硬件；</p>\n</li>\n<li data-nodeid="1105">\n<p data-nodeid="1106" class="">网络访问；</p>\n</li>\n<li data-nodeid="1107">\n<p data-nodeid="1108">联系人、日程表和邮件等系统 App 的数据；</p>\n</li>\n<li data-nodeid="1109">\n<p data-nodeid="1110">文件 App 里的文件；</p>\n</li>\n<li data-nodeid="1111">\n<p data-nodeid="1112">地理位置信息、推送通知、HealthKit 以及 HomeKit 等服务。</p>\n</li>\n</ul>\n<p data-nodeid="1113">我们以获取地理位置信息作为例子来看看<strong data-nodeid="1265">权限管理系统</strong>的运作方式。当 App 想要获得后台地理位置信息时，权限管理系统会检查 Info.plist 文件是否提供了描述信息，并检查用户是否同意，最后检查 Background Modes 的 Entitlement 是否允许 Location updates。如果这些都通过了，权限管理系统就允许 App 在后台访问地理位置信息。任何一项不通过，App 都无法在后台访问地理位置信息。</p>\n<p data-nodeid="1114">当 App 需要访问各种资源的时候，iOS 系统会询问 App 一些重要的问题来判断是否能通过权限检查。那谁能提供这些信息呢？<strong data-nodeid="1271">答案是 Provisioning Profile</strong>。可以这么说，Provisioning Profile 能回答下面的几大“哲学”问题。</p>\n<ul data-nodeid="1115">\n<li data-nodeid="1116">\n<p data-nodeid="1117"><strong data-nodeid="1276">你是谁？</strong> Provisioning Profile 具有 Team ID 等信息，iOS 能知道这个 App 的开发者是谁。</p>\n</li>\n<li data-nodeid="1118">\n<p data-nodeid="1119"><strong data-nodeid="1281">你要干吗？</strong> Provisioning Profile 关联的 Entitlement 能告诉 iOS 系统该 App 需要访问哪些系统资源。</p>\n</li>\n<li data-nodeid="1120">\n<p data-nodeid="1121"><strong data-nodeid="1286">你要去哪里？</strong> Provisioning Profile 里的设备列表能告诉 iOS 系统能否安装该 App。</p>\n</li>\n<li data-nodeid="1122">\n<p data-nodeid="1123"><strong data-nodeid="1291">我能相信你吗？</strong> 这涉及签名（Code Sign）的概念，通过签名，就能证明你是这个 App 的签名主体，并能证明这个 App 里面没有经过非法更改。</p>\n</li>\n</ul>\n<p data-nodeid="1124">你可能已经发现 Provisioning Profile 文件是打包在 App 里面的，那么我们能不能偷偷地替换了它，让系统给我们所有的权限呢？这时候签名就能发挥作用。通过签名以后，App 就带有一个封印（Code Seal），该封印能帮助 iOS 系统快速地检查 App 是否经过非法更改。</p>\n<p data-nodeid="1125">到这里，你已经知道为什么需要为 App 进行签名了。</p>\n<p data-nodeid="1126">假如我们通过手工的方式进行打包和签名，那会怎么操作呢？首先要把证书和 Provisioning Profile 文件从苹果开发者网站上下载下来，并需要手工安装和管理。接着可以通过两种方式来完成打包操作：要么使用 Xcode 的 Archive 菜单进行打包，然后再使用 Validate App 功能来签名；要么使用<code data-backticks="1" data-nodeid="1295">xcodebuild archive</code>命令来生成 .xcarchive 文件，然后调用<code data-backticks="1" data-nodeid="1297">xcodebuild -exportArchive</code>命令来生成 IPA 文件。这两种办法都需要大量的手工操作，并且还十分容易出错。<strong data-nodeid="1303">幸运的是 fastlane 能帮我们简化这些繁重的操作</strong>，下面我们一起看看如何使用 fastlane 来完成打包和签名吧。</p>\n<p data-nodeid="1127">首先看一下如何打包 Internal App，具体实现如下：</p>\n<pre class="lang-ruby" data-nodeid="1128"><code data-language="ruby">desc <span class="hljs-string">\'Creates an archive of the Internal app for testing\'</span>\nlane <span class="hljs-symbol">:archive_internal</span> <span class="hljs-keyword">do</span>\n  unlock_keychain(\n    <span class="hljs-symbol">path:</span> <span class="hljs-string">"TemporaryKeychain-db"</span>,\n    <span class="hljs-symbol">password:</span> <span class="hljs-string">"TemporaryKeychainPassword"</span>)\n  update_code_signing_settings(\n    <span class="hljs-symbol">use_automatic_signing:</span> <span class="hljs-literal">false</span>,\n    <span class="hljs-symbol">path:</span> <span class="hljs-string">"Moments/Moments.xcodeproj"</span>,\n    <span class="hljs-symbol">code_sign_identity:</span> <span class="hljs-string">"iPhone Distribution"</span>,\n    <span class="hljs-symbol">bundle_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments.internal"</span>,\n    <span class="hljs-symbol">profile_name:</span> <span class="hljs-string">"match AdHoc com.ibanimatable.moments.internal"</span>)\n  puts(<span class="hljs-string">"Create an archive for Internal testing"</span>)\n  gym(<span class="hljs-symbol">scheme:</span> <span class="hljs-string">"Moments-Internal"</span>,\n    <span class="hljs-symbol">workspace:</span> <span class="hljs-string">"Moments.xcworkspace"</span>,\n    <span class="hljs-symbol">export_method:</span> <span class="hljs-string">"ad-hoc"</span>,\n    <span class="hljs-symbol">xcargs:</span> <span class="hljs-string">"-allowProvisioningUpdates"</span>)\n  update_code_signing_settings(\n    <span class="hljs-symbol">use_automatic_signing:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">path:</span> <span class="hljs-string">"Moments/Moments.xcodeproj"</span>)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1129">我们定义了<code data-backticks="1" data-nodeid="1306">archive_internal</code>Lane 来打包和签名 Moments App 的 Internal 版本，具体分成以下四步。</p>\n<ul data-nodeid="1130">\n<li data-nodeid="1131">\n<p data-nodeid="1132">第一步是解锁 Keychain。因为签名所需的证书信息保存在 Keychain 里面，所以我们需要解锁 Keychain 来让 fastlane 进行访问。</p>\n</li>\n<li data-nodeid="1133">\n<p data-nodeid="1134">第二步是更新签名信息。我们使用“iPhone Distribution”作为签名主体，并使用“match AdHoc com.ibanimatable.moments.internal”作为 Provisioning Profile，这表示我们使用了 Ad Hoc 的 Provisioning Profile 来分发该 App。</p>\n</li>\n<li data-nodeid="1135">\n<p data-nodeid="1136">第三步是核心操作，调用<code data-backticks="1" data-nodeid="1311">gym</code>Action 来进行打包和签名。<code data-backticks="1" data-nodeid="1313">gym</code>帮我们封装了<code data-backticks="1" data-nodeid="1315">xcodebuild</code>的实现细节，我们只需要调用一个 Action 就能完成打包和签名的操作。这里需要注意，为了生成用于测试的 Internal App，我们需要把<code data-backticks="1" data-nodeid="1317">export_method</code>参数赋值为<code data-backticks="1" data-nodeid="1319">ad-hoc</code>，这样我们就能实现内部分发。</p>\n</li>\n<li data-nodeid="1137">\n<p data-nodeid="1138">第四步是恢复回自动签名。因为在开发环境中，我们使用的是自动签名。为了方便本地开发，在完成打包后，我们得把签名方式进行重置。</p>\n</li>\n</ul>\n<p data-nodeid="1139">下面再看一下如何为 App Store 版本的 App 进行打包和签名。</p>\n<pre class="lang-ruby" data-nodeid="1140"><code data-language="ruby">desc <span class="hljs-string">\'Creates an archive of the Production app with Appstore distribution\'</span>\nlane <span class="hljs-symbol">:archive_appstore</span> <span class="hljs-keyword">do</span>\n  unlock_keychain(\n    <span class="hljs-symbol">path:</span> <span class="hljs-string">"TemporaryKeychain-db"</span>,\n    <span class="hljs-symbol">password:</span> <span class="hljs-string">"TemporaryKeychainPassword"</span>)\n  update_code_signing_settings(\n    <span class="hljs-symbol">use_automatic_signing:</span> <span class="hljs-literal">false</span>,\n    <span class="hljs-symbol">path:</span> <span class="hljs-string">"Moments/Moments.xcodeproj"</span>,\n    <span class="hljs-symbol">code_sign_identity:</span> <span class="hljs-string">"iPhone Distribution"</span>,\n    <span class="hljs-symbol">bundle_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments"</span>,\n    <span class="hljs-symbol">profile_name:</span> <span class="hljs-string">"match AppStore com.ibanimatable.moments"</span>)\n  puts(<span class="hljs-string">"Create an archive for AppStore submission"</span>)\n  gym(<span class="hljs-symbol">scheme:</span> <span class="hljs-string">"Moments-AppStore"</span>,\n    <span class="hljs-symbol">workspace:</span> <span class="hljs-string">"Moments.xcworkspace"</span>,\n    <span class="hljs-symbol">export_method:</span> <span class="hljs-string">"app-store"</span>,\n    <span class="hljs-symbol">xcargs:</span> <span class="hljs-string">"-allowProvisioningUpdates"</span>)\n  update_code_signing_settings(\n    <span class="hljs-symbol">use_automatic_signing:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">path:</span> <span class="hljs-string">"Moments/Moments.xcodeproj"</span>)\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1141"><code data-backticks="1" data-nodeid="1323">archive_appstore</code>的实现基本上与<code data-backticks="1" data-nodeid="1325">archive_internal</code>一致。不同的地方是在<code data-backticks="1" data-nodeid="1327">archive_appstore</code>里面，我们指定的 Provisioning Profile 是 “match AppStore com.ibanimatable.moments”，而且在调用<code data-backticks="1" data-nodeid="1329">gym</code>Action 时传递了<code data-backticks="1" data-nodeid="1331">app-store</code>给<code data-backticks="1" data-nodeid="1333">export_method</code>参数，表示要生成上传到 App Store 的 App。</p>\n<p data-nodeid="1142">有了<code data-backticks="1" data-nodeid="1336">archive_internal</code>和<code data-backticks="1" data-nodeid="1338">archive_appstore</code>以后，再结合上一讲介绍的<code data-backticks="1" data-nodeid="1340">download_profiles</code>，我们就可以十分方便地自动化打包和签名 App 了。命令执行完毕以后，在项目文件夹里面会出现一个 Moments.ipa 文件。<strong data-nodeid="1346">IPA 文件也叫作 iOS&nbsp;App Store&nbsp;Package，该文件是一个包含了 iOS App 的存档（archive）文件。</strong> 为了查看 IPA 文件里面的内容，我们可以把后缀名修改成 .zip 文件并进行解压，其内容如下图所示：</p>\n<p data-nodeid="1143"><img src="https://s0.lgstatic.com/i/image6/M01/3F/D4/Cgp9HWCiCkOALAJ1AAEF7RK-scI993.png" alt="Drawing 1.png" data-nodeid="1349"></p>\n<p data-nodeid="1144">在图中有一个名为 embedded.mobileprovision 的 Provisioning Profile 文件，你可以打开该文件来查看相关内容，如下图所示：</p>\n<p data-nodeid="1145"><img src="https://s0.lgstatic.com/i/image6/M01/3F/D4/Cgp9HWCiCkiAd4TxAAGYCDQpM2k855.png" alt="Drawing 2.png" data-nodeid="1353"></p>\n<p data-nodeid="1146">在该 Provisioning Profile 中，你可以看到用于定义访问系统资源权限的 Entitlement 信息、证书信息以及用于安装的设备列表信息。有了这些信息，iOS 系统就能对 App 进行权限管理。</p>\n<h3 data-nodeid="1147">上传到发布渠道</h3>\n<p data-nodeid="1148">经过打包和签名生成 IPA 文件后，下一步是把 App 上传到各个发布渠道。为了方便内部测试人员和产品经理进行测试和验证新功能，我们把 Internal 版本的 App 上传到 Firebase 上。</p>\n<p data-nodeid="1149">Firebase 提供了一个免费 App 分发服务，我们在本模块的后半部分会详细讲述 Firebase 的各种服务。这里我们就先看一下如何使用 fastlane 自动把 App 上传到 Firebase 的 App 分发服务，具体代码如下：</p>\n<pre class="lang-ruby" data-nodeid="1150"><code data-language="ruby">desc <span class="hljs-string">\'Deploy the Internal app to Firebase Distribution\'</span>\nlane <span class="hljs-symbol">:deploy_internal</span> <span class="hljs-keyword">do</span>\n  firebase_app_distribution(\n      <span class="hljs-symbol">app:</span> <span class="hljs-string">"1:374168413412:ios:912d89b30767d8e5a038f1"</span>,\n      <span class="hljs-symbol">ipa_path:</span> <span class="hljs-string">"Moments.ipa"</span>,\n      <span class="hljs-symbol">groups:</span> <span class="hljs-string">"internal-testers"</span>,\n      <span class="hljs-symbol">release_notes:</span> <span class="hljs-string">"A new build for the Internal App"</span>,\n      <span class="hljs-symbol">firebase_cli_token:</span> ENV[<span class="hljs-string">"FIREBASE_API_TOKEN"</span>]\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1151">fastlane 通过插件的方式为我们提供了<code data-backticks="1" data-nodeid="1359">firebase_app_distribution</code>Action，用于把 App 上传到 Firebase 的 App 分发服务上。要使用这个 Action，我们需要执行<code data-backticks="1" data-nodeid="1361">bundle exec fastlane add_plugin fastlane-plugin-firebase_app_distribution</code>命令来安装 Firebase App 分发的插件。同时，为了能完全自动化执行该操作，我们需要把正确的参数传递给它。其中，<code data-backticks="1" data-nodeid="1363">app</code>参数接收 Firebase 的 App ID，我们可以在 Firebase 的网站上找到，如下图所示：</p>\n<p data-nodeid="1152"><img src="https://s0.lgstatic.com/i/image6/M01/3F/DC/CioPOWCiClOAF5DMAAI5dJ-pBIU662.png" alt="Drawing 3.png" data-nodeid="1367"></p>\n<p data-nodeid="1153"><code data-backticks="1" data-nodeid="1368">ipa_path</code>参数接收的是 IPA 文件的路径。当我们执行完上面的<code data-backticks="1" data-nodeid="1370">archive_internal</code>命令以后，根目录会生成一个名叫 Moments.ipa 的文件，我们把该文件名传递给<code data-backticks="1" data-nodeid="1372">ipa_path</code>参数即可。</p>\n<p data-nodeid="1154"><code data-backticks="1" data-nodeid="1374">groups</code>参数用于指定测试组。在 Firebase 网站上打开 App Distribution -&gt; Testers and Groups 就可以看到测试组。在 Moments App 项目里，我们配置了一个名叫 internal-testers 的测试组，如下图所示：</p>\n<p data-nodeid="1155"><img src="https://s0.lgstatic.com/i/image6/M01/3F/DC/CioPOWCiClmAJsjxAAGsz1GasqA461.png" alt="Drawing 4.png" data-nodeid="1378"></p>\n<p data-nodeid="1156">我们也可以使用不同测试组来管理不同的测试者，例如把测试人员和产品经理放置在不同的分组下。在上面的例子中，当我们把 internal-testers 传递给<code data-backticks="1" data-nodeid="1380">groups</code>参数来分发 App 时，该测试组下的所有用户都会接收到 App 的更新通知。</p>\n<p data-nodeid="1157"><code data-backticks="1" data-nodeid="1382">release_notes</code>参数用于传递发布公告信息。我们可以把 Git 的历史信息传递给该参数，这样测试人员就能看到该版本更新了哪些内容。</p>\n<p data-nodeid="1158"><code data-backticks="1" data-nodeid="1384">firebase_cli_token</code>参数是访问 Firebase 的 API token，我们需要下载 Firebase CLI 来生成这个 Token，执行的命令如下：</p>\n<pre class="lang-java" data-nodeid="1159"><code data-language="java">$&gt; curl -sL https:<span class="hljs-comment">//firebase.tools | bash</span>\n$&gt; firebase login:ci\n</code></pre>\n<p data-nodeid="1160">第一行命令用于安装 Firebase CLI，第二行命令用于生成一个 API Token，在执行过程中，我们需要在浏览器上登录并授权，其执行效果如下图所示：</p>\n<p data-nodeid="1161"><img src="https://s0.lgstatic.com/i/image6/M01/3F/D4/Cgp9HWCiCmCAFw7fAAIpk8yrsEA370.png" alt="Drawing 5.png" data-nodeid="1389"></p>\n<p data-nodeid="1162">我们可以把这个 Token 信息也放到 local.keys 文件里面，这样就能通过环境变量<code data-backticks="1" data-nodeid="1391">FIREBASE_API_TOKEN</code>来提供给 fastlane 使用了。</p>\n<p data-nodeid="6471">至此，我们已经完成了上传到 Firebase App 分发服务的所有配置。请注意，这些配置只需要执行一次，以后任何开发者或者 CI 都可以方便地执行<code data-backticks="1" data-nodeid="6474">deploy_internal</code>命令来完成上传操作。当上传完毕后，我们可以在 Firebase 网站上看到各个版本，如下图所示：</p>\n<p data-nodeid="6472" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3F/EC/Cgp9HWCiSMuAInUGAAWIaVp5nWU208.png" alt="图片2.png" data-nodeid="6478"></p>\n\n\n\n<p data-nodeid="4310">同时，测试者也能在手机上看到最新的版本，如下图所示：</p>\n\n\n\n\n\n\n\n\n\n<p data-nodeid="1166" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3F/D4/Cgp9HWCiCm2AQVxJAAN6wuVJh64174.png" alt="Drawing 7.png" data-nodeid="1402"></p>\n<p data-nodeid="1167" class="">最后，我们看看如何上传到 App Store，具体实现如下：</p>\n<pre class="lang-ruby" data-nodeid="1168"><code data-language="ruby">desc <span class="hljs-string">\'Deploy the Production app to TestFlight and App Store\'</span>\nlane <span class="hljs-symbol">:deploy_appstore</span> <span class="hljs-keyword">do</span>\n  api_key = get_app_store_connect_api_key\n  upload_to_app_store(\n    <span class="hljs-symbol">api_key:</span> api_key,\n    <span class="hljs-symbol">app_identifier:</span> <span class="hljs-string">"com.ibanimatable.moments"</span>,\n    <span class="hljs-symbol">skip_metadata:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">skip_screenshots:</span> <span class="hljs-literal">true</span>,\n    <span class="hljs-symbol">precheck_include_in_app_purchases:</span> <span class="hljs-literal">false</span>,\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="1169">我们可以调用<code data-backticks="1" data-nodeid="1405">upload_to_app_store</code>Action 来把生产版本的 IPA 上传到 App Store，这里面使用了我们上一讲提到的私有 Lane<code data-backticks="1" data-nodeid="1407">get_app_store_connect_api_key</code>，我们把取出的 API Key 赋值给<code data-backticks="1" data-nodeid="1409">api_key</code>参数，然后把 com.ibanimatable.moments 赋值给<code data-backticks="1" data-nodeid="1411">app_identifier</code>。其实，fastlane 还能帮助我们截图并自动上传到 App Store，但是为了给终端用户提供更准确的截图和描述信息，我们在上传的过程忽略了这两步。</p>\n<p data-nodeid="1170">好了，到这里任何开发者或者 CI 都可以执行<code data-backticks="1" data-nodeid="1414">deploy_appstore</code>命令把 App 上传到 App Store 了。</p>\n<h3 data-nodeid="1171">总结</h3>\n<p data-nodeid="1172">在这一讲中，我们主要讲解了如何使用 fastlane 来开发编译、执行测试、打包和签名，以及发布到 Firebase 和 App Store 等各个自动化操作。</p>\n<p data-nodeid="1173">我非常建议你投资一些时间来开发这些自动化操作，这是一件事半功倍的事情。自动化能帮我们节省大量的时间，方便共享知识并减少错误的发生。除此之外，自动化也是搭建 CI 的基础，没有这些自动化操作，就无法搭建 CI。</p>\n<p data-nodeid="1174"><strong data-nodeid="1422">思考题</strong></p>\n<blockquote data-nodeid="1175">\n<p data-nodeid="1176">这一讲我留一个操作题：请使用 fastlane 开发一个自动截图的 Lane。</p>\n</blockquote>\n<p data-nodeid="1177">可以把你的答案写到留言区，或者提交一个 PR 哦。下一讲我将介绍如何搭建 CI 来实现无需人手的快速交付。</p>\n<p data-nodeid="1178"><strong data-nodeid="1428">源码地址</strong></p>\n<blockquote data-nodeid="1179">\n<p data-nodeid="1180" class="">Fastfile 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L211-L261?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1432">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L211-L261</a></p>\n</blockquote>',
          },
          {
            theme: '26 | 持续集成：如何实现无需人手的快速交付？',
            id: 42,
            content:
              '<p data-nodeid="2751" class="">在前面的课程中，我们已经讲过如何使用 fastlane 来自动化常用的操作，例如管理私钥、证书和 Provisioning Profile 文件，打包和签名 App，以及把 App 上传到 App Store 等。有了这些自动化操作，我们就可以很方便地通过一条命令把 App 发布到 App Store。但有没有更好的办法做到不需要人手就能自动完成打包和上传等所有的操作呢？当然有！我们可以通过 CI，也就是<strong data-nodeid="2757">持续集成</strong>（Continuous Integration）来完成这一任务。</p>\n\n\n\n\n\n\n<p data-nodeid="5516" class="te-preview-highlight">那什么是 CI 呢？<strong data-nodeid="5522">CI 是一种有效的工程实践，能帮助团队更频繁、更可靠地交付代码</strong>。我们可以利用 CI 来不断优化构建、测试和发布流程，从而保证产品的快速交付，推动工程化进程与最佳实践，并推进工程师文化的建设。</p>\n\n\n\n\n\n\n<h3 data-nodeid="822">CI 的系统架构</h3>\n<p data-nodeid="823">要搭建一套完整的 CI，我们需要理解 CI 的构建流程和系统架构。首先，我们以 Moments App 为例子来看看一套完整 CI 的构建流程吧。</p>\n<p data-nodeid="824"><img src="https://s0.lgstatic.com/i/image6/M01/40/6B/CioPOWCkxAqAU2EgAAZuYYLOM70201.png" alt="图片6.png" data-nodeid="913"></p>\n<p data-nodeid="825">通过上图，我们可以看到一套 CI 流程主要由两大部分组成：GitHub 流程和 CI 管道。其中，<strong data-nodeid="919">GitHub 流程是 CI 流程的触发者，而 CI 管道是 CI 流程的执行者</strong>。</p>\n<p data-nodeid="826">我们在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6659&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="925">《06 | 代码管理：如何使用 Git 与 GitHub 统一代码管理流程？》</a>里讲述过管理多个分支的代码流程，在此基础上，我们可以让分支在合并的时候自动触发 CI 流程，例如，在功能分支合并到主分支时触发 CI 管道 1，当主分支合并到发布分支时触发 CI 管道 2。</p>\n<p data-nodeid="827">那 CI 管道到底是什么呢？<strong data-nodeid="932">CI 管道是自动化软件交付的流程定义，它把多个自动化操作串联起来，并按照一定的顺序执行，最终达到从源码到交付的全自动化</strong>。例如，CI 管道 1 执行编译、运行测试、打包和签名 AdHoc 版本的 App，以及上传到 Firebase 的 App 分发服务等操作。而 CI 管道 2 执行了打包和签名 AppStore 版本的 App ，以及上传到 AppStore 这两项操作。可以看到，在整个 CI 流程中没有任何手工操作的参与，都是由 GitHub 流程自动触发的。</p>\n<p data-nodeid="828">那没有任何人手参与，CI 管道到底在哪里执行呢？答案能在下面 CI 的系统架构图中找到。</p>\n<p data-nodeid="829"><img src="https://s0.lgstatic.com/i/image6/M01/3F/DD/CioPOWCiCryALxStAAJGPQUyTrA302.png" alt="Drawing 1.png" data-nodeid="936"></p>\n<p data-nodeid="830">CI 架构通常由 CI<strong data-nodeid="950">中心服务</strong>和 CI<strong data-nodeid="951">构建中介</strong>（Build Agent）所组成。当 GitHub 发生变更时会通知 CI 中心服务，中心服务会把构建任务（Build Job）调度和分发给可用的 CI 构建中介。当接收到任务时，构建中介会从 GitHub 上下载代码并按照 CI 管道的配置来执行构建任务。对，<strong data-nodeid="952">CI 构建中介就是具体的执行者</strong>。</p>\n<p data-nodeid="831">目前流行的 CI 构建中介主要分成三大类。</p>\n<ul data-nodeid="832">\n<li data-nodeid="833">\n<p data-nodeid="834"><strong data-nodeid="958">全手工维护 CI</strong>。该类 CI 从物理主机、操作系统、Ruby 环境以及 Xcode 版本都由开发团队维护。这类型的 CI 维护成本比较高，例如，需要管理物理主机和网络联通性，需要维护操作系统的安全更新等，但同时也给了我们很大管控性和灵活性。</p>\n</li>\n<li data-nodeid="835">\n<p data-nodeid="836"><strong data-nodeid="963">云端虚拟机 CI</strong>。该类 CI 是通过租用云 Mac 虚拟机来进行搭建，目前比较流行的 Mac 虚拟机服务提供商有亚马逊的 AWS 和 MacStadium。有了这些云服务提供商，我们就不用再进行安全补丁等常规维护了，只需选择特定的 Mac OS 版本来启动虚拟机，然后在虚拟机上执行脚本来搭建 Ruby 和 Xcode 环境即可，就如 Moments App 项目里执行 setup.sh 脚本就能完成项目搭建。</p>\n</li>\n<li data-nodeid="837">\n<p data-nodeid="838"><strong data-nodeid="968">全服务 CI</strong>。该类 CI 不仅为我们提供了虚拟机，而且还提供了 Ruby 和 Xcode 等环境，我们只需要提供一个 CI 管道配置文件就能完成这个 App 的自动构建。</p>\n</li>\n</ul>\n<p data-nodeid="839">没有一类 CI 是完美的，它们都有各自的优缺点。这三类 CI 从上往下看，维护成本越来越低，但从长远来看，运行成本却越来越高。从便利性来看，下面的类型会比上面的更加易用，但同时也牺牲了灵活性。</p>\n<p data-nodeid="840">我建议你根据团队的自身情况来选择。假如你所在的团队没有专门的人员来维护 CI，可以从全服务 CI 开始。随着项目和团队的发展，慢慢地升级为云端虚拟机 CI 和全手工维护 CI。作为一个只有一个开发者的开源项目，Moments App 也选择了全服务 CI。</p>\n<p data-nodeid="841">下面我们就以 Moments App 为例子，看看如何配置一个全服务 CI。</p>\n<h3 data-nodeid="842">配置 Travis CI</h3>\n<p data-nodeid="843">Moments App 选择了 Travis CI 作为全服务 CI，原因有如下四个。</p>\n<ul data-nodeid="844">\n<li data-nodeid="845">\n<p data-nodeid="846">Travis CI 使用了“代码即配置”的方式来配置 CI 管道，这是最重要的一个原因。我们可以把 CI 管道的配置信息都写在一个 YAML 文件里面，并保存在 GitHub 上。这样能方便我们把 CI 配置共享到多个项目，而且通过 Git 历史记录来不断对比和优化 CI 配置。除此之外，YAML 文件的配置方式已成为 CI 配置的标准，当需要升级为云端虚拟机 CI 和全手工维护 CI 时，我们可以重用 Travis CI 的 YAML 文件。相比之下，有些 CI 需要在网页上进行手工配置，而且无法看到修改历史，这使得我们无法通过代码把配置信息共享到其他项目中去。</p>\n</li>\n<li data-nodeid="847">\n<p data-nodeid="848">Travis CI 免费给开源项目使用。</p>\n</li>\n<li data-nodeid="849">\n<p data-nodeid="850">Travis CI 整合了 GitHub 和 GitLab 等代码管理平台，只需要一次授权就能整合 CI 服务。</p>\n</li>\n<li data-nodeid="851">\n<p data-nodeid="852">Travis CI 支持多个不同版本的 Mac OS 和 Xcode，我们可以根据项目的要求来灵活选择不同的版本。例如通过 Travis CI，我们可以方便地测试 Xcode Beta 版的构建情况。</p>\n</li>\n</ul>\n<h4 data-nodeid="853">连接 Travis CI 与 GitHub</h4>\n<p data-nodeid="854">要搭建 Travis CI，首先需要使用 GitHub 账户登录到 Travis CI，然后给 Travis CI 授权，如下图所示：</p>\n<p data-nodeid="855"><img src="https://s0.lgstatic.com/i/image6/M01/3F/D4/Cgp9HWCiCsqAWtJkAAHWmLlqjFY886.png" alt="Drawing 2.png" data-nodeid="982"></p>\n<p data-nodeid="856">然后在 Travis CI 的配置页面上点击 Activate 按钮来激活 Travis CI 与 GitHub 的连接。</p>\n<p data-nodeid="857"><img src="https://s0.lgstatic.com/i/image6/M00/3F/DD/CioPOWCiCtKABmSKAAJlbBo-xLw222.png" alt="Drawing 3.png" data-nodeid="986"></p>\n<p data-nodeid="858">就这样，Travis CI 与 GitHub 的连接完成了。</p>\n<p data-nodeid="859">假如你需要管理该连接，可以到 GitHub 的 Settings -&gt; Applications -&gt; Installed GitHub Apps 下点击 Configure 按钮来打开下面的管理页面。</p>\n<p data-nodeid="860"><img src="https://s0.lgstatic.com/i/image6/M00/3F/DD/CioPOWCiCtiAKcJKAAOx6n3LWLo595.png" alt="Drawing 4.png" data-nodeid="991"></p>\n<h4 data-nodeid="861">配置 .travis.yml</h4>\n<p data-nodeid="862">完成 Travis CI 与 GitHub 的连接以后，下一步是通过 .travis.yml 文件来配置 CI 管道。.yml 也叫作 YAML 文件，全称是 YAML Ain\'t Markup Language （YAML 并不是标记语言）。<strong data-nodeid="1000">相比其他标记语言，YAML 具有更好的可读性，非常适合来做配置文件</strong>。下面我们一起看看 Moments App 的 .travis.yml 文件吧。</p>\n<pre class="lang-yaml" data-nodeid="863"><code data-language="yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">swift</span>\n<span class="hljs-attr">osx_image:</span> <span class="hljs-string">xcode12.2</span>\n<span class="hljs-attr">env:</span>\n  <span class="hljs-attr">global:</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">CI_BUILD_NUMBER=${TRAVIS_BUILD_NUMBER}</span>\n<span class="hljs-attr">before_install:</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">install</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">pod</span> <span class="hljs-string">install</span>\n</code></pre>\n<p data-nodeid="864">在 .travis.yml 文件的开头，我们定义了项目所使用的语言以及 Xcode 的版本号。接着定义全局的环境变量<code data-backticks="1" data-nodeid="1002">CI_BUILD_NUMBER</code>，该变量的值来自<code data-backticks="1" data-nodeid="1004">TRAVIS_BUILD_NUMBER</code>，<code data-backticks="1" data-nodeid="1006">TRAVIS_BUILD_NUMBER</code>的值由 Travis CI 系统所提供，它能帮助我们生成一个自增的 Build Number（构建数值）。</p>\n<p data-nodeid="865"><code data-backticks="1" data-nodeid="1008">CI_BUILD_NUMBER</code>会在 increment_build_number.sh 脚本中使用，如下代码所示：</p>\n<pre class="lang-java" data-nodeid="866"><code data-language="java">VERSION_XCCONFIG="Moments/Moments/Configurations/BaseTarget.xcconfig"\nSED_CMD="s/\\\\(PRODUCT_VERSION_SUFFIX=\\\\).*/\\\\1${CI_BUILD_NUMBER}/" # Make sure setting this environment variable before call script.\nsed -e ${SED_CMD} -i.bak ${VERSION_XCCONFIG} \nrm -f ${VERSION_XCCONFIG}.bak\n</code></pre>\n<p data-nodeid="867">这个 Shell 会更新 BaseTarget.xcconfig 文件里面的<code data-backticks="1" data-nodeid="1015">PRODUCT_VERSION</code>的值。在下面 CI 管道的配置里，你将会看到如何使用该值。</p>\n<p data-nodeid="868">最后是定义<code data-backticks="1" data-nodeid="1018">before_install</code>步骤，该步骤会在每一个构建任务执行前先运行。在 Moments App 的 CI 里，我们在该步骤里安装了 Bundler 和 CocoaPods 的各个依赖项。</p>\n<p data-nodeid="869">准备工作做完以后，我们看看如何配置 CI 管道的构建任务。</p>\n<pre class="lang-yaml" data-nodeid="870"><code data-language="yaml"><span class="hljs-attr">jobs:</span>\n  <span class="hljs-attr">include:</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-attr">stage:</span> <span class="hljs-string">"Build"</span>\n      <span class="hljs-attr">name:</span> <span class="hljs-string">"Build internal app"</span>\n      <span class="hljs-attr">script:</span>\n        <span class="hljs-bullet">-</span> <span class="hljs-string">set</span> <span class="hljs-string">-o</span> <span class="hljs-string">pipefail</span>\n        <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"machine github.com login $GITHUB_API_TOKEN"</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.netrc</span>\n        <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">download_profiles</span>\n        <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">archive_internal</span>\n</code></pre>\n<p data-nodeid="871">所有的 CI 管道都配置在<code data-backticks="1" data-nodeid="1022">jobs</code>下面，首先看一下用于构建的<code data-backticks="1" data-nodeid="1024">Build</code>任务。为了让 CI 可以访问存放在 GitHub 私有 Repo 里面的私钥、证书和 Provisioning Profile 文件，我们要为 Travis CI 配置<code data-backticks="1" data-nodeid="1026">GITHUB_API_TOKEN</code>。在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6679&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1032">《24 | 解决打包痛点：如何统一管理 Certificates 和 Profiles？》</a> 里，我们讲过如何获取 GitHub Access Token，假如你记不清楚了，可以回去复习一下。当拿到 GitHub Access Token 以后，就可以在 Travis CI 上的项目 Settings 页面里面进行添加，如下图所示：</p>\n<p data-nodeid="872"><img src="https://s0.lgstatic.com/i/image6/M00/40/63/Cgp9HWCkxF2Ab0pqAANKAzqQfK8033.png" alt="图片7.png" data-nodeid="1036"></p>\n<p data-nodeid="873">同时，我们还需要把 local.keys 文件的其他环境变量一同加上。</p>\n<p data-nodeid="874">配置好<code data-backticks="1" data-nodeid="1039">GITHUB_API_TOKEN</code>环境变量后，我们就可以调用 fastlane 的<code data-backticks="1" data-nodeid="1041">download_profiles</code>和<code data-backticks="1" data-nodeid="1043">archive_internal</code>来完成 Build 的步骤了。</p>\n<p data-nodeid="875">下面看看执行测试的<code data-backticks="1" data-nodeid="1046">Test</code>任务。</p>\n<pre class="lang-yaml" data-nodeid="876"><code data-language="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">stage:</span> <span class="hljs-string">"Test"</span>\n  <span class="hljs-attr">name:</span> <span class="hljs-string">"Test app"</span>\n  <span class="hljs-attr">script:</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">set</span> <span class="hljs-string">-o</span> <span class="hljs-string">pipefail</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">tests</span>\n</code></pre>\n<p data-nodeid="877">执行测试的操作非常简单，只需要执行 fastlane 的<code data-backticks="1" data-nodeid="1049">tests</code>即可。</p>\n<p data-nodeid="878">接着再看看打包和部署 Internal App 的任务，具体代码如下：</p>\n<pre class="lang-yaml" data-nodeid="879"><code data-language="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">stage:</span> <span class="hljs-string">"Archive, sign and deploy internal app"</span>\n  <span class="hljs-attr">name:</span> <span class="hljs-string">"Archive Internal app"</span>\n  <span class="hljs-attr">if:</span> <span class="hljs-string">branch</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>\n  <span class="hljs-attr">script:</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">set</span> <span class="hljs-string">-o</span> <span class="hljs-string">pipefail</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"machine github.com login $GITHUB_API_TOKEN"</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.netrc</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">download_profiles</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">./scripts/increment_build_number.sh</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">archive_internal</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">deploy_internal</span>\n</code></pre>\n<p data-nodeid="880">为了访问 GitHub 私有 Repo，我们也需要把<code data-backticks="1" data-nodeid="1053">GITHUB_API_TOKEN</code>配置到 .netrc 文件里面，然后就可以下载私钥、证书和 Provisioning Profile 等文件了。接着是执行<code data-backticks="1" data-nodeid="1055">increment_build_number.sh</code>来更新<code data-backticks="1" data-nodeid="1057">PRODUCT_VERSION</code>的值。因为 Info.plist 文件引用了更新过的<code data-backticks="1" data-nodeid="1059">PRODUCT_VERSION</code>，每次打包时，App 都具备不同的 Build Number。最后是执行 fastlane 的<code data-backticks="1" data-nodeid="1061">archive_internal</code>和<code data-backticks="1" data-nodeid="1063">deploy_internal</code>来完成打包和上传任务。</p>\n<p data-nodeid="881">最后一个是打包和上传 Production 版本的 App 到 App Store，具体配置代码如下：</p>\n<pre class="lang-yaml" data-nodeid="882"><code data-language="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">stage:</span> <span class="hljs-string">"Archive, sign and deploy production app"</span>\n  <span class="hljs-attr">name:</span> <span class="hljs-string">"Archive Production app"</span>\n  <span class="hljs-attr">if:</span> <span class="hljs-string">branch</span> <span class="hljs-string">=</span> <span class="hljs-string">release</span>\n  <span class="hljs-attr">script:</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">set</span> <span class="hljs-string">-o</span> <span class="hljs-string">pipefail</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"machine github.com login $GITHUB_API_TOKEN"</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.netrc</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">download_profiles</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">./scripts/increment_build_number.sh</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">archive_appstore</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">deploy_appstore</span>\n</code></pre>\n<p data-nodeid="883">这个在步骤上与打包和部署 Internal App 的任务基本一致，不同的地方是，我们通过条件判断语句<code data-backticks="1" data-nodeid="1067">if: branch = release</code>来构建发布分支而不是主分支，并且最后调用的是 fastlane 的<code data-backticks="1" data-nodeid="1069">archive_appstore</code>和<code data-backticks="1" data-nodeid="1071">deploy_appstore</code>来打包和发布到 App Store。</p>\n<p data-nodeid="884">到这里，Moments App 的 CI 就配置完毕了，其执行效果如下：</p>\n<p data-nodeid="885"><img src="https://s0.lgstatic.com/i/image6/M00/40/63/Cgp9HWCkxH2AP76qAAMmv7m5zGQ751.png" alt="图片8.png" data-nodeid="1076"></p>\n<h3 data-nodeid="886">总结</h3>\n<p data-nodeid="887">在这一讲，我们讲述了 CI 的系统架构和构建流程，并且还以 Moments App 为例子讲述了如何使用 Travis CI 来搭建一套完整的 CI。在此基础上，你可以根据项目的具体需求，不断地完善 CI 管道，并推动项目的自动化与工程化建设。CI 是每个工程化团队所必备的，我建议每个团队都建立起自己的 CI 并不断优化。CI 不仅能解放所有手工操作，还能减少错误的发生，更重要的是 CI 能推动一个团队工程师文化的发展。</p>\n<p data-nodeid="888"><strong data-nodeid="1082">思考题</strong></p>\n<blockquote data-nodeid="889">\n<p data-nodeid="890">你可能已经注意到，在 .travis.yml 文件里面，我们都是调用 fastlane 里面的 Lane 来完成具体的构建任务，这样做有什么好处呢？</p>\n</blockquote>\n<p data-nodeid="891">可以把你的答案写到留言区哦。从下一讲开始，我们就进入本模块的下半部分——App 上架后的优化，我会先介绍如何使用 Firebase 的统计分析服务，记得按时来听课。</p>\n<p data-nodeid="892"><strong data-nodeid="1088">源码地址</strong></p>\n<blockquote data-nodeid="893">\n<p data-nodeid="894" class="">.travis.yml 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.travis.yml?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1092">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.travis.yml</a></p>\n</blockquote>',
          },
          {
            theme: '27 | 统计分析：如何架构灵活的统计分析服务，助力产品增长？',
            id: 43,
            content:
              '<p data-nodeid="1147" class="">App 上架是产品发展的一个里程碑，同时也是产品长远发展的起点。那有没有什么方法能帮助我们持续地改善产品功能与用户体验，并制定产品发展的方向与目标呢？当然有！我们可以使用统计分析服务（Analytics）。</p>\n<p data-nodeid="1148"><strong data-nodeid="1256">统计分析服务能为我们提供用户交互度指标（Engagement Metrics），这些指标包括用户会话的活跃度、活跃的设备类型以及用户留存率等。</strong> 有了这些指标，我们就能衡量每次发布的新功能是否能有效提高用户的交互频率，从而及时调整产品发展的方向。</p>\n<p data-nodeid="1149">市面上有许多统计分析服务，为了方便使用各种不同的服务，我们为 Moments App 架构了一套灵活的统计分析模块，同时使用 Firebase 作为例子来演示如何支持一种统计分析服务。之所以选择 Firebase，其主要原因有如下三个：</p>\n<ol data-nodeid="1150">\n<li data-nodeid="1151">\n<p data-nodeid="1152">Firebase 功能齐全，除了统计分析服务以外，几乎包含了我们优化 App 所需的各种服务，例如崩溃报告、远程配置与遥控功能开关、App 分发服务、A/B 测试等；</p>\n</li>\n<li data-nodeid="1153">\n<p data-nodeid="1154">免费版的 Firebase 足够使用，与功能相当的收费产品相比，能省下不少钱；</p>\n</li>\n<li data-nodeid="1155">\n<p data-nodeid="1156">Firebase 配置方便，只需搭建一次就能长久使用。</p>\n</li>\n</ol>\n<h3 data-nodeid="1157">配置 Firebase 服务</h3>\n<p data-nodeid="1158">在讲述如何使用 Firebase 的统计分析服务前，我们先看看如何为 Moments App 配置 Firebase 的服务。</p>\n<h4 data-nodeid="1159">1. 创建项目</h4>\n<p data-nodeid="1160">首先，我们登录到 Firebase 网站来新建一个项目。请注意，在新建的时候必须选择“Enable Google Analytics for this project”（为该项目启动统计分析服务）选项，否则将没办法使用 A/B 测试等一系列的服务。</p>\n<p data-nodeid="1161">然后在新项目里添加 App，我的做法是为开发环境、测试环境和生产环境各自添加不同的 App。下图演示了如何添加测试环境的 Internal App。</p>\n<p data-nodeid="1162"><img src="https://s0.lgstatic.com/i/image6/M00/41/51/Cgp9HWCrgiGAUFjAAAD2MmgiiDs166.png" alt="Drawing 1.png" data-nodeid="1270"></p>\n<p data-nodeid="1163">这里关键是要填写正确的 Bundle ID。你可以到各个 Target 的 xcconfig 文件里面分别找到它们的 Bundle ID，例如在 InternalTarget.xcconfig 文件里面有如下的定义：</p>\n<pre class="lang-java" data-nodeid="1164"><code data-language="java">PRODUCT_BUNDLE_IDENTIFIER = com.ibanimatable.moments.internal\n</code></pre>\n<h4 data-nodeid="1165">2. 下载 Firebase 配置文件</h4>\n<p data-nodeid="1166">第二步是为三个环境的 App 分别下载 Firebase 的配置文件。当我们把三个配置文件下载完毕后，为了方便管理，可以使用“GoogleService-Info-&lt;环境名称&gt;.plist”的命名方式来改名，然后把所有的配置文件都拖到 Moments 项目里面，如下图所示：</p>\n<p data-nodeid="1167"><img src="https://s0.lgstatic.com/i/image6/M00/41/51/Cgp9HWCrgi6ACes3AA-s5YKaXBk146.png" alt="Drawing 3.png" data-nodeid="1280"></p>\n<p data-nodeid="1168">同时在各个 Target 的 xcconfig 文件分别添加名叫<code data-backticks="1" data-nodeid="1282">FIREBASE_CONFIG_FILENAME</code>的 Build Setting，如下所示：</p>\n<pre class="lang-java" data-nodeid="1169"><code data-language="java">FIREBASE_CONFIG_FILENAME = GoogleService-Info-Development\n</code></pre>\n<p data-nodeid="1170">接着在 Build Phases 上添加“Copy Firebase Config File”步骤的配置信息，并输入下面的脚本：</p>\n<pre class="lang-java" data-nodeid="1171"><code data-language="java">cp <span class="hljs-string">"${PROJECT_DIR}/Moments/Configurations/Firebase/${FIREBASE_CONFIG_FILENAME}.plist"</span> <span class="hljs-string">"${BUILT_PRODUCTS_DIR}/${FULL_PRODUCT_NAME}/GoogleService-Info.plist"</span>\n</code></pre>\n<p data-nodeid="1172">具体配置如下图所示：</p>\n<p data-nodeid="1173"><img src="https://s0.lgstatic.com/i/image6/M00/41/51/Cgp9HWCrgjaAcJ61AA15f4d4K2M666.png" alt="Drawing 4.png" data-nodeid="1288"></p>\n<p data-nodeid="1174">有了这个步骤的配置，Xcode 在构建的过程中就会执行。因为步骤配置里的 Shell 脚本中使用了 xcconfig 里面的<code data-backticks="1" data-nodeid="1290">FIREBASE_CONFIG_FILENAME</code>变量，所以当我们构建不同环境的 App 时，Xcode 会自动拷贝对应的 Firebase 配置文件到不同的 App 里面，这样就使得不同的 App 能把用户事件发送到不同的统计分析数据服务，进而保证生产环境的数据不会受到污染。</p>\n<h4 data-nodeid="1175">3. 安装 Firebase SDK</h4>\n<p data-nodeid="1176">下载完配置文件以后，下一步是安装 Firebase SDK。<strong data-nodeid="1300">官方推荐的方式是使用 CocoaPods 来安装 Firebase SDK</strong>。我们只需要把 Firebase 添加到 Podfile 即可，具体代码如下：</p>\n<pre class="lang-java" data-nodeid="1177"><code data-language="java">def thirdparty_pods\n  pod <span class="hljs-string">\'Firebase/Analytics\'</span>, <span class="hljs-string">\'= 7.0.0\'</span>\nend\ntarget <span class="hljs-string">\'Moments\'</span> <span class="hljs-keyword">do</span>\n  ...\n  thirdparty_pods\n  ...\nend\n</code></pre>\n<p data-nodeid="1178">我们通过<code data-backticks="1" data-nodeid="1302">pod</code>命令来添加统计分析服务，然后把这些 Pod 通过<code data-backticks="1" data-nodeid="1304">thirdparty_pods</code>函数添加到 Moments target 里面，最后重新执行<code data-backticks="1" data-nodeid="1306">bundle exec pod install</code>命令就能完成 Firebase SDK 的安装了。</p>\n<h4 data-nodeid="1179">4. 初始化 Firebase 服务</h4>\n<p data-nodeid="1180">安装完 Firebase SDK 后，我们还需要在 App 里面进行初始化 Firebase 服务，只需要两步，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="1181"><code data-language="swift"><span class="hljs-keyword">import</span> Firebase <span class="hljs-comment">// 1</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">UIResponder</span>, <span class="hljs-title">UIApplicationDelegate</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication,\n                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="hljs-keyword">Any</span>]?)</span></span> -&gt; <span class="hljs-type">Bool</span> {\n        <span class="hljs-type">FirebaseApp</span>.configure() <span class="hljs-comment">// 2</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n    }\n}\n</code></pre>\n<p data-nodeid="1182">第一步是通过<code data-backticks="1" data-nodeid="1313">import Firebase</code>语句来引入 Firebase 库，第二步是在<code data-backticks="1" data-nodeid="1315">application(_:didFinishLaunchingWithOptions:)</code>函数里调用<code data-backticks="1" data-nodeid="1317">FirebaseApp.configure()</code> 函数来启动 Firebase 服务。</p>\n<p data-nodeid="1183">好了，至此我们就为 Moments App 配置好 Firebase 服务了。</p>\n<h3 data-nodeid="1184">统计分析模块</h3>\n<p data-nodeid="1185">下面我们以 Moments App 为例子，看看如何架构与实现一个灵活的统计分析模块以及如何使用该模块。</p>\n<h4 data-nodeid="1186">1. 统计分析模块的架构与实现</h4>\n<p data-nodeid="1187">首先，我们看一下统计分析模块的架构图，如下图所示：</p>\n<p data-nodeid="1188"><img src="https://s0.lgstatic.com/i/image6/M00/41/51/Cgp9HWCrglCAZTKOAAM0NmFucJo862.png" alt="Drawing 6.png" data-nodeid="1328"></p>\n<p data-nodeid="1189">这里我们从右往左看，根据依赖关系，<strong data-nodeid="1334">统计分析模块由用户活动事件（Event）、事件跟踪提供者（Provider）和事件跟踪数据仓库（Repo）这三部分组成</strong>。</p>\n<p data-nodeid="1190">下面我们分别看一下它们的实现。</p>\n<p data-nodeid="1191">所有的事件类型都遵循了一个名叫<code data-backticks="1" data-nodeid="1337">TrackingEventType</code>的空协议（Protocol），其定义如下：</p>\n<pre class="lang-swift" data-nodeid="1192"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TrackingEventType</span> </span>{ }\n</code></pre>\n<p data-nodeid="1193">然后就可以定义该协议的字类型。根据用途的不同，我们把事件分成以下三类：</p>\n<ul data-nodeid="1194">\n<li data-nodeid="1195">\n<p data-nodeid="1196"><code data-backticks="1" data-nodeid="1340">ScreenviewsTrackingEvent</code>，用于记录页面事件；</p>\n</li>\n<li data-nodeid="1197">\n<p data-nodeid="1198"><code data-backticks="1" data-nodeid="1342">ActionTrackingEventType</code>，用于记录行为事件，例如点击了某个按钮；</p>\n</li>\n<li data-nodeid="1199">\n<p data-nodeid="1200"><code data-backticks="1" data-nodeid="1344">TrackingEvent</code>，用于记录通用的事件。</p>\n</li>\n</ul>\n<p data-nodeid="1201">接着我们定义了<code data-backticks="1" data-nodeid="1347">TrackingProvider</code>协议来发送事件。该协议定义了三个方法来分别发送不同的事件，具体定义如下：</p>\n<pre class="lang-swift" data-nodeid="1202"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TrackingProvider</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackScreenviews</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackAction</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackEvent</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span>\n}\n</code></pre>\n<p data-nodeid="1203">其中，<code data-backticks="1" data-nodeid="1350">trackScreenviews()</code>用于发送页面事件，<code data-backticks="1" data-nodeid="1352">trackAction()</code>负责发送行为事件，而<code data-backticks="1" data-nodeid="1354">trackEvent()</code>用于发送通用的事件。</p>\n<p data-nodeid="1204">当要支持某种统计分析服务（例如 Firebase）的时候，我们就需要为<code data-backticks="1" data-nodeid="1357">TrackingProvider</code>提供一个具体的实现类型，比如，下面就是<code data-backticks="1" data-nodeid="1359">FirebaseTrackingProvider</code>的具体实现：</p>\n<pre class="lang-swift" data-nodeid="1205"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FirebaseTrackingProvider</span>: <span class="hljs-title">TrackingProvider</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackScreenviews</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> event = event <span class="hljs-keyword">as</span>? <span class="hljs-type">ScreenviewsTrackingEvent</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span>\n        }\n        <span class="hljs-type">Analytics</span>.logEvent(<span class="hljs-type">AnalyticsEventSelectContent</span>, parameters: [\n                            <span class="hljs-type">AnalyticsParameterScreenName</span>: event.screenName,\n                            <span class="hljs-type">AnalyticsParameterScreenClass</span>: event.screenClass])\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackAction</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> event = event <span class="hljs-keyword">as</span>? <span class="hljs-type">FirebaseActionTrackingEvent</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span>\n        }\n        <span class="hljs-type">Analytics</span>.logEvent(<span class="hljs-type">AnalyticsEventSelectContent</span>, parameters: event.parameters)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackEvent</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> event = event <span class="hljs-keyword">as</span>? <span class="hljs-type">TrackingEvent</span> <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span>\n        }\n        <span class="hljs-type">Analytics</span>.logEvent(event.name, parameters: event.parameters)\n    }\n}\n</code></pre>\n<p data-nodeid="1206"><code data-backticks="1" data-nodeid="1361">FirebaseTrackingProvider</code>遵循了<code data-backticks="1" data-nodeid="1363">TrackingProvider</code>协议，并实现了<code data-backticks="1" data-nodeid="1365">trackScreenviews()</code>、<code data-backticks="1" data-nodeid="1367">trackAction()</code>和<code data-backticks="1" data-nodeid="1369">trackEvent()</code>三个方法。在这些方法里面，都是通过<code data-backticks="1" data-nodeid="1371">guard</code>语句来检查输入类型是否正确，并通过 Firebase SDK 所提供的<code data-backticks="1" data-nodeid="1373">Analytics.logEvent()</code>方法来发送事件。</p>\n<p data-nodeid="1207">假如我们需要支持新的统计分析服务时，就可以为该服务提供一个遵循<code data-backticks="1" data-nodeid="1376">TrackingProvider</code>协议的实现类型。例如，当我们支持 Mixpanel 时，就可实现一个名叫<code data-backticks="1" data-nodeid="1378">MixpanelTrackingProvider</code>的结构体。</p>\n<p data-nodeid="1208">有了<code data-backticks="1" data-nodeid="1381">TrackingProvider</code>的实例以后，我们就可以通过 Repo 来管理它们。这里我们一起看一下<code data-backticks="1" data-nodeid="1383">TrackingRepoType</code>协议和它的实现类型<code data-backticks="1" data-nodeid="1385">TrackingRepo</code>。</p>\n<p data-nodeid="1209"><code data-backticks="1" data-nodeid="1387">TrackingRepoType</code>的实现如下：</p>\n<pre class="lang-swift" data-nodeid="1210"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TrackingRepoType</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(trackingProvider: TrackingProvider)</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackScreenviews</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackAction</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackEvent</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span>\n}\n</code></pre>\n<p data-nodeid="1529">该协议定义了<code data-backticks="1" data-nodeid="1532">register(trackingProvider:)</code>方法来注册各种<code data-backticks="1" data-nodeid="1534">TrackingProvider</code>，然后还定义了三个方法来发送不同类型的事件。</p>\n<p data-nodeid="1530"><code data-backticks="1" data-nodeid="1536">TrackingRepo</code>的具体实现如下：</p>\n\n<pre class="lang-swift" data-nodeid="1212"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrackingRepo</span>: <span class="hljs-title">TrackingRepoType</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">TrackingRepo</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> providers = [<span class="hljs-type">TrackingProvider</span>]()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() { }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(trackingProvider: TrackingProvider)</span></span> {\n        providers.append(trackingProvider)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackScreenviews</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n        providers.forEach { $<span class="hljs-number">0</span>.trackScreenviews(event) }\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackAction</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n        providers.forEach { $<span class="hljs-number">0</span>.trackAction(event) }\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackEvent</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n        providers.forEach { $<span class="hljs-number">0</span>.trackEvent(event) }\n    }\n}\n</code></pre>\n<p data-nodeid="1213"><code data-backticks="1" data-nodeid="1397">TrackingRepo</code>实现了<code data-backticks="1" data-nodeid="1399">TrackingRepoType</code>协议的所有方法，其中<code data-backticks="1" data-nodeid="1401">register(trackingProvider:)</code>方法把各个注册的<code data-backticks="1" data-nodeid="1403">TrackingProvider</code>的实例都保存在<code data-backticks="1" data-nodeid="1405">providers</code>属性里面，而<code data-backticks="1" data-nodeid="1407">trackScreenviews()</code>、<code data-backticks="1" data-nodeid="1409">trackAction()</code>和<code data-backticks="1" data-nodeid="1411">trackEvent()</code>三个方法则分别调用了<code data-backticks="1" data-nodeid="1413">providers</code>属性所对应的方法。你可以看到，假如我们注册了多个统计分析服务的 Provider，<code data-backticks="1" data-nodeid="1415">TrackingRepo</code>会把每个事件依次发送给各个后台服务。</p>\n<p data-nodeid="1214">到此为止，我们就实现了一套灵活的统计分析模块。有了它，我们可以很便捷地添加或者替换不同的统计分析服务。</p>\n<h4 data-nodeid="1215">2. 统计分析模块的使用</h4>\n<p data-nodeid="1216">要使用统计分析模块，需要两步，第一步是注册<code data-backticks="1" data-nodeid="1422">TrackingProvider</code>的实例，代码如下：</p>\n<pre class="lang-swift" data-nodeid="1217"><code data-language="swift">[<span class="hljs-type">FirebaseTrackingProvider</span>()].forEach {\n    <span class="hljs-type">TrackingRepo</span>.shared.register(trackingProvider: $<span class="hljs-number">0</span>)\n}\n</code></pre>\n<p data-nodeid="2302">我们通过调用<code data-backticks="1" data-nodeid="2305">TrackingRepo</code>的<code data-backticks="1" data-nodeid="2307">register</code>方法来注册<code data-backticks="1" data-nodeid="2309">FirebaseTrackingProvider</code>的实例，这样就能把事件发送到 Firebase 统计分析服务了。如果有需要，我们还可以同时注册多个统计分析服务的 Provider。</p>\n<p data-nodeid="2303">第二步是使用<code data-backticks="1" data-nodeid="2312">TrackingRepo</code>的实例来发送事件。例如，下面的代码演示了如何发送页面事件：</p>\n\n<pre class="lang-swift" data-nodeid="1219"><code data-language="swift">trackingRepo.trackScreenviews(<span class="hljs-type">ScreenviewsTrackingEvent</span>(screenName: <span class="hljs-type">L10n</span>.<span class="hljs-type">Tracking</span>.momentsScreen, screenClass: <span class="hljs-type">String</span>(describing: <span class="hljs-keyword">self</span>)))\n</code></pre>\n<p data-nodeid="1220">我们通过调用<code data-backticks="1" data-nodeid="1436">trackingRepo</code>的<code data-backticks="1" data-nodeid="1438">trackScreenviews()</code>方法来发送进入朋友圈页面的事件。</p>\n<h4 data-nodeid="1221">3. 为不同统计分析服务自定义事件内容</h4>\n<p data-nodeid="1222">不同的统计分析服务所接收的事件内容可能不一样。这里我们以点赞按钮事件为例子看看如何为 Firebase 服务自定义事件。</p>\n<p data-nodeid="1223">首先我们看一下<code data-backticks="1" data-nodeid="1445">LikeActionTrackingEvent</code>的定义：</p>\n<pre class="lang-swift" data-nodeid="1224"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LikeActionTrackingEvent</span>: <span class="hljs-title">ActionTrackingEventType</span> </span>{\n    <span class="hljs-keyword">let</span> momentID: <span class="hljs-type">String</span>\n    <span class="hljs-keyword">let</span> userID: <span class="hljs-type">String</span>\n}\n</code></pre>\n<p data-nodeid="1225">该事件只有两个属性，其中<code data-backticks="1" data-nodeid="1448">momentID</code>表示点赞的朋友圈信息的 ID，而<code data-backticks="1" data-nodeid="1450">userID</code>表示点赞用户的 ID。为了特定给 Firebase 统计分析服务定制事件的内容，我们定义了一个名叫<code data-backticks="1" data-nodeid="1452">FirebaseActionTrackingEvent</code>的空协议：</p>\n<pre class="lang-swift" data-nodeid="1226"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">FirebaseActionTrackingEvent</span>: <span class="hljs-title">ActionTrackingEventType</span> </span>{ }\n</code></pre>\n<p data-nodeid="1227">然后给<code data-backticks="1" data-nodeid="1455">LikeActionTrackingEvent</code>提供了一个类型扩展，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="1228"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LikeActionTrackingEvent</span>: <span class="hljs-title">FirebaseActionTrackingEvent</span> </span>{\n    <span class="hljs-keyword">var</span> parameters: [<span class="hljs-type">String</span> : <span class="hljs-type">Any</span>] {\n        <span class="hljs-keyword">return</span> [\n            <span class="hljs-type">AnalyticsParameterItemID</span>: <span class="hljs-string">"moment-id-\\(momentID)-user-id-\\(userID)"</span>,\n            <span class="hljs-type">AnalyticsParameterItemName</span>: <span class="hljs-string">"moment-like"</span>\n        ]\n    }\n}\n</code></pre>\n<p data-nodeid="1229">该类型扩展使得<code data-backticks="1" data-nodeid="1458">LikeActionTrackingEvent</code>遵循了<code data-backticks="1" data-nodeid="1460">FirebaseActionTrackingEvent</code>协议，并为<code data-backticks="1" data-nodeid="1462">parameters</code>属性提供了一个默认的实现，在实现里面使用了在 Firebase SDK 里面定义的两个常量：<code data-backticks="1" data-nodeid="1464">AnalyticsParameterItemID</code>和<code data-backticks="1" data-nodeid="1466">AnalyticsParameterItemName</code>。当我们使用了这些常量时，Firebase 统计分析后台就会把事件自动映射成选择内容的 Item ID 和名字。</p>\n<p data-nodeid="1230">那提供这样一个类型扩展到底有什么好处呢？我们再看一下<code data-backticks="1" data-nodeid="1469">FirebaseTrackingProvider</code>里<code data-backticks="1" data-nodeid="1471">trackAction</code>方法的实现。</p>\n<pre class="lang-swift" data-nodeid="1231"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trackAction</span><span class="hljs-params">(<span class="hljs-number">_</span> event: TrackingEventType)</span></span> {\n    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> event = event <span class="hljs-keyword">as</span>? <span class="hljs-type">FirebaseActionTrackingEvent</span> <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span>\n    }\n    <span class="hljs-type">Analytics</span>.logEvent(<span class="hljs-type">AnalyticsEventSelectContent</span>, parameters: event.parameters)\n}\n</code></pre>\n<p data-nodeid="1232">在该方法里面，我们通过<code data-backticks="1" data-nodeid="1474">guard</code>语句检查传递进来的事件是否为<code data-backticks="1" data-nodeid="1476">FirebaseActionTrackingEvent</code>类型，如果不是，程序就直接退出了。如果是，就调用<code data-backticks="1" data-nodeid="1478">event.parameters</code>属性来获取事件的内容，这时候就会调用类型扩展里<code data-backticks="1" data-nodeid="1480">parameters</code>属性的默认实现，类型扩展方法能保证<code data-backticks="1" data-nodeid="1482">FirebaseTrackingProvider</code>只发送遵循了<code data-backticks="1" data-nodeid="1484">FirebaseActionTrackingEvent</code>协议的事件类型。</p>\n<p data-nodeid="1233">假如我们需要为其他统计分析服务自定义事件的内容时，该怎么做呢？例如，为 Mixpanel 自定义事件，可以通过下面的代码实现：</p>\n<pre class="lang-swift" data-nodeid="1234"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LikeActionTrackingEvent</span>: <span class="hljs-title">MixpanelActionTrackingEvent</span> </span>{\n    <span class="hljs-keyword">var</span> parameters: [<span class="hljs-type">String</span> : <span class="hljs-type">Any</span>] {\n        <span class="hljs-keyword">return</span> [\n            <span class="hljs-type">MixPanelEventKey</span>: <span class="hljs-string">"moment-id-\\(momentID)-user-id-\\(userID)"</span>,\n            <span class="hljs-type">MixPanelEventName</span>: <span class="hljs-string">"moment-like"</span>\n        ]\n    }\n}\n</code></pre>\n<p data-nodeid="3078">通过类型扩展来遵循不同的事件协议，我们就可以很灵活地为各个统计分析服务发送不同内容的事件了。</p>\n<p data-nodeid="3079">最后，我们再看一下如何发送<code data-backticks="1" data-nodeid="3082">LikeActionTrackingEvent</code>事件，具体实现如下：</p>\n\n<pre class="lang-swift" data-nodeid="1236"><code data-language="swift">trackingRepo.trackAction(<span class="hljs-type">LikeActionTrackingEvent</span>(momentID: momentID, userID: userID))\n</code></pre>\n<p data-nodeid="1237"><code data-backticks="1" data-nodeid="1492">trackingRepo</code>会自动把事件发送到各个注册的统计分析服务中，并且根据<code data-backticks="1" data-nodeid="1494">LikeActionTrackingEvent</code>的类型扩展来准备不同的事件内容。</p>\n<h4 data-nodeid="1238">4. Firebase 统计分析报告</h4>\n<p data-nodeid="1239">完成了上述的开发工作后，我们就能收集用户行为数据了，并且还可以在 Firebase 的统计分析服务上查看相关的报告。下图是 Moments App 的统计分析报告：<br>\n<img src="https://s0.lgstatic.com/i/image6/M00/41/59/CioPOWCrgm-ACTRxAAUh4NIuWcI675.png" alt="Drawing 8.png" data-nodeid="1503"></p>\n<p data-nodeid="1240">我们可以在 Analyics 菜单下看到各种各样的报告，如事件统计、设备类型以及用户留存率等。<strong data-nodeid="1509">这些报告能协助我们更准确地做出产品决定</strong>，比如，通过 iOS 活跃版本的报告能帮我们决定 App 支持 iOS 的最低版本号，假如绝大部分用户都使用 iOS 13 以上的版本，我们就引入 SwiftUI 和 Combine 等新技术。</p>\n<p data-nodeid="1241">我建议你仔细阅读统计分析服务的相关文档，并熟悉各种统计报告以及指标，从而助力产品的增长。</p>\n<h3 data-nodeid="1242">总结</h3>\n<p data-nodeid="1243">在这一讲，我们讲述了如何架构一个灵活的统计分析模块，有了这个模块，我们就可以很方便地支持和替换不同的统计分析服务。同时，我们还以 Firebase 为例子讲述了如何配置 Firebase 的统计分析服务。总之，我希望你能好好地利用这些分析报告和指标，进而助力产品的增长。</p>\n<p data-nodeid="1244"><strong data-nodeid="1516">思考题</strong></p>\n<blockquote data-nodeid="1245">\n<p data-nodeid="1246">请参照 FirebaseTrackingProvider 来编写一个遵循 TrackingProvider 协议的 SystemLogTrackingProvider 来打印日志，在该 Provider 里通过系统提供的 os_log() 方法来打印事件。</p>\n</blockquote>\n<p data-nodeid="1247">请把你的答案写到留言区或者提交一个 PR 哦。下一讲我将介绍如何使用 Firebase 的崩溃报告服务去解决线上的 Bug，记得按时来听课。</p>\n<p data-nodeid="1248"><strong data-nodeid="1524">源码地址</strong></p>\n<blockquote data-nodeid="1249">\n<p data-nodeid="1250" class="">统计分析模块源码地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Analytics?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1528">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Analytics</a></p>\n</blockquote>',
          },
          {
            theme: '28 | 崩溃报告：如何借助崩溃报告解决线上的 Bug？',
            id: 44,
            content:
              '<p data-nodeid="619" class="">App 在运行过程中发生闪退会给用户带来极其恶劣的体验，因此，用户往往会把经常闪退的 App 直接删掉。同样地，对开发者来说，重现线上问题也是件困难的事，因为这些 Bug 可能与用户使用时的网络连接状态、iOS 系统版本、内存空间、是否越狱等有关。那有没有什么好办法能帮助我们解决线上的 Bug，并提升用户体验呢？</p>\n<p data-nodeid="620"><strong data-nodeid="688">崩溃报告是一种解决线上闪退问题的有效办法。崩溃报告可以实时收集真实用户在使用 App 过程中发生闪退的信息，并将其解释成对开发者友好的报告，这可以很好地帮助我们确认和诊断线上的问题。</strong></p>\n<p data-nodeid="621">可以这么说，崩溃报告服务已经成为 App 不可或缺的支撑功能。在 Moments App 中，我选择了 Firebase Crashlytics 作为崩溃报告服务。与市面上其他服务相比，Firebase Crashlytics 有以下 5 个优点。</p>\n<ol data-nodeid="622">\n<li data-nodeid="623">\n<p data-nodeid="624">Crashlytics 产品有 10 年的历史，经过这快 10 年的实践检验，我们发现该产品非常稳定。</p>\n</li>\n<li data-nodeid="625">\n<p data-nodeid="626">Crashlytics 能同时支持 iOS 和 Android 等平台，方便我们在同一个地方查看所有 App 的崩溃报告。</p>\n</li>\n<li data-nodeid="627">\n<p data-nodeid="628">Crashlytics 完美地整合在 Firebase 里面，可以与 Firebase 其他服务一同使用，例如可以配合性能监控一起使用。</p>\n</li>\n<li data-nodeid="629">\n<p data-nodeid="630">与 Firebase 的其他产品一样，Crashlytics 可以免费使用。</p>\n</li>\n<li data-nodeid="631">\n<p data-nodeid="632">fastlane 支持 Crashlytics 的整合，只需要简单的配置就可以通过 CI 自动化上传 dSYM 文件。</p>\n</li>\n</ol>\n<p data-nodeid="633">下面我们就来看看如何在 Moments App 里面使用 Crashlytics。</p>\n<h3 data-nodeid="634">配置 Crashlytics</h3>\n<p data-nodeid="635">在使用 Crashlytics 前，我们需要完成一次性的配置。</p>\n<p data-nodeid="636">首先登录到 Firebase 网站，并通过位于左边 Crashlytics 菜单打开 Crashlytics 页面，接着点击“Enable Crashlytics”按钮来启动 Crashlytics 功能。</p>\n<p data-nodeid="637"><img src="https://s0.lgstatic.com/i/image6/M00/41/5A/CioPOWCrg9uAHGPoAAMmXqOKJGo185.png" alt="Drawing 0.png" data-nodeid="701"></p>\n<p data-nodeid="638">启动 Crashlytics 服务以后，在 Podfile 文件里添加以下的 Pod：</p>\n<pre class="lang-java" data-nodeid="639"><code data-language="java">def thirdparty_pods\n  pod <span class="hljs-string">\'Firebase/Crashlytics\'</span>, <span class="hljs-string">\'= 7.0.0\'</span>\n  pod <span class="hljs-string">\'Firebase/Performance\'</span>, <span class="hljs-string">\'= 7.0.0\'</span>\nend\n</code></pre>\n<p data-nodeid="640">其中，<code data-backticks="1" data-nodeid="704">Firebase/Crashlytics</code>是用于崩溃报告服务的 Pod，而<code data-backticks="1" data-nodeid="706">Firebase/Performance</code>是用于性能监控的 Pod。完成上面的配置以后，只需重新执行<code data-backticks="1" data-nodeid="708">bundle exec pod install</code>命令就能完成 Crashlytics 的安装了。</p>\n<p data-nodeid="641">最后一步是调用<code data-backticks="1" data-nodeid="711">FirebaseApp.configure()</code>函数来启动崩溃报告服务。如果你已经使用了统计分析服务，那么这一步之前就做过了。</p>\n<h3 data-nodeid="642">自动化上传 dSYM 文件</h3>\n<p data-nodeid="1649">完成了上述的配置以后，一旦发生闪退，在 Firebase Crashlytics 页面就能看到相关的闪退信息，除此之外，你还可能会看到以下的警告页面：</p>\n<p data-nodeid="1650"><img src="https://s0.lgstatic.com/i/image6/M00/41/C7/CioPOWCt9oiAGLfXAASImtow89w029.png" alt="图片1.png" data-nodeid="1654"></p>\n\n\n\n\n<p data-nodeid="645">该页面告诉我们“Missing required dSYMs”，中文意思就是“缺了必需的 dSYM 文件”。那什么是 dSYM 文件呢？</p>\n<p data-nodeid="646">当 Xcode 在把源代码编译成机器码的时候，编译器会生成一堆 Symbol（符号）来存放类型的名字、全局变量和方法的名称等，这些 Symbol 会把机器码对应到各种类型所在的文件和行号。因此，我们可以利用这些 Symbol 在 Xcode 里面进行 Debug，或者在崩溃报告上定位 Bug。默认情况下，当我们生成一个 Debug 版本的 App 时，所有的 Debug Symbol 都会自动存放在 App 里面。</p>\n<p data-nodeid="647">但是 Release 版本的 App 却不一样，<strong data-nodeid="725">为了减小 App 的尺寸，编译器并不把 Debug Symbol 存放在 App 里面，而是生成一些额外的 dSYM 文件（Debug Symbol file）来存放</strong>。每个可执行文件、Framework 以及 Extension 都通过唯一的 UUID 来配对相应的 dSYM 文件。为了便于定位线上 App 的问题，我们需要保存这些 dSYM 文件，并上传到崩溃报告服务上去。</p>\n<p data-nodeid="648">幸运的是，fastlane 提供了一个<code data-backticks="1" data-nodeid="727">upload_symbols_to_crashlytics</code>Action 来帮我们简化上传 dSYM 文件的操作。上传 Internal App dSYM 文件的具体实现如下：</p>\n<pre class="lang-ruby" data-nodeid="649"><code data-language="ruby">desc <span class="hljs-string">\'Upload symbols to Crashlytics for Internal app\'</span>\nlane <span class="hljs-symbol">:upload_symbols_to_crashlytics_internal</span> <span class="hljs-keyword">do</span>\n  upload_symbols_to_crashlytics(\n    <span class="hljs-symbol">dsym_path:</span> <span class="hljs-string">"./Moments.app.dSYM.zip"</span>,\n    <span class="hljs-symbol">gsp_path:</span> <span class="hljs-string">"./Moments/Moments/Configurations/Firebase/GoogleService-Info-Internal.plist"</span>,\n    <span class="hljs-symbol">api_token:</span> ENV[<span class="hljs-string">"FIREBASE_API_TOKEN"</span>]\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="650">在调用<code data-backticks="1" data-nodeid="730">upload_symbols_to_crashlytics</code>Action 时，我们需要传递三个参数：首先把 dSYM 文件的路径传递给<code data-backticks="1" data-nodeid="732">dsym_path</code>参数，然后把 Firebase 的配置文件传递给<code data-backticks="1" data-nodeid="734">gsp_path</code>参数，最后是把 Firebase API Token 传递给<code data-backticks="1" data-nodeid="736">api_token</code>参数。在前面的<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6680&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="742">《25 | 自动化构建：解决大量重复性人力工作神器》</a>里我们已经讲述过如何获取这个 Token 了，我们是将<code data-backticks="1" data-nodeid="744">FIRBASE_API_TOKEN</code>环境变量配置在 local.keys 文件里面。</p>\n<p data-nodeid="651">接下来我们再一起看看上传 AppStore 版本 dSYM 文件的具体实现：</p>\n<pre class="lang-ruby" data-nodeid="652"><code data-language="ruby">desc <span class="hljs-string">\'Upload symbols to Crashlytics for Production app\'</span>\nlane <span class="hljs-symbol">:upload_symbols_to_crashlytics_appstore</span> <span class="hljs-keyword">do</span>\n  upload_symbols_to_crashlytics(\n    <span class="hljs-symbol">dsym_path:</span> <span class="hljs-string">"./Moments.app.dSYM.zip"</span>,\n    <span class="hljs-symbol">gsp_path:</span> <span class="hljs-string">"./Moments/Moments/Configurations/Firebase/GoogleService-Info-AppStore.plist"</span>,\n    <span class="hljs-symbol">api_token:</span> ENV[<span class="hljs-string">"FIREBASE_API_TOKEN"</span>]\n  )\n<span class="hljs-keyword">end</span>\n</code></pre>\n<p data-nodeid="653">可以看到，<code data-backticks="1" data-nodeid="748">upload_symbols_to_crashlytics_appstore</code>与<code data-backticks="1" data-nodeid="750">upload_symbols_to_crashlytics_internal</code>的实现基本一样，唯一不同的地方是<code data-backticks="1" data-nodeid="752">upload_symbols_to_crashlytics_appstore</code>把 GoogleService-Info-AppStore.plist 文件传递给了<code data-backticks="1" data-nodeid="754">gsp_path</code>参数。</p>\n<p data-nodeid="654">有了这些 Lane 以后，我们就可以修改 CI 的配置来自动完成上传 dSYM 文件的操作。下面是 .travis.yml 的配置：</p>\n<pre class="lang-yaml" data-nodeid="655"><code data-language="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">stage:</span> <span class="hljs-string">"Archive, sign and deploy internal app"</span>\n  <span class="hljs-attr">name:</span> <span class="hljs-string">"Archive Internal app"</span>\n  <span class="hljs-attr">if:</span> <span class="hljs-string">branch</span> <span class="hljs-string">=</span> <span class="hljs-string">main</span>\n  <span class="hljs-attr">script:</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">archive_internal</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">upload_symbols_to_crashlytics_internal</span> <span class="hljs-comment"># 新增的步骤</span>\n    <span class="hljs-bullet">-</span> <span class="hljs-string">bundle</span> <span class="hljs-string">exec</span> <span class="hljs-string">fastlane</span> <span class="hljs-string">deploy_internal</span>\n</code></pre>\n<p data-nodeid="656">可以看到，我们在<code data-backticks="1" data-nodeid="758">script</code>下增加了<code data-backticks="1" data-nodeid="760">upload_symbols_to_crashlytics_internal</code>步骤。</p>\n<h3 data-nodeid="657">查看崩溃报告</h3>\n<p data-nodeid="658">得到了上传的 dSYM 文件以后，Crashlytics 就能自动处理 dSYM 文件，并把崩溃信息解释成对开发者友好的报告，如下图所示：</p>\n<p data-nodeid="659"><img src="https://s0.lgstatic.com/i/image6/M01/41/51/Cgp9HWCrg_GAVqX7AAJUyq4Wg7c868.png" alt="Drawing 2.png" data-nodeid="766"></p>\n<p data-nodeid="660">报告中最关键的信息是堆栈回溯（Trace Stack），它会把 App 闪退前所调用的方法名称、代码执行的行号都按顺序依次打印出来，这样能方便我们对照着源码来定位问题。</p>\n<p data-nodeid="661">另外，Crashlytics 还能把收集到的设备信息显示出来，方便我们重现和诊断问题，这些信息如下图所示：</p>\n<p data-nodeid="662"><img src="https://s0.lgstatic.com/i/image6/M01/41/51/Cgp9HWCrg_aASscLAAB9tjkKGTA430.png" alt="Drawing 3.png" data-nodeid="771"></p>\n<p data-nodeid="663">如果我们同时使用了 Firebase 的统计分析服务，那么 Crashlytics 还会给我们提供闪退前的用户行为事件，方便我们按照这些步骤来重现问题，如下图所示：</p>\n<p data-nodeid="664"><img src="https://s0.lgstatic.com/i/image6/M01/41/5A/CioPOWCrg_uAWvqlAACNjcsm3ps311.png" alt="Drawing 4.png" data-nodeid="775"></p>\n<p data-nodeid="4115">除了提供崩溃报告以外，Crashlytics 还能提供可配置的警告信息，Crashlytics 会根据崩溃率的阈值来给我们及时发送警告通知。例如，下面的配置表示当有 0.1% 的用户在最近一小时内发生闪退时就发送警告通知。</p>\n<p data-nodeid="4116" class=""><img src="https://s0.lgstatic.com/i/image6/M01/41/C7/CioPOWCt9vKASHf_AAGEXm8i864118.png" alt="图片3.png" data-nodeid="4120"></p>\n\n\n\n\n<h3 data-nodeid="667" class="">性能报告</h3>\n<p data-nodeid="4937">因为我们安装了<code data-backticks="1" data-nodeid="4940">Firebase/Performance</code>Pod，所以 Firebase 会自动生成性能监控报告，如下图所示：</p>\n<p data-nodeid="4938" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/41/C7/CioPOWCt9xqABA89AAUscXwHDVg298.png" alt="图片4.png" data-nodeid="4944"></p>\n\n\n<p data-nodeid="670" class="">这些报告能为我们提供网络运行状态、屏幕呈现速度、App 启动速度等指标。</p>\n<p data-nodeid="3293" class="">这里我们还可以为各个指标配置不同阈值与目标值来进一步监控 App 的性能状况。比如，下图显示了 App 启动速度指标的详细信息。</p>\n<p data-nodeid="3294" class=""><img src="https://s0.lgstatic.com/i/image6/M01/41/52/Cgp9HWCrhBSAMMylAAIEEs1Bhvk758.png" alt="Drawing 7.png" data-nodeid="3298"></p>\n\n\n<p data-nodeid="673">除了启动速度以外，Crashlytics 还提供了各种脱敏信息，例如操作系统的版本、设备的类型等，这些信息能帮助我们更准确地定位性能问题的瓶颈。</p>\n<h3 data-nodeid="674">总结</h3>\n<p data-nodeid="675">在这一讲中，我们讲述了如何使用 Firebase Crashlytics 来收集崩溃报告，还讲解了如何使用 fastlane 来开发上传 dSYM 文件的操作，以及通过 CI 的配置来完成全自动化上传。通过与统计分析服务相结合，Crashlytics 能提供详细的崩溃信息，帮助我们快速地诊断和定位线上的 Bug，从而降低崩溃率，提升用户的使用体验。</p>\n<p data-nodeid="676">这里我再分享一些减少闪退的有效办法。你可以根据项目的具体情况，<strong data-nodeid="804">合理配置崩溃率的阈值</strong>，并随着 App 质量的提高而不断降低崩溃率的阈值配置。然后，在发布新版本的时候采用<strong data-nodeid="805">分阶段发布</strong>的方式，例如，通过发布 1% 的用户来观察崩溃率是否提升，一旦超过一定的阈值就马上暂停发布，修复好引起崩溃的 Bug 后再重新发布新版本。总之，结合我自己的开发经验来看，通过合理配置崩溃率阈值和分阶段发布的方式，可以在很大程度上降低闪退的概率，所以，在你的开发工作中，建议你可以考虑使用。</p>\n<p data-nodeid="677"><strong data-nodeid="809">思考题</strong></p>\n<blockquote data-nodeid="678">\n<p data-nodeid="679">请问你是通过什么办法来解决线上崩溃的问题呢？能分享一下你的经验吗？</p>\n</blockquote>\n<p data-nodeid="680">请把你的答案写到留言区哦。下一讲我将介绍“如何使用远程开关来远程遥控上线 App 的产品行为”的相关内容，记得按时来听课。</p>\n<p data-nodeid="681"><strong data-nodeid="815">源码地址</strong></p>\n<blockquote data-nodeid="682">\n<p data-nodeid="683" class="">Fastfile 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L264-L281?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="819">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/fastlane/Fastfile#L264-L281</a><br>\n.travis.yml 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.travis.yml#L35?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="824">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/.travis.yml#L35</a></p>\n</blockquote>',
          },
          {
            theme: '29 | 远程开关：如何远程遥控上线 App 的产品行为？',
            id: 45,
            content:
              '<p data-nodeid="16382">在前面<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6662&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="16386">《09 | 开关组件：如何使用功能开关，支持产品快速迭代》</a>那一讲中，我介绍过如何实现编译时开关和本地开关。有了这两种开关，我们就可以很方便地让测试人员在 App 里面手动启动或者关闭一些功能。那有没有什么好的办法可以让产品经理远程遥控功能呢？远程开关就能完成这一任务。</p>\n\n\n<p data-nodeid="17038" class=""><strong data-nodeid="17043">通过远程开关，我们就可以在无须发布新版本的情况下开关 App 的某些功能，甚至可以为不同的用户群体提供不同的功能。</strong> 远程功能开关能帮助我们快速测试新功能，从而保证产品的快速迭代。</p>\n\n<h3 data-nodeid="15404">远程功能开关模块的架构与实现</h3>\n<p data-nodeid="15405">下面我们通过 Moments App 来看看如何架构一个灵活的远程功能开关模块，并使用 Firebase 来实现一个远程功能开关。该模块主要由两部分所组成：<strong data-nodeid="15497">Remote Config 模块</strong>和<strong data-nodeid="15498">Toggle 模块</strong>。远程功能开关模块的架构图如下所示：</p>\n<p data-nodeid="17696" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwv2SADMy0AAaS5zXqWdw226.png" alt="Drawing 0.png" data-nodeid="17699"></p>\n\n<h4 data-nodeid="18356" class="">1. Remote Config 模块的架构与实现</h4>\n\n<p data-nodeid="15410">由于 Toggle 模块依赖于 Remote Config 模块，所以我们就先看一下 Remote Config 模块的架构与实现。</p>\n<p data-nodeid="19010" class=""><strong data-nodeid="19015">Remote Config 也叫作“远程配置”，它可以帮助我们把 App 所需的配置信息存储在服务端，让所有的 App 在启动的时候读取相关的配置信息，并根据这些配置信息来调整 App 的行为。</strong> Remote Config 应用广泛，可用于远程功能开关、 A/B 测试和强制更新等功能上。</p>\n\n<p data-nodeid="15412">Remote Config 的架构十分简单，由<code data-backticks="1" data-nodeid="15507">RemoteConfigKey</code>和<code data-backticks="1" data-nodeid="15509">RemoteConfigProvider</code>所组成，其中<code data-backticks="1" data-nodeid="15511">RemoteConfigKey</code>是一个空协议（Protocol），用于存放配置信息的唯一标识，其定义如下：</p>\n<pre class="lang-swift" data-nodeid="15413"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RemoteConfigKey</span> </span>{ }\n</code></pre>\n<p data-nodeid="15414">为了支持 Firebase 的 Remote Config 服务，我们定义一个遵循了<code data-backticks="1" data-nodeid="15514">RemoteConfigKey</code>协议的枚举类型（Enum）， 其具体的代码如下：</p>\n<pre class="lang-swift" data-nodeid="15415"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FirebaseRemoteConfigKey</span>: <span class="hljs-title">String</span>, <span class="hljs-title">RemoteConfigKey</span> </span>{\n    <span class="hljs-keyword">case</span> isRoundedAvatar\n}\n</code></pre>\n<p data-nodeid="15416">因为 Firebase Remote Config 的标识都是字符串类型，所以我们把<code data-backticks="1" data-nodeid="15517">FirebaseRemoteConfigKey</code>的<code data-backticks="1" data-nodeid="15519">rawValue</code>也指定为<code data-backticks="1" data-nodeid="15521">String</code>类型，这样就能很方便地取出<code data-backticks="1" data-nodeid="15523">case</code>的值，例如，通过<code data-backticks="1" data-nodeid="15525">FirebaseRemoteConfigKey.isRoundedAvatar.rawValue</code>来得到“isRoundedAvatar”字符串。</p>\n<p data-nodeid="15417">有了配置信息的标识以后，我们再来看看如何在 App 里面访问 Remote Config 服务。首先，我们定义一个名叫<code data-backticks="1" data-nodeid="15528">RemoteConfigProvider</code>的协议，其定义如下：</p>\n<pre class="lang-swift" data-nodeid="15418"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RemoteConfigProvider</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">()</span></span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getString</span><span class="hljs-params">(by key: RemoteConfigKey)</span></span> -&gt; <span class="hljs-type">String?</span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInt</span><span class="hljs-params">(by key: RemoteConfigKey)</span></span> -&gt; <span class="hljs-type">Int?</span>\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBool</span><span class="hljs-params">(by key: RemoteConfigKey)</span></span> -&gt; <span class="hljs-type">Bool</span>\n}\n</code></pre>\n<p data-nodeid="15419"><code data-backticks="1" data-nodeid="15530">RemoteConfigProvider</code>协议定义了<code data-backticks="1" data-nodeid="15532">setup()</code>、<code data-backticks="1" data-nodeid="15534">fetch()</code>等五个方法。为了使用 Firebase 的Remote Config 服务，我们定义了一个结构体<code data-backticks="1" data-nodeid="15536">FirebaseRemoteConfigProvider</code>来遵循该协议，该结构体实现了协议里的五个方法。</p>\n<p data-nodeid="15420">我们先来看一下<code data-backticks="1" data-nodeid="15539">setup()</code>和<code data-backticks="1" data-nodeid="15541">fetch()</code>方法的具体代码实现：</p>\n<pre class="lang-swift" data-nodeid="15421"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> remoteConfig = <span class="hljs-type">RemoteConfig</span>.remoteConfig()\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> {\n    remoteConfig.setDefaults(fromPlist: <span class="hljs-string">"FirebaseRemoteConfigDefaults"</span>)\n}\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">()</span></span> {\n    remoteConfig.fetchAndActivate()\n}\n</code></pre>\n<p data-nodeid="15422">在初始化的时候，我们调用 Firebase SDK 所提供的<code data-backticks="1" data-nodeid="15544">RemoteConfig.remoteConfig()</code>方法来生成一个<code data-backticks="1" data-nodeid="15546">RemoteConfig</code>的实例并赋值给<code data-backticks="1" data-nodeid="15548">remoteConfig</code>属性，然后在<code data-backticks="1" data-nodeid="15550">setup()</code>里调用<code data-backticks="1" data-nodeid="15552">remoteConfig.setDefaults(fromPlist:)</code>方法从 FirebaseRemoteConfigDefaults.plist 文件里读取配置的默认值。下图展示的就是该 plist 文件，在该文件里，我们把<code data-backticks="1" data-nodeid="15554">isRoundedAvatar</code>的默认值设置为 false，这样能保证 App 在无法联网的情况下也能正常运行。</p>\n<p data-nodeid="19670" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwv3SAVlZxAAEErVPTcjU511.png" alt="Drawing 1.png" data-nodeid="19673"></p>\n\n<p data-nodeid="15424">在<code data-backticks="1" data-nodeid="15558">fetch()</code>里，我们调用了 Firebase SDK 里的<code data-backticks="1" data-nodeid="15560">fetchAndActivate()</code>方法来获取远程配置信息。</p>\n<p data-nodeid="15425">接着我们再来看看另外三个方法的具体实现：</p>\n<pre class="lang-swift" data-nodeid="15426"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getString</span><span class="hljs-params">(by key: RemoteConfigKey)</span></span> -&gt; <span class="hljs-type">String?</span> {\n    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> key = key <span class="hljs-keyword">as</span>? <span class="hljs-type">FirebaseRemoteConfigKey</span> <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>\n    }\n    <span class="hljs-keyword">return</span> remoteConfig[key.rawValue].stringValue\n}\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInt</span><span class="hljs-params">(by key: RemoteConfigKey)</span></span> -&gt; <span class="hljs-type">Int?</span> {\n    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> key = key <span class="hljs-keyword">as</span>? <span class="hljs-type">FirebaseRemoteConfigKey</span> <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(truncating: remoteConfig[key.rawValue].numberValue)\n}\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBool</span><span class="hljs-params">(by key: RemoteConfigKey)</span></span> -&gt; <span class="hljs-type">Bool</span> {\n    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> key = key <span class="hljs-keyword">as</span>? <span class="hljs-type">FirebaseRemoteConfigKey</span> <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n    }\n    <span class="hljs-keyword">return</span> remoteConfig[key.rawValue].boolValue\n}\n</code></pre>\n<p data-nodeid="15427">这三个方法都使用了<code data-backticks="1" data-nodeid="15564">RemoteConfigKey</code>作为标识符从<code data-backticks="1" data-nodeid="15566">remoteConfig</code>对象里读取相关的配置信息，然后把获取到的信息分别转换成所需的类型，例如字符串、整型或者布尔类型。</p>\n<p data-nodeid="15428">至此，我们就实现了 Remote Config 模块，假如还需要支持其他的远程配置服务，只需为<code data-backticks="1" data-nodeid="15569">RemoteConfigProvider</code>协议实现另外一个子类型即可，例如需要支持 Optimizely 的远程配置服务时，可以实现一个名叫<code data-backticks="1" data-nodeid="15571">OptimizelyRemoteConfigProvider</code>的结构体来封装访问 Optimizely 后台服务的逻辑。</p>\n<h4 data-nodeid="20332" class="">2. Toggle 模块的架构与实现</h4>\n\n<p data-nodeid="15432">有了 Remote Config 模块，实现 Toggle 模块就变得十分简单了。在前面<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6662&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="15577">《09 | 开关组件：如何使用功能开关，支持产品快速迭代》</a>里面，我们讲过 Toggle 模块的架构与实现。要添加远程开关的支持，我们只需要增加两个实现类型：<code data-backticks="1" data-nodeid="15579">RemoteToggle</code>和<code data-backticks="1" data-nodeid="15581">FirebaseRemoteTogglesDataStore</code>结构体。我们先看一下<code data-backticks="1" data-nodeid="15583">RemoteToggle</code>的实现：</p>\n<pre class="lang-swift" data-nodeid="15433"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RemoteToggle</span>: <span class="hljs-title">String</span>, <span class="hljs-title">ToggleType</span> </span>{\n    <span class="hljs-keyword">case</span> isRoundedAvatar\n}\n</code></pre>\n<p data-nodeid="15434">和编译时开关以及本地开关一样，<code data-backticks="1" data-nodeid="15586">RemoteToggle</code>也是一个遵循了<code data-backticks="1" data-nodeid="15588">ToggleType</code>协议的枚举类型。所有的远程开关功能的名称都罗列在<code data-backticks="1" data-nodeid="15590">case</code>里面，例如，<code data-backticks="1" data-nodeid="15592">isRoundedAvatar</code>表示是否把朋友圈页面里的头像显示为圆形。</p>\n<p data-nodeid="15435">有了功能开关的名称定义以后，我们就要为<code data-backticks="1" data-nodeid="15595">TogglesDataStoreType</code>提供一个远程开关的具体实现。因为我们使用了 Firebase 服务，所以就把它命名为<code data-backticks="1" data-nodeid="15597">FirebaseRemoteTogglesDataStore</code>，其具体实现如下：</p>\n<pre class="lang-swift" data-nodeid="15436"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FirebaseRemoteTogglesDataStore</span>: <span class="hljs-title">TogglesDataStoreType</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">FirebaseRemoteTogglesDataStore</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> remoteConfigProvider: <span class="hljs-type">RemoteConfigProvider</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>(remoteConfigProvider: <span class="hljs-type">RemoteConfigProvider</span> = <span class="hljs-type">FirebaseRemoteConfigProvider</span>.shared) {\n        <span class="hljs-keyword">self</span>.remoteConfigProvider = remoteConfigProvider\n        <span class="hljs-keyword">self</span>.remoteConfigProvider.setup()\n        <span class="hljs-keyword">self</span>.remoteConfigProvider.fetch()\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isToggleOn</span><span class="hljs-params">(<span class="hljs-number">_</span> toggle: ToggleType)</span></span> -&gt; <span class="hljs-type">Bool</span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> toggle = toggle <span class="hljs-keyword">as</span>? <span class="hljs-type">RemoteToggle</span>, <span class="hljs-keyword">let</span> remoteConfiKey = <span class="hljs-type">FirebaseRemoteConfigKey</span>(rawValue: toggle.rawValue) <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n        }\n        <span class="hljs-keyword">return</span> remoteConfigProvider.getBool(by: remoteConfiKey)\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(toggle: ToggleType, value: Bool)</span></span> { }\n}\n</code></pre>\n<p data-nodeid="15437"><code data-backticks="1" data-nodeid="15599">FirebaseRemoteTogglesDataStore</code>依赖了 Remote Config 模块。在<code data-backticks="1" data-nodeid="15601">init()</code>方法里面，我们通过依赖注入的方式把<code data-backticks="1" data-nodeid="15603">FirebaseRemoteConfigProvider</code>的实例传递进来，并调用<code data-backticks="1" data-nodeid="15605">setup()</code>方法来初始化 Firebase 的 Remote Config 服务，然后调用<code data-backticks="1" data-nodeid="15607">fetch()</code>方法来读取所有的配置信息。</p>\n<p data-nodeid="15438">因为<code data-backticks="1" data-nodeid="15610">FirebaseRemoteTogglesDataStore</code>遵循了<code data-backticks="1" data-nodeid="15612">TogglesDataStoreType</code>协议，所以必须实现<code data-backticks="1" data-nodeid="15614">isToggleOn(_:)</code>和<code data-backticks="1" data-nodeid="15616">update(toggle:value:)</code>两个方法。</p>\n<p data-nodeid="15439"><code data-backticks="1" data-nodeid="15618">isToggleOn(_:)</code>方法用于判断某个开关是否打开，在方法实现里，我们先判断传递进来的<code data-backticks="1" data-nodeid="15620">toggle</code>是否为<code data-backticks="1" data-nodeid="15622">RemoteToggle</code>类型，然后再判断该 Toggle 的名称是否匹配<code data-backticks="1" data-nodeid="15624">FirebaseRemoteConfigKey</code>里的定义。如果都符合条件，那么就可以调用<code data-backticks="1" data-nodeid="15626">remoteConfigProvider</code>的<code data-backticks="1" data-nodeid="15628">getBool(by:)</code>方法来判断开关是否打开。</p>\n<p data-nodeid="15440"><code data-backticks="1" data-nodeid="15630">update(toggle: ToggleType, value: Bool)</code>方法的实现非常简单，因为 App 是无法更新远程开关信息的，所以它的实现为空。</p>\n<p data-nodeid="15441">至此，我们就为 Toggle 模块添加好了 Firebase 远程开关的支持。</p>\n<h3 data-nodeid="15442">远程开关的使用与配置</h3>\n<p data-nodeid="15443"><strong data-nodeid="15640">使用远程开关仅仅需要两步</strong>，下面我们就以<code data-backticks="1" data-nodeid="15638">MomentListItemView</code>为例子看看如何使用远程开关来控制头像的显示风格吧。</p>\n<p data-nodeid="15444">第一步是在<code data-backticks="1" data-nodeid="15642">init()</code>方法里面把<code data-backticks="1" data-nodeid="15644">TogglesDataStoreType</code>子类型的实例通过依赖注入的方式传递进去，具体代码如下：</p>\n<pre class="lang-java" data-nodeid="15445"><code data-language="java"><span class="hljs-keyword">private</span> let remoteTogglesDataStore: <span class="hljs-function">TogglesDataStoreType\n<span class="hljs-title">init</span><span class="hljs-params">(frame: CGRect = .zero, ..., remoteTogglesDataStore: TogglesDataStoreType = FirebaseRemoteTogglesDataStore.shared)</span> </span>{\n    self.remoteTogglesDataStore = remoteTogglesDataStore\n    <span class="hljs-keyword">super</span>.init(frame: frame)\n}\n</code></pre>\n<p data-nodeid="15446">因为 Moments App 使用了 Firebase 作为远程开关服务，所以我们就把<code data-backticks="1" data-nodeid="15647">FirebaseRemoteTogglesDataStore</code>的实例赋值给<code data-backticks="1" data-nodeid="15649">remoteTogglesDataStore</code>属性。</p>\n<p data-nodeid="15447">第二步是调用<code data-backticks="1" data-nodeid="15652">isToggleOn(_:)</code>方法来判断远程开关是否开启，示例代码如下：</p>\n<pre class="lang-swift" data-nodeid="15448"><code data-language="swift"><span class="hljs-keyword">if</span> remoteTogglesDataStore.isToggleOn(<span class="hljs-type">RemoteToggle</span>.isRoundedAvatar) {\n    avatarImageView.asAvatar(cornerRadius: <span class="hljs-number">10</span>)\n}\n</code></pre>\n<p data-nodeid="15449">我们把<code data-backticks="1" data-nodeid="15655">isRoundedAvatar</code>作为标识符来调用<code data-backticks="1" data-nodeid="15657">isToggleOn(_:)</code>方法，如果该方法返回<code data-backticks="1" data-nodeid="15659">true</code>，就把<code data-backticks="1" data-nodeid="15661">avatarImageView</code>的圆角设置为 10 pt。因为<code data-backticks="1" data-nodeid="15663">avatarImageView</code>的高度和宽度都为 20 pt，所以当圆角设置为 10 pt 时就会显示为圆形。</p>\n<p data-nodeid="15450">就这样，我们就能在 App 里使用名为<code data-backticks="1" data-nodeid="15666">isRoundedAvatar</code>的远程开关了。假如要使用其他的远程开关，只需要在<code data-backticks="1" data-nodeid="15668">RemoteToggle</code>和<code data-backticks="1" data-nodeid="15670">FirebaseRemoteConfigKey</code>两个枚举类型里添加新的<code data-backticks="1" data-nodeid="15672">case</code>，并在 FirebaseRemoteConfigDefaults.plist 文件设置默认值即可。</p>\n<p data-nodeid="15451">但是，产品经理怎样才能在 Firebase 服务端<strong data-nodeid="15679">配置远程开关</strong>呢？下面我们一起看一下这个配置的步骤吧。</p>\n<p data-nodeid="20988" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/40/Cgp9HWCwv4mAaXxBAAFQQUUchME827.png" alt="Drawing 2.png" data-nodeid="20991"></p>\n\n<p data-nodeid="15453">我们可以在 Firebase 网站上点击 Engage -&gt;  Remote Config 菜单来打开 Remote Config 配置页面，然后点击“Add parameter”来添加一个名叫“isRoundedAvatar”的配置，如下图所示：</p>\n<p data-nodeid="21650" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/40/Cgp9HWCwv46AJnkoAABDkckTx4Q957.png" alt="Drawing 3.png" data-nodeid="21653"></p>\n\n<p data-nodeid="15455">当添加或修改完配置后，一定要记住点击下图的“Publish changes”按钮来发布更新。</p>\n<p data-nodeid="22316" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwv5WAeslvAAA35s5FG6I535.png" alt="Drawing 4.png" data-nodeid="22319"></p>\n\n<p data-nodeid="15457">现在我们就能很方便地在 Firebase 网站上修改“isRoundedAvatar”配置的值来控制头像的显示风格了。</p>\n<p data-nodeid="15458">除了简单地启动或者关闭远程开关以外，Firebase 还可以帮我们根据用户的特征进行条件配置，例如，我们可以让所有使用中文的用户启动圆形头像风格，而让其他语言的用户保留原有风格。</p>\n<p data-nodeid="15459">下面我们就来看看如何在 Firebase 网站上<strong data-nodeid="15692">进行条件配置</strong>。</p>\n<p data-nodeid="15460">我们可以点击修改按钮的图标来打开修改弹框，然后点击“Add value for condition”按钮来添加条件。如下图所示，我们添加了一个名叫“Chinese users”的条件，该条件会判断用户是否使用中文作为他们设备的默认语言。</p>\n<p data-nodeid="22986" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwv5uAVDBQAABwa1bn3zE273.png" alt="Drawing 5.png" data-nodeid="22989"></p>\n\n<p data-nodeid="15462">然后我们就可以为符合该条件的用户配置不同的值，例如在下图中，符合“Chinese users”条件的用户在读取“isRoundedAvatar”配置时都会得到<code data-backticks="1" data-nodeid="15696">true</code>。</p>\n<p data-nodeid="23660" class=""><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwv6CAVm2nAABefStzJKo444.png" alt="Drawing 6.png" data-nodeid="23663"></p>\n\n<p data-nodeid="15464">下面是 Moments App 运行在不同语言设备上的效果图，你可以对比一下。</p>\n<p data-nodeid="25696"><img src="https://s0.lgstatic.com/i/image6/M01/42/40/Cgp9HWCwv6mALnzGAGJIzKWo3xc607.png" alt="Drawing 7.png" data-nodeid="25699"></p>\n\n\n\n<h3 data-nodeid="15467">总结</h3>\n<p data-nodeid="15468">在这一讲中，我们主要讲解了如何架构一个灵活的远程开关模块，该模块可以使用不同的后台服务来支持远程开关。接着我们以 Firebase 作为例子讲述了如何使用 Remote Config 来实现一个头像风格的远程开关，并且演示了如何根据用户的特征来为远程开关配置不同的值。</p>\n<p data-nodeid="15469">有了远程开关，产品经理就能很方便地遥控 App 的行为，并能快速地尝试新功能。但需要注意的是：<strong data-nodeid="15708">不能滥用远程开关，并且最好能经常回顾上线的远程开关，把测试完毕的开关及时删除掉</strong>，否则会导致 App 里面的开关越来越多，使得程序的逻辑变得十分复杂且难以维护，再加上每个远程开关都需要从网络读取相关的配置信息，太多的开关还会影响到用户的使用体验。</p>\n<p data-nodeid="15470"><strong data-nodeid="15712">思考题</strong></p>\n<blockquote data-nodeid="15471">\n<p data-nodeid="15472">在 FirebaseRemoteTogglesDataStore 里面，为什么没有直接使用 Firebase SDK 来读取 Remote Config 呢？另外，把读取 Remote Config 的逻辑封装在 FirebaseRemoteConfigProvider 里有什么好处呢？</p>\n</blockquote>\n<p data-nodeid="15473">可以把你的思考与答案写到留言区哦。下一讲我将介绍“如何使用 A/B 测试协助产品抉择”的相关内容，记得按时来听课哦。</p>\n<p data-nodeid="15474"><strong data-nodeid="15718">源码地址</strong></p>\n<blockquote data-nodeid="15475">\n<p data-nodeid="15476">RemoteConfig 源码地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/RemoteConfig?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="15722">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/RemoteConfig</a><br>\n远程开关源码地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/Moments/Foundations/Toggles/FirebaseRemoteTogglesDataStore.swift?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="15727">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Moments/Moments/Foundations/Toggles/FirebaseRemoteTogglesDataStore.swift</a></p>\n</blockquote>',
          },
          {
            theme: '30 | A/B 测试：如何用 A/B 测试协助产品抉择？',
            id: 46,
            content:
              '<p data-nodeid="790" class="">你有没有遇到过花了很大精力和时间开发出来的功能却得不到用户认同的尴尬情况？其实，这往往是产品决策方向错误导致的。目前流行的产品抉择方法有以下几种。</p>\n<p data-nodeid="791"><strong data-nodeid="861">第一种是由产品经理根据经验和个人喜好来决定</strong>，据说乔布斯就是这种类型的产品决策者。他认为无论做出怎样的产品，用户都会买账，所以他可以根据自己的喜好来决定产品的方向。市场上有不少这一类型的产品经理，可是乔布斯只有一个，由于个人认知的局限性，这些产品经理没有办法保证每个决定都是正确的。</p>\n<p data-nodeid="792">那怎样才能避开因个人喜好而导致决策错误的“坑”呢？这就引出了<strong data-nodeid="867">第二种产品抉择的办法——用户调研</strong>。用户调研是通过问卷或者面谈的方式来挖掘用户的需求，这种方法对于面向特定群体的 App 会比较有效，例如面向 HR 流程的企业 App，我们可以根据多个 HR 的回答或反馈来筛选出产品需求。</p>\n<p data-nodeid="793">可是对于面向大众的 App，用户调研往往就很难保证其有效性了，因为会面临诸多问题，比如，调研的问题设计是否合理？所调研的用户是否具有代表性？用户在回答问题时是否如实所想？等等。</p>\n<p data-nodeid="794">那怎样才能进一步提高产品抉择的有效性呢？这就是今天我们要讲的<strong data-nodeid="874">第三种办法——A/B 测试</strong>。</p>\n<p data-nodeid="795"><strong data-nodeid="879">A/B 测试是把用户随机地分成两个或以上的组别，并为各组分发同一功能的不同版本，然后根据留存率、点击率等指标来选择最佳版本。</strong> A/B 测试的概念来源于生物医学的双盲测试。在双盲测试中，我们把病人在不知情的情况随机分成两组，一组使用需要测试的药物，另一组是不使用任何药物的控制组，然后对比两组病人的表现是否具有显著的差异，从而决定测试药物是否有效。</p>\n<p data-nodeid="796">因此，App 的 A/B 测试有以下三个特征。</p>\n<ol data-nodeid="797">\n<li data-nodeid="798">\n<p data-nodeid="799">A/B 测试需要大量的样本。由于 A/B 测试成本相对比较低，所以我们可以很方便地把测试推送给大量的用户，从而排除结果的偶然性。</p>\n</li>\n<li data-nodeid="800">\n<p data-nodeid="801">A/B 测试分组的用户特征需要保持一致。例如，不能把 A 版本只分发给女性用户，B 版本只分发给男性用户，而是要把不同版本无差异地分发给同类用户群，这样才能保证测试的公正性。</p>\n</li>\n<li data-nodeid="802">\n<p data-nodeid="803">A/B 测试用户需要在不知情的情况下执行测试。因为一些“额外”的信息可能会影响到用户的思考和习惯，而用户在不知情的情况下，他们就可以很“自然”地按照自身的行为习惯与 App 进行交互，这样就能保证我们收集到用户的真实想法了。</p>\n</li>\n</ol>\n<p data-nodeid="804">A/B 测试是一种提升用户体验的有效方法。通过 A/B 测试，我们可以把用户交互非常频繁的版本保留下来，并在该版本的基础上不断迭代。同时，A/B 测试也能协助产品经理做出抉择，保证产品方向的正确性。</p>\n<p data-nodeid="805">下面我们就以 Moments App 作为例子来看看如何架构和实现 A/B 测试模块吧。</p>\n<h3 data-nodeid="806">A/B 测试模块的架构与实现</h3>\n<p data-nodeid="3671">首先我们来看一下 A/B 测试模块的架构图，如下所示：</p>\n<p data-nodeid="3672" class=""><img src="https://s0.lgstatic.com/i/image6/M00/43/13/CioPOWC3MDiAAbTIAAKMI8cISRI143.png" alt="图片1.png" data-nodeid="3676"></p>\n\n\n\n\n\n\n<p data-nodeid="809" class=""><strong data-nodeid="897">A/B 测试模块依赖于 Remote Config 模块</strong>，而 Remote Config 模块在上一讲中我们已经介绍过了，如有记不清的地方你可以再复习一下。为了支持新的 A/B 测试案例，我们在<code data-backticks="1" data-nodeid="895">FirebaseRemoteConfigKey</code>里面增加了一个新的 case，如下代码所示：</p>\n<pre class="lang-swift" data-nodeid="810"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FirebaseRemoteConfigKey</span>: <span class="hljs-title">String</span>, <span class="hljs-title">RemoteConfigKey</span> </span>{\n    <span class="hljs-keyword">case</span> isRoundedAvatar\n    <span class="hljs-keyword">case</span> likeButtonStyle <span class="hljs-comment">// 新增用于 A/B 测试的 case</span>\n}\n</code></pre>\n<p data-nodeid="811">在 Moments App 里面，我们想通过 A/B 测试来找出哪种点赞按钮的风格更受欢迎。因此，在 A/B 测试模块里面，我们定义了一个枚举类型来表示不同的按钮风格，如下代码所示：</p>\n<pre class="lang-swift" data-nodeid="812"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LikeButtonStyle</span>: <span class="hljs-title">String</span> </span>{\n    <span class="hljs-keyword">case</span> heart, star\n}\n</code></pre>\n<p data-nodeid="813"><code data-backticks="1" data-nodeid="899">LikeButtonStyle</code>的<code data-backticks="1" data-nodeid="901">rawValue</code>是字符串类型。因为我们希望测试的按钮风格为心形和星形，所以分别定义了<code data-backticks="1" data-nodeid="903">heart</code>和<code data-backticks="1" data-nodeid="905">star</code>两个 case。</p>\n<p data-nodeid="814">有了测试案例以后，我们就可以定义如下的协议：</p>\n<pre class="lang-swift" data-nodeid="815"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ABTestProvider</span> </span>{\n    <span class="hljs-keyword">var</span> likeButtonStyle: <span class="hljs-type">LikeButtonStyle?</span> { <span class="hljs-keyword">get</span> }\n}\n</code></pre>\n<p data-nodeid="816"><code data-backticks="1" data-nodeid="908">ABTestProvider</code>协议包含了所有需要测试的案例，例如，当前需要测试点赞按钮的风格，我们就定义了<code data-backticks="1" data-nodeid="910">likeButtonStyle</code>属性。</p>\n<p data-nodeid="817">接着看一下<code data-backticks="1" data-nodeid="913">FirebaseABTestProvider</code>的具体实现：</p>\n<pre class="lang-swift" data-nodeid="818"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FirebaseABTestProvider</span>: <span class="hljs-title">ABTestProvider</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">FirebaseABTestProvider</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> remoteConfigProvider: <span class="hljs-type">RemoteConfigProvider</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>(remoteConfigProvider: <span class="hljs-type">RemoteConfigProvider</span> = <span class="hljs-type">FirebaseRemoteConfigProvider</span>.shared) {\n        <span class="hljs-keyword">self</span>.remoteConfigProvider = remoteConfigProvider\n    }\n    <span class="hljs-keyword">var</span> likeButtonStyle: <span class="hljs-type">LikeButtonStyle?</span> {\n        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> likeButtonStyleString = remoteConfigProvider.getString(by: <span class="hljs-type">FirebaseRemoteConfigKey</span>.likeButtonStyle) <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-type">LikeButtonStyle</span>(rawValue: likeButtonStyleString)\n    }\n}\n</code></pre>\n<p data-nodeid="819"><code data-backticks="1" data-nodeid="915">FirebaseABTestProvider</code>依赖了<code data-backticks="1" data-nodeid="917">RemoteConfigProvider</code>来读取 Firebase 的 A/B 测试配置，因此我们在<code data-backticks="1" data-nodeid="919">init()</code>方法中通过依赖注入的方式传进了<code data-backticks="1" data-nodeid="921">FirebaseRemoteConfigProvider</code>的实例，并赋值给<code data-backticks="1" data-nodeid="923">remoteConfigProvider</code>属性。同时，由于<code data-backticks="1" data-nodeid="925">FirebaseABTestProvider</code>遵循了<code data-backticks="1" data-nodeid="927">ABTestProvider</code>协议，所以必须实现<code data-backticks="1" data-nodeid="929">likeButtonStyle</code>属性。在<code data-backticks="1" data-nodeid="931">likeButtonStyle</code>属性的代码实现里，我们通过调用<code data-backticks="1" data-nodeid="933">remoteConfigProvider.getString(by:)</code>方法取出来自 Firebase 后台配置的点赞按钮风格字符串，然后把该字符串传递给<code data-backticks="1" data-nodeid="935">LikeButtonStyle</code>的<code data-backticks="1" data-nodeid="937">init(rawValue:)</code>方法进行初始化。假如按钮风格的字符串为空，那<code data-backticks="1" data-nodeid="939">likeButtonStyle</code>就会返回<code data-backticks="1" data-nodeid="941">nil</code>。</p>\n<p data-nodeid="820">就这样，我们就完成了 A/B 测试模块的开发，如果我们需要添加其他的测试案例，只需要在<code data-backticks="1" data-nodeid="944">ABTestProvider</code>添加一个新的属性，并在<code data-backticks="1" data-nodeid="946">FirebaseABTestProvider</code>里实现该新属性即可。</p>\n<h3 data-nodeid="821">A/B 测试的使用与配置</h3>\n<p data-nodeid="822">下面我们继续以<code data-backticks="1" data-nodeid="950">likeButtonStyle</code>为例子看看<strong data-nodeid="956">如何使用 A/B 测试模块</strong>。</p>\n<p data-nodeid="823">在 App 里面使用 A/B 测试非常简单，仅仅需要两步。例如，在<code data-backticks="1" data-nodeid="958">MomentListItemView</code>里测试点赞按钮的风格，第一步是在<code data-backticks="1" data-nodeid="960">init()</code>方法，通过依赖注入的方式把<code data-backticks="1" data-nodeid="962">ABTestProvider</code>子类型的实例传递进去，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="824"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> abTestProvider: <span class="hljs-type">ABTestProvider</span>\n<span class="hljs-keyword">init</span>(frame: <span class="hljs-type">CGRect</span> = .zero, ..., abTestProvider: <span class="hljs-type">ABTestProvider</span> = <span class="hljs-type">FirebaseABTestProvider</span>.shared) {\n    <span class="hljs-keyword">self</span>.abTestProvider = abTestProvider\n    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)\n}\n</code></pre>\n<p data-nodeid="825">因为 Moments App 使用了 Firebase 作为 A/B 测试服务，所以我们就把<code data-backticks="1" data-nodeid="965">FirebaseABTestProvider</code>的实例赋值给<code data-backticks="1" data-nodeid="967">abTestProvider</code>属性。</p>\n<p data-nodeid="826">第二步是通过检查<code data-backticks="1" data-nodeid="970">abTestProvider</code>的<code data-backticks="1" data-nodeid="972">likeButtonStyle</code>属性来控制 UI 的显示，其代码如下：</p>\n<pre class="lang-swift" data-nodeid="827"><code data-language="swift"><span class="hljs-keyword">switch</span> abTestProvider.likeButtonStyle {\n<span class="hljs-keyword">case</span> .heart:\n    favoriteButton.asHeartFavoriteButton()\n<span class="hljs-keyword">case</span> .star:\n    favoriteButton.asStarFavoriteButton()\n<span class="hljs-keyword">case</span> .<span class="hljs-keyword">none</span>:\n    <span class="hljs-comment">// 如果 Firebase 后台没有配置该属性</span>\n    favoriteButton.asHeartFavoriteButton()\n}\n</code></pre>\n<p data-nodeid="828">当<code data-backticks="1" data-nodeid="975">likeButtonStyle</code>属性返回<code data-backticks="1" data-nodeid="977">heart</code>时，我们调用 DesignKit 里面的<code data-backticks="1" data-nodeid="979">asHeartFavoriteButton()</code>方法来把按钮变成心形。当<code data-backticks="1" data-nodeid="981">likeButtonStyle</code>属性返回<code data-backticks="1" data-nodeid="983">star</code>时，我们就调用<code data-backticks="1" data-nodeid="985">asStarFavoriteButton()</code>方法来把按钮变成星形。</p>\n<p data-nodeid="829">看完如何使用 A/B 测试模块以后，接下来我们再来看看<strong data-nodeid="992">如何在 Firebase 后台配置 A/B 测试</strong>。</p>\n<p data-nodeid="4721">首先，我们要打开 Remote Config 页面，并为点赞按钮风格的测试案例里添加一个新配置，如下图里名为 “likeButtonStyle”的配置。</p>\n<p data-nodeid="4722" class=""><img src="https://s0.lgstatic.com/i/image6/M00/43/13/CioPOWC3MGOABhAsAARfo6cAlsk706.png" alt="图片2.png" data-nodeid="4726"></p>\n\n\n<p data-nodeid="832" class="">然后在 A/B Testing 页面里点击“Create experiment”按钮，并选择“Remote Config”选项，接下来就可以按照下面罗列的四个步骤来配置一个新 A/B 测试案例了。</p>\n<p data-nodeid="833">第一步是填写测试案例的名称，如下图所示，我们添加了一个名叫“点赞按钮风格”的案例。</p>\n<p data-nodeid="834"><img src="https://s0.lgstatic.com/i/image6/M01/42/40/Cgp9HWCwwE2AYZreAAA0zcXKvOg846.png" alt="Drawing 2.png" data-nodeid="1001"></p>\n<p data-nodeid="835">第二步是配置需要测试的 App ID，以及测试的覆盖率。基于 App 的用户基数，我们一般选择 1% 到 10% 的用户进行测试。</p>\n<p data-nodeid="836"><img src="https://s0.lgstatic.com/i/image6/M01/42/40/Cgp9HWCwwFGAdXP-AABOtCCCSmk794.png" alt="Drawing 3.png" data-nodeid="1005"></p>\n<p data-nodeid="837">第三步是配置测试的指标，例如点击率、留存率等。</p>\n<p data-nodeid="838"><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwwFaAccGlAAA8G0M_s84999.png" alt="Drawing 4.png" data-nodeid="1009"></p>\n<p data-nodeid="839">第四步是配置测试版本（Variant），例如把基础版本配置为心形，而 A 版本设置为星形。</p>\n<p data-nodeid="840"><img src="https://s0.lgstatic.com/i/image6/M00/42/48/CioPOWCwwFyASKgzAABW05OPFww377.png" alt="Drawing 5.png" data-nodeid="1013"></p>\n<p data-nodeid="841">操作完这四个步骤以后，就可以点击“Start experiment”按钮来启动测试案例了。</p>\n<p data-nodeid="5771">我们还可以配置测试运行时长，例如一到三个月，当测试运行完毕以后，就能看到测试报告，如下图所示：</p>\n<p data-nodeid="5772" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/43/0B/Cgp9HWC3MJeAV6xEAALCXmpwiMM187.png" alt="图片3.png" data-nodeid="5776"></p>\n\n\n<p data-nodeid="844">根据报告的结果，我们就能发现哪种按钮风格更受欢迎，然后就可以保留胜出的版本，并移除其他版本。</p>\n<h3 data-nodeid="845">总结</h3>\n<p data-nodeid="846">在这一讲中，我们讲述了如何架构和实现 A/B 测试模块，并且我们还以 Firebase 为例子演示了如何测试不同风格版本的点赞按钮。总之，A/B 测试能很好地协助我们进行产品决策。</p>\n<p data-nodeid="847">下面我再分享下我使用 A/B 测试过程中的一些经验。进行 A/B 测试的<strong data-nodeid="1035">用户样本必须足够大</strong>，否则很容易出现误差。同时，测试过程中<strong data-nodeid="1036">一般只分发给 1% 到 10% 的用户</strong>，在得到结论后才推广到所有的用户。另外，当你得到测试结果时，最好<strong data-nodeid="1037">及时删除</strong>整个测试案例，在 App 里面只保留胜出的版本。</p>\n<p data-nodeid="848">至此，课程模块四的内容我们就全部讲完了。这个模块由两部分组成：前半部分主要讲述如何使用 fastlane 和 CI 来自动化证书管理、打包和签名，以及上传 App Store 等重复性操作；而后半部分则讲述了如何架构灵活的统计分析、崩溃报告、远程开关以及 A/B 测试模块，并且还为这些模块提供了 Firebase 的实现。如果你的 App 是面向海外市场的，Firebase 是一个不错的选择，它不但可以免费使用，而且简单易用、功能丰富。</p>\n<p data-nodeid="849"><strong data-nodeid="1042">思考题</strong></p>\n<blockquote data-nodeid="850">\n<p data-nodeid="851" class="">我们讲了三种产品抉择的方法，请问你一般是使用哪种办法来进行产品抉择的？能分享一下你的经验吗？</p>\n</blockquote>\n<p data-nodeid="852">请把你的思考与答案写到留言区哦。从下一讲开始就进入加餐部分了，我会先介绍“如何使用 Figma 快速制作 App Icon”的相关内容，记得按时来听课哦。</p>\n<p data-nodeid="853"><strong data-nodeid="1048">源码地址</strong></p>\n<blockquote data-nodeid="854">\n<p data-nodeid="855" class="">A/B&nbsp; 测试源码地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/ABTest?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1052">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/ABTest</a></p>\n</blockquote>',
          },
        ],
      },
      {
        sectionName: '模块五：加餐',
        sectionId: 5,
        courseList: [
          {
            theme: '31 | App Icon 制作：如何使用 Figma 快速制作 App Icon？',
            id: 50,
            content:
              '<p data-nodeid="11145">与后台开发者的要求不一样，iOS 开发者不仅要保证程序逻辑的正确性，而且要注重用户的使用体验。为了给用户带来良好的使用体验，我们需要提升自身的设计能力。那该怎么来提高呢？阅读优秀的开源代码是提升编码能力的有效办法。相应地，学习和模仿优秀设计也是提高设计能力的重要途径。在这一讲中，我会以制作 Moments App 图标（Icon）为例子，讲解如何使用 Figma 进行设计。</p>\n<p data-nodeid="11146">目前流行的设计工具主要有 PhotoShop、Adobe XD、Sketch 和 Figma 等，这些工具各有优缺点。而我选择最近一两年特别流行的 Figma，其主要原因有如下。</p>\n<ol data-nodeid="11147">\n<li data-nodeid="11148">\n<p data-nodeid="11149">Figma 能运行在主流的浏览器上，可以在 Mac、Windows、Linux 甚至 Chromebook 下使用，而 Sketch 等一些工具只能在 Mac 上运行。</p>\n</li>\n<li data-nodeid="11150">\n<p data-nodeid="11151">Figma 把所有的设计稿都自动保存在云端，我们可以在任何能连接网络的机器上访问设计稿，无须任何额外的工具和平台来管理设计文件。</p>\n</li>\n<li data-nodeid="11152">\n<p data-nodeid="11153">Figma 提供给个人免费使用，而且不限制文件的数量、云存储的空间，以及预览者和评论者人数等。而其他工具一般都需要收取一定费用，比如，PhotoShop 就收费不菲。</p>\n</li>\n<li data-nodeid="11154">\n<p data-nodeid="11155">Figma 支持多人同时预览、修改和评论同一份设计稿，方便大家在线实时协作，我们可以在设计稿上通过人像实时看到其他同事的操作和留言。</p>\n</li>\n<li data-nodeid="11156">\n<p data-nodeid="11157">Figma 自带版本管理功能，方便我们查看所有人的历史修改记录。</p>\n</li>\n<li data-nodeid="11158">\n<p data-nodeid="11159">Figma 支持按权限级别的方式进行分享，例如设计师可以有修改权限，而产品经理和开发者只具有评论权限。</p>\n</li>\n<li data-nodeid="11160">\n<p data-nodeid="11161">Figma 能生成 Web、iOS 和 Android 的 UI 代码，方便我们把设计稿转换为代码。</p>\n</li>\n<li data-nodeid="11162">\n<p data-nodeid="11163">Figma 支持以 Components（组件）的方式来封装常用的 UI 组件，方便我们把常用组件共享到多个设计稿里面。</p>\n</li>\n<li data-nodeid="11164">\n<p data-nodeid="11165">Figma 为第三方开发者提供了丰富的 API，方便社区开发插件，因此 Figma 具有很多实用的第三方插件来简化我们的设计工作。</p>\n</li>\n<li data-nodeid="11166">\n<p data-nodeid="11167">Figma 支持原型设计功能（Prototyping），这样能帮助我们设计页面之间的交互、换场和导航。</p>\n</li>\n<li data-nodeid="11168">\n<p data-nodeid="11169">Figma 还提供在线预览和演示功能，方便设计师与产品经理、开发者进行实时沟通。</p>\n</li>\n</ol>\n<p data-nodeid="11170">总之，Figma 的功能齐全而且丰富，只需要一个工具就能完成几乎所有的设计工作，不像以前那样，我们需要使用 Sketch 来编辑设计稿，还需要使用 InVision 来共享设计稿，并使用 Marvel 来预览原型等。因此，我非常推荐你使用 Figma，对于个人开发者而言，免费版的功能已经足够满足各个需求了。</p>\n<h3 data-nodeid="11171">Figma 工具概括</h3>\n<p data-nodeid="11172">那下面我们就一起看看如何使用 Figma 来设计 Moments App 的图标吧。</p>\n<p data-nodeid="11173">首先，我们需要在浏览器上登录到 figma.com 网站并免费注册一个账号，然后就会看到 Figma 的主界面，如下图所示：</p>\n<p data-nodeid="11982" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/22/CioPOWC9z3OAIUMEAAFI4jh8tqo125.png" alt="Drawing 0.png" data-nodeid="11985"></p>\n\n<p data-nodeid="11175" class="">左边区域是功能菜单，而右边区域是当前选中菜单的详情页面。当我们要开发一个设计稿的时候，第一件事往往是寻找有没有类似模板可以参考。Figma Community 为我们提供了大量的设计模板，可以点击左边的 Community 菜单来打开以下的 Figma 社区页面。</p>\n<p data-nodeid="12548" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z3qATuvCAAI4o7lalO8847.png" alt="Drawing 1.png" data-nodeid="12551"></p>\n\n<p data-nodeid="11177">由于我们要做 App 的图标，因此，可以在搜索框输入“App Icon Template”关键字来搜索 App 图标的模板，结果如下：</p>\n<p data-nodeid="13118" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z4CAEvF4AAOPQ548-S4649.png" alt="Drawing 2.png" data-nodeid="13121"></p>\n\n<p data-nodeid="11179">在实际工作中，我们可以打开多个文件模块进行尝试与比较，并选择自己喜欢的模板。在今天这个例子中，我们选择了图上的“iOS App Icon Template”模板。只需要点击“向下箭头”按钮就能把该模板复制到我们的初稿文件夹里面，复制完毕后会显示下面的提示，翻译成中文就是“文件已经复制到你的初稿里面了”。</p>\n<p data-nodeid="14272"><img src="https://s0.lgstatic.com/i/image6/M01/44/23/CioPOWC9z4aAGon8AAAntk0s0Fs586.png" alt="Drawing 3.png" data-nodeid="14276"></p>\n<p data-nodeid="14273">点击提示框的“View”按钮就能打开复制的设计稿，如下图所示：</p>\n\n\n\n<p data-nodeid="14852" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z4yADsi1AAFmnSWqxTg642.png" alt="Drawing 4.png" data-nodeid="14855"></p>\n\n<p data-nodeid="11183">这就是我们的工具页面，最上面的黑色部分是菜单栏，我们可以点击左上角的 Figma 图标来打开 Figma 程序的菜单，而 Figma 图标右边就是我们常用的操作，例如添加形状、文本和绘画工具等。</p>\n<p data-nodeid="11184">左边区域是设计稿的图层关系组织图，它把当前的页面、图层分组和图层通过树状的方式呈现出来，方便我们快速地定位所需要浏览和编辑的设计元素。</p>\n<p data-nodeid="11185">中间区域是主编辑区域，我们的设计工作就在里面完成，例如添加和修改形状、文本等设计元素，改变图层的顺序，移动元素的位置，等等。</p>\n<p data-nodeid="11186">右边区域可称为属性配置页，它会根据我们当前选中的设计元素而动态改变，方便我们编辑选中元素的属性。例如，在下图中，当我们选中一个圆形的时候，属性配置页会显示该圆形的位置、约束和填充色等信息，我们可以通过修改这些属性来改变该圆形的设计。</p>\n<p data-nodeid="15434" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z5SAKyW8AAD7-e3IPeo710.png" alt="Drawing 5.png" data-nodeid="15437"></p>\n\n<p data-nodeid="11188">对 Figma 工具有一个概括性的了解以后，下一步我们再来看看如何使用“iOS App Icon Template”模板。</p>\n<p data-nodeid="11189">我们需要先详细阅读模板的描述信息，这个模板的描述信息非常简单，如下图所示：</p>\n<p data-nodeid="16020" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/23/CioPOWC9z5qAeC_TAAFcNS9pBoQ237.png" alt="Drawing 6.png" data-nodeid="16023"></p>\n\n<p data-nodeid="11191">简单来说，我们需要在名为“icon-ios”的图层里面根据自己的需要设计和编辑 App 的图标，然后把图标的约束（Constraints）设置为“Scale”，最后再把设计好的图标按照图上的各种尺寸进行导出。</p>\n<h3 data-nodeid="11192">图标设计</h3>\n<p data-nodeid="11193">现在我们就可以开始设计和编辑图标了。为了加快设计的速度，我们可以参考微信朋友圈的图标，该图标可以到微信开放平台的官方文档里找到，如下图所示：</p>\n<p data-nodeid="16610" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z6KAWYC0AACPDYAinvE306.png" alt="Drawing 7.png" data-nodeid="16613"></p>\n\n<p data-nodeid="11195">接着我们就可以下载微信朋友圈图标，并把它放到设计稿里面，如下图所示：</p>\n<p data-nodeid="17792" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/23/CioPOWC9z62Abi2xAACcE_JkT6c247.png" alt="Drawing 8.png" data-nodeid="17795"></p>\n\n<h4 data-nodeid="17204" class="">1. 绘制图标</h4>\n\n<p data-nodeid="11200">要学习如何绘制一个图标，第一步可以把该图标里面的元素进行拆分。我们可以看到，该图标的外层是一个圆形，中心部分是一个八边形，中间是八块形状一样但颜色不同的圆边三角形。</p>\n<p data-nodeid="11201">拆分完毕以后，我们就可以<strong data-nodeid="11330">从外部的圆形和中心的八边形开始进行编辑</strong>。在“icon-ios”图层里面，我们先把不需要的内圆删除掉，然后点击下图的“Polygon”菜单来添加一个多边形，为了生成等边的多边形，我们需要在拖放该多边形的时候按着 Shift 键。</p>\n<p data-nodeid="18386" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z7WAV0ekAABdx1yh4yU812.png" alt="Drawing 9.png" data-nodeid="18389"></p>\n\n<p data-nodeid="11203">然后在右边的属性配置页中选择长和高都为 20，角度为 22.5 度，边数为 8，这样就能生成一个如下图所示的八边形来。不过需要注意，我们要把这个八边形布局到圆形的中心上，操作也十分简单，只需要点击和拖动即可。</p>\n<p data-nodeid="18984" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC9z72AGsF8AACkcS2zrlU932.png" alt="Drawing 10.png" data-nodeid="18987"></p>\n\n<p data-nodeid="11205">接着就可以画一个长方形了，我们可以在菜单里面点击 Rectangle，或者使用快捷键 R 来画，如下图所示：</p>\n<p data-nodeid="19586" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1A/Cgp9HWC9z8SAT31gAADs0RpjNUw198.png" alt="Drawing 11.png" data-nodeid="19589"></p>\n\n<p data-nodeid="11207"><strong data-nodeid="11340">下一步是复制八条形状一样的长方形，并旋转它们的布局角度</strong>。由于 Figma 没有自带的 Sketch 里面的 Rotate Copies（旋转复制）功能，所以我们需要下载一个插件。那怎么寻找和下载第三方插件呢？我们可以点击 Figma -&gt; Plugins -&gt; Browse plugins in Community 菜单来打开社区插件库网页。</p>\n<p data-nodeid="20192" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC9z8qAT8pwAADUpZB5nPE746.png" alt="Drawing 12.png" data-nodeid="20195"></p>\n\n<p data-nodeid="11209">然后输入“Rotate Copies”关键字进行搜索，并点击“Install”按钮进行安装，如下图所示：</p>\n<p data-nodeid="20802" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC9z9GAd084AAA5E-FP-6A356.png" alt="Drawing 13.png" data-nodeid="20805"></p>\n\n<p data-nodeid="11211">插件安装完毕以后，我们右键图层就能看到如下图所示的插件菜单了。</p>\n<p data-nodeid="21416" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC9z9eAdGxnAAEdJTkJemM215.png" alt="Drawing 14.png" data-nodeid="21419"></p>\n\n<p data-nodeid="11213">当我们选择“Rotate Copies”菜单时，Figma 就会弹出下图的弹出框。</p>\n<p data-nodeid="22034" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/1A/Cgp9HWC9z-OAfzSJAAD4UbJC3xY413.png" alt="Drawing 15.png" data-nodeid="22037"></p>\n\n<p data-nodeid="11215">该弹出框显示了该插件所需的配置信息，我们可以修改这些配置信息来生成不同的效果。在我们的例子中，我们在“Number of copies”输入框里填入 4，然后点击“Rotate”按钮，这样就能复制 4 条不同角度的长条。由于我们需要 8 条长条，所以还需要再点击一次“Rotate”按钮。</p>\n<p data-nodeid="11216">然后把这 8 条长条分别移动到中心八边形的边上，如下图所示：</p>\n<p data-nodeid="22656" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/1A/Cgp9HWC9z-qAMWVHAAE8_JE6A9g840.png" alt="Drawing 16.png" data-nodeid="22659"></p>\n\n<p data-nodeid="11218">现在可以删掉中心八边形以及用于辅助布局的十字形状，生成的效果如下图所示：</p>\n<p data-nodeid="23282" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC9z_KAHWU9AADkbhxdR0E065.png" alt="Drawing 17.png" data-nodeid="23285"></p>\n\n<p data-nodeid="11220">再下一步就是<strong data-nodeid="11358">把这 8 条长条合并到同一个图层里面</strong>，我们可以在左边区域的图层树上同时选中这 8 条长条，然后右键打开菜单，如下图所示：</p>\n<p data-nodeid="23912" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/1A/Cgp9HWC9z_yAGke2AACm8mNcRnw803.png" alt="Drawing 18.png" data-nodeid="23915"></p>\n\n<p data-nodeid="11222">选中 Flatten 菜单项就能合成一个名叫“Vector”的图层了。假如你能熟练使用 Figma，也可以直接通过“Command + E 键”来完成这个合并操作。</p>\n<h4 data-nodeid="24546" class="">2. 布尔操作</h4>\n\n<p data-nodeid="26442" class="">有了圆形和 8 条长条以后，怎样才能生成八个圆边三角形呢？这里需要使用到 Boolean Operations（布尔操作）。那什么是布尔操作呢？<strong data-nodeid="26448">布尔操作是把任意数量的形状图层通过 Union（并集）、Subtract（减集）、Intersect（交集）或者 Exclude（差集）方式进行合并。</strong> 为了方便你理解，我就通过下面的图来演示它们的效果：</p>\n\n<p data-nodeid="25808" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/23/CioPOWC90A-AXHTRAAE4RzcdE3Y486.png" alt="Drawing 19.png" data-nodeid="25811"></p>\n\n\n<p data-nodeid="11228">图最上面展示的是操作前 A 和 B 图层，下面是分别使用四种不同的方式进行布尔操作合并的结果。</p>\n<ul data-nodeid="11229">\n<li data-nodeid="11230">\n<p data-nodeid="11231">Union 会把两个图层合并在同一个图层，重复部分的轮廓线会被抹掉，只保留外部的轮廓线。</p>\n</li>\n<li data-nodeid="11232">\n<p data-nodeid="11233">Subtract 和 Union 相反，该操作需要制定基础图层。由于 A 是基础图层，Subtract 操作会从 A 图层去掉 B 图层部分，并只保留基础图层中没有被覆盖的部分。</p>\n</li>\n<li data-nodeid="11234">\n<p data-nodeid="11235">Intersect 只保留两个图层的重复部分。</p>\n</li>\n<li data-nodeid="11236">\n<p data-nodeid="11237">Exclude 和 Intersect 相反，会把重复部分去掉，只保留不重复的部分。</p>\n</li>\n</ul>\n<p data-nodeid="11238">合理使用这四个布尔操作能帮助我们绘制各种效果的图标，比如，现如今流行的 App 图标，其中绝大部分图标都可以通过图层间的布尔操作来制作。</p>\n<p data-nodeid="11239">下面我们就一起看看如何使用布尔操作来制作八个圆边三角形。首先需要同时选中“Vector”（八条边的合并图）和“Ellipse”（圆形）两个图层，然后点击下图的“Subtract Selection”菜单。</p>\n<p data-nodeid="27081" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90IyAKRPHAAG0Y4_bhXU110.png" alt="Drawing 20.png" data-nodeid="27084"></p>\n\n<p data-nodeid="11241">这样就能生成如下图所示的八个圆边三角形了。</p>\n<p data-nodeid="27721" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/1B/Cgp9HWC90JWAVyhIAAFzRizSj7U520.png" alt="Drawing 21.png" data-nodeid="27724"></p>\n\n<h4 data-nodeid="28365" class="">3. 分离图层</h4>\n\n<p data-nodeid="11246">因为布尔操作会把多个图层合并成单独一个图层，所以我们没有办法为各个圆边三角形分别添加不同的颜色。那怎么办呢？我告诉你一个小技巧：首先把图层先通过 Flatten 进行合并，然后导出成 SVG 文件，再把 SVG 文件拖进设计稿进行编辑。</p>\n<p data-nodeid="11247">前面已经讲过，我们可以通过“Command + E 键”来合并成如下图的“Subtract”的图层。导出 SVG 的操作也非常简单，先选择需要导出的图层，再打开右边的 Export 配置，最后把导出的文件格式修改为 SVG，并点击“Export Subtract”按钮即可。</p>\n<p data-nodeid="29003" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/1B/Cgp9HWC90KGAUsZbAAEudY4FVjo855.png" alt="Drawing 22.png" data-nodeid="29006"></p>\n\n<p data-nodeid="11249">现在就可以在“icon-ios”里把原有的“Subtract”图层删除掉，并把导出的 SVG 文件拖进里面。如下图所示，你看到一个名叫“Exported Subtract”的新图层。</p>\n<p data-nodeid="29647" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90KiAKgZiAADstdxYsYc335.png" alt="Drawing 23.png" data-nodeid="29650"></p>\n\n<p data-nodeid="11251">当我们设计完一个图标以后，通常会使用到 Home Screen、App Store 和 Push Notification 等不同的地方，各个地方图标的尺寸各不相同，为了能正确地导出各种尺寸的图标，我们必须在属性配置页上把 Constraints 设置为 Scale。这一步非常重要，初次使用 Figma 常常容易忽略这一细节。</p>\n<p data-nodeid="11252">接着可以删掉不需要的图层，如下图所示，我们可以展开“Exported Subtract”图层并选中第一、第二个图层。</p>\n<p data-nodeid="31603" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90OaAbSeFAABQV0Sa8cU177.png" alt="Drawing 24.png" data-nodeid="31606"></p>\n\n\n<p data-nodeid="11254">把它们删掉后，就只保留了八个圆边三角形，如下图所示：</p>\n<p data-nodeid="30947" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90NyAQFlhAADVT10WJ-k599.png" alt="Drawing 25.png" data-nodeid="30950"></p>\n\n<h4 data-nodeid="32259" class="">4. 填充颜色</h4>\n\n<p data-nodeid="11259">最后一步是<strong data-nodeid="11395">为各个圆边三角形分别填充颜色</strong>。填充颜色的操作非常简单，先选择其中一个圆边三角形，然后点击 Control + C 把鼠标变成取色器，接着再把取色器移动到右边的图就能撷取各块的颜色了，如下图所示：</p>\n<p data-nodeid="32909" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90PCAKg64AAENBx1xXDY270.png" alt="Drawing 26.png" data-nodeid="32912"></p>\n\n<p data-nodeid="11261">就这样，八个圆边三角形填充完毕以后效果如下：</p>\n<p data-nodeid="33565" class=""><img src="https://s0.lgstatic.com/i/image6/M01/44/1B/Cgp9HWC90PaANXn_AAD-vsRdji4260.png" alt="Drawing 27.png" data-nodeid="33568"></p>\n\n<p data-nodeid="11263">同时，我们还可以看到该图标应用到不同地方的效果，如下图所示：</p>\n<p data-nodeid="34225" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90P2AYjVzAAJ7qHdIOBA753.png" alt="Drawing 28.png" data-nodeid="34228"></p>\n\n<h4 data-nodeid="34889" class="">5. 导出图标</h4>\n\n<p data-nodeid="11268">接着就可以导出图标了，选择“icon-ios”图层并点击“Export icon-ios”按钮，如下图所示：</p>\n<p data-nodeid="35547" class=""><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90QWAISIHAADw4hSpf38419.png" alt="Drawing 29.png" data-nodeid="35550"></p>\n\n<p data-nodeid="11270">最后一步就是把图标导入 Xcode 里面，只需把所有的 PNG 文件拖到 Xcode 的 AppIcons 下就完成了。</p>\n<p data-nodeid="36211" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/44/1B/Cgp9HWC90QuAUXIaAAFLc1rV-Fs236.png" alt="Drawing 30.png" data-nodeid="36214"></p>\n\n<h3 data-nodeid="11272">总结</h3>\n<p data-nodeid="11273">在这一讲，我们介绍了如何使用 Figma 来绘制一个 Moments App 的图标。其中，我们重点讲解了如何寻找模板、怎样安装插件以及如何使用布尔操作来合并多个图层。</p>\n<p data-nodeid="11274">如果你刚入门 App 设计，我建议你从模仿图标的制作入手，把流行的 App 图标下载下来，思考如何把图标拆解成基本图形，例如圆形和多边形等，然后通过布尔操作把多个图形组合成新图层，并填充颜色。一旦能熟练设计图标，页面的设计就变得相对简单了。学习页面设计的方法和图标设计类似，可以通过学习流行的 App 以及 Dribbble 上的热门设计来不断提高。当你掌握这些后，还可以系统地学习字体、颜色、间距、对比度、布局、信息架构等内容。</p>\n<p data-nodeid="11275">在设计工具的选择上，Figma 简单易用，功能齐全，而且支持团队协作，我非常建议你多花一点时间学习与研究，这会很好地帮助你与设计师进行沟通和交流。</p>\n<p data-nodeid="11276"><strong data-nodeid="11413">思考题</strong></p>\n<blockquote data-nodeid="11277">\n<p data-nodeid="11278">今天留给你一个操作题：请使用 Figma 绘制一个微信 App 的图标。</p>\n</blockquote>\n<p data-nodeid="11279">可以把你的设计稿发到留言区哦。下一讲我将介绍如何使用 SwiftUI 快速替换原有 UI 层，记得按时来听课。</p>\n<p data-nodeid="11280"><strong data-nodeid="11419">源码地址</strong></p>\n<blockquote data-nodeid="11281">\n<p data-nodeid="11282">App 图标设计稿地址：<a href="https://www.figma.com/file/Zn86wXELmljrYKZKu95uKf/iOS-App-Icon-Template-Community?node-id=1:55&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="11423">https://www.figma.com/file/Zn86wXELmljrYKZKu95uKf/iOS-App-Icon-Template-Community?node-id=1%3A55</a></p>\n</blockquote>',
          },
          {
            theme: '32 | UI 替换：如何使用 SwiftUI 快速替换原有 UI？',
            id: 51,
            content:
              '<p data-nodeid="1852" class="">如今苹果公司力推的 SwiftUI 越来越流行，例如 Widget 等一些新功能只能使用 SwiftUI 进行开发，再加上 SwiftUI 又变得越来越稳定，可以说现在是学习和使用 SwiftUI 的良好时机。但并不是每个 App 都可以很方便地升级技术栈，幸运的是，Moments App 使用了 MVVM 的架构，该架构为我们提供了良好的灵活性和可扩展性，下面我们一起看看如何把 Moments App 的 UI 层从 UIKit 替换成 SwiftUI。</p>\n<p data-nodeid="1853">在前面<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6669&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1955">第 16 讲</a>里，我们讲了如何使用 MVVM 模式来架构 Moments App。在这一讲中，我准备把 UIViewController 和 UIView 从 View 层移除，替换成 SwiftUI 的实现，如下图所示：</p>\n<p data-nodeid="1854"><img src="https://s0.lgstatic.com/i/image6/M01/44/1B/Cgp9HWC90WWALsfHAAMRfIFPUjA184.png" alt="Drawing 0.png" data-nodeid="1959"></p>\n<p data-nodeid="1855">可以看到，除了 View 层以外，其他模块（包括 ViewModel 和 Model 层等）都没有做任何的改动。下面我们就来剖析下这个实现原理和步骤。</p>\n<h3 data-nodeid="1856">SwiftUI 的状态管理</h3>\n<p data-nodeid="1857">SwiftUI 是一个由状态驱动的 UI 框架，为了更好地理解 SwiftUI 的使用，我们就先来看看 SwiftUI 是如何管理状态的。</p>\n<p data-nodeid="1858"><strong data-nodeid="1967">状态管理最简单的方式是使用 @State 属性包装器（Property Wrapper）</strong>，下面是使用 @State 的示例代码：</p>\n<pre class="lang-swift" data-nodeid="1859"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">Button</span>(<span class="hljs-string">"生日啦，现在几岁: \\(age)"</span>) {\n            age += <span class="hljs-number">1</span>\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1860">我们在<code data-backticks="1" data-nodeid="1969">ContentView</code>里面创建了一个名叫<code data-backticks="1" data-nodeid="1971">age</code>的属性，由于使用了 @State 属性包装器，所以 SwiftUI 会帮我们自动管理这个属性的内存并监听其状态更新的情况。在上述的例子中，当用户点击“生日啦”按钮时，就会把<code data-backticks="1" data-nodeid="1973">age</code>属性的值增加一，这一更改会促使 SwiftUI 自动刷新<code data-backticks="1" data-nodeid="1975">ContentView</code>。</p>\n<p data-nodeid="1861">@State 适合为某个特定的 View 管理类型为值（Value）的属性，而且我们通常把 @State 的属性都定义为<code data-backticks="1" data-nodeid="1978">private</code>（私有的）以禁止外部的访问。但如何实现多个对象间（例如，父子视图间）的状态共享呢？那就需要使用到 @StateObject 和 @ObservedObject 属性包装器了。这两个属性包装器所定义的属性都必须遵循<code data-backticks="1" data-nodeid="1980">ObservableObject</code>协议。</p>\n<p data-nodeid="1862">那接下来我们就再看一下为什么使用<code data-backticks="1" data-nodeid="1983">ObservableObject</code>协议吧。</p>\n<p data-nodeid="12378" class="te-preview-highlight"><strong data-nodeid="12383">为了让 SwiftUI 能访问来自 Model 的状态更新，我们必须让 Model 遵循 ObservableObject 协议</strong>。那 Model 怎样才能发送状态通知呢？可以结合下面的例子来理解。</p>\n\n\n\n\n\n\n\n\n\n<pre class="lang-swift" data-nodeid="1864"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObservableObject</span>: <span class="hljs-title">ObservableObject</span> </span>{\n    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Jake"</span>\n    <span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span> {\n        <span class="hljs-keyword">willSet</span> {\n            objectWillChange.send()\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1865"><code data-backticks="1" data-nodeid="1995">UserObservableObject</code>是一个遵循了<code data-backticks="1" data-nodeid="1997">ObservableObject</code>协议的类。因为所有遵循<code data-backticks="1" data-nodeid="1999">ObservableObject</code>协议的子类型都必须是引用类型，所以我们只能使用类而不是结构体（Struct）。<code data-backticks="1" data-nodeid="2001">UserObservableObject</code>定义了两个属性：<code data-backticks="1" data-nodeid="2003">age</code>属性的<code data-backticks="1" data-nodeid="2005">willSet</code>里面调用了<code data-backticks="1" data-nodeid="2007">objectWillChange.send()</code>方法，当我们修改<code data-backticks="1" data-nodeid="2009">age</code>属性时，就会发送状态更新通知；而<code data-backticks="1" data-nodeid="2011">name</code>属性没有调用<code data-backticks="1" data-nodeid="2013">objectWillChange.send()</code>方法，因此我们修改它的时候并不会发送更新通知。</p>\n<p data-nodeid="1866">你可以看到，所有需要发送更新通知的属性都必须编写重复的<code data-backticks="1" data-nodeid="2016">willSet</code>代码，幸运的是苹果为我们提供了 <code data-backticks="1" data-nodeid="2018">@Published</code>属性包装器来简化编写更新通知的工作。有了<code data-backticks="1" data-nodeid="2020">@Published</code>，上述的代码就可以简化为如下：</p>\n<pre class="lang-swift" data-nodeid="1867"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObservableObject</span>: <span class="hljs-title">ObservableObject</span> </span>{\n    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Jake"</span>\n    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>\n}\n</code></pre>\n<p data-nodeid="1868">我们只需要在发送状态更新的属性定义前加上<code data-backticks="1" data-nodeid="2023">@Published</code>即可。</p>\n<p data-nodeid="1869">介绍完<code data-backticks="1" data-nodeid="2026">ObservableObject</code>协议以后，我们就可以通过下面的例子看看如何使用 @StateObject 和 @ObservedObject 属性包装器了。</p>\n<pre class="lang-swift" data-nodeid="1870"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> user: <span class="hljs-type">UserObservableObject</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">Button</span>(<span class="hljs-string">"生日啦，现在几岁: \\(user.age)"</span>) {\n            user.age += <span class="hljs-number">1</span>\n        }\n    }\n}\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParentView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> user: <span class="hljs-type">UserObservableObject</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">VStack</span> {\n            <span class="hljs-type">Text</span>(<span class="hljs-string">"你的名字：\\(user.name)"</span>)\n            <span class="hljs-type">ChildView</span>(user: user)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1871"><strong data-nodeid="2047">@StateObject 和 @ObservedObject 都可以定义用于状态共享的属性，而且这些属性的类型都必须遵循</strong><code data-backticks="1" data-nodeid="2031">ObservableObject</code>协议。不同的地方是 @StateObject 用于生成和管理状态属性的生命周期，而 @ObservedObject 只能把共享状态从外部传递进来。例如，在上面的示例代码中，我们在<code data-backticks="1" data-nodeid="2033">ParentView</code>里使用 @StateObject 来定义并初始化<code data-backticks="1" data-nodeid="2035">user</code>属性，然后传递给<code data-backticks="1" data-nodeid="2037">ChildView</code>的<code data-backticks="1" data-nodeid="2039">user</code>属性。由于<code data-backticks="1" data-nodeid="2041">ChildView</code>的<code data-backticks="1" data-nodeid="2043">user</code>属性来自外部的<code data-backticks="1" data-nodeid="2045">ParentView</code>，因此定义为 @ObservedObject。</p>\n<p data-nodeid="1872">当我们需要共享状态的时候，通常在父对象里定义和初始化一个 @StateObject 属性，然后传递给子对象里的 @ObservedObject 属性。如果只有两层关系还是很方便的，但假如有好几层的父子关系，逐层传递会变得非常麻烦，那有没有好办法解决这个问题呢？</p>\n<p data-nodeid="1873">@EnvironmentObject 就是用于解决这个问题的。@EnvironmentObject 能帮我们把状态共享到整个 App 里面，下面还是通过一个例子来看看。</p>\n<pre class="lang-swift" data-nodeid="1874"><code data-language="swift">@main\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MomentsApp</span>: <span class="hljs-title">App</span> </span>{\n    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> user: <span class="hljs-type">UserObservableObject</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {\n        <span class="hljs-type">WindowGroup</span> {\n            <span class="hljs-type">ParentView</span>()\n                .environmentObject(user)\n        }\n    }\n}\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> user: <span class="hljs-type">UserObservableObject</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">Button</span>(<span class="hljs-string">"生日啦，现在几岁: \\(user.age)"</span>) {\n            user.age += <span class="hljs-number">1</span>\n        }\n    }\n}\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParentView</span>: <span class="hljs-title">View</span> </span>{\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">VStack</span> {\n            <span class="hljs-type">ChildView</span>()\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1875">我们在<code data-backticks="1" data-nodeid="2051">MomentsApp</code>里面通过 @StateObject 定义并初始化<code data-backticks="1" data-nodeid="2053">user</code>属性，然后调用<code data-backticks="1" data-nodeid="2055">environmentObject()</code>方法把该属性注册成环境对象。<code data-backticks="1" data-nodeid="2057">MomentsApp</code>内嵌了<code data-backticks="1" data-nodeid="2059">ParentView</code>，而<code data-backticks="1" data-nodeid="2061">ParentView</code>并没有使用<code data-backticks="1" data-nodeid="2063">user</code>属性。<code data-backticks="1" data-nodeid="2065">ParentView</code>内嵌了<code data-backticks="1" data-nodeid="2067">ChildView</code>，<code data-backticks="1" data-nodeid="2069">ChildView</code>则通过 @EnvironmentObject 来定义<code data-backticks="1" data-nodeid="2071">user</code>属性，这样<code data-backticks="1" data-nodeid="2073">ChildView</code>就能从环境对象中取出<code data-backticks="1" data-nodeid="2075">MomentsApp</code>注册的值了。</p>\n<p data-nodeid="1876"><strong data-nodeid="2081">@EnvironmentObject 能帮我们把对象传递到 App 任何的地方，特别适合共享公共的状态</strong>，例如用户登录的信息等。但是 @EnvironmentObject 有点像 Singleton，我们不能过度使用它，否则会增加模块间的耦合度。</p>\n<p data-nodeid="1877">@ObservedObject 与 @EnvironmentObject 都能帮助我们共享引用类型的属性，但如何共享值类型的属性呢？<strong data-nodeid="2087">@Binding 属性包装器就能帮我们定义共享值类型的属性。</strong> 下面我们还是通过示例代码来看看如何使用 @Binding。</p>\n<pre class="lang-swift" data-nodeid="1878"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> isPresented: <span class="hljs-type">Bool</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">Button</span>(<span class="hljs-string">"关闭"</span>) {\n            isPresented = <span class="hljs-literal">false</span>\n        }\n    }\n}\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParentView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showingChildView = <span class="hljs-literal">false</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">VStack</span> {\n            <span class="hljs-type">Text</span>(<span class="hljs-string">"父 View"</span>)\n        }.sheet(isPresented: $showingChildView) {\n            <span class="hljs-type">ChildView</span>(isPresented: $showingChildView)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1879"><code data-backticks="1" data-nodeid="2088">ChildView</code>通过 @Binding 定义了<code data-backticks="1" data-nodeid="2090">isPresented</code>属性，表示该视图是否可见。该属性的值与<code data-backticks="1" data-nodeid="2092">ParentView</code>的<code data-backticks="1" data-nodeid="2094">showingChildView</code>属性同步。通过 @Binding，我们就可以把值类型的属性进行共享了。</p>\n<p data-nodeid="1880">至此，我们就介绍完 SwiftUI 的状态管理了。</p>\n<h3 data-nodeid="1881">SwiftUI 的架构与实现</h3>\n<p data-nodeid="1882">下面一起来看看使用 SwiftUI 开发 View 层的系统架构图。</p>\n<p data-nodeid="1883"><img src="https://s0.lgstatic.com/i/image6/M00/44/23/CioPOWC90amACsvfAAHhOfaicTI452.png" alt="Drawing 1.png" data-nodeid="2101"></p>\n<p data-nodeid="1884">该架构图由两部分组成，分别是左边的 View 模块和右边的 ViewModel 模块。由于 View 模块依赖了 ViewModel 模块，所以这里我们就先看右边的 ViewModel 模块。该模块包含了<code data-backticks="1" data-nodeid="2103">MomentsTimelineViewModel</code>、<code data-backticks="1" data-nodeid="2105">ListItemViewModel</code>、<code data-backticks="1" data-nodeid="2107">MomentListItemViewModel</code>和<code data-backticks="1" data-nodeid="2109">UserProfileListItemViewModel</code>四个原有的 ViewModel，因为它们具有良好的可扩展性，所以我们无须对它们进行任何的改动。</p>\n<h4 data-nodeid="1885">1. 桥接 RxSwift 与 SwiftUI</h4>\n<p data-nodeid="1886">为了把这些 ViewModel 类型桥接到 SwiftUI 版本的 View 模块，我们增加了两个类型：<code data-backticks="1" data-nodeid="2115">MomentsListObservableObject</code>和<code data-backticks="1" data-nodeid="2117">IdentifiableListItemViewModel</code>。<code data-backticks="1" data-nodeid="2119">MomentsListObservableObject</code>负责给 SwiftUI 组件发送更新消息，下面是它的具体实现：</p>\n<pre class="lang-swift" data-nodeid="1887"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsListObservableObject</span>: <span class="hljs-title">ObservableObject</span> </span>{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">MomentsTimelineViewModel</span>\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()\n    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> listItems: [<span class="hljs-type">IdentifiableListItemViewModel</span>] = []\n    <span class="hljs-keyword">init</span>(userID: <span class="hljs-type">String</span>, momentsRepo: <span class="hljs-type">MomentsRepoType</span>) {\n        viewModel = <span class="hljs-type">MomentsTimelineViewModel</span>(userID: userID, momentsRepo: momentsRepo)\n        setupBindings()\n    }\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadItems</span><span class="hljs-params">()</span></span> {\n        viewModel.loadItems()\n            .subscribe()\n            .disposed(by: disposeBag)\n    }\n    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupBindings</span><span class="hljs-params">()</span></span> {\n        viewModel.listItems\n            .observeOn(<span class="hljs-type">MainScheduler</span>.instance)\n            .subscribe(onNext: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] items <span class="hljs-keyword">in</span>\n                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }\n                <span class="hljs-keyword">self</span>.listItems.removeAll()\n                <span class="hljs-keyword">self</span>.listItems.append(contentsOf: items.flatMap { $<span class="hljs-number">0</span>.items }.<span class="hljs-built_in">map</span> { <span class="hljs-type">IdentifiableListItemViewModel</span>(viewModel: $<span class="hljs-number">0</span>) })\n            })\n            .disposed(by: disposeBag)\n    }\n}\n</code></pre>\n<p data-nodeid="1888"><code data-backticks="1" data-nodeid="2121">MomentsListObservableObject</code>遵循了<code data-backticks="1" data-nodeid="2123">ObservableObject</code>协议，并使用了 @Published 来定义<code data-backticks="1" data-nodeid="2125">listItems</code>属性，这样使得<code data-backticks="1" data-nodeid="2127">listItems</code>的状态更新会自动往外发送。<br>\n<code data-backticks="1" data-nodeid="2130">listItems</code>属性的类型是<code data-backticks="1" data-nodeid="2132">IdentifiableListItemViewModel</code>的数组，下面是<code data-backticks="1" data-nodeid="2134">IdentifiableListItemViewModel</code>的具体实现：</p>\n<pre class="lang-swift" data-nodeid="1889"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IdentifiableListItemViewModel</span>: <span class="hljs-title">Identifiable</span> </span>{\n    <span class="hljs-keyword">let</span> id: <span class="hljs-type">UUID</span> = .<span class="hljs-keyword">init</span>()\n    <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">ListItemViewModel</span>\n}\n</code></pre>\n<p data-nodeid="1890"><code data-backticks="1" data-nodeid="2136">IdentifiableListItemViewModel</code>其实是<code data-backticks="1" data-nodeid="2138">ListItemViewModel</code>的一个包装类型，因为我们要在 SwiftUI 上重复显示<code data-backticks="1" data-nodeid="2140">ListItemViewModel</code>的数据，所以就要用到<code data-backticks="1" data-nodeid="2142">ForEach</code>语句来执行循环操作。而<code data-backticks="1" data-nodeid="2144">ForEach</code>语句要求所有 Model 类型都遵循<code data-backticks="1" data-nodeid="2146">Identifiable</code>协议，因此，我们定义了<code data-backticks="1" data-nodeid="2148">IdentifiableListItemViewModel</code>来遵循<code data-backticks="1" data-nodeid="2150">Identifiable</code>协议，并把<code data-backticks="1" data-nodeid="2152">ListItemViewModel</code>包装在里面，同时还通过<code data-backticks="1" data-nodeid="2154">id</code>属性来返回一个 UUID 的实例。</p>\n<p data-nodeid="1891">在<code data-backticks="1" data-nodeid="2157">init()</code>初始化函数里，我们订阅了<code data-backticks="1" data-nodeid="2159">MomentsTimelineViewModel</code>的<code data-backticks="1" data-nodeid="2161">listItems</code>Subject 属性的更新，而且把接收到的数据转换成<code data-backticks="1" data-nodeid="2163">IdentifiableListItemViewModel</code>类型并赋值给<code data-backticks="1" data-nodeid="2165">listItems</code>属性，这样就能把 RxSwift 的事件消息桥接给 SwiftUI 进行自动更新了。</p>\n<p data-nodeid="1892">接着再来看看 View 模块，该模块由<code data-backticks="1" data-nodeid="2168">SwiftUIMomentsTimelineView</code>、<code data-backticks="1" data-nodeid="2170">SwiftUIMomentsListItemView</code>、<code data-backticks="1" data-nodeid="2172">SwiftUIMomentListItemView</code>和<code data-backticks="1" data-nodeid="2174">SwiftUIUserProfileListItemView</code>所组成，你可以结合下图了解它们之间的嵌套关系。</p>\n<p data-nodeid="1893"><img src="https://s0.lgstatic.com/i/image6/M01/44/1B/Cgp9HWC90b-AAGkCAAdM0BD6GgE546.png" alt="Drawing 2.png" data-nodeid="2178"></p>\n<p data-nodeid="1894"><code data-backticks="1" data-nodeid="2179">SwiftUIMomentsTimelineView</code>是一个容器视图，包含了多个<code data-backticks="1" data-nodeid="2181">SwiftUIMomentsListItemView</code>。<code data-backticks="1" data-nodeid="2183">SwiftUIMomentsListItemView</code>会根据 ViewModel 的具体类型来显示<code data-backticks="1" data-nodeid="2185">SwiftUIUserProfileListItemView</code>或者<code data-backticks="1" data-nodeid="2187">SwiftUIMomentListItemView</code>。</p>\n<h4 data-nodeid="1895">2. 朋友圈时间轴视图</h4>\n<p data-nodeid="1896">下面我们分别看看它们的实现吧，首先看容器视图<code data-backticks="1" data-nodeid="2193">SwiftUIMomentsTimelineView</code>的代码实现。</p>\n<pre class="lang-swift" data-nodeid="1897"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftUIMomentsTimelineView</span>: <span class="hljs-title">View</span> </span>{\n    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> userDataStore: <span class="hljs-type">UserDataStoreObservableObject</span> = .<span class="hljs-keyword">init</span>()\n    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> momentsList: <span class="hljs-type">MomentsListObservableObject</span> = .<span class="hljs-keyword">init</span>(userID: <span class="hljs-type">UserDataStore</span>.current.userID, momentsRepo: <span class="hljs-type">MomentsRepo</span>.shared)\n    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isDragging: <span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">ScrollView</span>(axes, showsIndicators: <span class="hljs-literal">true</span>) {\n            <span class="hljs-type">LazyVStack</span> {\n                <span class="hljs-type">ForEach</span> (momentsList.listItems) { item <span class="hljs-keyword">in</span>\n                    <span class="hljs-type">SwiftUIMomentsListItemView</span>(viewModel: item.viewModel, isDragging: $isDragging).ignoresSafeArea(.all)\n                }.onAppear(perform: {\n                    momentsList.loadItems()\n                })\n            }\n        }.frame(minWidth: <span class="hljs-number">0</span>, maxWidth: .infinity, minHeight: <span class="hljs-number">0</span>, maxHeight: .infinity)\n        .background(<span class="hljs-type">Color</span>(<span class="hljs-string">"background"</span>))\n        .ignoresSafeArea(.all)\n        .environmentObject(userDataStore)\n    }\n}\n</code></pre>\n<p data-nodeid="1898">我们使用 @StateObject 定义了<code data-backticks="1" data-nodeid="2196">userDataStore</code>属性，并通过<code data-backticks="1" data-nodeid="2198">environmentObject()</code>方法把它注册到环境对象中，这样就使得所有的子视图都能通过 @EnvironmentObject 来访问<code data-backticks="1" data-nodeid="2200">userDataStore</code>属性的值了。</p>\n<p data-nodeid="1899"><code data-backticks="1" data-nodeid="2202">SwiftUIMomentsTimelineView</code>的布局比较简单，是一个<code data-backticks="1" data-nodeid="2204">ScrollView</code>，在<code data-backticks="1" data-nodeid="2206">ScrollView</code>里通过<code data-backticks="1" data-nodeid="2208">LazyVStack</code>和<code data-backticks="1" data-nodeid="2210">ForEach</code>把<code data-backticks="1" data-nodeid="2212">momentsList.listItems</code>的每一条数据通过<code data-backticks="1" data-nodeid="2214">SwiftUIMomentsListItemView</code>分别显示出来，而且在初始化<code data-backticks="1" data-nodeid="2216">SwiftUIMomentsListItemView</code>的时候把具体的 ViewModel 以及<code data-backticks="1" data-nodeid="2218">isDragging</code>属性传递进去。</p>\n<h4 data-nodeid="1900">3. 中介视图</h4>\n<p data-nodeid="1901"><code data-backticks="1" data-nodeid="2223">SwiftUIMomentsListItemView</code>担任中介的角色，其具体代码实现如下：</p>\n<pre class="lang-swift" data-nodeid="1902"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftUIMomentsListItemView</span>: <span class="hljs-title">View</span> </span>{\n    <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">ListItemViewModel</span>\n    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> isDragging: <span class="hljs-type">Bool</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> viewModel = viewModel <span class="hljs-keyword">as</span>? <span class="hljs-type">UserProfileListItemViewModel</span> {\n            <span class="hljs-type">SwiftUIUserProfileListItemView</span>(viewModel: viewModel, isDragging: $isDragging)\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> viewModel = viewModel <span class="hljs-keyword">as</span>? <span class="hljs-type">MomentListItemViewModel</span> {\n            <span class="hljs-type">SwiftUIMomentListItemView</span>(viewModel: viewModel)\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1903">我们使用了 @Binding 来定义<code data-backticks="1" data-nodeid="2226">isDragging</code>属性，这样就能与父视图<code data-backticks="1" data-nodeid="2228">SwiftUIMomentsTimelineView</code>共享用户的拖动状态了。<code data-backticks="1" data-nodeid="2230">SwiftUIMomentsListItemView</code>本身不做任何的显示操作，而是在<code data-backticks="1" data-nodeid="2232">body</code>属性里根据<code data-backticks="1" data-nodeid="2234">viewModel</code>的类型来分别通过<code data-backticks="1" data-nodeid="2236">SwiftUIUserProfileListItemView</code>或者<code data-backticks="1" data-nodeid="2238">SwiftUIMomentListItemView</code>进行显示。为什么需要这样做呢？因为 SwiftUI 里所有的组件都是值类型，例如 View 就不支持继承关系，我们无法使用多态（Polymorphism）的方式来动态显示的子 View，只能通过条件判断语句来选择性显示不同的 View。</p>\n<h4 data-nodeid="1904">4. 用户属性视图</h4>\n<p data-nodeid="1905">朋友圈功能最上面的部分是用户属性视图，下面我们看一下它的具体实现。由于<code data-backticks="1" data-nodeid="2244">SwiftUIUserProfileListItemView</code>的具体实现代码有点长，所以这里我把它拆成几部分来分别解释。</p>\n<pre class="lang-swift" data-nodeid="1906"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftUIUserProfileListItemView</span>: <span class="hljs-title">View</span> </span>{\n    <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">UserProfileListItemViewModel</span>\n    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> isDragging: <span class="hljs-type">Bool</span>\n    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewSize: <span class="hljs-type">CGSize</span> = .zero\n}\n</code></pre>\n<p data-nodeid="1907">首先看一下属性的定义，我们定义了<code data-backticks="1" data-nodeid="2247">viewModel</code>属性来保存从父视图传进来的<code data-backticks="1" data-nodeid="2249">UserProfileListItemViewModel</code>对象，这样我们就能使用该<code data-backticks="1" data-nodeid="2251">viewModel</code>里的属性来进行显示了。</p>\n<p data-nodeid="1908">同时我们还使用了 @Binding 来定义<code data-backticks="1" data-nodeid="2254">isDragging</code>属性，该属性与父视图<code data-backticks="1" data-nodeid="2256">SwiftUIMomentsTimelineView</code>共享用户拖动的状态。有了这个属性，我们在启动触摸动画时就可以停止父视图的拖动事件，从而避免奇怪的拖动效果。</p>\n<p data-nodeid="1909">另外，我们还使用 @State 来定义一个私有的属性<code data-backticks="1" data-nodeid="2259">viewSize</code>，该属性用于控制拖拉动画的视图大小。</p>\n<p data-nodeid="1910">为了更好地理解布局的代码实现，我们可以结合下面的图来看看各个组件之间的嵌套关系。</p>\n<p data-nodeid="1911"><img src="https://s0.lgstatic.com/i/image6/M01/44/1B/Cgp9HWC90d-AH97-AAYCP8Dw-HE675.png" alt="Drawing 3.png" data-nodeid="2264"></p>\n<p data-nodeid="1912">因为我们要把名字和头像放在底部，所以使用了用于垂直布局的<code data-backticks="1" data-nodeid="2266">VStack</code>。在该<code data-backticks="1" data-nodeid="2268">VStack</code>里先放一个<code data-backticks="1" data-nodeid="2270">Spacer</code>，这样能把下面的<code data-backticks="1" data-nodeid="2272">HStack</code>压到底部。<code data-backticks="1" data-nodeid="2274">HStack</code>用于水平布局，我们可以通过<code data-backticks="1" data-nodeid="2276">Spacer</code>把其他视图推到右边，右边是用于显示名字的<code data-backticks="1" data-nodeid="2278">Text</code>和显示头像的<code data-backticks="1" data-nodeid="2280">KFImage</code>控件。这所有的布局代码都存放在<code data-backticks="1" data-nodeid="2282">body</code>属性里，如下所示：</p>\n<pre class="lang-swift" data-nodeid="1913"><code data-language="swift"><span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n    <span class="hljs-type">VStack</span> {\n        <span class="hljs-type">Spacer</span>()\n        <span class="hljs-type">HStack</span> {\n            <span class="hljs-type">Spacer</span>()\n            <span class="hljs-type">Text</span>(viewModel.name)\n                .font(.title2)\n                .foregroundColor(.white)\n                .padding(.trailing, <span class="hljs-number">10</span>)\n            <span class="hljs-type">KFImage</span>(viewModel.avatarURL)\n                .resizable()\n                .aspectRatio(contentMode: .fill)\n                .frame(width: <span class="hljs-number">80</span>, height: <span class="hljs-number">80</span>, alignment: .center)\n                .clipShape(<span class="hljs-type">Circle</span>())\n        }\n        .padding(.trailing, <span class="hljs-number">10</span>)\n        .padding(.bottom, <span class="hljs-number">10</span>)\n    }\n    .frame(height: <span class="hljs-number">350</span>)\n    .frame(maxWidth: .infinity)\n}\n</code></pre>\n<p data-nodeid="1914">由于<code data-backticks="1" data-nodeid="2285">Spacer</code>不能提供高度和宽度，所以除了布局代码以外，我们还需要调用<code data-backticks="1" data-nodeid="2287">frame(height: 350)</code>方法来配置视图的高度，然后使用<code data-backticks="1" data-nodeid="2289">frame(maxWidth: .infinity)</code>方法使得视图占据设备的全部宽度。</p>\n<p data-nodeid="1915">你可能会问，后面两个深蓝色的圆圈和背景图在哪里配置呢？其实它们都放在<code data-backticks="1" data-nodeid="2292">background</code>方法里面，具体代码如下：</p>\n<pre class="lang-swift" data-nodeid="1916"><code data-language="swift">.background(\n    <span class="hljs-type">ZStack</span> {\n        <span class="hljs-type">Image</span>(uiImage: #imageLiteral(resourceName: <span class="hljs-string">"Blob"</span>))\n            .offset(x: -<span class="hljs-number">200</span>, y: -<span class="hljs-number">200</span>)\n            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">450</span>))\n            .blendMode(.plusDarker)\n        <span class="hljs-type">Image</span>(uiImage: #imageLiteral(resourceName: <span class="hljs-string">"Blob"</span>))\n            .offset(x: -<span class="hljs-number">200</span>, y: -<span class="hljs-number">250</span>)\n            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), anchor: .leading)\n            .blendMode(.overlay)\n    }\n)\n.background(\n    <span class="hljs-type">KFImage</span>(viewModel.backgroundImageURL)\n        .resizable()\n        .offset(x: viewSize.width / <span class="hljs-number">20</span>, y: viewSize.height / <span class="hljs-number">20</span>)\n)\n.clipShape(<span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">30</span>, style: .continuous))\n</code></pre>\n<p data-nodeid="1917">这里调用了两次<code data-backticks="1" data-nodeid="2295">background</code>方法。在第一个<code data-backticks="1" data-nodeid="2297">background</code>方法里，我们使用了<code data-backticks="1" data-nodeid="2299">ZStack</code>来进行布局，<code data-backticks="1" data-nodeid="2301">ZStack</code>能帮助我们布局彼此覆盖的视图。在<code data-backticks="1" data-nodeid="2303">ZStack</code>里，我们存放了两个名叫 Blob 的<code data-backticks="1" data-nodeid="2305">Image</code>组件，由于它们使用了不一样的<code data-backticks="1" data-nodeid="2307">blendMode</code>，所以显示的效果有所不同。</p>\n<p data-nodeid="1918">在第二个<code data-backticks="1" data-nodeid="2310">background</code>方法里，我们使用了<code data-backticks="1" data-nodeid="2312">KFImage</code>来加载背景图片，同时把<code data-backticks="1" data-nodeid="2314">viewSize</code>传递给<code data-backticks="1" data-nodeid="2316">offset()</code>方法来实现非常微妙的视差（parallax）效果。</p>\n<p data-nodeid="1919">最后我们调用了<code data-backticks="1" data-nodeid="2319">clipShape()</code>方法来配置大圆角的效果，这是近期一种流行的设计风格。</p>\n<p data-nodeid="1920">以上都是配置静态 UI 风格的代码，下面我们再来看看如何为<code data-backticks="1" data-nodeid="2322">SwiftUIUserProfileListItemView</code>呈现浮动的动画效果，如下实现代码：</p>\n<pre class="lang-swift" data-nodeid="1921"><code data-language="swift">.scaleEffect(isDragging ? <span class="hljs-number">0.9</span> : <span class="hljs-number">1</span>)\n.animation(.timingCurve(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">1</span>, duration: <span class="hljs-number">0.8</span>))\n.rotation3DEffect(<span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">5</span>), axis: (x: viewSize.width, y: viewSize.height, z: <span class="hljs-number">0</span>))\n.gesture(\n    <span class="hljs-type">DragGesture</span>().onChanged({ value <span class="hljs-keyword">in</span>\n        <span class="hljs-keyword">self</span>.isDragging = <span class="hljs-literal">true</span>\n        <span class="hljs-keyword">self</span>.viewSize = value.translation\n    }).onEnded({ <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>\n        <span class="hljs-keyword">self</span>.isDragging = <span class="hljs-literal">false</span>\n        <span class="hljs-keyword">self</span>.viewSize = .zero\n    })\n)\n</code></pre>\n<p data-nodeid="1922">当调用<code data-backticks="1" data-nodeid="2325">scaleEffect()</code>方法时，我们根据<code data-backticks="1" data-nodeid="2327">isDragging</code>属性的状态来配置不同的缩放系数，这样能使得当用户拖拉视图时，视图会变小一点点。然后调用<code data-backticks="1" data-nodeid="2329">animation()</code>方法使得视图改变大小时会有平滑的转换动画效果，<code data-backticks="1" data-nodeid="2331">rotation3DEffect()</code>方法会使得拖拉视图时有浮动效果，<code data-backticks="1" data-nodeid="2333">gesture()</code>方法让我们可以根据用户的触摸状态来改变<code data-backticks="1" data-nodeid="2335">isDragging</code>和<code data-backticks="1" data-nodeid="2337">viewSize</code>的状态，从而影响动画的运行状态。</p>\n<h4 data-nodeid="1923">5. 朋友圈信息视图</h4>\n<p data-nodeid="1924">看完用户属性视图的实现后，下面我们一起看看一条朋友圈信息是如何显示的，首先看一下它的布局图。</p>\n<p data-nodeid="1925"><img src="https://s0.lgstatic.com/i/image6/M01/44/1C/Cgp9HWC90huAF_a6AAIy6uuggTs430.png" alt="Drawing 4.png" data-nodeid="2345"></p>\n<p data-nodeid="1926">外层是一个<code data-backticks="1" data-nodeid="2347">ZStack</code>，这样能保证<code data-backticks="1" data-nodeid="2349">Toggle</code>可以一直浮动在右下角。<code data-backticks="1" data-nodeid="2351">ZStack</code>还包含一个<code data-backticks="1" data-nodeid="2353">HStack</code>，在<code data-backticks="1" data-nodeid="2355">HStack</code>的左边是一张用于显示朋友头像的图片，右边是一个<code data-backticks="1" data-nodeid="2357">VStack</code>。<code data-backticks="1" data-nodeid="2359">VStack</code>里依次放了显示朋友名字的<code data-backticks="1" data-nodeid="2361">Text</code>、显示标题的<code data-backticks="1" data-nodeid="2363">Text</code>、显示图片的<code data-backticks="1" data-nodeid="2365">KFImage</code>、显示时间的<code data-backticks="1" data-nodeid="2367">Text</code>，以及最底层的<code data-backticks="1" data-nodeid="2369">HStack</code>，这个<code data-backticks="1" data-nodeid="2371">HStack</code>放置了一个心形图片和多个点赞人的头像。其布局代码如下所示， 你可以结合上面的图来理解。</p>\n<pre class="lang-swift" data-nodeid="1927"><code data-language="swift"><span class="hljs-type">ZStack</span>(alignment: .bottomTrailing) {\n    <span class="hljs-type">HStack</span>(alignment: .top, spacing: <span class="hljs-type">Spacing</span>.medium) {\n        <span class="hljs-type">KFImage</span>(viewModel.userAvatarURL)\n            .resizable()\n            .clipShape(<span class="hljs-type">Circle</span>())\n            .frame(width: <span class="hljs-number">44</span>, height: <span class="hljs-number">44</span>)\n            .shadow(color: <span class="hljs-type">Color</span>.primary.opacity(<span class="hljs-number">0.15</span>), radius: <span class="hljs-number">5</span>, x: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span>)\n            .padding(.leading, <span class="hljs-type">Spacing</span>.medium)\n        <span class="hljs-type">VStack</span>(alignment: .leading) {\n            <span class="hljs-type">Text</span>(viewModel.userName)\n                .font(.subheadline)\n                .foregroundColor(.primary)\n            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> title = viewModel.title {\n                <span class="hljs-type">Text</span>(title)\n                    .font(.body)\n                    .foregroundColor(<span class="hljs-type">Color</span>.secondary)\n            }\n            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> photoURL = viewModel.photoURL {\n                <span class="hljs-type">KFImage</span>(photoURL)\n                    .resizable()\n                    .frame(width: <span class="hljs-number">240</span>, height: <span class="hljs-number">120</span>)\n            }\n            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> postDateDescription = viewModel.postDateDescription {\n                <span class="hljs-type">Text</span>(postDateDescription)\n                    .font(.footnote)\n                    .foregroundColor(<span class="hljs-type">Color</span>.secondary)\n            }\n            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> likes = viewModel.likes, !likes.isEmpty {\n                <span class="hljs-type">HStack</span> {\n                    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart"</span>)\n                        .foregroundColor(.secondary)\n                    <span class="hljs-type">ForEach</span>(likes.<span class="hljs-built_in">map</span> { <span class="hljs-type">IdentifiableURL</span>(url: $<span class="hljs-number">0</span>) }) {\n                        <span class="hljs-type">KFImage</span>($<span class="hljs-number">0</span>.url)\n                            .resizable()\n                            .frame(width: <span class="hljs-number">20</span>, height: <span class="hljs-number">20</span>)\n                            .clipShape(<span class="hljs-type">Circle</span>())\n                            .shadow(color: <span class="hljs-type">Color</span>.primary.opacity(<span class="hljs-number">0.15</span>), radius: <span class="hljs-number">3</span>, x: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span>)\n                    }\n                }\n            }\n        }\n        <span class="hljs-type">Spacer</span>()\n    }\n    <span class="hljs-type">Toggle</span>(isOn: $isLiked) {\n    }\n}\n</code></pre>\n<p data-nodeid="1928">其中，<code data-backticks="1" data-nodeid="2374">Toggle</code>使用了当前流行的新拟物化设计（Neumorphism），其具有光影效果，同时在点击时会有丝绸物料凸凹变化的效果。那是怎样做到的呢？下面一起看看<code data-backticks="1" data-nodeid="2376">Toggle</code>组件的代码。</p>\n<pre class="lang-swift" data-nodeid="1929"><code data-language="swift"><span class="hljs-type">Toggle</span>(isOn: $isLiked) {\n    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart.fill"</span>)\n        .foregroundColor(isLiked == <span class="hljs-literal">true</span> ? <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonSelected"</span>) : <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonNotSelected"</span>))\n        .animation(.easeIn)\n}\n.toggleStyle(<span class="hljs-type">LikeToggleStyle</span>())\n.padding(.trailing, <span class="hljs-type">Spacing</span>.medium)\n.onChange(of: isLiked, perform: { isOn <span class="hljs-keyword">in</span>\n    <span class="hljs-keyword">guard</span> isLiked == isOn <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }\n    <span class="hljs-keyword">if</span> isOn {\n        viewModel.like(from: userDataStore.currentUser.userID).subscribe().disposed(by: disposeBag)\n    } <span class="hljs-keyword">else</span> {\n        viewModel.unlike(from: userDataStore.currentUser.userID).subscribe().disposed(by: disposeBag)\n    }\n})\n</code></pre>\n<p data-nodeid="1930">我们在<code data-backticks="1" data-nodeid="2379">Toggle</code>里面放了一个心形的<code data-backticks="1" data-nodeid="2381">Image</code>，并根据选中状态来填充不同的颜色。当我们点击<code data-backticks="1" data-nodeid="2383">Toggle</code>时，会根据选中状态来调用<code data-backticks="1" data-nodeid="2385">viewModel</code>的<code data-backticks="1" data-nodeid="2387">like()</code>或者<code data-backticks="1" data-nodeid="2389">unlike()</code>方法，这样就能把选中状态更新到后台去了。</p>\n<p data-nodeid="1931">下面看一下如何配置<code data-backticks="1" data-nodeid="2392">Toggle</code>的显示风格。这里我们定义了一个名叫<code data-backticks="1" data-nodeid="2394">LikeToggleStyle</code>的结构体，该结构体遵循了<code data-backticks="1" data-nodeid="2396">ToggleStyle</code>协议。我们可以在<code data-backticks="1" data-nodeid="2398">LikeToggleStyle</code>里面配置<code data-backticks="1" data-nodeid="2400">Toggle</code>的显示风格，代码如下：</p>\n<pre class="lang-swift" data-nodeid="1932"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LikeToggleStyle</span>: <span class="hljs-title">ToggleStyle</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {\n        <span class="hljs-type">Button</span>(action: {\n            configuration.isOn.toggle()\n        }, label: {\n            configuration.label\n                .padding(<span class="hljs-type">Spacing</span>.extraSmall)\n                .contentShape(<span class="hljs-type">Circle</span>())\n        })\n        .background(\n            <span class="hljs-type">LikeToggleBackground</span>(isHighlighted: configuration.isOn, shape: <span class="hljs-type">Circle</span>())\n        )\n    }\n}\n</code></pre>\n<p data-nodeid="1933">要配置<code data-backticks="1" data-nodeid="2403">Toggle</code>的显示风格，我们需要实现<code data-backticks="1" data-nodeid="2405">makeBody(configuration:)</code>方法来返回一个<code data-backticks="1" data-nodeid="2407">View</code>。在这个<code data-backticks="1" data-nodeid="2409">View</code>里面包含了一个<code data-backticks="1" data-nodeid="2411">Button</code>组件来处理用户的点击事件，当用户点击的时候，我们会改变了<code data-backticks="1" data-nodeid="2413">isOn</code>属性的值。除了按钮以外，我们还使用了<code data-backticks="1" data-nodeid="2415">label</code>参数把<code data-backticks="1" data-nodeid="2417">Toggle</code>配置成圆形，并通过<code data-backticks="1" data-nodeid="2419">background()</code>方法来进行绘制，绘制 UI 的代码都封装在<code data-backticks="1" data-nodeid="2421">LikeToggleBackground</code>里面。下面一起看看它的实现代码：</p>\n<pre class="lang-swift" data-nodeid="1934"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LikeToggleBackground</span>&lt;<span class="hljs-title">S</span>: <span class="hljs-title">Shape</span>&gt;: <span class="hljs-title">View</span> </span>{\n    <span class="hljs-keyword">var</span> isHighlighted: <span class="hljs-type">Bool</span>\n    <span class="hljs-keyword">var</span> shape: <span class="hljs-type">S</span>\n    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {\n        <span class="hljs-type">ZStack</span> {\n            <span class="hljs-keyword">if</span> isHighlighted {\n                shape\n                    .fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillEnd"</span>), <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillStart"</span>)))\n                    .overlay(shape.stroke(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillStart"</span>), <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillEnd"</span>)), lineWidth: <span class="hljs-number">2</span>))\n                    .shadow(color: <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonStart"</span>), radius: <span class="hljs-number">5</span>, x: <span class="hljs-number">5</span>, y: <span class="hljs-number">5</span>)\n                    .shadow(color: <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonEnd"</span>), radius: <span class="hljs-number">5</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)\n            } <span class="hljs-keyword">else</span> {\n                shape\n                    .fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillStart"</span>), <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillEnd"</span>)))\n                    .overlay(shape.stroke(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillStart"</span>), <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonFillEnd"</span>)), lineWidth: <span class="hljs-number">2</span>))\n                    .shadow(color: <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonStart"</span>), radius: <span class="hljs-number">5</span>, x: <span class="hljs-number">5</span>, y: <span class="hljs-number">5</span>)\n                    .shadow(color: <span class="hljs-type">Color</span>(<span class="hljs-string">"likeButtonEnd"</span>), radius: <span class="hljs-number">5</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)\n            }\n        }\n    }\n}\n</code></pre>\n<p data-nodeid="1935">在<code data-backticks="1" data-nodeid="2424">LikeToggleBackground</code>里面，我们根据<code data-backticks="1" data-nodeid="2426">isHighlighted</code>属性的选中状态，为图形填充不同的颜色和阴影效果，从而做出丝绸材质的效果。<br>\n最后看看朋友圈信息视图的外层显示风格，代码如下：</p>\n<pre class="lang-swift" data-nodeid="1936"><code data-language="swift">.frame(maxWidth:.infinity)\n.padding(<span class="hljs-type">EdgeInsets</span>(top: <span class="hljs-type">Spacing</span>.medium, leading: <span class="hljs-number">0</span>, bottom: <span class="hljs-type">Spacing</span>.medium, trailing: <span class="hljs-number">0</span>))\n.background(<span class="hljs-type">BlurView</span>(style: .systemMaterial))\n.clipShape(<span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">30</span>, style: .continuous))\n.shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.15</span>), radius: <span class="hljs-number">20</span>, x: <span class="hljs-number">0</span>, y: <span class="hljs-number">20</span>)\n.padding(.horizontal)\n</code></pre>\n<p data-nodeid="1937">我们调用<code data-backticks="1" data-nodeid="2431">frame(maxWidth:.infinity)</code>和<code data-backticks="1" data-nodeid="2433">padding(.horizontal)</code>方法把<code data-backticks="1" data-nodeid="2435">SwiftUIMomentListItemView</code>的宽度设为设备大小并减去左右两边的留白间距。<code data-backticks="1" data-nodeid="2437">padding(EdgeInsets())</code>方法用于添加上下的间距。通过把自定义的<code data-backticks="1" data-nodeid="2439">BlurView</code>传递给<code data-backticks="1" data-nodeid="2441">background()</code>方法，我们就能实现毛玻璃的显示效果；调用<code data-backticks="1" data-nodeid="2443">clipShape()</code>方法可以来设置大圆角的效果；而调用<code data-backticks="1" data-nodeid="2445">shadow()</code>方法就能完成配置阴影的效果，从而使得朋友圈信息视图有浮动起来的特效。</p>\n<p data-nodeid="1938">到此为止，我们已经使用 SwiftUI 实现了整个 View 层了，最后看一下实现的效果，如下动图：</p>\n<p data-nodeid="1939"><img src="https://s0.lgstatic.com/i/image6/M00/44/24/CioPOWC90g2ANeBIAAWrFoNi17Q433.png" alt="Drawing 5.png" data-nodeid="2450"></p>\n<h3 data-nodeid="1940">总结</h3>\n<p data-nodeid="1941">在这一讲，我们介绍了 SwiftUI 管理状态的几种方法，它们之间有些细微的区别，搞清楚它们的工作原理能帮助我们在实践中选择出合适的方法。</p>\n<p data-nodeid="1942">另外，我们还讲述了如何使用 SwiftUI 重新实现 Moments App 的 UI 层。你可能已经发现了，在实现的过程中，我们完全没有改动原有的代码，只是在原有代码的基础上进行扩展。一套灵活的框架能帮助我们不断扩展新功能，并无缝引入新技术。</p>\n<p data-nodeid="1943">作为开发者，学习新东西已经成为我们生活的一部分。我建议你多花点时间学习一下 SwiftUI，因为现在很多新功能（例如 Widget）只能使用 SwiftUI 进行开发了。后续随着 SwiftUI 的不断成熟，再加上用户设备上 iOS 版本的更新，SwiftUI 慢慢会成为 iOS 乃至苹果所有操作系统开发的主流。</p>\n<p data-nodeid="1944"><strong data-nodeid="2458">思考题</strong></p>\n<blockquote data-nodeid="1945">\n<p data-nodeid="1946">请问你在实际工作中使用过 SwiftUI 吗？能分享一下你的使用经验吗？</p>\n</blockquote>\n<p data-nodeid="1947">可以把你心得体会写到留言区哦。到此为止，整个课程就学习完毕了，下一讲是结束语，我会把整个课程做一个简单的梳理和串讲，也相当于我们课程的一个小结吧，记住按时来听课哦。</p>\n<p data-nodeid="1948"><strong data-nodeid="2464">源码地址</strong></p>\n<blockquote data-nodeid="1949">\n<p data-nodeid="1950" class="">SwiftUI 实现的 PR：<a href="https://github.com/lagoueduCol/iOS-linyongjian/pull/13?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2468">https://github.com/lagoueduCol/iOS-linyongjian/pull/13</a></p>\n</blockquote>',
          },
        ],
      },
      {
        sectionName: '结束语',
        sectionId: 6,
        courseList: [
          {
            theme: '结束语 | 眼见千遍，不如手过一遍',
            id: 60,
            content:
              '<p data-nodeid="777" class="">首先，我要说一句：恭喜你完成了整个课程的学习！当然，我也很感谢你这四个月来的陪伴和支持！相信通过这个课程的学习，你会对 iOS 开发有了一个整体的认识和理解了。不过，在这最后的结束语中，我还是想强调一下：提升技术最有效的办法是动手实践，眼见千遍，不如手过一遍。</p>\n<p data-nodeid="778">那怎么来“手过一遍”呢？下面我就结合课程的内容来给你提供一条实践路径，你可以使用它来提高架构和编码能力，以及推动项目的自动化和工程化进程。</p>\n<p data-nodeid="779">第一步，我建议你<strong data-nodeid="816">先搭建一个统一的开发环境</strong>。磨刀不误砍柴工，统一的开发环境是项目规范化和自动化的基础。你可以通过<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6654&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="803">《01 | 开发环境：如何使用 Ruby 工具链统一开发环境？》</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6655&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="808">《02 | 依赖管理：如何使用 CocoaPods 统一依赖库的管理？ 》</a>和<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6656&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="814">《03 | 配置准备：如何搭建多环境支持，为 App 开发作准备》</a>的学习来为团队搭建统一的开发环境。该环境包括统一的开发工具和 Ruby 工具链、统一的依赖库管理，以及为 App 配置开发、测试和生产等不同运行版本。</p>\n<p data-nodeid="780">有了统一的环境以后，接下来我建议你<strong data-nodeid="839">使用 fastlane 来开发自动化脚本</strong>，以减少大量重复的手工操作。课程的<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6658&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="826">《05 | 自动化准备：如何使用 fastlane 管理自动化操作？》</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6679&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="831">《24 | 解决打包痛点：如何统一管理 Certificates 和 Profiles？》</a>和<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6680&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="837">《25 | 自动化构建：解决大量重复性人力工作神器》</a>中详细讲述了如何使用 fastlane 管理私钥、Certificates 和 Provisioning Profiles，以及如何自动化打包、签名和发布等操作。从时间成本来看，开发自动化脚本的投入收益率非常最高，你可以参考这些文章以及 Moments App 的 Fastfile 文件来为项目定制一套顺手的自动化配置。</p>\n<p data-nodeid="971" class="">完成自动化脚本的开发以后，你就可以在任何一台机器上进行打包、签名和发布了。为了进一步推动工程化建设，你可以<strong data-nodeid="989">搭建 CI 来完成无人手交付</strong>。要搭建 CI，就要先统一代码的管理流程，这个你可以参考<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6659&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="981">《06 | 代码管理：如何使用 Git 与 GitHub 统一代码管理流程？》</a>来规范代码管理流程，然后参考<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6681&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="987">《26 | 持续集成：如何实现无需人手的快速交付？》</a>来搭建你所需的 CI，例如使用 Travis CI 来搭建全服务 CI，当然也可以随着团队发展升级为云端虚拟机 CI 乃至全手工维护 CI。CI 不仅能优化构建、测试和发布流程，从而保证产品的快速交付，同时也能推动工程化进程。因此，可以利用 CI 来优化流程并推进工程师文化的建设。</p>\n\n<p data-nodeid="782">假如你成功搭建了 CI，相信已经为团队节省了大量的时间，再接下来就可以把精力专注在推动产品的快速迭代和优化上面了。</p>\n<p data-nodeid="1378" class="te-preview-highlight">从课程留言反馈来看，功能开关是一个非常实用的功能，它能帮助我们分离开发、测试和产品环境，并能帮助测试人员和产品经理快速验证产品的功能。你可以参考<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6662&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1384">《09 | 开关组件：如何使用功能开关，支持产品快速迭代》</a>和<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6663&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1390">《10 | 支撑组件：如何实现隐藏菜单，快速测试与验证？》</a>来<strong data-nodeid="1396">实现功能开关和隐藏菜单</strong>。</p>\n\n<p data-nodeid="784">为了进一步优化线上的 App，我建议所有的 App 都<strong data-nodeid="904">添加统计分析服务、崩溃和性能监控以及执行 A/B 测试</strong>。引入这些服务的开发成本都非常低，具体操作可以参考<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6682&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="886">《27 | 统计分析：如何架构灵活的统计分析服务，助力产品增长？》</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6683&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="891">《28 | 崩溃报告：如何借助崩溃报告解决线上的 Bug？》</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6684&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="896">《29 | 远程开关：如何远程遥控上线 App 的产品行为？》</a>和<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6685&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="902">《30 | A/B 测试：如何用 A/B 测试协助产品抉择？》</a>。</p>\n<p data-nodeid="785">除此之外，你还可以根据自身的需求为 App<strong data-nodeid="927">添加多语言、动态字体或者深色模式的支持</strong>，这样能帮助你把 App 推广到更广阔的用户群。这些功能都相对独立，可以参考<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6665&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="914">《12 | 功能组件：如何设置多语言支持，为全球化做准备？》</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6666&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="919">《13 | 功能组件：如何设置动态字体，提升视力辅助功能？》</a>和<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6667&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="925">《14 | 功能组件：如何使用语义色，支持深色模式？》</a>来选择实施。</p>\n<p data-nodeid="786">这里再看一下 App 的架构与实现。从课程留言反馈来看，组件化是大家最为关心的一个主题。其实，我们课程中有好几讲都与组件化相关。以我的理解，<strong data-nodeid="939">组件化主要由两大部分组成：逻辑上的解耦和物理上的分离</strong>。物理上的分离相对简单，通常使用依赖管理工具来完成，我们在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6661&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="937">《08 | 设计组件：DesignKit 组件桥接设计与开发规范》</a>里讲述了如何使用 CocoaPods 来管理内部的 Pod。从技术深度来看，这方面属于“术”，遇到问题可以通过查看文档等方式得以很好地解决。在组件化的建设道路上，我认为最为重要的是如何实现架构上的解耦和分层，以及理顺各个模块之间的单向依赖关系。只要模块内部的职责定义好，模块之间的依赖关系设计好，要实现物理上的分离就变成水到渠成的事情了。反过来，如果代码的架构没有解耦，模块之间彼此依赖，就无法把模块进行物理分离了。由此可见，实现逻辑上的解耦属于“道”，是我们关注的重点。</p>\n<p data-nodeid="787">那怎么才能设计一个责任清晰的模块呢？又该如何理顺模块间的依赖关系呢？我们在课程的“模块三：架构与实现”中详细讲述了如何使用 BFF 和 MVVM 来进行 App 的架构，并介绍了 MVVM 内每一层的架构与实现方式。在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6687&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="945">《32 | UI 替换：如何使用 SwiftUI 快速替换原有 UI？》</a>中还进一步讲解了如何在不改动其他模块的情况下把 UIKit 替换成 SwiftUI，想必你已经见识到这套架构的威力了。当然，这并不代表课程里的架构就是默认的或者标准的 MVVM 实现方式，软件架构领域根本就没有什么一成不变的标准方案，一套好的方案应该可以根据需求的变化而不断地迭代与改进。在课程里面，我们沿用了一些通用的原则，例如单一责任原则和开闭原则等进行架构和设计。遵循这些原则，我们就能开发出具备可重用、可扩展和可维护等特性的高质量代码。我希望你在学习完这个课程以后能灵活运行那些原则来架构和设计 App，而不是简单地照搬 Moments App 上的实现。</p>\n<p data-nodeid="788">假如你自己编写完了代码，那怎样才能验证这些代码是否具备高质量呢？<strong data-nodeid="958">单元测试是检验代码质量的一种有效办法</strong>，因为单元测试能强迫我们厘清模块内部的责任，并且强迫我们使用依赖注入的方式来管理模块之间的依赖关系。你可以参考<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=657&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6678&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="956">《23 | TDD 与单元测试：如何保证功能模块的高质量？》</a>来看看如何进行单元测试。</p>\n<p data-nodeid="789">最后，我想说的是：<strong data-nodeid="964">写代码是一门手艺活</strong>。我们整个课程的所有知识点都是通过 Moments App 表现出来的，你要融会贯通，把所学应用到实际工作中，动手实践是关键，我建议你把 Moments App 的代码从 GitHub 下载下来，然后对照课程思考为什么这样做、这样做有什么优缺点，等等。</p>\n<p data-nodeid="790">关于这个课程，我是从去年 9 月份开始编写 Moments App 的代码，然后梳理大纲，分类知识点并完善 Moments App 的架构与实现，最后再编写文章和反复审核，历经了整整 9 个月的时间。这段时间不仅仅是一个输出的过程，更多的是我对自己多年来经验的总结与提炼，是一个自我提升的过程。很感谢拉勾教育团队给予我分享经验的机会，还有再次感谢有你相伴，希望在移动开发的道路上一起并肩前行。</p>\n<p data-nodeid="791" class="">这里我也邀请你参与对本课程的评价，你的每一个意见或建议对我来说都是很重要的。<a href="https://wj.qq.com/s2/8564745/5905/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="969">点击链接，即可参与评价</a>，还有机会获得惊喜奖品哦！</p>',
          },
        ],
      },
    ],
  },
};
