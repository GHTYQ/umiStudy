export default {
  'GET /api/lago/courseList/react': {
    data: [
      {
        sectionName: '开篇词',
        sectionId: 1,
        courseList: [
          {
            theme: '开篇词 | 这一次，真正吃透 React 知识链路与底层逻辑',
            id: 21,
            content:
              '<p data-nodeid="841" class="">在接下来的一段时间里，我们将一起深入 React 这个框架领域，完成从“小工”到“专家”的蜕变。</p>\n<p data-nodeid="842">作为一名React 重度用户，与其说我对 React 源码、底层原理及周边生态有着较为深入的探究，不如说我对它们有着浓厚的兴趣。早期，我专注于性能优化和前端工程化，曾将线上大型应用性能提升率做到 40%，并基于 React 打造过团队新基建。此外，我还担任过多年一线前端面试官，积累了丰富的面试经验。</p>\n<p data-nodeid="843">前端生涯至今，我从未停止过挑战自己的能力边界，始终乐于拥抱新的技术和工具，这不止让我保持了很好的职场竞争力，还使我深知新手从入门到精通过程中的痛点和难点。</p>\n<p data-nodeid="844">作为一线开发者，我不认同技术圈时下盛行的“造名词”风气，痛恨故弄玄虚的“语言壁垒”——其实<strong data-nodeid="911">技术本身在多数情况下都是一些简单且有趣的东西，人们越是试图神化它，越容易脱离技术本质</strong>。这也是我在这个专栏中秉持和践行的一个原则。</p>\n<h3 data-nodeid="845">学好 React，到底有多爽？</h3>\n<p data-nodeid="846"><img src="https://s0.lgstatic.com/i/image/M00/5D/40/CgqCHl-ECi-Aeep6AACZ17MFsQw154.png" alt="Lark20201012-154736.png" data-nodeid="915"></p>\n<p data-nodeid="847">在过去的几年，“变化”始终是前端框架世界里的一号关键词：前有 jQuery 刚刚式微时各路神仙各显神通，后有 React/Vue/Angular 三分天下，如今又渐渐演变成了 React/Vue 两分天下。</p>\n<p data-nodeid="848">而反观框架本身，你会发现 Vue、React 乃至 Angular 之间不仅写法越来越像，甚至在设计层面也日渐趋同——它们似乎像是约好了一样，在齐刷刷地朝着 WebComponents 标准前进。因此在展望未来的前端框架时，我们有充分的理由相信，属于前端框架的一号关键词终有一日会从“变化”发展为“稳定”或“标准化”。</p>\n<p data-nodeid="849">在这样的趋势下，站在任何主观视角去拉踩任何前端框架的行为都是不合适的。<strong data-nodeid="923">学习者在意的不应是“哪个框架最牛”这样娱乐性的问题，而应该是学习的效用</strong>。</p>\n<p data-nodeid="850">那么学习 React，将会带来什么样的效用呢？</p>\n<h4 data-nodeid="851">利好个人职业生涯：大厂更喜欢 React</h4>\n<p data-nodeid="852">若单说岗位数量，我不敢妄言，但<strong data-nodeid="935">在一二线的互联网大厂中，React 的绝对优势凸显无疑。</strong>（比如，阿里就统一使用 React 作为底层技术栈，并且在内部紧密共建 React 生态。）国外的一份<a href="https://2019.stateofjs.com/front-end-frameworks/" data-nodeid="933">“2019 年度 JavaScript 趋势报告”</a>中，React 也被评估为综合指数最高的前端框架：</p>\n<p data-nodeid="853"><img src="https://s0.lgstatic.com/i/image/M00/5D/1E/CgqCHl-D4tuAIhZGAACpSU_Pme8543.png" alt="Drawing 0.png" data-nodeid="938"></p>\n<p data-nodeid="854">在招聘上，大厂普遍青睐 React 人才，各种高薪职位中不乏“精通 React”“掌握 React”的字眼。作为前端，我们必须认识到这样一个现状：<strong data-nodeid="944">大厂（包括国内、国外）更喜欢 React，当我们立下一个有朝一日进大厂的志愿时，就意味着必须先下定决心搞定 React</strong>。</p>\n<p data-nodeid="855"><img src="https://s0.lgstatic.com/i/image/M00/5D/13/Ciqc1F-D4uWAEDz9AACMs7KhhTk568.png" alt="Drawing 1.png" data-nodeid="947"></p>\n<div data-nodeid="856"><p style="text-align:center">（信息来源：拉勾网）</p></div>\n<h4 data-nodeid="857">强化项目实战能力：吃透 React，疑难杂症不在话下</h4>\n<p data-nodeid="858">面试时，React 相关的问题往往具备较高的区分度，能够在 React 方面脱颖而出的候选人并不多。很多时候，候选人似乎也确实不理解面试官“为什么要问得这么难”。比如常见的吐槽就有“我不读源码，不研究调用栈，用 React 写业务照样一把梭”这样的说辞。</p>\n<p data-nodeid="859">确实，通过阅读 React 文档以及市面上一些“快速上手”“XX 实战”类型的学习材料，也能胜任一定的业务开发工作，但当业务复杂度攀升，“奇形怪状”的问题就会如雨后春笋般接连冒头。当你对 React 的运行机制不甚了解时，遇到这样的“疑难杂症”，就很容易懵掉。</p>\n<p data-nodeid="860">面试环节的 React 深度考察，正是为了筛选出这些能够真正吃透 React、解决复杂问题的“高级玩家”：<strong data-nodeid="960">对 React 的理解深度</strong>，<strong data-nodeid="961">将决定着你所能解决的实战问题复杂度的上限</strong>。</p>\n<h4 data-nodeid="861">普通开发者的“逆袭”机会：一个好的框架，就是最好的老师</h4>\n<p data-nodeid="862">这两年，许多中小型公司的前端工程师都面临着这样一个困境：<strong data-nodeid="968">业务含金量不高，老板又不重视，技术专项难以提取，架构机会更是没有……好像永远都没办法破局，难道我这辈子就这样了吗</strong>？</p>\n<p data-nodeid="863">当然不是！当环境无法给我们提供优质的成长途径时，不妨自己尝试创造途径，比如：</p>\n<ul data-nodeid="864">\n<li data-nodeid="865">\n<p data-nodeid="866">深挖一个优质的前端框架，吃透其底层原理；</p>\n</li>\n<li data-nodeid="867">\n<p data-nodeid="868">跟框架作者（React 团队）学架构思想、学编码规范、学设计模式。</p>\n</li>\n</ul>\n<p data-nodeid="869">React 正是一个优秀前端框架的典型 ，它在架构上融合了数据驱动视图、组件化、函数式编程、面向对象、Fiber 等经典设计“哲学”，在底层技术选型上涉及了 JSX、虚拟 DOM 等经典解决方案，在周边生态上至少涵盖了状态管理和前端路由两大领域的最佳实践。此外，它还自建了状态管理机制与事件系统，创造性地在前端框架中引入了 Hooks 思想...... React 十年如一日的稳定输出背后，有太多值得我们去吸收和借鉴的东西。</p>\n<p data-nodeid="870">这个专栏我将带你掌握目前行业里相对前沿且具有代表性的一套东西，也是真正能够在你的职业生涯里沉淀下来、发挥长期效用的“底层技能”。</p>\n<h3 data-nodeid="871">React 为什么这么难学？</h3>\n<p data-nodeid="872">在实际的招聘过程中，我和同事都曾经不止一次地发过这样的感慨：<strong data-nodeid="980">当下要想从社区招到一个符合预期的 React 开发，真的太太太太太太难了</strong>。</p>\n<p data-nodeid="873">不知道你有没有观察到一个比较有趣的现象：Vue 知识体系/原理的相关内容百花齐放，但 React 知识体系/原理的相关内容却屈指可数。</p>\n<p data-nodeid="874">市面上以 React 为主题的进阶性内容，大部分是在教会一系列 API 的基础上，描述如何去实战一个具体的项目，即专精于“使用”；而为数不多的源码分析性内容，虽然试图去拆解“原理”，但却往往伴随着细化到逐行代码的知识粒度，对读者的时间、耐力和既有水平（提炼知识、抽象知识的能力）都提出了很高的要求。</p>\n<p data-nodeid="875">这些现象的背后，和 React 令人望而却步的庞大知识体系、精密复杂的底层原理以及长长的知识链路是分不开的。平心而论，学透 React 很难，而我想帮你解决的，也正是这个“难”。</p>\n<h3 data-nodeid="876">课程设计：串联知识链路，讲透底层逻辑</h3>\n<p data-nodeid="3600" class="te-preview-highlight">我分享技术内容有两年多了，一直将“接地气、说人话”作为写作的第一要务，这个专栏更是将“<strong data-nodeid="3606">把复杂的问题简单化、把琐碎的问题系统化</strong>”作为课程设计的核心原则。它并非平铺直叙的学习笔记，而是一次我与你之间的对话。</p>\n\n\n\n\n\n\n\n<p data-nodeid="878">我希望做一个能够将学习体验与知识深度中和到最佳状态，切实为你带来学习效用的专栏。为此，专栏在设计层面做了以下几件事情。</p>\n<h4 data-nodeid="879">设计原则：贴着大厂面试逻辑做大纲，贴着源码讲原理</h4>\n<p data-nodeid="880">大厂的 React 面试不是走过场，更不是“造火箭”式的炫技，它是最有“效用导向”的一个学习依据。如果能够将大厂面试的逻辑利用充分，我们将实现面试和应用的双重突破。</p>\n<p data-nodeid="881">贴着源码讲原理，绝不是带着你死磕源码，源码 !== 原理，源码是代码，而原理是逻辑，代码是繁杂冗长的，原理却可以是简洁清晰的。在一些场景下，源码确实能够成为一个不错的教具，但阅读源码不是抵达原理的唯一途径。因此，必要时我会提取对你理解问题有帮助的源码；也会在一些场景下选取其他的教具，确保你能够用正确且高效的姿势抵达知识的重点。</p>\n<p data-nodeid="882">专栏所涉及的原理，<strong data-nodeid="1002">可以帮你解决实际工作中的大多数疑难杂症，也可以 Match 上大厂对资深前端工程师的技术深度的要求</strong>。</p>\n<h4 data-nodeid="883">对于体系性较强的知识：创建足够充分的上下文</h4>\n<p data-nodeid="884" class="">之前曾经读到过木心关于红楼梦的书评，印象极深：“红楼梦中的诗词像是水中摇曳的水草，美极。若是捞出来看，就干巴巴了。”</p>\n<p data-nodeid="885">同样的道理也适用于 React 的知识链路：<strong data-nodeid="1010">一些知识之所以难学，不是因为它有多复杂，而是因为理解它是需要上下文的</strong>。你若把它放到正确的上下文里，可能想通这件事也就是一瞬间的工夫；但如果你的学习上下文是断裂的，那么知识点本身自然会变得“干巴巴”，难以下咽。</p>\n<h4 data-nodeid="886">对于复杂度较高的知识：用现象向原理提问</h4>\n<p data-nodeid="887">考虑来学习这门专栏的同学的学习阶段参差不齐，我在讲解复杂原理时，会尽量遵循“<strong data-nodeid="1017">先提现象/问题，再挖原理</strong>”这个顺序，将困难知识的学习坡度降至最低。专栏中有一些内容的前置知识，我写得比较细，一般也会提前标明这是“先导知识”，如果你是高端玩家，直接跳过即可。</p>\n<p data-nodeid="888">整个专栏的结构规划思路如下。</p>\n<ul data-nodeid="889">\n<li data-nodeid="890">\n<p data-nodeid="891"><strong data-nodeid="1023">模块一：基础夯实</strong>。这部分内容涉及 React 的基本原理和源码，对大多数人普遍薄弱的、说不清楚的基础知识做深入浅出的讲解，帮你突破一些重点和难点。</p>\n</li>\n<li data-nodeid="892">\n<p data-nodeid="893"><strong data-nodeid="1028">模块二：核心原理</strong>。这部分内容源于日常开发中的疑难杂症、大厂面试的压轴难题，呈现出框架的底层逻辑和源码设计，我将用最少的篇幅来提取尽量多的信息。如果你想要从事一些高级岗位，或者精通 React，那么这块的内容你肯定避不开，而面试官能够通过这些内容，对候选人的能力做一个评价，甚至是定级。</p>\n</li>\n<li data-nodeid="894">\n<p data-nodeid="895"><strong data-nodeid="1033">模块三：周边生态</strong>。很多人用过 Redux、听说过 React-Router，但为什么要用它？其背后的工作原理、设计思想又是怎样的？专栏要讲的就是这部分比较有区分度的内容，面向使用过 React 全家桶，或者接触过还不具备熟练使用能力的前端工程师，解决你出了 Bug 却不知如何调试的问题。</p>\n</li>\n<li data-nodeid="896">\n<p data-nodeid="897"><strong data-nodeid="1038">模块四：生产实践</strong>。对于一个优秀的前端应用来说，性能和设计模式是永恒的主题，性能决定用户体验，设计模式决定研发效率。这部分将结合我团队的实践经验以及当下行业里推崇的最佳实践，为你输出实战观点。对于这些最佳实践，你不仅要知道怎么做，还要理解“为什么这么做”。学完个模块可以强化你的实际应用能力，提升自主研发创新实践的线索和灵感。</p>\n</li>\n</ul>\n<p data-nodeid="898"><img src="https://s0.lgstatic.com/i/image/M00/7E/2E/CgqCHl_O8AiAMsLrAAOzA7Lqfa0393.png" alt="Lark20201208-111532.png" data-nodeid="1041"></p>\n<h3 data-nodeid="899">讲师寄语</h3>\n<p data-nodeid="900"><strong data-nodeid="1047">我认为，学习的本质是重复</strong>，对于重要的知识，我会翻来覆去地说，想方设法让你记住它。所以，如果你在学习过程中发现某一块知识似曾相识或者早已埋下伏笔，多半意味着你发现了一个重难点，请牢牢抓住它。</p>\n<p data-nodeid="901">为了将晦涩的知识转化为你手里实实在在的生产力，专栏的框架和内容也历经了多次的迭代和重构。每一次的果断推翻早期设想，每一次的重构表达逻辑，都是希望帮你更好地消化吸收这份知识。希望你也能够不吝耐心和智慧，顺利走完整个 React 学习曲线中最难的一段路。</p>\n<p data-nodeid="902" class="">到这里，我的故事就结束了，而你和我的故事才刚刚开始。欢迎在留言区分享你的前端经历，或者写写学习 React 过程中遇到的问题、想要学习的内容，让我们一起写出“我们”的故事，开启 React 奇幻之旅。</p>',
          },
        ],
      },
      {
        sectionName: '模块一：系统深入学习“基础知识”',
        sectionId: 2,
        courseList: [
          {
            theme: '01 | JSX 代码是如何“摇身一变”成为 DOM 的？',
            id: 22,
            content:
              '<p data-nodeid="1113" class="">时下虽然接入 JSX 语法的框架越来越多，但与之缘分最深的毫无疑问仍然是 React。2013 年，当 React 带着 JSX 横空出世时，社区曾对 JSX 有过不少的争议，但如今，越来越多的人面对 JSX 都要说上一句“真香”！本课时我们就来一起认识下这个“真香”的 JSX，聊一聊“JSX 代码是如何‘摇身一变’成为 DOM 的”。</p>\n<h3 data-nodeid="1114">关于 JSX 的 3 个“大问题”</h3>\n<p data-nodeid="1115">在日常的 React 开发工作中，我们已经习惯了使用 JSX 来描述 React 的组件内容。关于 JSX 语法本身，相信每位 React 开发者都不陌生。这里我用一个简单的 React 组件，来帮你迅速地唤醒自己脑海中与 JSX 相关的记忆。下面这个组件中的 render 方法返回值，就是用 JSX 代码来填充的：</p>\n<pre class="lang-js" data-nodeid="1116"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"title"</span>&gt;</span>I am the title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"content"</span>&gt;</span>I am the content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);\nReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);\n</code></pre>\n<p data-nodeid="1117">由于本专栏的整体目标是帮助你在 React 这个领域完成从“小工”到“行家”的进阶，此处我无意再去带你反复咀嚼 JSX 的基础语法，而是希望能够引导你去探寻 JSX 背后的故事。针对这“背后的故事”，我总结了 3 个最具代表性和区分度的问题。</p>\n<p data-nodeid="1118">在开始正式讲解之前，我希望你能在自己心中尝试回答这 3 个问题：</p>\n<ul data-nodeid="1119">\n<li data-nodeid="1120">\n<p data-nodeid="1121">JSX 的本质是什么，它和 JS 之间到底是什么关系？</p>\n</li>\n<li data-nodeid="1122">\n<p data-nodeid="1123">为什么要用 JSX？不用会有什么后果？</p>\n</li>\n<li data-nodeid="1124">\n<p data-nodeid="1125">JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？</p>\n</li>\n</ul>\n<p data-nodeid="1126">面对以上问题，如果你无法形成清晰且系统的思路，那么很可能是你把 JSX 想得过于简单了。大多数人只是简单地把它理解为模板语法的一种，但事实上，JSX 作为 React 框架的一大特色，它与 React 本身的运作机制之间存在着千丝万缕的联系。</p>\n<p data-nodeid="1127">上述 3 个问题的答案，就恰恰隐藏在这层“联系”中，在面试场景下，候选人对这层“联系”吃得透不透，是我们评价其在 React 方面是否“资深”的一个重要依据。</p>\n<p data-nodeid="1128">接下来，我就将带你由表及里地起底 JSX 相关的底层原理，帮助你吃透这层“联系”，建立起强大的理论自信。你可以将“能够用自己的话回答上面 3 个问题”来作为本课时的学习目标，待课时结束后，记得回来检验自己的学习成果^_^。</p>\n<h3 data-nodeid="1129">JSX 的本质：JavaScript 的语法扩展</h3>\n<p data-nodeid="1130">JSX 到底是什么，我们先来看看 <a href="https://reactjs.org/docs/glossary.html#jsx" data-nodeid="1217">React 官网</a>给出的一段定义：</p>\n<blockquote data-nodeid="1131">\n<p data-nodeid="1132">JSX 是 JavaScript 的一种语法扩展，它和模板语言很接近，但是它充分具备 JavaScript 的能力。</p>\n</blockquote>\n<p data-nodeid="1133">“语法扩展”这一点在理解上几乎不会产生歧义，不过“它充分具备 JavaScript 的能力”这句，却总让人摸不着头脑，JSX 和 JS 怎么看也不像是一路人啊？这就引出了“<strong data-nodeid="1225">JSX 语法是如何在 JavaScript 中生效的</strong>”这个问题。</p>\n<h4 data-nodeid="1134">JSX 语法是如何在 JavaScript 中生效的：认识 Babel</h4>\n<p data-nodeid="1135">Facebook 公司给 JSX 的定位是 JavaScript 的“扩展”，而非 JavaScript 的“某个版本”，这就直接决定了浏览器并不会像天然支持 JavaScript 一样地支持 JSX。那么，JSX 的语法是如何在 JavaScript 中生效的呢？<a href="https://reactjs.org/docs/glossary.html#jsx" data-nodeid="1230">React 官网</a>其实早已给过我们线索：</p>\n<blockquote data-nodeid="1136">\n<p data-nodeid="1137">JSX 会被编译为 React.createElement()，&nbsp;React.createElement() 将返回一个叫作“React Element”的 JS 对象。</p>\n</blockquote>\n<p data-nodeid="1138">这里提到，JSX 在被<strong data-nodeid="1238">编译</strong>后，会变成一个针对 React.createElement 的调用，此时你大可不必急于关注 React.createElement 这个 API 到底做了什么（下文会单独讲解）。咱们先来说说这个“编译”是怎么回事：“编译”这个动作，是由 Babel 来完成的。</p>\n<p data-nodeid="1139"><strong data-nodeid="1242">什么是 Babel 呢？</strong></p>\n<blockquote data-nodeid="1140">\n<p data-nodeid="1141">Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。<br>\n—— Babel 官网</p>\n</blockquote>\n<p data-nodeid="1142">比如说，ES2015+ 版本推出了一种名为“模板字符串”的新语法，这种语法在一些低版本的浏览器里并不兼容。下面是一段模板字符串的示例代码：</p>\n<pre class="lang-java" data-nodeid="1143"><code data-language="java"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"Guy Fieri"</span>;\n<span class="hljs-keyword">var</span> place = <span class="hljs-string">"Flavortown"</span>;\n`Hello ${name}, ready <span class="hljs-keyword">for</span> ${place}?`;\n</code></pre>\n<p data-nodeid="1144">Babel 就可以帮我们把这段代码转换为大部分低版本浏览器也能够识别的 ES5 代码：</p>\n<pre class="lang-java" data-nodeid="1145"><code data-language="java"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"Guy Fieri"</span>;\n<span class="hljs-keyword">var</span> place = <span class="hljs-string">"Flavortown"</span>;\n<span class="hljs-string">"Hello "</span>.concat(name, <span class="hljs-string">", ready for "</span>).concat(place, <span class="hljs-string">"?"</span>);\n</code></pre>\n<p data-nodeid="1146">类似的，<strong data-nodeid="1255">Babel 也具备将 JSX 语法转换为 JavaScript 代码的能力</strong>。<br>\n那么 Babel 具体会将 JSX 处理成什么样子呢？我们不如直接打开 Babel 的 playground 来看一看。这里我仍然键入文章开头示例代码中的JSX 部分：</p>\n<p data-nodeid="1147"><img src="https://s0.lgstatic.com/i/image/M00/5C/73/CgqCHl-BegWAbxNEAAH9HxafvWE988.png" alt="Drawing 0.png" data-nodeid="1258"></p>\n<p data-nodeid="1148">可以看到，所有的 JSX 标签都被转化成了 React.createElement 调用，这也就意味着，我们写的 JSX 其实写的就是 React.createElement，虽然它看起来有点像 HTML，但也只是“看起来像”而已。<strong data-nodeid="1272">JSX 的本质是</strong>React.createElement<strong data-nodeid="1273">这个 JavaScript 调用的语法糖</strong>，这也就完美地呼应上了 React 官方给出的“<strong data-nodeid="1274">JSX 充分具备 JavaScript 的能力</strong>”这句话。</p>\n<h4 data-nodeid="1149">React 选用 JSX 语法的动机</h4>\n<p data-nodeid="1150">换个角度想想，既然 JSX 等价于一次 React.createElement 调用，那么 React 官方为什么不直接引导我们用 React.createElement 来创建元素呢？</p>\n<p data-nodeid="1151">原因非常简单，我们来看一个相对复杂一些的组件的 JSX 代码和 React.createElement 调用之间的对比。它们各自的形态如下图所示，图中左侧是 JSX 代码，右侧是 React.createElement 调用：</p>\n<p data-nodeid="1152"><img src="https://s0.lgstatic.com/i/image/M00/5C/73/CgqCHl-Beg-AXBihAA4t3S7nxKc532.png" alt="Drawing 1.png" data-nodeid="1280"></p>\n<p data-nodeid="1153">你会发现，在实际功能效果一致的前提下，JSX 代码层次分明、嵌套关系清晰；而 React.createElement 代码则给人一种非常混乱的“杂糅感”，这样的代码不仅读起来不友好，写起来也费劲。</p>\n<p data-nodeid="1154"><strong data-nodeid="1285">JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML 标签语法来创建虚拟 DOM，在降低学习成本的同时，也提升了研发效率与研发体验。</strong></p>\n<p data-nodeid="1155">读到这里，相信你已经充分理解了“<strong data-nodeid="1291">JSX 是 JavaScript 的一种语法扩展，它和模板语言很接近，但是它充分具备 JavaScript 的能力</strong>。&nbsp;”这一定义背后的深意。那么我们文中反复提及的 React.createElement 又是何方神圣呢？下面我们就深入相关源码来一窥究竟。</p>\n<h3 data-nodeid="1156">JSX 是如何映射为 DOM 的：起底 createElement 源码</h3>\n<p data-nodeid="1157">在分析开始之前，你可以先尝试阅读我追加进源码中的逐行代码解析，大致理解 createElement 中每一行代码的作用：</p>\n<pre class="lang-java te-preview-highlight" data-nodeid="2505"><code data-language="java"><span class="hljs-comment">/**\n 101. React的创建元素方法\n */</span>\n<span class="hljs-function">export function <span class="hljs-title">createElement</span><span class="hljs-params">(type, config, children)</span> </span>{\n  <span class="hljs-comment">// propName 变量用于储存后面需要用到的元素属性</span>\n  let propName; \n  <span class="hljs-comment">// props 变量用于储存元素属性的键值对集合</span>\n  <span class="hljs-keyword">const</span> props = {}; \n  <span class="hljs-comment">// key、ref、self、source 均为 React 元素的属性，此处不必深究</span>\n  let key = <span class="hljs-keyword">null</span>;\n  let ref = <span class="hljs-keyword">null</span>; \n  let self = <span class="hljs-keyword">null</span>; \n  let source = <span class="hljs-keyword">null</span>; \n\n  <span class="hljs-comment">// config 对象中存储的是元素的属性</span>\n  <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span>) { \n    <span class="hljs-comment">// 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值</span>\n    <span class="hljs-keyword">if</span> (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    <span class="hljs-comment">// 此处将 key 值字符串化</span>\n    <span class="hljs-keyword">if</span> (hasValidKey(config)) {\n      key = <span class="hljs-string">\'\'</span> + config.key; \n    }\n    self = config.__self === undefined ? <span class="hljs-keyword">null</span> : config.__self;\n    source = config.__source === undefined ? <span class="hljs-keyword">null</span> : config.__source;\n    <span class="hljs-comment">// 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span>\n    <span class="hljs-keyword">for</span> (propName in config) {\n      <span class="hljs-keyword">if</span> (\n        <span class="hljs-comment">// 筛选出可以提进 props 对象里的属性</span>\n        hasOwnProperty.call(config, propName) &amp;&amp;\n        !RESERVED_PROPS.hasOwnProperty(propName) \n      ) {\n        props[propName] = config[propName]; \n      }\n    }\n  }\n  <span class="hljs-comment">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span>\n  <span class="hljs-keyword">const</span> childrenLength = arguments.length - <span class="hljs-number">2</span>; \n  <span class="hljs-comment">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span>\n  <span class="hljs-keyword">if</span> (childrenLength === <span class="hljs-number">1</span>) { \n    <span class="hljs-comment">// 直接把这个参数的值赋给props.children</span>\n    props.children = children; \n    <span class="hljs-comment">// 处理嵌套多个子元素的情况</span>\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenLength &gt; <span class="hljs-number">1</span>) { \n    <span class="hljs-comment">// 声明一个子元素数组</span>\n    <span class="hljs-keyword">const</span> childArray = Array(childrenLength); \n    <span class="hljs-comment">// 把子元素推进数组里</span>\n    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; childrenLength; i++) { \n      childArray[i] = arguments[i + <span class="hljs-number">2</span>];\n    }\n    <span class="hljs-comment">// 最后把这个数组赋值给props.children</span>\n    props.children = childArray; \n  } \n\n  <span class="hljs-comment">// 处理 defaultProps</span>\n  <span class="hljs-keyword">if</span> (type &amp;&amp; type.defaultProps) {\n    <span class="hljs-keyword">const</span> defaultProps = type.defaultProps;\n    <span class="hljs-keyword">for</span> (propName in defaultProps) { \n      <span class="hljs-keyword">if</span> (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  <span class="hljs-comment">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span>\n  <span class="hljs-keyword">return</span> ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n</code></pre>\n\n\n\n<p data-nodeid="1159">上面是对源码细节的初步展示，接下来我会带你逐步提取源码中的关键知识点和核心思想。</p>\n<h4 data-nodeid="1160">入参解读：创造一个元素需要知道哪些信息</h4>\n<p data-nodeid="1161">我们先来看看方法的入参：</p>\n<pre class="lang-java" data-nodeid="1162"><code data-language="java"><span class="hljs-function">export function <span class="hljs-title">createElement</span><span class="hljs-params">(type, config, children)</span>\n</span></code></pre>\n<p data-nodeid="1163">createElement 有 3 个入参，这 3 个入参囊括了 React 创建一个元素所需要知道的全部信息。</p>\n<ul data-nodeid="1164">\n<li data-nodeid="1165">\n<p data-nodeid="1166">type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。</p>\n</li>\n<li data-nodeid="1167">\n<p data-nodeid="1168">config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。</p>\n</li>\n<li data-nodeid="1169">\n<p data-nodeid="1170">children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。</p>\n</li>\n</ul>\n<p data-nodeid="1171">如果文字描述使你觉得抽象，下面这个调用示例可以帮你增进对概念的理解：</p>\n<pre class="lang-java" data-nodeid="1172"><code data-language="java">React.createElement(<span class="hljs-string">"ul"</span>, {\n  <span class="hljs-comment">// 传入属性键值对</span>\n  className: <span class="hljs-string">"list"</span>\n   <span class="hljs-comment">// 从第三个入参开始往后，传入的参数都是 children</span>\n}, React.createElement(<span class="hljs-string">"li"</span>, {\n  key: <span class="hljs-string">"1"</span>\n}, <span class="hljs-string">"1"</span>), React.createElement(<span class="hljs-string">"li"</span>, {\n  key: <span class="hljs-string">"2"</span>\n}, <span class="hljs-string">"2"</span>));\n</code></pre>\n<p data-nodeid="1173">这个调用对应的 DOM 结构如下：</p>\n<pre class="lang-js" data-nodeid="1174"><code data-language="js">&lt;ul className=<span class="hljs-string">"list"</span>&gt;\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n&lt;/ul&gt;\n</code></pre>\n<p data-nodeid="1175">对入参的形式和内容有了大致的把握之后，下面我们继续来讲解 createElement 的函数逻辑。</p>\n<h4 data-nodeid="1176">createElement 函数体拆解</h4>\n<p data-nodeid="1177" class="">前面你已经阅读过 createElement 源码细化到每一行的解读，这里我想和你探讨的是 createElement<strong data-nodeid="1310">在逻辑层面的任务流转</strong>。针对这个过程，我为你总结了下面这张流程图：</p>\n<p data-nodeid="1178"><img src="https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BeuGAepNsAACqreYXrj0410.png" alt="Drawing 3.png" data-nodeid="1313"></p>\n<p data-nodeid="1179">这个流程图，或许会打破不少同学对 createElement 的幻想。<strong data-nodeid="1323">在实际的面试场景下，许多候选人由于缺乏对源码的了解，谈及 createElement 时总会倾向于去夸大它的“工作量”</strong>。但其实，相信你也已经发现了，createElement 中并没有十分复杂的涉及算法或真实 DOM 的逻辑，它的<strong data-nodeid="1324">每一个步骤几乎都是在格式化数据</strong>。</p>\n<p data-nodeid="1180">说得更直白点，createElement 就像是开发者和 ReactElement 调用之间的一个“<strong data-nodeid="1334">转换器</strong>”、一个<strong data-nodeid="1335">数据处理层</strong>。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。整个过程如下图所示：</p>\n<p data-nodeid="1181"><img src="https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BevGANuu4AACN5mBDMlg569.png" alt="Drawing 5.png" data-nodeid="1338"></p>\n<p data-nodeid="1182">现在看来，createElement 原来只是个“参数中介”。此时我们的注意力自然而然地就聚焦在了 ReactElement 上，接下来我们就乘胜追击，一起去挖一挖 ReactElement 的源码吧！</p>\n<h4 data-nodeid="1183">出参解读：初识虚拟 DOM</h4>\n<p data-nodeid="1184">上面已经分析过，createElement 执行到最后会 return 一个针对 ReactElement 的调用。这里关于 ReactElement，我依然先给出源码 + 注释形式的解析：</p>\n<pre class="lang-java" data-nodeid="1185"><code data-language="java"><span class="hljs-keyword">const</span> ReactElement = function(type, key, ref, self, source, owner, props) {\n  <span class="hljs-keyword">const</span> element = {\n    <span class="hljs-comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span>\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    <span class="hljs-comment">// 内置属性赋值</span>\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    <span class="hljs-comment">// 记录创造该元素的组件</span>\n    _owner: owner,\n  };\n\n  <span class="hljs-comment">// </span>\n  <span class="hljs-keyword">if</span> (__DEV__) {\n    <span class="hljs-comment">// 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听</span>\n  }\n\n  <span class="hljs-keyword">return</span> element;\n};\n</code></pre>\n<p data-nodeid="1186">ReactElement 的代码出乎意料的简短，从逻辑上我们可以看出，ReactElement 其实只做了一件事情，那就是“<strong data-nodeid="1351">创建</strong>”，说得更精确一点，是“<strong data-nodeid="1352">组装</strong>”：ReactElement 把传入的参数按照一定的规范，“组装”进了 element 对象里，并把它返回给了 React.createElement，最终 React.createElement 又把它交回到了开发者手中。整个过程如下图所示：</p>\n<p data-nodeid="1187"><img src="https://s0.lgstatic.com/i/image/M00/5C/74/CgqCHl-Bex6AM5rhAACJMrix5bk913.png" alt="Drawing 7.png" data-nodeid="1355"></p>\n<p data-nodeid="1188">如果你想要验证这一点，可以尝试输出我们示例中 App 组件的 JSX 部分：</p>\n<pre class="lang-js" data-nodeid="1189"><code data-language="js"><span class="hljs-keyword">const</span> AppJSX = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"title"</span>&gt;</span>I am the title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"content"</span>&gt;</span>I am the content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)\n\n<span class="hljs-built_in">console</span>.log(AppJSX)\n</code></pre>\n<p data-nodeid="1190">你会发现它确实是一个标准的 ReactElement 对象实例，如下图（生产环境下的输出结果）所示：</p>\n<p data-nodeid="1191"><img src="https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BezKAW4rXAAIUYQW6Lk0911.png" alt="Drawing 8.png" data-nodeid="1360"></p>\n<p data-nodeid="1192">这个 ReactElement 对象实例，本质上是<strong data-nodeid="1370">以 JavaScript 对象形式存在的对 DOM 的描述</strong>，也就是老生常谈的“虚拟 DOM”（<strong data-nodeid="1371">准确地说，是虚拟 DOM 中的一个节点</strong>。关于虚拟 DOM， 我们将在专栏的“模块二：核心原理”中花大量的篇幅来研究它，此处你只需要能够结合源码，形成初步认知即可）。</p>\n<p data-nodeid="1193">既然是“虚拟 DOM”，那就意味着和渲染到页面上的真实 DOM 之间还有一些距离，这个“距离”，就是由大家喜闻乐见的<strong data-nodeid="1377">ReactDOM.render</strong>方法来填补的。</p>\n<p data-nodeid="1194">在每一个 React 项目的入口文件中，都少不了对 React.render 函数的调用。下面我简单介绍下 ReactDOM.render 方法的入参规则：</p>\n<pre class="lang-java" data-nodeid="1195"><code data-language="java">ReactDOM.render(\n    <span class="hljs-comment">// 需要渲染的元素（ReactElement）</span>\n    element, \n    <span class="hljs-comment">// 元素挂载的目标容器（一个真实DOM）</span>\n    container,\n    <span class="hljs-comment">// 回调函数，可选参数，可以用来处理渲染结束后的逻辑</span>\n    [callback]\n)\n</code></pre>\n<p data-nodeid="1196">ReactDOM.render 方法可以接收 3 个参数，其中<strong data-nodeid="1388">第二个参数就是一个真实的 DOM 节点</strong>，<strong data-nodeid="1389">这个真实的 DOM 节点充当“容器”的角色</strong>，React 元素最终会被渲染到这个“容器”里面去。比如，示例中的 App 组件，它对应的 render 调用是这样的：</p>\n<pre class="lang-java" data-nodeid="1197"><code data-language="java"><span class="hljs-keyword">const</span> rootElement = document.getElementById(<span class="hljs-string">"root"</span>);\nReactDOM.render(&lt;App /&gt;, rootElement);\n</code></pre>\n<p data-nodeid="1198">注意，这个真实 DOM 一定是确实存在的。比如，在 App 组件对应的 index.html 中，已经提前预置 了 id 为 root 的根节点：</p>\n<pre class="lang-js" data-nodeid="1199"><code data-language="js">&lt;body&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n&lt;/body&gt;\n</code></pre>',
          },
          {
            theme: '02 | 为什么 React 16 要更改组件的生命周期？（上）',
            id: 23,
            content:
              '<p data-nodeid="1389" class="">React 生命周期已经是一个老生常谈的话题了，几乎没有哪一门 React 入门教材会省略对组件生命周期的介绍。然而，入门教材在设计上往往追求的是“简单省事、迅速上手”，这就导致许多同学对于生命周期知识的刻板印象为“背就完了、别想太多”。</p>\n<p data-nodeid="1390">“背就完了”这样简单粗暴的学习方式，或许可以帮助你理解“What to do”，到达“How to do”，但却不能帮助你去思考和认知“Why to do”。作为一个专业的 React 开发者，我们必须要求自己在知其然的基础上，知其所以然。</p>\n<p data-nodeid="1391">在本课时和下一个课时，我将抱着帮你做到“知其所以然”的目的，以 React 的基本原理为引子，<strong data-nodeid="1503">对 React 15、React 16 两个版本的生命周期进行探讨、比对和总结，通过搞清楚一个又一个的“Why”，来帮你建立系统而完善的生命周期知识体系</strong>。</p>\n<h3 data-nodeid="1392">生命周期背后的设计思想：把握 React 中的“大方向”</h3>\n<p data-nodeid="1393">在介绍具体的生命周期之前，我想先带你初步理解 React 框架中的一些关键的设计思想，以便为你后续的学习提供不可或缺的“加速度”。</p>\n<p data-nodeid="1394">如果你经常翻阅 React 官网或者 React 官方的一些文章，你会发现“<strong data-nodeid="1515">组件</strong>”和“<strong data-nodeid="1516">虚拟 DOM</strong>”这两个词的出镜率是非常高的，它们是 React 基本原理中极为关键的两个概念，也是我们这个小节的学习切入点。</p>\n<h4 data-nodeid="1395">虚拟 DOM：核心算法的基石</h4>\n<p data-nodeid="1396">通过 01 课时的学习，你已经知晓了虚拟 DOM 节点的基本形态，现在我们需要简单了解下虚拟 DOM 在整个 React 工作流中的作用。</p>\n<p data-nodeid="1397">组件在初始化时，会通过调用生命周期中的 render 方法，<strong data-nodeid="1524">生成虚拟 DOM</strong>，然后再通过调用 ReactDOM.render 方法，实现虚拟 DOM 到真实 DOM 的转换。</p>\n<p data-nodeid="1398">当组件更新时，会再次通过调用 render 方法<strong data-nodeid="1534">生成新的虚拟 DOM</strong>，然后借助 diff（这是一个非常关键的算法，我将在“模块二：核心原理”重点讲解）<strong data-nodeid="1535">定位出两次虚拟 DOM 的差异</strong>，从而针对发生变化的真实 DOM 作定向更新。</p>\n<p data-nodeid="1399">以上就是 React 框架核心算法的大致流程。对于这套关键的工作流来说，“虚拟 DOM”是所有操作的大前提，是核心算法的基石。</p>\n<h4 data-nodeid="1400">组件化：工程化思想在框架中的落地</h4>\n<p data-nodeid="1401">组件化是一种优秀的软件设计思想，也是 React 团队在研发效能方面所做的一个重要的努力。</p>\n<p data-nodeid="1402">在一个 React 项目中，几乎所有的可见/不可见的内容都可以被抽离为各种各样的组件，每个组件既是“封闭”的，也是“开放”的。</p>\n<p data-nodeid="1403">所谓“封闭”，主要是针对“渲染工作流”（指从<strong data-nodeid="1549">组件数据改变</strong>到<strong data-nodeid="1550">组件实际更新发生的</strong>过程）来说的。在组件自身的渲染工作流中，每个组件都只处理它内部的渲染逻辑。在没有数据流交互的情况下，组件与组件之间可以做到“各自为政”。</p>\n<p data-nodeid="1404">而所谓“开放”，则是针对组件间通信来说的。React 允许开发者基于“单向数据流”的原则完成组件间的通信。而组件之间的通信又将改变通信双方/某一方内部的数据，进而对渲染结果构成影响。所以说在数据这个“红娘”的牵线搭桥之下，组件之间又是彼此开放的，是可以相互影响的。</p>\n<p data-nodeid="1405">这一“开放”与“封闭”兼具的特性，使得 React 组件<strong data-nodeid="1557">既专注又灵活</strong>，具备高度的可重用性和可维护性。</p>\n<h4 data-nodeid="1406">生命周期方法的本质：组件的“灵魂”与“躯干”</h4>\n<p data-nodeid="1407">之前我曾经在社区读过一篇文章，文中将 render 方法形容为 React 组件的“灵魂”。当时我对这句话产生了非常强烈的共鸣，这里我就想以这个曾经打动过我的比喻为引子，帮助你从宏观上建立对 React 生命周期的感性认知。</p>\n<p data-nodeid="1408">注意，这里提到的 render 方法，和我们 01 课时所说的 ReactDOM.render 可不是一个东西，它指的是 React 组件内部的这个生命周期方法：</p>\n<pre class="lang-js" data-nodeid="1409"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n\n  render() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"render方法执行"</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>\n        this is content\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="1410">前面咱们介绍了虚拟 DOM、组件化，倘若把这两块知识整合一下，你就会发现这两个概念似乎都在围着 render 这个生命周期打转：虚拟 DOM 自然不必多说，它的生成都要仰仗 render；而组件化概念中所提及的“渲染工作流”，这里指的是从<strong data-nodeid="1570">组件数据改变</strong>到<strong data-nodeid="1571">组件实际更新发生的</strong>过程，这个过程的实现同样离不开 render。</p>\n<p data-nodeid="1411">由此看来，render 方法在整个组件生命周期中确实举足轻重，它担得起“灵魂”这个有分量的比喻。那么如果将 render 方法比作组件的“<strong data-nodeid="1581">灵魂</strong>”，render 之外的生命周期方法就完全可以理解为是组件的“<strong data-nodeid="1582">躯干</strong>”。</p>\n<p data-nodeid="1412">“躯干”未必总是会做具体的事情（比如说我们可以选择性地省略对 render 之外的任何生命周期方法内容的编写），而“灵魂”却总是充实的（render 函数却坚决不能省略）；倘若“躯干”做了点什么，往往都会直接或间接地影响到“灵魂”（因为即便是 render 之外的生命周期逻辑，也大部分是在为 render 层面的效果服务）；“躯干”和“灵魂”一起，共同构成了 React 组件完整而不可分割的“生命时间轴”。</p>\n<h3 data-nodeid="1413">拆解 React 生命周期：从 React 15 说起</h3>\n<p data-nodeid="1414">我发现时下许多资料在讲解 React 生命周期时，喜欢直接拿 React 16 开刀。这样做虽然省事儿，却也模糊掉了新老生命周期变化背后的“Why”（关于两者的差异，我们会在“03 课时”中详细讲解）。这里为了把这个“Why”拎出来，我将首先带你认识 React 15 的生命周期流程。</p>\n<p data-nodeid="1415">在 React 15 中，大家需要关注以下几个生命周期方法：</p>\n<pre class="lang-java" data-nodeid="1416"><code data-language="java">constructor()\ncomponentWillReceiveProps()\nshouldComponentUpdate()\ncomponentWillMount()\ncomponentWillUpdate()\ncomponentDidUpdate()\ncomponentDidMount()\nrender()\ncomponentWillUnmount()\n</code></pre>\n<blockquote data-nodeid="1417">\n<p data-nodeid="1418">如果你接触 React 足够早，或许会记得还有 getDefaultProps 和 getInitState 这两个方法，它们都是 React.createClass() 模式下初始化数据的方法。由于这种写法在 ES6 普及后已经不常见，这里不再详细展开。</p>\n</blockquote>\n<p data-nodeid="1419">这些生命周期方法是如何彼此串联、相互依存的呢？这里我为你总结了一张大图：</p>\n<p data-nodeid="1420"><img src="https://s0.lgstatic.com/i/image/M00/5E/31/Ciqc1F-GZbGAGNcBAAE775qohj8453.png" alt="1.png" data-nodeid="1591"></p>\n<p data-nodeid="1421">接下来，我就围绕这张大图，分阶段讨论组件生命周期的运作规律。在学习的过程中，下面这个 Demo 可以帮助你具体地验证每个阶段的工作流程：</p>\n<pre class="lang-js te-preview-highlight" data-nodeid="7991"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;\n<span class="hljs-comment">// 定义子组件</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-keyword">constructor</span>(props) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"进入constructor"</span>);\n    <span class="hljs-keyword">super</span>(props);\n    <span class="hljs-comment">// state 可以在 constructor 里初始化</span>\n    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">text</span>: <span class="hljs-string">"子组件的文本"</span> };\n  }\n  <span class="hljs-comment">// 初始化渲染时调用</span>\n  componentWillMount() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentWillMount方法执行"</span>);\n  }\n  <span class="hljs-comment">// 初始化渲染时调用</span>\n  componentDidMount() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentDidMount方法执行"</span>);\n  }\n  <span class="hljs-comment">// 父组件修改组件的props时会调用</span>\n  componentWillReceiveProps(nextProps) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentWillReceiveProps方法执行"</span>);\n  }\n  <span class="hljs-comment">// 组件更新时调用</span>\n  shouldComponentUpdate(nextProps, nextState) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"shouldComponentUpdate方法执行"</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n  }\n\n  <span class="hljs-comment">// 组件更新时调用</span>\n  componentWillUpdate(nextProps, nextState) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentWillUpdate方法执行"</span>);\n  }\n  <span class="hljs-comment">// 组件更新后调用</span>\n  componentDidUpdate(preProps, preState) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentDidUpdate方法执行"</span>);\n  }\n  <span class="hljs-comment">// 组件卸载时调用</span>\n  componentWillUnmount() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子组件的componentWillUnmount方法执行"</span>);\n  }\n  <span class="hljs-comment">// 点击按钮，修改子组件文本内容的方法</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"修改后的子组件文本"</span>\n    });\n  };\n  render() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"render方法执行"</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"changeText"</span>&gt;</span>\n          修改子组件文本内容\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"textContent"</span>&gt;</span>{this.state.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fatherContent"</span>&gt;</span>{this.props.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n<span class="hljs-comment">// 定义 LifeCycle 组件的父组件</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycleContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n\n  <span class="hljs-comment">// state 也可以像这样用属性声明的形式初始化</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"父组件的文本"</span>,\n    <span class="hljs-attr">hideChild</span>: <span class="hljs-literal">false</span>\n  };\n  <span class="hljs-comment">// 点击按钮，修改父组件文本的方法</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"修改后的父组件文本"</span>\n    });\n  };\n  <span class="hljs-comment">// 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span>\n  hideChild = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">hideChild</span>: <span class="hljs-literal">true</span>\n    });\n  };\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fatherContainer"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"changeText"</span>&gt;</span>\n          修改父组件文本内容\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.hideChild}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"hideChild"</span>&gt;</span>\n          隐藏子组件\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        {this.state.hideChild ? null : <span class="hljs-tag">&lt;<span class="hljs-name">LifeCycle</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\nReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LifeCycleContainer</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>));\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="1423">该入口文件对应的 index.html 中预置了 id 为 root 的真实 DOM 节点作为根节点，body 标签内容如下：</p>\n<pre class="lang-js" data-nodeid="1424"><code data-language="js">&lt;body&gt;\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n&lt;/body&gt;\n</code></pre>\n<p data-nodeid="1425">这个 Demo 渲染到浏览器上大概是这样的：</p>\n<p data-nodeid="1426"><img src="https://s0.lgstatic.com/i/image/M00/5D/CC/Ciqc1F-FU-yAMLh0AABeqOeqLek815.png" alt="Drawing 1.png" data-nodeid="1597"></p>\n<p data-nodeid="1427">此处由于我们强调的是对生命周期执行规律的验证，所以样式上从简，你也可以根据自己的喜好添加 CSS 相关的内容。</p>\n<p data-nodeid="1428">接下来我们就结合这个 Demo 和开头的生命周期大图，一起来看看挂载、更新、卸载这 3 个阶段，React 组件都经历了哪些事情。</p>\n<h4 data-nodeid="1429">Mounting 阶段：组件的初始化渲染（挂载）</h4>\n<p data-nodeid="1430">挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成所谓的“首次渲染”。</p>\n<p data-nodeid="1431">在挂载阶段，一个 React 组件会按照顺序经历如下图所示的生命周期：</p>\n<p data-nodeid="1432"><img src="https://s0.lgstatic.com/i/image/M00/5E/32/Ciqc1F-GZ1OAWETTAAA3Am2CwU0383.png" alt="3.png" data-nodeid="1605"></p>\n<p data-nodeid="1433">首先我们来看 constructor 方法，该方法仅仅在挂载的时候被调用一次，我们可以在该方法中对 this.state 进行初始化：</p>\n<pre class="lang-java" data-nodeid="1434"><code data-language="java">constructor(props) {\n  console.log(<span class="hljs-string">"进入constructor"</span>);\n  <span class="hljs-keyword">super</span>(props);\n  <span class="hljs-comment">// state 可以在 constructor 里初始化</span>\n  <span class="hljs-keyword">this</span>.state = { text: <span class="hljs-string">"子组件的文本"</span> };\n}\n</code></pre>\n<p data-nodeid="1435">componentWillMount、componentDidMount 方法同样只会在挂载阶段被调用一次。其中 componentWillMount 会在执行 render 方法前被触发，一些同学习惯在这个方法里做一些初始化的操作，但这些操作往往会伴随一些风险或者说不必要性（这一点大家先建立认知，具体原因将在“03 课时”展开讲解）。</p>\n<p data-nodeid="1436">接下来 render 方法被触发。注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是<strong data-nodeid="1613">把需要渲染的内容返回出来</strong>。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。</p>\n<p data-nodeid="1437">componentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里执行真实 DOM 相关的操作。此外，类似于异步请求、数据初始化这样的操作也大可以放在这个生命周期来做（侧面印证了 componentWillMount 真的很鸡肋）。</p>\n<p data-nodeid="1438">这一整个流程对应的其实就是我们 Demo 页面刚刚打开时，组件完成初始化渲染的过程。下图是 Demo 中的 LifeCycle 组件在挂载过程中控制台的输出，你可以用它来验证挂载过程中生命周期顺序的正确性：</p>\n<p data-nodeid="1439"><img src="https://s0.lgstatic.com/i/image/M00/5D/D8/CgqCHl-FU_6AeWUcAAB8X4bjwqE102.png" alt="Drawing 3.png" data-nodeid="1618"></p>\n<h4 data-nodeid="1440">Updating 阶段：组件的更新</h4>\n<p data-nodeid="1441">组件的更新分为两种：一种是由父组件更新触发的更新；另一种是组件自身调用自己的 setState 触发的更新。这两种更新对应的生命周期流程如下图所示：</p>\n<p data-nodeid="1442"><img src="https://s0.lgstatic.com/i/image/M00/5E/3C/CgqCHl-GZf-AUjsLAACmOsiQl3M485.png" alt="2.png" data-nodeid="1623"></p>\n<p data-nodeid="1443"><strong data-nodeid="1627">componentWillReceiProps 到底是由什么触发的？</strong></p>\n<p data-nodeid="1444">从图中你可以明显看出，父组件触发的更新和组件自身的更新相比，多出了这样一个生命周期方法：</p>\n<pre class="lang-java" data-nodeid="1445"><code data-language="java">componentWillReceiveProps(nextProps)\n</code></pre>\n<p data-nodeid="1446">在这个生命周期方法里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）我们可以通过 this.props 拿到，由此便能够感知到 props 的变化。</p>\n<p data-nodeid="1447">写到这里，就不得不在“变化”这个动作上深挖一下了。我在一些社区文章里，包括一些候选人面试时的回答里，都不约而同地见过/听过这样一种说法：<strong data-nodeid="1634">componentWillReceiveProps 是在组件的 props 内容发生了变化时被触发的。</strong></p>\n<p data-nodeid="1448"><strong data-nodeid="1639">这种说法不够严谨</strong>。远的不说，就拿咱们上文给出的 Demo 开刀，该界面的控制台输出在初始化完成后是这样的：</p>\n<p data-nodeid="1449"><img src="https://s0.lgstatic.com/i/image/M00/5D/CC/Ciqc1F-FVA6AYiD4AADSl2lr-_Q663.png" alt="Drawing 5.png" data-nodeid="1642"></p>\n<p data-nodeid="1450">注意，我们代码里面，LifeCycleContainer 这个父组件传递给子组件 LifeCycle 的 props 只有一个 text：</p>\n<pre class="lang-java" data-nodeid="1451"><code data-language="java">&lt;LifeCycle text={<span class="hljs-keyword">this</span>.state.text} /&gt;\n</code></pre>\n<p data-nodeid="1452">假如我点击“修改父组件文本内容”这个按钮，父组件的 this.state.text 会发生改变，进而带动子组件的 this.props.text 发生改变。此时一定会触发 componentWillReceiveProps 这个生命周期，这是毋庸置疑的：</p>\n<p data-nodeid="1453"><img src="https://s0.lgstatic.com/i/image/M00/5D/CC/Ciqc1F-FVBWAEqTGAAEdsvX2TAM747.png" alt="Drawing 6.png" data-nodeid="1647"></p>\n<p data-nodeid="1454">但如果我现在对父组件的结构进行一个小小的修改，给它一个和子组件完全无关的 state（this.state.ownText），同时相应地给到一个修改这个 state 的方法（this.changeOwnText），并用一个新的 button 按钮来承接这个触发的动作。</p>\n<p data-nodeid="1455">改变后的 LifeCycleContainer 如下所示：</p>\n<pre class="lang-js" data-nodeid="1456"><code data-language="js"><span class="hljs-comment">// 定义 LifeCycle 组件的父组件</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycleContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// state 也可以像这样用属性声明的形式初始化</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"父组件的文本"</span>,\n    <span class="hljs-comment">// 新增的只与父组件有关的 state</span>\n    <span class="hljs-attr">ownText</span>: <span class="hljs-string">"仅仅和父组件有关的文本"</span>,\n    <span class="hljs-attr">hideChild</span>: <span class="hljs-literal">false</span>\n  };\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"修改后的父组件文本"</span>\n    });\n  };\n  <span class="hljs-comment">// 修改 ownText 的方法</span>\n  changeOwnText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">ownText</span>: <span class="hljs-string">"修改后的父组件自有文本"</span>\n    });\n  };\n  hideChild = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">hideChild</span>: <span class="hljs-literal">true</span>\n    });\n  };\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fatherContainer"</span>&gt;</span>\n        {/* 新的button按钮 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeOwnText}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"changeText"</span>&gt;</span>\n          修改父组件自有文本内容\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"changeText"</span>&gt;</span>\n          修改父组件文本内容\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.hideChild}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"hideChild"</span>&gt;</span>\n          隐藏子组件\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> {this.state.ownText} <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        {this.state.hideChild ? null : <span class="hljs-tag">&lt;<span class="hljs-name">LifeCycle</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="1457">新的界面如下图所示：</p>\n<p data-nodeid="1458"><img src="https://s0.lgstatic.com/i/image/M00/5D/CD/Ciqc1F-FVCGAVX_GAAFADHW8-9A107.png" alt="Drawing 7.png" data-nodeid="1653"></p>\n<p data-nodeid="1459">可以看到，this.state.ownText 这个状态和子组件完全无关。但是当我点击“修改父组件自有文本内容”这个按钮的时候，componentReceiveProps 仍然被触发了，效果如下图所示：</p>\n<p data-nodeid="1460"><img src="https://s0.lgstatic.com/i/image/M00/5D/D8/CgqCHl-FVCqASZNkAAGmF-R62cg649.png" alt="Drawing 8.png" data-nodeid="1657"></p>\n<p data-nodeid="1461">耳听为虚，眼见为实。面对这样的运行结果，我不由得要带你复习一下 React 官方文档中的这句话：</p>\n<p data-nodeid="1462"><img src="https://s0.lgstatic.com/i/image/M00/5D/E1/Ciqc1F-FaGuADV5vAACZ2YRV6qQ941.png" alt="图片7.png" data-nodeid="1661"></p>\n<p data-nodeid="1463"><strong data-nodeid="1666">componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的</strong>，这个结论，请你谨记。</p>\n<p data-nodeid="1464"><strong data-nodeid="1670">组件自身 setState 触发的更新</strong></p>\n<p data-nodeid="1465">this.setState() 调用后导致的更新流程，前面大图中已经有体现，这里我直接沿用上一个 Demo 来做演示。若我们点击上一个 Demo 中的“修改子组件文本内容”这个按钮：</p>\n<p data-nodeid="1466"><img src="https://s0.lgstatic.com/i/image/M00/5D/D8/CgqCHl-FVDWABuVmAADVzZuKCO0699.png" alt="Drawing 9.png" data-nodeid="1674"></p>\n<p data-nodeid="1467">这个动作将会触发子组件 LifeCycle 自身的更新流程，随之被触发的生命周期函数如下图增加的 console 内容所示：</p>\n<p data-nodeid="1468"><img src="https://s0.lgstatic.com/i/image/M00/5D/CD/Ciqc1F-FVDuASw5bAAEhb9melJQ452.png" alt="Drawing 10.png" data-nodeid="1678"></p>\n<p data-nodeid="1469">先来说说 componentWillUpdate 和 componentDidUpdate 这一对好基友。</p>\n<p data-nodeid="1470">componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。</p>\n<p data-nodeid="1471"><strong data-nodeid="1684">render 与性能：初识 shouldComponentUpdate</strong></p>\n<p data-nodeid="1472">这里需要重点提一下 shouldComponentUpdate 这个生命周期方法，它的调用形式如下所示：</p>\n<pre class="lang-js" data-nodeid="1473"><code data-language="js">shouldComponentUpdate(nextProps, nextState)\n</code></pre>\n<p data-nodeid="1474">render 方法由于伴随着对虚拟 DOM 的构建和对比，过程可以说相当耗时。而在 React 当中，很多时候我们会不经意间就频繁地调用了 render。为了避免不必要的 render 操作带来的性能开销，React 为我们提供了 shouldComponentUpdate 这个口子。</p>\n<p data-nodeid="1475">React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行<strong data-nodeid="1692">re-render</strong>（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。</p>\n<p data-nodeid="1476">关于 shouldComponentUpdate 及 PureComponent 对 React 的优化，我们会在后续的性能小节中详细展开。这里你只需要认识到 shouldComponentUpdate 的基本使用及其<strong data-nodeid="1698">与 React 性能之间的关联关系</strong>即可。</p>\n<h4 data-nodeid="1477">Unmounting 阶段：组件的卸载</h4>\n<p data-nodeid="1478">组件的销毁阶段本身是比较简单的，只涉及一个生命周期，如下图所示：</p>\n<p data-nodeid="1479"><img src="https://s0.lgstatic.com/i/image/M00/5D/EC/CgqCHl-FaHuAVGc_AABE6JqN9E0073.png" alt="图片6.png" data-nodeid="1703"></p>\n<p data-nodeid="1480">对应上文的 Demo 来看，我们点击“隐藏子组件”后就可以把 LifeCycle 从父组件中移除掉，进而实现卸载的效果。整个过程如下图所示：</p>\n<p data-nodeid="1481"><img src="https://s0.lgstatic.com/i/image/M00/5D/CD/Ciqc1F-FVFeABZvpAAO9lJVFKhs335.png" alt="Drawing 12.png" data-nodeid="1707"></p>\n<p data-nodeid="1482">这个生命周期本身不难理解，我们重点说说怎么触发它。组件销毁的常见原因有以下两个。</p>\n<ul data-nodeid="1483">\n<li data-nodeid="1484">\n<p data-nodeid="1485">组件在父组件中被移除了：这种情况相对比较直观，对应的就是我们上图描述的这个过程。</p>\n</li>\n<li data-nodeid="1486">\n<p data-nodeid="1487">组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被干掉。</p>\n</li>\n</ul>\n<p data-nodeid="1488">在本课时，只要能够理解到 1 就可以了。对于 2 这种情况，你只需要先记住有这样一种现象，这就够了。至于组件里面为什么要设置 key，为什么 key 改变后组件就必须被干掉？要回答这个问题，需要你先理解 React 的“调和过程”，而“调和过程”也会是我们第二模块中重点讲解的一个内容。这里我先把这个知识点点出来，方便你定位我们整个知识体系里的<strong data-nodeid="1716">重难点</strong>。</p>\n<h3 data-nodeid="1489">总结</h3>\n<p data-nodeid="1490">在本课时，我们对 React 设计思想中的“虚拟 DOM”和“组件化”这两个关键概念形成了初步的理解，同时也对 React 15 中的生命周期进行了系统的学习和总结。到这里，你已经了解到了 React 生命周期在很长一段“过去”里的形态。</p>\n<p data-nodeid="1491">而在 React 16 中，组件的生命周期其实已经发生了一系列的变化。这些变化到底是什么样的，它们背后又蕴含着 React 团队怎样的思量呢？</p>\n<p data-nodeid="1492">古人说“以史为镜，可以知兴衰”。在下个课时，我们将一起去“照镜子”，对 React 新旧生命周期进行对比，并探求变化的动机。</p>\n<p data-nodeid="1493"><strong data-nodeid="1725">小编有话说</strong>：</p>\n<p data-nodeid="1494">作为一名前端开发人员，我相信大家都会有一个明显的感觉：其实前端并没有想象的那么简单。近年来，前端的职责越来越重要，战场越来越多样，应用也越来越复杂。作为现阶段的“入局者”，你是否能够系统地掌握前端的知识体系？你对技术的理解是否触达底层原理？你的能力是否可以受到大厂青睐？</p>\n<p data-nodeid="1495" class="">为了帮助前端人实现进阶学习，摆脱高不成低不就的困局。拉勾教育不仅开设了前端领域的专栏课，还研发了<a href="https://kaiwu.lagou.com/fe_enhancement.html?utm_source=lagouedu&amp;utm_medium=zhuanlan&amp;utm_campaign=%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%AB%98%E8%96%AA%E8%AE%AD%E7%BB%83%E8%90%A5" data-nodeid="1730">“大前端高薪训练营”</a>，从知识体系构建、底层基础夯实、实战项目剖析、面试场景模拟到一线大厂内推，一站式解决前端进阶难题，打造你的核心竞争力。<a href="https://kaiwu.lagou.com/fe_enhancement.html?utm_source=lagouedu&amp;utm_medium=zhuanlan&amp;utm_campaign=%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%AB%98%E8%96%AA%E8%AE%AD%E7%BB%83%E8%90%A5" data-nodeid="1734">点击链接</a>，即可了解更多关于前端进阶的内容。</p>',
          },
          {
            theme: '03 | 为什么 React 16 要更改组件的生命周期？（下）',
            id: 24,
            content:
              '<p data-nodeid="13784" class="">通过对上一个课时的学习，你已经对 React 15 的生命周期有了系统的掌握和理解。本课时，我将在此基础上，对 React 16 以来的生命周期进行剖析。在理解“是什么”的基础上，我将带你对比新旧两个版本生命周期之间的差异，并探寻变化背后的原因。</p>\n<p data-nodeid="13785">通过本课时的学习，你将明白 React 团队“动作频频”背后的思量与野心，同时也将对时下大热的 Fiber 架构形成初步的认知。</p>\n<h3 data-nodeid="13786">进化的生命周期方法：React 16 生命周期工作流详解</h3>\n<p data-nodeid="13787">关于 React 16 以来的生命周期，<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" data-nodeid="13940">这个民间开源项目</a>为我们提供了目前公认的比较优秀的流程大图（在下不才，自己动手画了半天仍然自觉无法超越下图，所以这里就直接引用过来辅助讲解）。我们先来看 React 16.3 的大图：</p>\n<p data-nodeid="13788"><img src="https://s0.lgstatic.com/i/image/M00/5D/D9/CgqCHl-FVVeAaMJvAAKXOyLlUwM592.png" alt="Drawing 0.png" data-nodeid="13944"></p>\n<p data-nodeid="13789">这里之所以特意将版本号精确到了小数点后面一位，是因为在<strong data-nodeid="13950">React 16.4</strong>之后，React 生命周期在之前版本的基础上又经历了一次微调。不过你先不用着急，在理解 16.3 生命周期的基础上，掌握这个“微调”对你来说将易如反掌。</p>\n<p data-nodeid="13790">接下来，我会先把上面这张 React 16.3 生命周期大图中所涉及的内容讲清楚，然后再对 16.4 的改动进行介绍。还是老规矩，这里我先提供一个 Demo，它将辅助你理解新的生命周期。Demo 代码如下：</p>\n<pre class="lang-js te-preview-highlight" data-nodeid="23159"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;\n<span class="hljs-comment">// 定义子组件</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-keyword">constructor</span>(props) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"进入constructor"</span>);\n    <span class="hljs-keyword">super</span>(props);\n    <span class="hljs-comment">// state 可以在 constructor 里初始化</span>\n    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">text</span>: <span class="hljs-string">"子组件的文本"</span> };\n  }\n  <span class="hljs-comment">// 初始化/更新时调用</span>\n  <span class="hljs-keyword">static</span> getDerivedStateFromProps(props, state) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"getDerivedStateFromProps方法执行"</span>);\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">fatherText</span>: props.text\n    }\n  }\n  <span class="hljs-comment">// 初始化渲染时调用</span>\n  componentDidMount() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentDidMount方法执行"</span>);\n  }\n  <span class="hljs-comment">// 组件更新时调用</span>\n  shouldComponentUpdate(prevProps, nextState) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"shouldComponentUpdate方法执行"</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n  }\n\n  <span class="hljs-comment">// 组件更新时调用</span>\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"getSnapshotBeforeUpdate方法执行"</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-string">"haha"</span>;\n  }\n  <span class="hljs-comment">// 组件更新后调用</span>\n  componentDidUpdate(preProps, preState, valueFromSnapshot) {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"componentDidUpdate方法执行"</span>);\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"从 getSnapshotBeforeUpdate 获取到的值是"</span>, valueFromSnapshot);\n  }\n  <span class="hljs-comment">// 组件卸载时调用</span>\n  componentWillUnmount() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子组件的componentWillUnmount方法执行"</span>);\n  }\n  <span class="hljs-comment">// 点击按钮，修改子组件文本内容的方法</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"修改后的子组件文本"</span>\n    });\n  };\n  render() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"render方法执行"</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"changeText"</span>&gt;</span>\n          修改子组件文本内容\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"textContent"</span>&gt;</span>{this.state.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fatherContent"</span>&gt;</span>{this.props.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n<span class="hljs-comment">// 定义 LifeCycle 组件的父组件</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycleContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n\n  <span class="hljs-comment">// state 也可以像这样用属性声明的形式初始化</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"父组件的文本"</span>,\n    <span class="hljs-attr">hideChild</span>: <span class="hljs-literal">false</span>\n  };\n  <span class="hljs-comment">// 点击按钮，修改父组件文本的方法</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"修改后的父组件文本"</span>\n    });\n  };\n  <span class="hljs-comment">// 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span>\n  hideChild = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">hideChild</span>: <span class="hljs-literal">true</span>\n    });\n  };\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fatherContainer"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"changeText"</span>&gt;</span>\n          修改父组件文本内容\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.hideChild}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"hideChild"</span>&gt;</span>\n          隐藏子组件\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        {this.state.hideChild ? null : <span class="hljs-tag">&lt;<span class="hljs-name">LifeCycle</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\nReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LifeCycleContainer</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>));\n</code></pre>\n\n\n\n\n\n\n\n\n\n<p data-nodeid="13792">React 16 以来的生命周期也可以按照“挂载”“更新”和“卸载”三个阶段来看，所以接下来我们要做的事情仍然是分阶段拆解工作流程。在这个过程中，我将把 React 16 新增的生命周期方法，以及流程上相对于 React 15 产生的一些差异，作为我们学习的重点。对于和 React 15 保持一致的部分，这里不再重复讲解。</p>\n<h4 data-nodeid="13793">Mounting 阶段：组件的初始化渲染（挂载）</h4>\n<p data-nodeid="13794">为了凸显 16 和 15 两个版本生命周期之间的差异，我将两个流程绘制到了同一张大图里，请看下面这张图：</p>\n<p data-nodeid="13795"><img src="https://s0.lgstatic.com/i/image/M00/5F/B0/Ciqc1F-Klv6AIeOPAADAZZgLu7U105.png" alt="图片1.png" data-nodeid="13957"></p>\n<p data-nodeid="13796">你现在可以打开开篇我给出的 Demo，将你的 React 版本更新到 16.3，然后运行这个项目，你就可以在控制台看到新的生命周期执行过程了。控制台的输出如图所示：</p>\n<p data-nodeid="13797"><img src="https://s0.lgstatic.com/i/image/M00/5D/CE/Ciqc1F-FVW6AAX_PAADMEGvjdFI487.png" alt="Drawing 2.png" data-nodeid="13961"></p>\n<h5 data-nodeid="13798">消失的 componentWillMount，新增的 getDerivedStateFromProps</h5>\n<p data-nodeid="13799">从上图中不难看出，React 15 生命周期和 React 16.3 生命周期在挂载阶段的主要差异在于，<strong data-nodeid="13968">废弃了 componentWillMount，新增了 getDerivedStateFromProps</strong>。</p>\n<blockquote data-nodeid="13800">\n<p data-nodeid="13801">注：细心的你可能记得，React 16 对 render 方法也进行了一些改进。React 16 之前，render方法必须返回单个元素，而 React 16 允许我们返回元素数组和字符串。但本课时我们更加侧重讨论的是生命周期升级过程中的“主要矛盾”，也就是“工作流”层面的改变，故对现有方法的迭代细节，以及不在主要工作流里的<a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch" data-nodeid="13972">componentDidCatch</a> 等生命周期不再予以赘述。</p>\n</blockquote>\n<p data-nodeid="13802">一些同学在初次发现这个改变的时候，倾向于认为是 React 16.3 在试图用 getDerivedStateFromProps代替componentWillMount，这种想法是不严谨的。</p>\n<h5 data-nodeid="13803">getDerivedStateFromProps 不是 componentWillMount 的替代品</h5>\n<p data-nodeid="13804">事实上，<strong data-nodeid="13981">componentWillMount 的存在不仅“鸡肋”而且危险，因此它并不值得被“代替”，它就应该被废弃。</strong> 为了证明这点，我将在本文后续的“透过现象看本质”环节为大家细数 componentWillMount 的几宗“罪”。</p>\n<p data-nodeid="13805">而 getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉 <strong data-nodeid="13995">componentWillMount</strong>，而是试图替换掉 <strong data-nodeid="13996">componentWillReceiveProps</strong>，因此它有且仅有一个用途：<strong data-nodeid="13997">使用 props 来派生/更新 state</strong>。</p>\n<p data-nodeid="13806">React 团队为了确保 getDerivedStateFromProps 这个生命周期的纯洁性，直接从命名层面约束了它的用途（getDerivedStateFromProps 直译过来就是“从 Props 里派生 State”）。所以，如果你不是出于这个目的来使用 getDerivedStateFromProps，原则上来说都是不符合规范的。</p>\n<p data-nodeid="13807">值得一提的是，getDerivedStateFromProps 在更新和挂载两个阶段都会“出镜”（这点不同于仅在更新阶段出现的 componentWillReceiveProps）。这是因为“派生 state”这种诉求不仅在 props 更新时存在，<strong data-nodeid="14004">在 props 初始化的时候也是存在的</strong>。React 16 以提供特定生命周期的形式，对这类诉求提供了更直接的支持。</p>\n<p data-nodeid="13808">由此看来，挂载阶段的生命周期改变，并不是一个简单的“替换”逻辑，而是一个雄心勃勃的“进化”逻辑。</p>\n<h5 data-nodeid="13809">认识 getDerivedStateFromProps</h5>\n<p data-nodeid="13810">这个新生命周期方法的调用规则如下：</p>\n<pre class="lang-java" data-nodeid="13811"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">getDerivedStateFromProps</span><span class="hljs-params">(props, state)</span>\n</span></code></pre>\n<p data-nodeid="13812">在使用层面，你需要把握三个重点。</p>\n<p data-nodeid="13813">第一个重点是最特别的一点：<strong data-nodeid="14018">getDerivedStateFromProps 是一个静态方法</strong>。静态方法不依赖组件实例而存在，因此你在这个方法内部是<strong data-nodeid="14019">访问不到 this</strong> 的。若你偏要尝试这样做，必定报错，报错形式如下图所示：</p>\n<p data-nodeid="13814"><img src="https://s0.lgstatic.com/i/image/M00/5D/DA/CgqCHl-FVZSAX16PAAK3atPnbSg411.png" alt="Drawing 3.png" data-nodeid="14022"></p>\n<p data-nodeid="13815">第二个重点，该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。我们可以尝试在 Demo 中输出这两个参数看一看，输出效果如下图所示：</p>\n<p data-nodeid="13816"><img src="https://s0.lgstatic.com/i/image/M00/5D/DA/CgqCHl-FVZqAJnD-AAQlZUXOgq0760.png" alt="Drawing 4.png" data-nodeid="14026"></p>\n<p data-nodeid="13817">可以看出，挂载阶段输出的 props 正是初始化阶段父组件传进来的 this.props 对象；而 state 是 LifeCycle 组件自身的 state 对象。</p>\n<p data-nodeid="13818">第三个重点，getDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番，警告内容如下图所示：</p>\n<p data-nodeid="13819"><img src="https://s0.lgstatic.com/i/image/M00/5D/CE/Ciqc1F-FVaCAOOnzAALVyD02cdg817.png" alt="Drawing 5.png" data-nodeid="14031"></p>\n<p data-nodeid="13820"><strong data-nodeid="14036">getDerivedStateFromProps 的返回值之所以不可或缺，是因为 React 需要用这个返回值来更新（派生）组件的 state</strong>。因此当你确实不存在“使用 props 派生 state ”这个需求的时候，最好是直接省略掉这个生命周期方法的编写，否则一定记得给它 return 一个 null。</p>\n<p data-nodeid="13821">注意，<strong data-nodeid="14046">getDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新</strong>，<strong data-nodeid="14047">而是针对某个属性的定向更新</strong>。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：</p>\n<pre class="lang-js" data-nodeid="13822"><code data-language="js">{\n  <span class="hljs-attr">fatherText</span>: props.text\n}\n</code></pre>\n<p data-nodeid="13823">该对象并不会替换掉组件原始的这个 state：</p>\n<pre class="lang-java" data-nodeid="13824"><code data-language="java"><span class="hljs-keyword">this</span>.state = { text: <span class="hljs-string">"子组件的文本"</span> };\n</code></pre>\n<p data-nodeid="13825">而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示：</p>\n<p data-nodeid="13826"><img src="https://s0.lgstatic.com/i/image/M00/5D/DA/CgqCHl-FVbiAR1FtAABja-0bwL0578.png" alt="Drawing 6.png" data-nodeid="14052"></p>\n<h4 data-nodeid="13827">Updating 阶段：组件的更新</h4>\n<p data-nodeid="13828">React 15 与 React 16.3 的更新流程对比如下图所示：</p>\n<p data-nodeid="13829"><img src="https://s0.lgstatic.com/i/image/M00/5F/BB/CgqCHl-KlxyAB5MpAAFaH-Kgggo887.png" alt="图片2.png" data-nodeid="14057"></p>\n<p data-nodeid="13830">注意，咱们前面提到 React 16.4 对生命周期流程进行了“微调”，其实就调在了更新过程的getDerivedStateFromProps 这个生命周期上。先来看一张 React 16.4+ 的生命周期大图（出处仍然是<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" data-nodeid="14061">Wojciech Maj 的 react-lifecycle-methods-diagram</a>）：</p>\n<p data-nodeid="13831"><img src="https://s0.lgstatic.com/i/image/M00/5D/CF/Ciqc1F-FVcSALRwNAAIomWwVcQU231.png" alt="Drawing 8.png" data-nodeid="14065"></p>\n<p data-nodeid="13832">React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：</p>\n<ul data-nodeid="13833">\n<li data-nodeid="13834">\n<p data-nodeid="13835">在 React 16.4 中，<strong data-nodeid="14072">任何因素触发的组件更新流程</strong>（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；</p>\n</li>\n<li data-nodeid="13836">\n<p data-nodeid="13837">而在 v 16.3 版本时，<strong data-nodeid="14078">只有父组件的更新</strong>会触发该生命周期。</p>\n</li>\n</ul>\n<p data-nodeid="13838">到这里，你已经对 getDerivedStateFromProps 相关的改变有了充分的了解。接下来，我们就基于这层了解，问出生命周期改变背后的第一个“Why”。</p>\n<h5 data-nodeid="13839">改变背后的第一个“Why”：为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？</h5>\n<p data-nodeid="13840">对于 getDerivedStateFromProps 这个 API，React 官方曾经给出过这样的描述：</p>\n<blockquote data-nodeid="13841">\n<p data-nodeid="13842">与 componentDidUpdate 一起，这个新的生命周期涵盖过时componentWillReceiveProps 的所有用例。</p>\n</blockquote>\n<p data-nodeid="13843">在这里，请你细细品味这句话，这句话里蕴含了下面两个关键信息：</p>\n<ul data-nodeid="13844">\n<li data-nodeid="13845">\n<p data-nodeid="13846">getDerivedStateFromProps 是作为一个<strong data-nodeid="14089">试图代替 componentWillReceiveProps</strong> 的 API 而出现的；</p>\n</li>\n<li data-nodeid="13847">\n<p data-nodeid="13848">getDerivedStateFromProps<strong data-nodeid="14095">不能完全和 componentWillReceiveProps 画等号</strong>，其特性决定了我们曾经在 componentWillReceiveProps 里面做的事情，不能够百分百迁移到getDerivedStateFromProps 里。</p>\n</li>\n</ul>\n<p data-nodeid="13849">接下来我们就展开说说这两点。</p>\n<ul data-nodeid="13850">\n<li data-nodeid="13851">\n<p data-nodeid="13852">关于 getDerivedStateFromProps 是如何代替componentWillReceiveProps 的，在“挂载”环节已经讨论过：getDerivedStateFromProps 可以代替 componentWillReceiveProps 实现<strong data-nodeid="14102">基于 props 派生 state</strong>。</p>\n</li>\n<li data-nodeid="13853">\n<p data-nodeid="13854">至于它为何不能完全和 componentWillReceiveProps 画等号，则是因为它过于“专注”了。这一点，单单从getDerivedStateFromProps 这个 API 名字上也能够略窥一二。原则上来说，它能做且只能做这一件事。</p>\n</li>\n</ul>\n<p data-nodeid="13855">乍一看，原来的 API 能做的事情更多，现在的 API 却限制重重，难道是 React 16 的生命周期方法“退化”了？</p>\n<p data-nodeid="13856">当然不是。如果你对设计模式有所了解的话，就会知道，<strong data-nodeid="14110">一个 API 并非越庞大越复杂才越优秀</strong>。或者说得更直接一点，庞大和复杂的 API 往往会带来维护层面的“灾难”。</p>\n<p data-nodeid="13857">说回 getDerivedStateFromProps 这个 API，它相对于早期的 componentWillReceiveProps 来说，正是做了“<strong data-nodeid="14116">合理的减法</strong>”。而做这个减法的决心之强烈，从 getDerivedStateFromProps 直接被定义为 static 方法这件事上就可见一斑—— static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。</p>\n<p data-nodeid="13858">因此，getDerivedStateFromProps 生命周期替代 componentWillReceiveProps 的背后，<strong data-nodeid="14122">是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践</strong>。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。</p>\n<p data-nodeid="13859">到这里，相信你已经对 getDerivedStateFromProps 吃得透透的了。至于什么是 Fiber 架构，这条路该怎么铺，你将在本课时后续的内容中找到答案。现在，我们得回到“更新”这条工作流里来，一起去看看getSnapshotBeforeUpdate 是怎么一回事儿。</p>\n<h5 data-nodeid="13860">消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate</h5>\n<p data-nodeid="13861">咱们先来看看 getSnapshotBeforeUpdate 是什么：</p>\n<pre class="lang-js" data-nodeid="13862"><code data-language="js">getSnapshotBeforeUpdate(prevProps, prevState) {\n  <span class="hljs-comment">// ...</span>\n}\n</code></pre>\n<p data-nodeid="13863">这个方法和 getDerivedStateFromProps 颇有几分神似，它们都强调了“我需要一个返回值”这回事。区别在于 <strong data-nodeid="14141">getSnapshotBeforeUpdate 的返回值会作为第三个参数给到 componentDidUpdate</strong>。<strong data-nodeid="14142">它的执行时机是在 render 方法之后，真实 DOM 更新之前</strong>。在这个阶段里，我们可以<strong data-nodeid="14143">同时获取到更新前的真实 DOM 和更新前后的 state&amp;props 信息</strong>。</p>\n<p data-nodeid="13864">尽管在实际工作中，需要用到这么多信息的场景并不多，但在对于实现一些特殊的需求来说，没它还真的挺难办。这里我举一个非常有代表性的例子：实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化，来决定是否要记录滚动条的当前位置。</p>\n<p data-nodeid="13865">这个需求的前半截要求我们对比更新前后的数据（感知变化），后半截则需要获取真实的 DOM 信息（获取位置），这时用 getSnapshotBeforeUpdate 来解决就再合适不过了。</p>\n<p data-nodeid="13866">对于这个生命周期，需要重点把握的是它与 componentDidUpdate 间的通信过程。在 Demo 中我给出了一个使用示例，它将帮助你更加具体地认知这个过程。代码如下：</p>\n<pre class="lang-java" data-nodeid="13867"><code data-language="java"><span class="hljs-comment">// 组件更新时调用</span>\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  console.log(<span class="hljs-string">"getSnapshotBeforeUpdate方法执行"</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-string">"haha"</span>;\n}\n\n<span class="hljs-comment">// 组件更新后调用</span>\ncomponentDidUpdate(prevProps, prevState, valueFromSnapshot) {\n  console.log(<span class="hljs-string">"componentDidUpdate方法执行"</span>);\n  console.log(<span class="hljs-string">"从 getSnapshotBeforeUpdate 获取到的值是"</span>, valueFromSnapshot);\n}\n</code></pre>\n<p data-nodeid="13868">现在我们点击 Demo 界面上“修改子组件文本内容”按钮，就可以看到这两个生命周期的通信效果，如下图所示：</p>\n<p data-nodeid="13869"><img src="https://s0.lgstatic.com/i/image/M00/5D/CF/Ciqc1F-FVlOAX7VMAAE_3SdYf2M700.png" alt="Drawing 9.png" data-nodeid="14150"></p>\n<p data-nodeid="13870">值得一提的是，这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”（引用自 React 官网）。<strong data-nodeid="14156">getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合</strong>。</p>\n<p data-nodeid="13871">那么换个角度想想，<strong data-nodeid="14163">为什么 componentWillUpdate 就非死不可呢</strong>？说到底，还是因为它“挡了 Fiber 的路”。各位莫慌，咱们离真相越来越近了~</p>\n<h4 data-nodeid="13872">Unmounting 阶段：组件的卸载</h4>\n<p data-nodeid="13873">我们先继续把完整的生命周期流程走完，以下是组件卸载阶段的示意图：</p>\n<p data-nodeid="13874"><img src="https://s0.lgstatic.com/i/image/M00/5F/B0/Ciqc1F-KlzqACUOPAABE6JqN9E0200.png" alt="图片3.png" data-nodeid="14168"></p>\n<p data-nodeid="13875">卸载阶段的生命周期与 React 15 完全一致，只涉及 componentWillUnmount 这一个生命周期，此处不再重复讲解。</p>\n<p data-nodeid="13876">接下来，就让一切变化背后的”始作俑者“ Fiber 架构来和大家打个招呼吧！</p>\n<h3 data-nodeid="13877">透过现象看本质：React 16 缘何两次求变？</h3>\n<h5 data-nodeid="13878">Fiber 架构简析</h5>\n<p data-nodeid="13879">Fiber 是 React 16 对 React 核心算法的一次重写。关于 Fiber，我将在“模块二：核心原理”花大量的篇幅来介绍它的原理和细节。在本课时，你只需要 get 到这一个点：<strong data-nodeid="14178">Fiber 会使原本同步的渲染过程变成异步的</strong>。</p>\n<p data-nodeid="13880">在 React 16 之前，每当我们触发一次组件的更新，React 都会构建一棵新的虚拟 DOM 树，通过与上一次的虚拟 DOM 树进行 diff，实现对 DOM 的定向更新。这个过程，是一个递归的过程。下面这张图形象地展示了这个过程的特征：</p>\n<p data-nodeid="13881"><img src="https://s0.lgstatic.com/i/image/M00/5F/B0/Ciqc1F-Kl0WAO2mzAABxddWHnXI121.png" alt="图片4.png" data-nodeid="14182"></p>\n<p data-nodeid="13882">如图所示，<strong data-nodeid="14196">同步渲染的递归调用栈是非常深的</strong>，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。<strong data-nodeid="14198">这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：<strong data-nodeid="14197">同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种</strong>无法处理用户交互</strong>的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。</p>\n<p data-nodeid="13883">而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：<strong data-nodeid="14212">Fiber 会将一个大的更新任务拆解为许多个小任务</strong>。每当执行完一个小任务时，<strong data-nodeid="14213">渲染线程都会把主线程交回去</strong>，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，<strong data-nodeid="14214">渲染线程不再“一去不回头”，而是可以被打断的</strong>，这就是所谓的“异步渲染”，它的执行过程如下图所示：</p>\n<p data-nodeid="13884"><img src="https://s0.lgstatic.com/i/image/M00/5F/B0/Ciqc1F-Kl1CAA6pwAADpyi-xSnM494.png" alt="图片5.png" data-nodeid="14217"></p>\n<p data-nodeid="13885">如果你初学 Fiber，对上面的两段描述感到陌生或者说“吃不透”，这都是正常的。在本课时，你大可不必如此苛求自己，只需对“同步渲染”和“异步渲染”这两个概念有一个大致的印象，同时把握住 Fiber 架构下“任务拆解”和“可打断”这两个特性即可。接下来，我们继续往下走，看看“同步”变“异步”这个过程，是如何对生命周期构成影响的。</p>\n<h5 data-nodeid="13886">换个角度看生命周期工作流</h5>\n<p data-nodeid="13887">Fiber 架构的重要特征就是<strong data-nodeid="14229">可以被打断的</strong>异步渲染模式。但这个“打断”是有原则的，根据“<strong data-nodeid="14230">能否被打断</strong>”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：</p>\n<p data-nodeid="13888"><img src="https://s0.lgstatic.com/i/image/M00/5D/CF/Ciqc1F-FVn6AEtlxAAIomWwVcQU485.png" alt="Drawing 13.png" data-nodeid="14233"></p>\n<p data-nodeid="13889">我们先来看下三个阶段各自有哪些特征（以下特征翻译自上图）。</p>\n<ul data-nodeid="13890">\n<li data-nodeid="13891">\n<p data-nodeid="13892">render 阶段：纯净且没有副作用，可能会被 React 暂停、终止或重新启动。</p>\n</li>\n<li data-nodeid="13893">\n<p data-nodeid="13894">pre-commit 阶段：可以读取 DOM。</p>\n</li>\n<li data-nodeid="13895">\n<p data-nodeid="13896">commit 阶段：可以使用 DOM，运行副作用，安排更新。</p>\n</li>\n</ul>\n<p data-nodeid="13897"><strong data-nodeid="14241">总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</strong></p>\n<p data-nodeid="13898">为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p>\n<h5 data-nodeid="13899">细说生命周期“废旧立新”背后的思考</h5>\n<p data-nodeid="13900">在 Fiber 机制下，<strong data-nodeid="14253">render 阶段是允许暂停、终止和重启的</strong>。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。<strong data-nodeid="14254">这就导致 render 阶段的生命周期都是有可能被重复执行的</strong>。</p>\n<p data-nodeid="13901">带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：</p>\n<ul data-nodeid="13902">\n<li data-nodeid="13903">\n<p data-nodeid="13904">componentWillMount；</p>\n</li>\n<li data-nodeid="13905">\n<p data-nodeid="13906">componentWillUpdate；</p>\n</li>\n<li data-nodeid="13907">\n<p data-nodeid="13908">componentWillReceiveProps。</p>\n</li>\n</ul>\n<p data-nodeid="13909">这些生命周期的共性，<strong data-nodeid="14264">就是它们都处于 render 阶段，都可能重复被执行</strong>，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</p>\n<p data-nodeid="13910">别的不说，说说我自己在团队 code review 中见过的“骚操作”吧。在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:</p>\n<ul data-nodeid="13911">\n<li data-nodeid="13912">\n<p data-nodeid="13913">setState()；</p>\n</li>\n<li data-nodeid="13914">\n<p data-nodeid="13915">fetch 发起异步请求；</p>\n</li>\n<li data-nodeid="13916">\n<p data-nodeid="13917">操作真实 DOM。</p>\n</li>\n</ul>\n<p data-nodeid="13918">这些操作的问题（或不必要性）包括但不限于以下 3 点：</p>\n<p data-nodeid="13919"><strong data-nodeid="14274">（1）完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做</strong>。</p>\n<p data-nodeid="13920">比如在 componentWillMount 里发起异步请求。很多同学因为太年轻，以为这样做就可以让异步请求回来得“早一点”，从而避免首次渲染白屏。</p>\n<p data-nodeid="13921">可惜你忘了，异步请求再怎么快也快不过（React 15 下）同步的生命周期。componentWillMount 结束后，render 会迅速地被触发，所以说<strong data-nodeid="14281">首次渲染依然会在数据返回之前执行</strong>。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题，得不偿失。</p>\n<p data-nodeid="13922"><strong data-nodeid="14286">（2）在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug</strong>。</p>\n<p data-nodeid="13923">试想，假如你在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被<strong data-nodeid="14292">打断 + 重启多次</strong>后，就会发出多个付款请求。</p>\n<p data-nodeid="13924">比如说，这件商品单价只要 10 块钱，用户也只点击了一次付款。但实际却可能因为 componentWillxxx 被<strong data-nodeid="14298">打断 + 重启多次</strong>而多次调用付款接口，最终付了 50 块钱；又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。</p>\n<p data-nodeid="13925">结合上面的分析，我们再去思考 getDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了——避免开发者触碰 this，就是在避免各种危险的骚操作。</p>\n<p data-nodeid="13926"><strong data-nodeid="14303">（3）即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。</strong></p>\n<p data-nodeid="13927">比如在 componentWillReceiveProps &nbsp;和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的，大家都懂哈（邪魅一笑）。</p>\n<p data-nodeid="13928">总的来说，<strong data-nodeid="14322">React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制</strong>。在这个改造的过程中，React 团队精益求精，<strong data-nodeid="14323">针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践</strong>。这一系列的工作做下来，首先是<strong data-nodeid="14324">确保了 Fiber 机制下数据和视图的安全性</strong>，同时也<strong data-nodeid="14325">确保了生命周期方法的行为更加纯粹、可控、可预测</strong>。</p>\n<h3 data-nodeid="13929">总结</h3>\n<p data-nodeid="13930">通过 02 和 03 两个课时的学习，大家已经对 React 15、16 两个版本的生命周期有了深入的掌握，同时对 React 生命周期的一系列的变化以及其背后的原因都有了深刻而健全的理解。</p>\n<p data-nodeid="13931" class="">生命周期看似简单，但要想真正吃透，竟然需要挑战这么长的一个知识链路，实在不简单！在使用 React 进行项目开发的 5 年里，我曾不止一次地为各路合作伙伴在生命周期里“为所欲为”而感到痛苦，也曾不止一次地为 React 基础知识结构摇摇欲坠的候选人感到可惜。若你能够耐下心来彻底消化掉这两个课时，相信这世上定能多出一个靠谱的前端！</p>\n<p data-nodeid="13932">话说回来，现有的生命周期，虽然已经对方法的最佳实践做了强约束，但是仍然无法覆盖所有的“误操作”，其中最为典型的，就是对 getDerivedStateFromProps 的滥用。关于这点，社区的讨论不是很多，但是 <a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" data-nodeid="14332">React 团队给出的这篇文章</a>就帮助大家规避“误操作”来说是绰绰有余的。</p>\n<p data-nodeid="13933" class="">经过了漫长的两个课时的学习，我们终于征服了生命周期这座小山包。一个组件的一生如何度过，我们已经领教过了。那么，多个组件之间如何“心意相通”呢？在下个课时，将围绕“数据在组件间的流动”展开讲解，探索“心意相通”的艺术。</p>',
          },
          {
            theme: '04 | 数据是如何在 React 组件之间流动的？（上）',
            id: 25,
            content:
              '<p data-nodeid="12983" class="">通过前面 3 个课时的学习，相信你已经对 React 生命周期相关的“Why”“What”和“How”有了系统的理解和掌握。当我们谈论生命周期时，其实谈论的是组件的“内心世界”。但组件和人是一样的，它不仅需要拥有丰富的内心世界，还应该建立健全的“人际关系”，要学会<strong data-nodeid="13143">沟通和表达</strong>。</p>\n<p data-nodeid="12984">从本课时开始，我们将一起探索蕴含在 React 组件中的“沟通与表达”的艺术。我们知道，React 的核心特征是“<strong data-nodeid="13149">数据驱动视图</strong>”，这个特征在业内有一个非常有名的函数式来表达：</p>\n<p data-nodeid="12985"><img src="https://s0.lgstatic.com/i/image/M00/60/F7/Ciqc1F-OmrSAZkEwAAA2ThydXNs410.png" alt="Drawing 1.png" data-nodeid="13152"></p>\n<p data-nodeid="12986">这个表达式有很多的版本，一些版本会把入参里的 data 替换成 state，但它们本质上都指向同一个含义，那就是<strong data-nodeid="13158">React 的视图会随着数据的变化而变化</strong>。数据这个角色在 React 中的地位可见一斑。</p>\n<p data-nodeid="12987">在 React 中，如果说两个组件之间希望能够产生“耦合”（即 A 组件希望能够通过某种方式影响到 B 组件），那么毫无疑问，这两个组件必须先建立数据上的连接，以实现所谓的“组件间通信”。</p>\n<p data-nodeid="12988">“组件间通信”的背后是一套环环相扣的 React 数据流解决方案。虽然这套解决方案在业内已经有了比较成熟和稳定的结论，但<strong data-nodeid="13165">许多人仍然会因为知识的系统性和整体性不强而吃亏</strong>。</p>\n<p data-nodeid="12989"><strong data-nodeid="13170">在前面三个课时中，我们的学习思路是往纵深处去寻觅：铺陈大量的前置知识，然后一步一步地去询问生命周期背后的“Why”，最终揪出 Fiber 架构这个大 boss</strong>（不过学到这里，这个“纵深”我们才只挖到一半，专栏第二模块还有一大波 Fiber 原理等待我们继续寻觅）。</p>\n<p data-nodeid="12990">在接下来的第 04 和 05 课时中，我们要做的事情则更倾向于横向的“聚合”：我将用简单易懂的语言，帮你理解当下实践中 React 数据通信的四个大方向，并针对每个方向给出具体的场景和用例。<strong data-nodeid="13176">这些知识本身并不难，但摊子却可以铺得非常大，相关的问题在面试中也始终具备较高的区分度</strong>。要想扎扎实实掌握，必须耐下心、沉住气，在学习过程中主动地去串联自己的知识链路。</p>\n<h3 data-nodeid="12991">基于 props 的单向数据流</h3>\n<p data-nodeid="12992"><img src="https://s0.lgstatic.com/i/image/M00/61/02/CgqCHl-OmsuAF_FSAAB4ormSPI8355.png" alt="Drawing 2.png" data-nodeid="13180"></p>\n<p data-nodeid="12993">既然 props 是组件的入参，那么组件之间通过修改对方的入参来完成数据通信就是天经地义的事情了。不过，这个“修改”也是有原则的——你必须确保所有操作都在“<strong data-nodeid="13186">单向数据流</strong>”这个前提下。</p>\n<p data-nodeid="12994">所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，<strong data-nodeid="13192">只能流向组件树中比自己层级更低的组件。</strong> 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。</p>\n<p data-nodeid="12995">听上去虽然限制重重，但用起来却是相当的灵活。基于 props 传参这种形式，我们可以轻松实现父-子通信、子-父通信和兄弟组件通信。</p>\n<h4 data-nodeid="12996">父-子组件通信</h4>\n<p data-nodeid="12997"><strong data-nodeid="13198">原理讲解</strong></p>\n<p data-nodeid="12998">这是最常见、也是最好解决的一个通信场景。React 的数据流是单向的，父组件可以直接将 this.props 传入子组件，实现父-子间的通信。这里我给出一个示例。</p>\n<p data-nodeid="12999"><strong data-nodeid="13203">编码实现</strong></p>\n<ul data-nodeid="13000">\n<li data-nodeid="13001">\n<p data-nodeid="13002">子组件编码内容：</p>\n</li>\n</ul>\n<pre class="lang-js" data-nodeid="13003"><code data-language="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"child"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul data-nodeid="13004">\n<li data-nodeid="13005">\n<p data-nodeid="13006">父组件编码内容：</p>\n</li>\n</ul>\n<pre class="lang-js" data-nodeid="13007"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// 初始化父组件的 state</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"初始化的父组件的文本"</span>\n  };\n  <span class="hljs-comment">// 按钮的监听函数，用于更新 text 值</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"改变后的父组件文本"</span>\n    });\n  };\n  <span class="hljs-comment">// 渲染父组件</span>\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"father"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span>&gt;</span>\n          点击修改父组件传入子组件的文本\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        {/* 引入子组件，并通过 props 下发具体的状态值实现父-子通信 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">fatherText</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="13008"><strong data-nodeid="13209">视图层验证</strong></p>\n<p data-nodeid="13009">我们直接对父组件进行渲染，可以看到大致如下图所示的界面：</p>\n<p data-nodeid="13010"><img src="https://s0.lgstatic.com/i/image/M00/61/02/CgqCHl-OmuWAaqeoAABhmFu-VMo782.png" alt="Drawing 3.png" data-nodeid="13213"></p>\n<p data-nodeid="13011">通过子组件顺利读取到父组件的 this.props.text，从这一点可以看出，父-子之间的通信是没有问题的。此时假如我们点击父组件中的按钮，父组件的 this.state.text 会发生变化，同时子组件读取到的 props.text 也会跟着发生变化（如下图所示），也就是说，父子组件的数据始终保持一致。</p>\n<p data-nodeid="13012"><img src="https://s0.lgstatic.com/i/image/M00/60/F7/Ciqc1F-Omu-AcVKJAABe2pgKMlQ354.png" alt="Drawing 4.png" data-nodeid="13217"></p>\n<p data-nodeid="13013">由此我们便充分验证了父-子组件基于 props 实现通信的可行性。</p>\n<h4 data-nodeid="13014">子-父组件通信</h4>\n<p data-nodeid="13015"><strong data-nodeid="13223">原理讲解</strong></p>\n<p data-nodeid="13016">考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。假如父组件传递给子组件的是一个<strong data-nodeid="13233">绑定了自身上下文的函数</strong>，那么子组件在调用该函数时，就可以<strong data-nodeid="13234">将想要交给父组件的数据以函数入参的形式给出去</strong>，以此来间接地实现数据从子组件到父组件的流动。</p>\n<p data-nodeid="13017"><strong data-nodeid="13238">编码实现</strong></p>\n<p data-nodeid="13018">这里我们只需对父-子通信中的示例稍做修改，就可以完成子-父组件通信的可行性验证。</p>\n<p data-nodeid="13019">首先是对子组件的修改。在 Child 中，我们需要增加对状态的维护，以及对 Father 组件传入的函数形式入参的调用。子组件编码内容如下，修改点我已在代码中以注释的形式标出：</p>\n<pre class="lang-js" data-nodeid="13020"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// 初始化子组件的 state</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">\'子组件的文本\'</span>\n  }\n\n  <span class="hljs-comment">// 子组件的按钮监听函数</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-comment">// changeText 中，调用了父组件传入的 changeFatherText 方法</span>\n    <span class="hljs-keyword">this</span>.props.changeFatherText(<span class="hljs-keyword">this</span>.state.text)\n  }\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"child"</span>&gt;</span>\n        {/* 注意这里把修改父组件文本的动作放在了 Child 里 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span>&gt;</span>\n          点击更新父组件的文本\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="13021">在父组件中，我们只需要在 changeText 函数上开一个传参的口子，作为数据通信的入口，然后把 changeText 放在 props 里交给子组件即可。父组件的编码内容如下：</p>\n<pre class="lang-js" data-nodeid="13022"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// 初始化父组件的 state</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"初始化的父组件的文本"</span>\n  };\n  <span class="hljs-comment">// 这个方法会作为 props 传给子组件，用于更新父组件 text 值。newText 正是开放给子组件的数据通信入口</span>\n  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: newText\n    });\n  };\n  <span class="hljs-comment">// 渲染父组件</span>\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"father"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{`父组件的文本内容是：[${this.state.text}]`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        {/* 引入子组件，并通过 props 中下发可传参的函数 实现子-父通信 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>\n          <span class="hljs-attr">changeFatherText</span>=<span class="hljs-string">{this.changeText}</span>\n        /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n</code></pre>\n<p data-nodeid="13023"><strong data-nodeid="13245">视图层验证</strong></p>\n<p data-nodeid="13024">新的示例渲染后的界面大致如下图所示：</p>\n<p data-nodeid="13025"><img src="https://s0.lgstatic.com/i/image/M00/61/03/CgqCHl-Om1qAWYoYAABEbXaJOH4748.png" alt="Drawing 5.png" data-nodeid="13249"></p>\n<p data-nodeid="13026">注意，在这个 case 中，我们将具有更新数据能力的按钮转移到了子组件中。</p>\n<p data-nodeid="13027">当点击子组件中的按钮时，会调用已经绑定了父组件上下文的 this.props.changeFatherText 方法，同时将子组件的 this.state.text 以函数入参的形式传入，由此便能够间接地用子组件的 state 去更新父组件的 state。</p>\n<p data-nodeid="13028">点击按钮后，父组件的文本会按照我们的预期被子组件更新掉，如下图所示：</p>\n<p data-nodeid="13029"><img src="https://s0.lgstatic.com/i/image/M00/61/03/CgqCHl-Om1KAR7b2AABAwOe1KdQ729.png" alt="Drawing 6.png" data-nodeid="13255"></p>\n<h4 data-nodeid="13030">兄弟组件通信</h4>\n<p data-nodeid="13031"><strong data-nodeid="13260">原理讲解</strong></p>\n<p data-nodeid="13032">兄弟组件之间共享了同一个父组件，如下图所示，这是一个非常重要的先决条件。</p>\n<p data-nodeid="13033"><img src="https://s0.lgstatic.com/i/image/M00/60/F7/Ciqc1F-Om2qAJmdoAADBknkoDh4735.png" alt="Drawing 8.png" data-nodeid="13264"></p>\n<p data-nodeid="13034">这个先决条件使得我们可以继续利用父子组件这一层关系，将“兄弟 1 → 兄弟 2”之间的通信，转化为“兄弟 1 → 父组件”（子-父通信）、“父组件 → 兄弟 2”（父-子）通信两个步骤，如下图所示，这样一来就能够巧妙地把“兄弟”之间的新问题化解为“父子”之间的旧问题。</p>\n<p data-nodeid="13035"><img src="https://s0.lgstatic.com/i/image/M00/61/03/CgqCHl-Om3KAMCvhAADUh2BcieU209.png" alt="Drawing 10.png" data-nodeid="13268"></p>\n<p data-nodeid="13036"><strong data-nodeid="13272">编码实现</strong></p>\n<p data-nodeid="13037">接下来我们仍然从编码的角度进行验证。首先新增一个 NewChild 组件作为与 Child 组件同层级的兄弟组件。NewChild 将作为数据的发送方，将数据发送给 Child。在 NewChild 中，我们需要处理 NewChild 和 Father 之间的关系。NewChild 组件编码如下：</p>\n<pre class="lang-js" data-nodeid="13038"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"来自 newChild 的文本"</span>\n  };\n  <span class="hljs-comment">// NewChild 组件的按钮监听函数</span>\n  changeText = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-comment">// changeText 中，调用了父组件传入的 changeFatherText 方法</span>\n    <span class="hljs-keyword">this</span>.props.changeFatherText(<span class="hljs-keyword">this</span>.state.text);\n  };\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"child"</span>&gt;</span>\n        {/* 注意这里把修改父组件文本（同时也是 Child 组件的文本）的动作放在了 NewChild 里 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span>&gt;</span>点击更新 Child 组件的文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="13039">接下来看看 Father 组件。在 Father 组件中，我们通过 text 属性连接 Father 和 Child，通过 changeText 函数来连接 Father 和 NewChild。由此便把 text 属性的渲染工作交给了 Child，把 text 属性的更新工作交给 NewÇhild，以此来实现数据从 NewChild 到 Child 的流动。Father 组件编码如下：</p>\n<pre class="lang-js" data-nodeid="13040"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// 初始化父组件的 state</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">"初始化的父组件的文本"</span>\n  };\n  <span class="hljs-comment">// 传给 NewChild 组件按钮的监听函数，用于更新父组件 text 值（这个 text 值同时也是 Child 的 props）</span>\n  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: newText\n    });\n  };\n  <span class="hljs-comment">// 渲染父组件</span>\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"father"</span>&gt;</span>\n        {/* 引入 Child 组件，并通过 props 中下发具体的状态值 实现父-子通信 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">fatherText</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>\n        {/* 引入 NewChild 组件，并通过 props 中下发可传参的函数 实现子-父通信 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">NewChild</span> <span class="hljs-attr">changeFatherText</span>=<span class="hljs-string">{this.changeText}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="13041"><strong data-nodeid="13278">视图层验证</strong></p>\n<p data-nodeid="13042">编码完成之后，界面大致的结构如下图所示：</p>\n<p data-nodeid="13043"><img src="https://s0.lgstatic.com/i/image/M00/60/F7/Ciqc1F-Om4CAaYYmAABgp6tGilY796.png" alt="Drawing 11.png" data-nodeid="13282"></p>\n<p data-nodeid="13044">由于整体结构稍微复杂了一些，这里我把 Father、Child 和 NewChild 在图中的大致范围标一下：</p>\n<p data-nodeid="13045"><img src="https://s0.lgstatic.com/i/image/M00/60/F7/Ciqc1F-Om4eAFvb7AACD10q8ddE601.png" alt="Drawing 12.png" data-nodeid="13286"></p>\n<ul data-nodeid="13046">\n<li data-nodeid="13047">\n<p data-nodeid="13048">红色所圈范围为 Father 组件，它包括了 Child 和 NewChild；</p>\n</li>\n<li data-nodeid="13049">\n<p data-nodeid="13050">灰色圈住的按钮是 NewChild 组件的渲染结果，它可以触发数据的改变；</p>\n</li>\n<li data-nodeid="13051">\n<p data-nodeid="13052">蓝色圈住的文本是 Child 组件的渲染结果，它负责感知和渲染数据。</p>\n</li>\n</ul>\n<p data-nodeid="13053">现在我点击位于 NewChild 组件中的“点击更新 Child 组件的文本”按钮，就可以看到 Child 会跟着发生变化，如下图所示，进而验证方案的可行性。</p>\n<p data-nodeid="13054"><img src="https://s0.lgstatic.com/i/image/M00/60/F7/Ciqc1F-Om5GAagXzAAIiBlsRdIM293.png" alt="Drawing 14.png" data-nodeid="13293"></p>\n<h4 data-nodeid="13055">为什么不推荐用 props 解决其他场景的需求</h4>\n<p data-nodeid="13056">至此，我们给出了 props 传参这种形式比较适合处理的三种场景。尽管这并不意味着其他场景不能用 props 处理，但如果你试图用简单的 props 传递完成更加复杂的通信需求，往往会得不偿失。这里我给你举一个比较极端的例子：</p>\n<p data-nodeid="13057"><img src="https://s0.lgstatic.com/i/image/M00/60/F8/Ciqc1F-Om5iAAUUhAABLimeJTao712.png" alt="Drawing 16.png" data-nodeid="13298"></p>\n<p data-nodeid="13058">如上图所示，可以看到这是一个典型的多层嵌套组件结构。A 组件倘若想要和层层相隔的 E 组件实现通信，就必须把 props 经过 B、C、D 一层一层地传递下去。在这个过程中，反反复复的 props 传递不仅会带来庞大的工作量和代码量，还会污染中间无辜的 B、C、D 组件的属性结构。</p>\n<p data-nodeid="13059">层层传递的优点是非常简单，用已有知识就能解决，但问题是会浪费很多代码，非常烦琐，中间作为桥梁的组件会引入很多不属于自己的属性。短期来看，写代码的人会很痛苦；长期来看，整个项目的维护成本都会变得非常高昂。因此，<strong data-nodeid="13305">层层传递 props 要不得</strong>。</p>\n<p data-nodeid="13060">那有没有更加灵活的解决方案，能够帮我们处理“任意组件”之间的通信需求呢？答案是不仅有，而且姿势还很多。我先从最朴素的“发布-订阅”模式讲起。</p>\n<h3 data-nodeid="13061">利用“发布-订阅”模式驱动数据流</h3>\n<p data-nodeid="13062">“发布-订阅”模式可谓是解决通信类问题的“万金油”，在前端世界的应用非常广泛，比如：</p>\n<ul data-nodeid="13063">\n<li data-nodeid="13064">\n<p data-nodeid="13065">前两年爆火的 socket.io 模块，它就是一个典型的跨端发布-订阅模式的实现；</p>\n</li>\n<li data-nodeid="13066">\n<p data-nodeid="13067">在 Node.js 中，许多原生模块也是以 EventEmitter 为基类实现的；</p>\n</li>\n<li data-nodeid="13068">\n<p data-nodeid="13069">不过大家最为熟知的，应该还是 Vue.js 中作为常规操作被推而广之的“全局事件总线” EventBus。</p>\n</li>\n</ul>\n<p data-nodeid="13070">这些应用之间虽然名字各不相同，但内核是一致的，也就是我们下面要讲到的“发布-订阅”模型。</p>\n<h4 data-nodeid="13071">理解事件的发布-订阅机制</h4>\n<p data-nodeid="13072">发布-订阅机制早期最广泛的应用，应该是在浏览器的 DOM 事件中。 &nbsp;相信有过原生 JavaScript 开发经验的同学，对下面这样的用法都不会陌生：</p>\n<pre class="lang-js" data-nodeid="13073"><code data-language="js">target.addEventListener(type, listener, useCapture);\n</code></pre>\n<p data-nodeid="13074">通过调用 addEventListener 方法，我们可以创建一个事件监听器，这个动作就是“订阅”。比如我可以监听 click（点击）事件：</p>\n<pre class="lang-java" data-nodeid="13075"><code data-language="java">el.addEventListener(<span class="hljs-string">"click"</span>, func, <span class="hljs-keyword">false</span>);\n</code></pre>\n<p data-nodeid="13076">这样一来，当 click 事件被触发时，事件会被“发布”出去，进而触发监听这个事件的 func 函数。这就是一个最简单的发布-订阅案例。</p>\n<p data-nodeid="13077">使用发布-订阅模式的优点在于，<strong data-nodeid="13322">监听事件的位置和触发事件的位置是不受限的</strong>，就算相隔十万八千里，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。</p>\n<h4 data-nodeid="13078">发布-订阅模型 API 设计思路</h4>\n<p data-nodeid="13079">通过前面的讲解，不难看出发布-订阅模式中有两个关键的动作：<strong data-nodeid="13329">事件的监听（订阅）和事件的触发（发布）</strong>，这两个动作自然而然地对应着两个基本的 API 方法。</p>\n<ul data-nodeid="13080">\n<li data-nodeid="13081">\n<p data-nodeid="13082">on()：负责注册事件的监听器，指定事件触发时的回调函数。</p>\n</li>\n<li data-nodeid="13083">\n<p data-nodeid="13084">emit()：负责触发事件，可以通过传参使其在触发的时候携带数据 。</p>\n</li>\n</ul>\n<p data-nodeid="13085">最后，只进不出总是不太合理的，我们还要考虑一个 off() 方法，必要的时候用它来删除用不到的监听器：</p>\n<ul data-nodeid="13086">\n<li data-nodeid="13087">\n<p data-nodeid="13088">off()：负责监听器的删除。</p>\n</li>\n</ul>\n<h4 data-nodeid="13089">发布-订阅模型编码实现</h4>\n<p data-nodeid="13090">“发布-订阅”模式不仅在应用层面十分受欢迎，它更是面试官的心头好。在涉及设计模式的面试中，如果只允许出一道题，那么我相信大多数的面试官都会和我一样，会毫不犹豫地选择考察“发布-订阅模式的实现”。 接下来我就手把手带你来做这道题，写出一个同时拥有 on、emit 和 off 的 EventEmitter。</p>\n<p data-nodeid="13091">在写代码之前，先要捋清楚思路。这里我把“实现 EventEmitter”这个大问题，拆解为 3 个具体的小问题，下面我们逐个来解决。</p>\n<ul data-nodeid="13092">\n<li data-nodeid="13093">\n<p data-nodeid="13094"><strong data-nodeid="13340">问题一：事件和监听函数的对应关系如何处理？</strong></p>\n</li>\n</ul>\n<p data-nodeid="13095">提到“对应关系”，应该联想到的是“映射”。在 JavaScript 中，处理“映射”我们大部分情况下都是用对象来做的。所以说在全局我们需要设置一个对象，来存储事件和监听函数之间的关系：</p>\n<pre class="lang-java" data-nodeid="13096"><code data-language="java">constructor() {\n  <span class="hljs-comment">// eventMap 用来存储事件和监听函数之间的关系</span>\n  <span class="hljs-keyword">this</span>.eventMap= {}\n}\n</code></pre>\n<ul data-nodeid="13097">\n<li data-nodeid="13098">\n<p data-nodeid="13099"><strong data-nodeid="13345">问题二：如何实现订阅？</strong></p>\n</li>\n</ul>\n<p data-nodeid="16627" class="">所谓“订阅”，也就是注册事件监听函数的过程。这是一个“写”操作，具体来说就是把事件和对应的监听函数写入到 eventMap 里面去：</p>\n\n\n\n\n\n<pre class="lang-java te-preview-highlight" data-nodeid="38471"><code data-language="java"><span class="hljs-comment">// type 这里就代表事件的名称</span>\non(type, handler) {\n  <span class="hljs-comment">// hanlder 必须是一个函数，如果不是直接报错</span>\n  <span class="hljs-keyword">if</span>(!(handler <span class="hljs-keyword">instanceof</span> Function)) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"哥 你错了 请传一个函数"</span>)\n  }\n  <span class="hljs-comment">// 判断 type 事件对应的队列是否存在</span>\n  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.eventMap[type]) {\n   <span class="hljs-comment">// 若不存在，新建该队列</span>\n    <span class="hljs-keyword">this</span>.eventMap[type] = []\n  }\n  <span class="hljs-comment">// 若存在，直接往队列里推入 handler</span>\n  <span class="hljs-keyword">this</span>.eventMap[type].push(handler)\n}\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<ul data-nodeid="13102">\n<li data-nodeid="13103">\n<p data-nodeid="13104"><strong data-nodeid="13350">问题三：如何实现发布？</strong></p>\n</li>\n</ul>\n<p data-nodeid="13105">订阅操作是一个“写”操作，相应的，发布操作就是一个“读”操作。发布的本质是触发安装在某个事件上的监听函数，我们需要做的就是找到这个事件对应的监听函数队列，将队列中的 handler 依次执行出队：</p>\n<pre class="lang-java" data-nodeid="13106"><code data-language="java"><span class="hljs-comment">// 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体</span>\nemit(type, params) {\n  <span class="hljs-comment">// 假设该事件是有订阅的（对应的事件队列存在）</span>\n  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.eventMap[type]) {\n    <span class="hljs-comment">// 将事件队列里的 handler 依次执行出队</span>\n    <span class="hljs-keyword">this</span>.eventMap[type].forEach((handler, index)=&gt; {\n      <span class="hljs-comment">// 注意别忘了读取 params</span>\n      handler(params)\n    })\n  }\n}\n</code></pre>\n<p data-nodeid="13107">到这里，最最关键的 on 方法和 emit 方法就实现完毕了。最后我们补充一个 off 方法：</p>\n<pre class="lang-java" data-nodeid="13108"><code data-language="java">off(type, handler) {\n  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.eventMap[type]) {\n    <span class="hljs-keyword">this</span>.eventMap[type].splice(<span class="hljs-keyword">this</span>.eventMap[type].indexOf(handler)&gt;&gt;&gt;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)\n  }\n}\n</code></pre>\n<p data-nodeid="13109">接着把这些代码片段拼接进一个 class 里面，一个核心功能完备的 EventEmitter 就完成啦：</p>\n<pre class="lang-java" data-nodeid="13110"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myEventEmitter</span> </span>{\n  constructor() {\n    <span class="hljs-comment">// eventMap 用来存储事件和监听函数之间的关系</span>\n    <span class="hljs-keyword">this</span>.eventMap = {};\n  }\n  <span class="hljs-comment">// type 这里就代表事件的名称</span>\n  on(type, handler) {\n    <span class="hljs-comment">// hanlder 必须是一个函数，如果不是直接报错</span>\n    <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> Function)) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"哥 你错了 请传一个函数"</span>);\n    }\n    <span class="hljs-comment">// 判断 type 事件对应的队列是否存在</span>\n    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.eventMap[type]) {\n      <span class="hljs-comment">// 若不存在，新建该队列</span>\n      <span class="hljs-keyword">this</span>.eventMap[type] = [];\n    }\n    <span class="hljs-comment">// 若存在，直接往队列里推入 handler</span>\n    <span class="hljs-keyword">this</span>.eventMap[type].push(handler);\n  }\n  <span class="hljs-comment">// 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体</span>\n  emit(type, params) {\n    <span class="hljs-comment">// 假设该事件是有订阅的（对应的事件队列存在）</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventMap[type]) {\n      <span class="hljs-comment">// 将事件队列里的 handler 依次执行出队</span>\n      <span class="hljs-keyword">this</span>.eventMap[type].forEach((handler, index) =&gt; {\n        <span class="hljs-comment">// 注意别忘了读取 params</span>\n        handler(params);\n      });\n    }\n  }\n  off(type, handler) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventMap[type]) {\n      <span class="hljs-keyword">this</span>.eventMap[type].splice(<span class="hljs-keyword">this</span>.eventMap[type].indexOf(handler) &gt;&gt;&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="13111">下面我们对 myEventEmitter 进行一个简单的测试，创建一个 myEvent 对象作为 myEventEmitter 的实例，然后针对名为 “test” 的事件进行监听和触发：</p>\n<pre class="lang-java" data-nodeid="13112"><code data-language="java"><span class="hljs-comment">// 实例化 myEventEmitter</span>\n<span class="hljs-keyword">const</span> myEvent = <span class="hljs-keyword">new</span> myEventEmitter();\n<span class="hljs-comment">// 编写一个简单的 handler</span>\n<span class="hljs-keyword">const</span> testHandler = function (params) {\n  console.log(`test事件被触发了，testHandler 接收到的入参是${params}`);\n};\n<span class="hljs-comment">// 监听 test 事件</span>\nmyEvent.on(<span class="hljs-string">"test"</span>, testHandler);\n<span class="hljs-comment">// 在触发 test 事件的同时，传入希望 testHandler 感知的参数</span>\nmyEvent.emit(<span class="hljs-string">"test"</span>, <span class="hljs-string">"newState"</span>);\n</code></pre>\n<p data-nodeid="13113">以上代码会输出下面红色矩形框住的部分作为运行结果：</p>\n<p data-nodeid="13114"><img src="https://s0.lgstatic.com/i/image/M00/60/F8/Ciqc1F-Om7eAC75dAAMfTZMkn3A636.png" alt="Drawing 17.png" data-nodeid="13358"></p>\n<p data-nodeid="13115">由此可以看出，EventEmitter 的实例已经具备发布-订阅的能力，执行结果符合预期。</p>\n<p data-nodeid="13116">现在你可以试想一下，对于任意的两个组件 A 和 B，假如我希望实现双方之间的通信，借助 EventEmitter 来做就很简单了，以数据从 A 流向 B 为例。</p>\n<p data-nodeid="13117">我们可以在 B 中编写一个handler（记得将这个 handler 的 this 绑到 B 身上），在这个 handler 中进行以 B 为上下文的 this.setState 操作，然后将这个 handler 作为监听器与某个事件关联起来。比如这样：</p>\n<pre class="lang-js" data-nodeid="13118"><code data-language="js"><span class="hljs-comment">// 注意这个 myEvent 是提前实例化并挂载到全局的，此处不再重复示范实例化过程</span>\n<span class="hljs-keyword">const</span> globalEvent = <span class="hljs-built_in">window</span>.myEvent\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// 这里省略掉其他业务逻辑</span>\n  state = {\n    <span class="hljs-attr">newParams</span>: <span class="hljs-string">""</span>\n  };\n  handler = <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">newParams</span>: params\n    });\n  };\n  bindHandler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    globalEvent.on(<span class="hljs-string">"someEvent"</span>, <span class="hljs-keyword">this</span>.handler);\n  };\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.bindHandler}</span>&gt;</span>点我监听A的动作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A传入的内容是[{this.state.newParams}]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="13119">接下来在 A 组件中，只需要直接触发对应的事件，然后将希望携带给 B 的数据作为入参传递给 emit 方法即可。代码如下：</p>\n<pre class="lang-js" data-nodeid="13120"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  <span class="hljs-comment">// 这里省略掉其他业务逻辑</span>\n  state = {\n    <span class="hljs-attr">infoToB</span>: <span class="hljs-string">"哈哈哈哈我来自A"</span>\n  };\n  reportToB = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-comment">// 这里的 infoToB 表示 A 自身状态中需要让 B 感知的那部分数据</span>\n    globalEvent.emit(<span class="hljs-string">"someEvent"</span>, <span class="hljs-keyword">this</span>.state.infoToB);\n  };\n  render() {\n    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.reportToB}</span>&gt;</span>点我把state传递给B<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<p data-nodeid="13121">如此一来，便能够实现 A 到 B 的通信了。这里我将 A 与 B 编排为兄弟组件，代码如下：</p>\n<pre class="lang-js" data-nodeid="13122"><code data-language="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">B</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">A</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p data-nodeid="13123">你也可以在自己的 Demo 里将 A 和 B 定义为更加复杂的嵌套关系，这里我给出的这个 Demo 运行起来会渲染出这样的界面，如下图所示：</p>\n<p data-nodeid="13124"><img src="https://s0.lgstatic.com/i/image/M00/61/03/CgqCHl-Om8uAMxXIAAA9zJmLTSg441.png" alt="Drawing 18.png" data-nodeid="13367"></p>\n<p data-nodeid="13125" class="">依次点击顶部和底部的按钮，就可以实现对 someEvent 这个事件的监听和触发，进而观察到中间这行文本的改变，如下图所示：</p>\n<p data-nodeid="13126"><img src="https://s0.lgstatic.com/i/image/M00/60/F8/Ciqc1F-Om9CAUv1uAABH1-iBy-U054.png" alt="Drawing 19.png" data-nodeid="13371"></p>\n<p data-nodeid="13127">由此我们便可以验证到发布-订阅模式驱动 React 数据流的可行性。为了强化你对过程的理解，我将 A 与 B 的通信过程梳理进了一张图里，供你参考：</p>\n<p data-nodeid="13128"><img src="https://s0.lgstatic.com/i/image/M00/6E/B0/Ciqc1F-zbFSAa6tMAAC2rDdKPpI299.png" alt="Lark20201117-141619.png" data-nodeid="13375"></p>\n<h3 data-nodeid="13129">总结</h3>\n<p data-nodeid="13130">本课时，我们对 React 数据流管理方案中的前两个大方向进行了学习：</p>\n<ul data-nodeid="13131">\n<li data-nodeid="13132">\n<p data-nodeid="13133">使用基于 Props 的单向数据流串联父子、兄弟组件；</p>\n</li>\n<li data-nodeid="13134">\n<p data-nodeid="13135">利用“发布-订阅”模式驱动 React 数据在任意组件间流动。</p>\n</li>\n</ul>\n<p data-nodeid="13136">这两个方向下的解决方案，单纯从理解上来看，难度都不高。<strong data-nodeid="13385">你需要把重点放在对编码的实现和理解上，尤其是基于“发布-订阅”模式实现的 EventEmitter，多年来一直是面试的大热点，务必要好好把握</strong>。</p>\n<p data-nodeid="13137" class="">这一课时就讲到这里了，下个课时，我们将继续站在“数据在 React 组件中的流动”这个视角，对 React 中的 Context API，以及第三方数据流管理框架中的“佼佼者” Redux 进行分析，相信一定能够为你带来不一样的理解和收获。</p>',
          },
          {
            theme: '05 | 数据是如何在 React 组件之间流动的？（下）',
            id: 26,
            content:
              '<p data-nodeid="1337" class="">在上个课时，我们掌握了 React 数据流方案中风格相对“朴素”的 Props 单向数据流方案，以及通用性较强的“发布-订阅”模式。在本课时，我们将一起认识 React 天然具备的全局通信方式“Context API”，并对 Redux 的设计思想和编码形态进行初步的探索。</p>\n<h3 data-nodeid="1338">使用 Context API 维护全局状态</h3>\n<p data-nodeid="1339">Context API 是 React 官方提供的一种组件树全局通信的方式。</p>\n<p data-nodeid="1340">在 React 16.3 之前，Context API 由于存在种种局限性，并不被 React 官方提倡使用，开发者更多的是把它作为一个概念来探讨。而从 v 16.3.0 开始，React 对 Context API 进行了改进，新的 Context API 具备更强的可用性。这里我们首先针对 React 16 下 Context API 的形态进行介绍。</p>\n<h4 data-nodeid="1341">图解 Context API 工作流</h4>\n<p data-nodeid="1342">Context API 有 3 个关键的要素：React.createContext、Provider、Consumer。</p>\n<p data-nodeid="1343">我们通过调用 React.createContext，可以创建出一组 Provider。Provider 作为数据的提供方，可以将数据下发给自身组件树中任意层级的 Consumer，这三者之间的关系用一张图来表示：</p>\n<p data-nodeid="1344"><img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm7iAQ6ZRAAEW2Me7WVg371.png" alt="图片3.png" data-nodeid="1459"></p>\n<p data-nodeid="1345">注意：Cosumer 不仅能够读取到 Provider 下发的数据，<strong data-nodeid="1465">还能读取到这些数据后续的更新</strong>。这意味着数据在生产者和消费者之间能够及时同步，这对 Context 这种模式来说至关重要。</p>\n<h4 data-nodeid="1346">从编码的角度认识“三要素”</h4>\n<ul data-nodeid="1347">\n<li data-nodeid="1348">\n<p data-nodeid="1349"><strong data-nodeid="1471">React.createContext</strong>，作用是创建一个 context 对象。下面是一个简单的用法示范：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="1350"><code data-language="java"><span class="hljs-keyword">const</span> AppContext = React.createContext()\n</code></pre>\n<p data-nodeid="1351">注意，在创建的过程中，我们可以选择性地传入一个 defaultValue：</p>\n<pre class="lang-java" data-nodeid="1352"><code data-language="java"><span class="hljs-keyword">const</span> AppContext = React.createContext(defaultValue)\n</code></pre>\n<p data-nodeid="1353">从创建出的 context 对象中，我们可以读取到 Provider 和 Consumer：</p>\n<pre class="lang-java" data-nodeid="1354"><code data-language="java"><span class="hljs-keyword">const</span> { Provider, Consumer } = AppContext\n</code></pre>\n<ul data-nodeid="1355">\n<li data-nodeid="1356">\n<p data-nodeid="1357"><strong data-nodeid="1478">Provider</strong>，可以理解为“数据的 Provider（提供者）”。</p>\n</li>\n</ul>\n<p data-nodeid="1358">我们使用 Provider 对组件树中的根组件进行包裹，然后传入名为“value”的属性，这个 value 就是后续在组件树中流动的“数据”，它可以被 Consumer 消费。使用示例如下：</p>\n<pre class="lang-java" data-nodeid="1359"><code data-language="java">&lt;Provider value={title: this.state.title, content: this.state.content}&gt;\n  &lt;Title /&gt;\n  &lt;Content /&gt;\n &lt;/Provider&gt;\n</code></pre>\n<ul data-nodeid="1360">\n<li data-nodeid="1361">\n<p data-nodeid="1362"><strong data-nodeid="1484">Consumer</strong>，顾名思义就是“数据的消费者”，它可以读取 Provider 下发下来的数据。</p>\n</li>\n</ul>\n<p data-nodeid="1363">其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。像这样：</p>\n<pre class="lang-js" data-nodeid="1364"><code data-language="js">&lt;Consumer&gt;\n  {value =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{value.title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>}\n&lt;/Consumer&gt;\n</code></pre>\n<p data-nodeid="1365">注意，当 Consumer 没有对应的 Provider 时，value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。</p>\n<h4 data-nodeid="1366">新的 Context API 解决了什么问题</h4>\n<p data-nodeid="1367">想要知道新的 Context API 解决了什么问题，先要知道过时的 Context API 存在什么问题。</p>\n<p data-nodeid="1368"><strong data-nodeid="1492">我们先从编码角度认识“过时的”Context API</strong></p>\n<p data-nodeid="1369">“过时的”是 React 官方对旧的 &nbsp;Context API 的描述，由于个人和团队在实际项目中都并不会考虑去使用旧 Context API 来解决问题，这里我直接引用<a href="https://zh-hans.reactjs.org/docs/legacy-context.html" data-nodeid="1496">过时的文档</a>中的 Context API 使用示例：</p>\n<pre class="lang-js" data-nodeid="1370"><code data-language="js"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">\'prop-types\'</span>;\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{background:</span> <span class="hljs-attr">this.context.color</span>}}&gt;</span>\n        {this.props.children}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n    );\n  }\n}\nButton.contextTypes = {\n  <span class="hljs-attr">color</span>: PropTypes.string\n};\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        {this.props.text} <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Delete<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  getChildContext() {\n    <span class="hljs-keyword">return</span> {<span class="hljs-attr">color</span>: <span class="hljs-string">"purple"</span>};\n  }\n  render() {\n    <span class="hljs-keyword">const</span> children = <span class="hljs-keyword">this</span>.props.messages.map(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span>\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Message</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{message.text}</span> /&gt;</span></span>\n    );\n    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n}\nMessageList.childContextTypes = {\n  <span class="hljs-attr">color</span>: PropTypes.string\n};\n</code></pre>\n<p data-nodeid="1371">为了方便你理解，我将上述代码对应的组织结构梳理到一张图里，如下图所示：</p>\n<p data-nodeid="1372"><img src="https://s0.lgstatic.com/i/image/M00/62/8C/Ciqc1F-Sm8qAMOB0AAEcBeEv_vs533.png" alt="图片4.png" data-nodeid="1501"></p>\n<p data-nodeid="1373">借着这张图，我们来理解旧的 Context API 的工作过程：</p>\n<ul data-nodeid="1374">\n<li data-nodeid="1375">\n<p data-nodeid="1376">首先，通过给 MessageList 设置 childContextTypes 和 getChildContext，可以使其承担起 context 的生产者的角色；</p>\n</li>\n<li data-nodeid="1377">\n<p data-nodeid="1378">然后，MessageList 的组件树内部所有层级的组件都可以通过定义 contextTypes 来成为数据的消费者，进而通过 this.context 访问到 MessageList 提供的数据。</p>\n</li>\n</ul>\n<p data-nodeid="1379">现在回过头来，我们再从编码角度审视一遍“过时的” Context API 的用法。</p>\n<p data-nodeid="1380">首先映入眼帘的第一个问题是<strong data-nodeid="1511">代码不够优雅</strong>：一眼望去，你很难迅速辨别出谁是 Provider、谁是 Consumer。同时这琐碎的属性设置和 API 编写过程，也足够我们写代码的时候“喝一壶了”。总而言之，从编码形态的角度来说，“过时的” Context API 和新 Context API 相去甚远。</p>\n<p data-nodeid="1381">不过，这还不是最要命的，最要命的弊端我们从编码层面暂时感知不出来，但是一旦你感知到它，麻烦就大了——前面我们特别提到过，“Cosumer 不仅能够读取到 Provider 下发的数据，<strong data-nodeid="1517">还能够读取到这些数据后续的更新”</strong>。数据在生产者和消费者之间的及时同步，这一点对于 Context 这种模式来说是至关重要的，但旧的 Conext API 无法保证这一点：</p>\n<blockquote data-nodeid="1382">\n<p data-nodeid="1383">如果组件提供的一个Context发生了变化，而中间父组件的 shouldComponentUpdate 返回 false，<strong data-nodeid="1527">那么使用到该值的后代组件不会进行更新</strong>。使用了 Context 的组件则完全失控，所以基本上没有办法能够可靠的更新 Context。<a href="https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076" data-nodeid="1525">这篇博客文章</a>很好地解释了为何会出现此类问题，以及你该如何规避它。 &nbsp;——React 官方</p>\n</blockquote>\n<p data-nodeid="1384">新的 Context API 改进了这一点：<strong data-nodeid="1537">即便组件的 shouldComponentUpdate 返回 false，它仍然可以“穿透”组件继续向后代组件进行传播</strong>，<strong data-nodeid="1538">进而确保了数据生产者和数据消费者之间数据的一致性</strong>。再加上更加“好看”的语义化的声明式写法，新版 Context API 终于顺利地摘掉了“试验性 API”的帽子，成了一种确实可行的 React 组件间通信解决方案。</p>\n<p data-nodeid="1385">理解了 Context API 的前世今生，接下来我们继续来串联 React 组件间通信的解决方案。</p>\n<h3 data-nodeid="1386">第三方数据流框架“课代表”：初探 Redux</h3>\n<p data-nodeid="1387">对于简单的跨层级组件通信，我们可以使用发布-订阅模式或者 Context API 来搞定。但是随着应用的复杂度不断提升，需要维护的状态越来越多，组件间的关系也越来越难以处理的时候，我们就需要请出 Redux 来帮忙了。</p>\n<h4 data-nodeid="1388">什么是 Redux</h4>\n<p data-nodeid="1389">我们先来看一下官方对 Redux 的描述：</p>\n<blockquote data-nodeid="1390">\n<p data-nodeid="1391">Redux 是 JavaScript 状态容器，它提供可预测的状态管理。</p>\n</blockquote>\n<p data-nodeid="1392">我们一起品品这句话背后的深意：</p>\n<ul data-nodeid="1393">\n<li data-nodeid="1394">\n<p data-nodeid="1395">Redux 是为<strong data-nodeid="1551">JavaScript</strong>应用而生的，也就是说它不是 React 的专利，React 可以用，Vue 可以用，原生 JavaScript 也可以用；</p>\n</li>\n<li data-nodeid="1396">\n<p data-nodeid="1397">Redux 是一个<strong data-nodeid="1557">状态容器</strong>，什么是状态容器？这里我举个例子。</p>\n</li>\n</ul>\n<p data-nodeid="1398">假如把一个 React 项目里面的所有组件拉进一个钉钉群，那么 Redux 就充当了这个群里的“群文件”角色，所有的组件都可以把需要在组件树里流动的数据存储在群文件里。当某个数据改变的时候，其他组件都能够通过下载最新的群文件来获取到数据的最新值。这就是“状态容器”的含义——存放公共数据的仓库。</p>\n<p data-nodeid="1399">读懂了这个比喻之后，你对 Redux、数据和 React 组件的关系想必已经形成了一个初步的认知。这里我帮你把这层关系总结进一张图里：</p>\n<p data-nodeid="1400"><img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm9qASdHXAAEjhh30y4s113.png" alt="图片5.png" data-nodeid="1562"></p>\n<h4 data-nodeid="1401">Redux 是如何帮助 React 管理数据的</h4>\n<p data-nodeid="1402">Redux 主要由三部分组成：store、reducer 和 action。我们先来看看它们各自代表什么：</p>\n<ul data-nodeid="1403">\n<li data-nodeid="1404">\n<p data-nodeid="1405">store 就好比组件群里的“群文件”，它是一个<strong data-nodeid="1570">单一的数据源</strong>，而且是只读的；</p>\n</li>\n<li data-nodeid="1406">\n<p data-nodeid="1407">action 人如其名，是“动作”的意思，它是<strong data-nodeid="1576">对变化的描述</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="1408">举个例子，下面这个对象就是一个 action：</p>\n<pre class="lang-java" data-nodeid="1409"><code data-language="java"><span class="hljs-keyword">const</span> action = {\n  type: <span class="hljs-string">"ADD_ITEM"</span>,\n  payload: <span class="hljs-string">\'&lt;li&gt;text&lt;/li&gt;\'</span>\n}\n</code></pre>\n<ul data-nodeid="1410">\n<li data-nodeid="1411">\n<p data-nodeid="1412">reducer 是一个函数，它负责<strong data-nodeid="1583">对变化进行分发和处理，</strong> 最终将新的数据返回给 store。</p>\n</li>\n</ul>\n<p data-nodeid="1413">store、action 和 reducer 三者紧密配合，便形成了 Redux 独树一帜的工作流：</p>\n<p data-nodeid="1414"><img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm-yADE6PAACSEywFSaA197.png" alt="图片6.png" data-nodeid="1587"></p>\n<p data-nodeid="1415">从上图中，我们首先读出的是数据的流向规律：<strong data-nodeid="1593">在 Redux 的整个工作过程中，数据流是严格单向的</strong>。这一点一定一定要背下来，面试的时候也一定一定要记得说——不管面试官问的是 Redux 的设计思想还是工作流还是别的什么概念性的知识，开局先放这句话，准没错。</p>\n<p data-nodeid="1416">接下来仍然是围绕上图，我们来一起看看 Redux 是如何帮助 React 管理数据流的。对于一个 React 应用来说，视图（View）层面的所有数据（state）都来自 store（再一次诠释了单一数据源的原则）。</p>\n<p data-nodeid="1417">如果你想对数据进行修改，只有一种途径：派发 action。action 会被 reducer 读取，进而根据 action 内容的不同对数据进行修改、生成新的 state（状态），这个新的 state 会更新到 store 对象里，进而驱动视图层面做出对应的改变。</p>\n<p data-nodeid="1418">对于组件来说，任何组件都可以通过约定的方式从 store 读取到全局的状态，任何组件也都可以通过合理地派发 action 来修改全局的状态。<strong data-nodeid="1601">Redux 通过提供一个统一的状态容器，使得数据能够自由而有序地在任意组件之间穿梭</strong>，这就是 Redux 实现组件间通信的思路。</p>\n<h4 data-nodeid="1419">从编码的角度理解 Redux 工作流</h4>\n<p data-nodeid="1420">到这里，你已经了解了 Redux 的设计思想和要素关系。接下来我们将站在编码的角度，探讨 Redux 的工作流，将上文中所提及的各个要素和流程具象化。</p>\n<p data-nodeid="1421"><strong data-nodeid="1609">1. 使用 createStore 来完成 store 对象的创建</strong></p>\n<pre class="lang-java" data-nodeid="1422"><code data-language="java"><span class="hljs-comment">// 引入 redux</span>\n<span class="hljs-keyword">import</span> { createStore } from <span class="hljs-string">\'redux\'</span>\n<span class="hljs-comment">// 创建 store</span>\n<span class="hljs-keyword">const</span> store = createStore(\n    reducer,\n    initial_state,\n    applyMiddleware(middleware1, middleware2, ...)\n);\n</code></pre>\n<p data-nodeid="1423">createStore 方法是一切的开始，它接收三个入参：</p>\n<ul data-nodeid="1424">\n<li data-nodeid="1425">\n<p data-nodeid="1426">reducer；</p>\n</li>\n<li data-nodeid="1427">\n<p data-nodeid="1428">初始状态内容；</p>\n</li>\n<li data-nodeid="1429">\n<p data-nodeid="1430">指定中间件（这个你先不用管）。</p>\n</li>\n</ul>\n<p data-nodeid="1431">这其中一般来说，只有 reducer 是你不得不传的。下面我们就看看 reducer 的编码形态是什么样的。</p>\n<p data-nodeid="1432"><strong data-nodeid="1620">2. reducer 的作用是将新的 state 返回给 store</strong></p>\n<p data-nodeid="1433">一个 reducer 一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个 state：</p>\n<pre class="lang-java" data-nodeid="1434"><code data-language="java"><span class="hljs-keyword">const</span> reducer = (state, action) =&gt; {\n    <span class="hljs-comment">// 此处是各种样的 state处理逻辑</span>\n    <span class="hljs-keyword">return</span> new_state\n}\n</code></pre>\n<p data-nodeid="1435">当我们基于某个 reducer 去创建 store 的时候，其实就是给这个 store 指定了一套更新规则：</p>\n<pre class="lang-java" data-nodeid="1436"><code data-language="java"><span class="hljs-comment">// 更新规则全都写在 reducer 里 </span>\n<span class="hljs-keyword">const</span> store = createStore(reducer)\n</code></pre>\n<p data-nodeid="1437"><strong data-nodeid="1628">3. action 的作用是通知 reducer “让改变发生”</strong></p>\n<p data-nodeid="1438">如何在浩如烟海的 store 状态库中，准确地命中某个我们希望它发生改变的 state 呢？reducer 内部的逻辑虽然不尽相同，但其本质工作都是“将 action 与和它对应的更新动作对应起来，并处理这个更新”。所以说<strong data-nodeid="1634">要想让 state 发生改变，就必须用正确的 action 来驱动这个改变</strong>。</p>\n<p data-nodeid="1439">前面我们已经介绍过 action 的形态，这里再提点一下。首先，action 是一个大致长这样的对象：</p>\n<pre class="lang-java" data-nodeid="1440"><code data-language="java"><span class="hljs-keyword">const</span> action = {\n  type: <span class="hljs-string">"ADD_ITEM"</span>,\n  payload: <span class="hljs-string">\'&lt;li&gt;text&lt;/li&gt;\'</span>\n}\n</code></pre>\n<p data-nodeid="1441">action 对象中允许传入的属性有多个，<strong data-nodeid="1641">但只有 type 是必传的</strong>。type 是 action 的唯一标识，reducer 正是通过不同的 type 来识别出需要更新的不同的 state，由此才能够实现精准的“定向更新”。</p>\n<p data-nodeid="1442"><strong data-nodeid="1647">4. 派发 action，靠的是 dispatch</strong></p>\n<p data-nodeid="1443">action 本身只是一个对象，要想让 reducer 感知到 action，还需要“派发 action”这个动作，这个动作是由 store.dispatch 完成的。这里我简单地示范一下：</p>\n<pre class="lang-java" data-nodeid="1444"><code data-language="java"><span class="hljs-keyword">import</span> { createStore } from <span class="hljs-string">\'redux\'</span>\n<span class="hljs-comment">// 创建 reducer</span>\n<span class="hljs-keyword">const</span> reducer = (state, action) =&gt; {\n    <span class="hljs-comment">// 此处是各种样的 state处理逻辑</span>\n    <span class="hljs-keyword">return</span> new_state\n}\n<span class="hljs-comment">// 基于 reducer 创建 state</span>\n<span class="hljs-keyword">const</span> store = createStore(reducer)\n<span class="hljs-comment">// 创建一个 action，这个 action 用 “ADD_ITEM” 来标识 </span>\n<span class="hljs-keyword">const</span> action = {\n  type: <span class="hljs-string">"ADD_ITEM"</span>,\n  payload: <span class="hljs-string">\'&lt;li&gt;text&lt;/li&gt;\'</span>\n}\n<span class="hljs-comment">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span>\nstore.dispatch(action)\n</code></pre>\n<p data-nodeid="2338">以上这段代码，是从编码角度对 Redux 主要工作流的概括，这里我同样为你总结了一张对应的流程图：</p>\n<p data-nodeid="3019"><img src="https://s0.lgstatic.com/i/image/M00/81/9F/CgqCHl_Rii2AVvUbAADn4s_6rB8369.png" alt="图片7.png" data-nodeid="3023"></p>\n<p data-nodeid="3020">注意：先别急着死磕。本课时并不要求你掌握 Redux 中涉及的所有概念和原理，只需要你跟着我的思路走，大致理解 Redux 中几个关键角色之间的关系，进而明白 Redux 是如何驱动数据在 React 组件间流动、如何帮助我们实现<strong data-nodeid="3029">灵活的组件间通信</strong>的，这就够了。关于更多 Redux 的技术细节，我将在专栏的第三个大模块慢慢推敲。</p>\n\n\n\n\n\n<h3 data-nodeid="1448">总结</h3>\n<p data-nodeid="1449" class="">在 04 和 05 课时，我讲解的知识点覆盖面广、跨度大。面试场景下，考察此类问题的目的也主要是对候选人的知识广度进行检验。因此对于这两节的内容，你应抱着梳理“<strong data-nodeid="1669">知识地图</strong>”的目的去学习，以<strong data-nodeid="1670">构建知识体系</strong>为第一要务。完成第一要务后，再带着一个完整的上下文，去攻克某个具体的薄弱点。</p>',
          },
          {
            theme: '06 | React-Hooks 设计动机与工作模式（上）',
            id: 27,
            content:
              '<p data-nodeid="1253" class="">从本课时开始，我们将逐步进入 React-Hooks 的世界。</p>\n<p data-nodeid="1254">在动笔写 React-Hooks 之前，我发现许多人对这块的知识非常不自信，至少在面试场景下，几乎没有几个人在聊到 React-Hooks 的时候，能像聊 Diff 算法、Fiber 架构一样滔滔不绝、言之有物。后来我仔细反思了一下，认为问题应该出在学习姿势上。</p>\n<p data-nodeid="1255">提起 React-Hooks，可能很多人的第一反应，都会是 useState、useEffect、useContext 这些琐碎且繁多的 API。似乎 React-Hooks 就是一坨没有感情的工具性代码，压根没有啥玄妙的东西在里面，那些大厂面试官天天让咱聊 React-Hooks，到底是想听啥呢？</p>\n<h3 data-nodeid="1256">掌握 React-Hooks 的正确姿势</h3>\n<p data-nodeid="1257">前面我和你聊到过，当我们由浅入深地认知一样新事物的时候，往往需要遵循“Why→What→How”这样的一个认知过程。</p>\n<p data-nodeid="1258">在我的读者中，不少人在“What”和“How”这两个环节做得都不错，但是却疏于钻研背后的“Why”。其实这三者是相辅相成、缺一不可的：当我们了解了具体的“What”和“How”之后，往往能够更加具象地回答理论层面“Why”的问题；而我们对“Why”的探索和认知，也必然会反哺到对“What”的理解和对“How”的实践。</p>\n<p data-nodeid="1259">这其中，我们尤其不能忽略对“Why”的把控。</p>\n<p data-nodeid="1260"><img src="https://s0.lgstatic.com/i/image/M00/65/48/CgqCHl-aaC-AP5wdAACO3S8xt5c566.png" alt="1.png" data-nodeid="1349"></p>\n<p data-nodeid="1261">React-Hooks 自 React 16.8 以来才真正被推而广之，对我们每一个老 React 开发来说，它都是一个新事物。如果在认知它的过程当中，我们能够遵循“Why→What→How”这样的一个学习法则，并且以此为线索，梳理出属于自己的完整知识链路。那么我相信，面对再刁钻的面试官，你都可以做到心中有数、对答如流。</p>\n<p data-nodeid="1262">接下来两个课时，我们就遵循这个学习法则，向 React-Hooks 发起挑战，真正理解它背后的设计动机与工作模式。</p>\n<h3 data-nodeid="1263">React-Hooks 设计动机初探</h3>\n<p data-nodeid="1264">开篇我们先来聊“Why”。React-Hooks 这个东西比较特别，它是 React 团队在真刀真枪的 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对<strong data-nodeid="1362">类组件</strong>和<strong data-nodeid="1363">函数组件</strong>两种组件形式的思考和侧重。因此，你首先得知道，什么是类组件、什么是函数组件，并完成对这两种组件形式的辨析。</p>\n<h4 data-nodeid="1265">何谓类组件（Class Component）</h4>\n<p data-nodeid="1266">所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个典型的类组件：</p>\n<pre class="lang-js" data-nodeid="1267"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n \n  <span class="hljs-comment">// 初始化类组件的 state</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">""</span>\n  };\n  <span class="hljs-comment">// 编写生命周期方法 didMount</span>\n  componentDidMount() {\n    <span class="hljs-comment">// 省略业务逻辑</span>\n  }\n  <span class="hljs-comment">// 编写自定义的实例方法</span>\n  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> {\n    <span class="hljs-comment">// 更新 state</span>\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: newText\n    });\n  };\n  <span class="hljs-comment">// 编写生命周期方法 render</span>\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"demoClass"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span>&gt;</span>点我修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<h4 data-nodeid="1268">何谓函数组件/无状态组件（Function Component/Stateless Component）</h4>\n<p data-nodeid="1269">函数组件顾名思义，就是<strong data-nodeid="1372">以函数的形态</strong>存在的 React 组件。早期并没有 React-Hooks 的加持，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个典型的函数组件：</p>\n<pre class="lang-js" data-nodeid="1270"><code data-language="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DemoFunction</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">const</span> { text } = props\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"demoFunction"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{`function 组件所接收到的来自外界的文本内容是：[${text}]`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4 data-nodeid="1271">函数组件与类组件的对比：无关“优劣”，只谈“不同”</h4>\n<p data-nodeid="1272">我们先基于上面的两个 Demo，从形态上对两种组件做区分。它们之间肉眼可见的区别就包括但不限于：</p>\n<ul data-nodeid="1273">\n<li data-nodeid="1274">\n<p data-nodeid="1275">类组件需要继承 class，函数组件不需要；</p>\n</li>\n<li data-nodeid="1276">\n<p data-nodeid="1277">类组件可以访问生命周期方法，函数组件不能；</p>\n</li>\n<li data-nodeid="1278">\n<p data-nodeid="1279">类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</p>\n</li>\n<li data-nodeid="1280">\n<p data-nodeid="1281">类组件中可以定义并维护 state（状态），而函数组件不可以；</p>\n</li>\n<li data-nodeid="1282">\n<p data-nodeid="1283">......</p>\n</li>\n</ul>\n<p data-nodeid="1284">单就我们列出的这几点里面，频繁出现了“类组件可以 xxx，函数组件不可以 xxx”，这是否就意味着类组件比函数组件更好呢？</p>\n<p data-nodeid="1285">答案当然是否定的。你可以说，在 React-Hooks 出现之前的世界里，<strong data-nodeid="1386">类组件的能力边界明显强于函数组件</strong>，但要进一步推导“类组件强于函数组件”，未免显得有些牵强。同理，一些文章中一味鼓吹函数组件轻量优雅上手迅速，不久的将来一定会把类组件干没（类组件：我做错了什么？）之类的，更是不可偏听偏信。</p>\n<p data-nodeid="1286">当我们讨论这两种组件形式时，<strong data-nodeid="1392">不应怀揣“孰优孰劣”这样的成见，而应该更多地去关注两者的不同，进而把不同的特性与不同的场景做连接</strong>，这样才能求得一个全面的、辩证的认知。</p>\n<h3 data-nodeid="1287">重新理解类组件：包裹在面向对象思想下的“重装战舰”</h3>\n<p data-nodeid="1288">类组件是面向对象编程思想的一种表征。面向对象是一个老生常谈的概念了，当我们应用面向对象的时候，总是会有意或无意地做这样两件事情。</p>\n<ol data-nodeid="1289">\n<li data-nodeid="1290">\n<p data-nodeid="1291">封装：将一类属性和方法，“聚拢”到一个 Class 里去。</p>\n</li>\n<li data-nodeid="1292">\n<p data-nodeid="1293">继承：新的 Class 可以通过继承现有 Class，实现对某一类属性和方法的复用。</p>\n</li>\n</ol>\n<p data-nodeid="1294">React 类组件也不例外。我们再次审视一下这个典型的类组件 Case：</p>\n<pre class="lang-js" data-nodeid="1295"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n \n  <span class="hljs-comment">// 初始化类组件的 state</span>\n  state = {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">""</span>\n  };\n  <span class="hljs-comment">// 编写生命周期方法 didMount</span>\n  componentDidMount() {\n    <span class="hljs-comment">// 省略业务逻辑</span>\n  }\n  <span class="hljs-comment">// 编写自定义的实例方法</span>\n  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> {\n    <span class="hljs-comment">// 更新 state</span>\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">text</span>: newText\n    });\n  };\n  <span class="hljs-comment">// 编写生命周期方法 render</span>\n  render() {\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"demoClass"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span>&gt;</span>点我修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="1296">不难看出，React 类组件内部预置了相当多的“现成的东西”等着你去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，你只需要轻轻地<strong data-nodeid="1403">继承</strong>一个 React.Component 即可。</p>\n<p data-nodeid="1297">这种感觉就好像是你不费吹灰之力，就拥有了一辆“重装战舰”，该有的枪炮导弹早已配备整齐，就等你操纵控制台上的一堆开关了。</p>\n<p data-nodeid="1298">毋庸置疑，类组件给到开发者的东西是足够多的，但“多”就是“好”吗？其实未必。</p>\n<p data-nodeid="1299">把一个人塞进重装战舰里，他就一定能操纵这台战舰吗？如果他没有经过严格的训练，不清楚每一个操作点的内涵，那他极有可能会把炮弹打到友军的营地里去。</p>\n<p data-nodeid="1300">React 类组件，也有同样的问题——它提供了多少东西，你就需要学多少东西。假如背不住生命周期，你的组件逻辑顺序大概率会变成一团糟。<strong data-nodeid="1412">“大而全”的背后，是不可忽视的学习成本</strong>。</p>\n<p data-nodeid="1301">再想这样一个场景：假如我现在只是需要打死一只蚊子，而不是打掉一个军队。这时候继续开动重装战舰，是不是正应了那句老话——“可以，但没有必要”。这也是类组件的一个不便，<strong data-nodeid="1418">它太重了</strong>，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。</p>\n<p data-nodeid="1302">更要命的是，由于开发者编写的逻辑在<strong data-nodeid="1430">封装</strong>后是和组件粘在一起的，这就使得类**组件内部的逻辑难以实现拆分和复用。**如果你想要打破这个僵局，则需要进一步学习更加复杂的设计模式（比如高阶组件、Render Props 等），用更高的学习成本来交换一点点编码的灵活度。</p>\n<p data-nodeid="1303">这一切的一切，光是想想就让人头秃。所以说，<strong data-nodeid="1436">类组件固然强大， 但它绝非万能</strong>。</p>\n<h3 data-nodeid="1304">深入理解函数组件：呼应 React 设计思想的“轻巧快艇”</h3>\n<p data-nodeid="1305">我们再来看这个函数组件的 case：</p>\n<pre class="lang-js" data-nodeid="1306"><code data-language="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DemoFunction</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">const</span> { text } = props\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"demoFunction"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{`function 组件所接收到的来自外界的文本内容是：[${text}]`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p data-nodeid="1307">当然啦，要是你以为函数组件的简单是因为它只能承担渲染这一种任务，那可就太小瞧它了。它同样能够承接相对复杂的交互逻辑，像这样：</p>\n<pre class="lang-js" data-nodeid="1308"><code data-language="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DemoFunction</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">const</span> { text } = props \n\n  <span class="hljs-keyword">const</span> showAlert = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> {\n    alert(<span class="hljs-string">`我接收到的文本是<span class="hljs-subst">${text}</span>`</span>)\n  } \n\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"demoFunction"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{`function 组件所接收到的来自外界的文本内容是：[${text}]`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{showAlert}</span>&gt;</span>点击弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p data-nodeid="1309">相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。这些要素毫无疑问是重要的，它们也确实驱动着 React 团队做出改变。但是除此之外，还有一个非常容易被大家忽视、也极少有人能真正理解到的知识点，我在这里要着重讲一下。这个知识点缘起于 React 作者 Dan 早期特意为类组件和函数组件写过的<a href="https://overreacted.io/how-are-function-components-different-from-classes/" data-nodeid="1443">一篇非常棒的对比文章</a>，这篇文章很长，但是通篇都在论证这一句话：</p>\n<blockquote data-nodeid="1310">\n<p data-nodeid="1311"><strong data-nodeid="1448">函数组件会捕获 render 内部的状态，这是两类组件最大的不同。</strong></p>\n</blockquote>\n<p data-nodeid="1312">初读这篇文章时，我像文中的作者一样，感慨 JS 闭包机制竟能给到我们这么重要的解决问题的灵感。但在反复思考过后的现在，我更希望引导我的读者们去认知到这样一件事情——<strong data-nodeid="1454">类组件和函数组件之间，纵有千差万别，但最不能够被我们忽视掉的，是心智模式层面的差异</strong>，是面向对象和函数式编程这两套不同的设计思想之间的差异。</p>\n<p data-nodeid="1313">说得更具体一点，<strong data-nodeid="1460">函数组件更加契合 React 框架的设计理念</strong>。何出此言？不要忘了这个赫赫有名的 React 公式：</p>\n<p data-nodeid="1314"><img src="https://s0.lgstatic.com/i/image/M00/65/49/CgqCHl-aaQSAFRMAAAA9kdaM6Jw090.png" alt="2.png" data-nodeid="1463"></p>\n<p data-nodeid="1315">不夸张地说，<strong data-nodeid="1481">React 组件本身的定位就是函数，一个吃进数据、吐出 UI 的函数</strong>。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地<strong data-nodeid="1482">把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去</strong>。这就意味着从原则上来讲，<strong data-nodeid="1483">React 的数据应该总是紧紧地和渲染绑定在一起的</strong>，<strong data-nodeid="1484">而类组件做不到这一点</strong>。</p>\n<p data-nodeid="1316">为什么类组件做不到？这里我摘出上述<a href="https://overreacted.io/how-are-function-components-different-from-classes/" data-nodeid="1488">文章</a>中的 Demo，站在一个新的视角来解读一下“**函数组件会捕获 render 内部的状态，这是两类组件最大的不同”**这个结论。首先我们来看这样一个类组件：</p>\n<pre class="lang-js" data-nodeid="1317"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  showMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    alert(<span class="hljs-string">\'Followed \'</span> + <span class="hljs-keyword">this</span>.props.user);\n  };\n  handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    setTimeout(<span class="hljs-keyword">this</span>.showMessage, <span class="hljs-number">3000</span>);\n  };\n  render() {\n    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>Follow<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<p data-nodeid="1318">这个组件返回的是一个按钮，交互内容也很简单：点击按钮后，过 3s，界面上会弹出“Followed xxx”的文案。类似于我们在微博上点击“关注某人”之后弹出的“已关注”这样的提醒。</p>\n<p data-nodeid="1319">看起来好像没啥毛病，但是如果你在这个<a href="https://codesandbox.io/s/pjqnl16lm7" data-nodeid="1500">在线 Demo</a>中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：</p>\n<p data-nodeid="1320"><img src="https://s0.lgstatic.com/i/image/M00/65/3D/Ciqc1F-aaNGAQ0imAAETlLd2DpM458.png" alt="3.png" data-nodeid="1504"></p>\n<p data-nodeid="1321">图源：<a href="https://overreacted.io/how-are-function-components-different-from-classes/" data-nodeid="1508">https://overreacted.io/how-are-function-components-different-from-classes/</a></p>\n<p data-nodeid="1322">明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！</p>\n<p data-nodeid="1323">这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？</p>\n<p data-nodeid="1324">因为<strong data-nodeid="1516">虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的</strong>，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。</p>\n<p data-nodeid="1325">多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，<strong data-nodeid="1522">我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联</strong>，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。</p>\n<p data-nodeid="1326">但如果我们把 ProfilePage 改造为一个像这样的函数组件：</p>\n<pre class="lang-js" data-nodeid="1327"><code data-language="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProfilePage</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">const</span> showMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    alert(<span class="hljs-string">\'Followed \'</span> + props.user);\n  };\n  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    setTimeout(showMessage, <span class="hljs-number">3000</span>);\n  };\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Follow<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p data-nodeid="1328">事情就会大不一样。</p>\n<p data-nodeid="1329">props 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此<strong data-nodeid="1530">我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props</strong>。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。</p>\n<p data-nodeid="5982" class="te-preview-highlight">如果你认真阅读了我前面说过的那些话，相信你现在一定也不仅仅能够充分理解 Dan 所想要表达的“<strong data-nodeid="5992">函数组件会捕获 render 内部的状态</strong>”这个结论，而是能够更进一步地意识到这样一件事情：<strong data-nodeid="5993">函数组件真正地把数据和渲染绑定到了一起</strong>。</p>\n\n\n\n\n\n\n\n\n<p data-nodeid="1331">经过岁月的洗礼，React 团队显然也认识到了，<strong data-nodeid="1548">函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式</strong>，接下来便开始“用脚投票”，用实际行动支持开发者编写函数式组件。于是，React-Hooks 便应运而生。</p>\n<h3 data-nodeid="1332">Hooks 的本质：一套能够使函数组件更强大、更灵活的“钩子”</h3>\n<p data-nodeid="1333">React-Hooks 是什么？它是一套能够使函数组件更强大、更灵活的“钩子”。</p>\n<p data-nodeid="1334">前面我们已经说过，函数组件比起类组件“少”了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。</p>\n<p data-nodeid="1335">React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。</p>\n<p data-nodeid="1336"><strong data-nodeid="1561">如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱</strong>。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是<strong data-nodeid="1562">允许你自由地选择和使用你需要的那些能力</strong>，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。</p>\n<h3 data-nodeid="1337">总结</h3>\n<p data-nodeid="1338">行文至此，关于“Why”的研究已经基本到位，对于“What”的认知也已经初见眉目。虽然本课时并没有贴上哪怕一行 React-Hooks 相关的代码，但我相信，你对 React-Hooks 本质的把握已经超越了非常多的 React 开发者。</p>\n<p data-nodeid="1339" class="">在下个课时，我们将会和 React-Hooks 面对面交锋，从编码层面上认知“What”，从实践角度理解“How”。相信在课时的最后，你会对本文所讲解的“Why”有更深刻的理解和感悟。</p>',
          },
          {
            theme: '07 | React-Hooks 设计动机与工作模式（下）',
            id: 28,
            content:
              '<p data-nodeid="6770" class="">经过第 6 课时的学习，相信你已经清楚了 React-Hooks 的来头，并理解了其背后的“设计动机”。本课时我们的任务是构建对 React-Hooks 的整体认知。</p>\n<p data-nodeid="6771">在本课时的主体部分，我将通过一系列的编码实例来帮助你认识 useState、useEffect 这两个有代表性的 Hook，这一步意在帮助初学者对 React-Hooks 可以快速上手。在此基础上，我们将重新理解“Why React-Hooks”这个问题。在课时的最后，我将结合自身的开发体验，和你分享当下这个阶段，我所认识到的 Hooks 的局限性。</p>\n<blockquote data-nodeid="6772">\n<p data-nodeid="6773">注：在学习本课时的过程中，请你摒弃“认识的 API 名字越多就越牛”这种错误的学习理念。如果你希望掌握尽可能多的 Hook 的用法，<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" data-nodeid="6896">点击这里</a>可以一键进入 React-Hooks API 文档的海洋。对本课时来说，所有涉及对 API 用法的介绍都是 <strong data-nodeid="6902">“教具”</strong>，仅仅是为后续更深层次的知识讲解作铺垫。</p>\n</blockquote>\n<h3 data-nodeid="6774">先导知识：从核心 API 看 Hooks 的基本形态</h3>\n<h4 data-nodeid="6775">useState()：为函数组件引入状态</h4>\n<p data-nodeid="6776">早期的函数组件相比于类组件，其一大劣势是缺乏定义和维护 state 的能力，而 state（状态）作为 React 组件的灵魂，必然是不可省略的。因此 React-Hooks 在诞生之初，就优先考虑了对 state 的支持。useState 正是这样一个能够为函数组件引入状态的 API。</p>\n<h5 data-nodeid="6777">函数组件，真的很轻</h5>\n<p data-nodeid="6778">在过去，你可能会为了使用 state，不得不去编写一个类组件（这里我给出一个 Demo，编码如下所示）：</p>\n<pre class="lang-js" data-nodeid="6779"><code data-language="js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n\n  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {\n    <span class="hljs-built_in">super</span>();\n    <span class="hljs-built_in">this</span>.state = {\n      <span class="hljs-attr">text</span>: <span class="hljs-string">"初始文本"</span>\n    };\n  }\n\n  changeText = <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-built_in">this</span>.setState(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-keyword">return</span> {\n        <span class="hljs-attr">text</span>: <span class="hljs-string">"修改后的文本"</span>\n      };\n    });\n  };\n  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {\n    <span class="hljs-keyword">const</span> { text } = <span class="hljs-built_in">this</span>.state;\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"textButton"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeText}</span>&gt;</span>点击修改文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p data-nodeid="6780">有了 useState 后，我们就可以直接在函数组件里引入 state。以下是使用 useState 改造过后的 TextButton 组件：</p>\n<pre class="lang-js" data-nodeid="6781"><code data-language="js"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> [text, setText] = useState(<span class="hljs-string">"初始文本"</span>);\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeText</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> setText(<span class="hljs-string">"修改后的文本"</span>);\n  }\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"textButton"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{changeText}</span>&gt;</span>点击修改文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p data-nodeid="6782">上面两套代码实现的界面交互效果完全一样，而函数组件的代码量几乎是类组件代码量的一半！</p>\n<p data-nodeid="6783">如果你在第 06 课时曾或多或少地对“类组件太重了”这个观点感到茫然，那么相信眼前这个 Demo 足以让你真真切切地感受到两类组件在复杂度上的差异——<strong data-nodeid="6915">同样逻辑的函数组件相比类组件而言，复杂度要低得多得多</strong>。</p>\n<h5 data-nodeid="6784">useState 快速上手</h5>\n<p data-nodeid="6785">从用法上看，useState 返回的是一个数组，数组的第一个元素对应的是我们想要的那个 state 变量，第二个元素对应的是能够修改这个变量的 API。我们可以通过数组解构的语法，将这两个元素取出来，并且按照我们自己的想法命名。一个典型的调用示例如下：</p>\n<pre class="lang-java" data-nodeid="6786"><code data-language="java"><span class="hljs-keyword">const</span> [state, setState] = useState(initialState);\n</code></pre>\n<p data-nodeid="6787">在这个示例中，我们给自己期望的那个状态变量命名为 state，给修改 state 的 API 命名为 setState。useState 中传入的 initialState 正是 state 的初始值。后续我们可以通过调用 setState，来修改 state 的值，像这样：</p>\n<pre class="lang-java" data-nodeid="6788"><code data-language="java">setState(newState)\n</code></pre>\n<p data-nodeid="6789">状态更新后会触发渲染层面的更新，这点和类组件是一致的。</p>\n<p data-nodeid="6790">这里需要向初学者强调的一点是：<strong data-nodeid="6925">状态和修改状态的 API 名都是可以自定义的</strong>。比如在上文的 Demo 中，就分别将其自定义为 text 和 setText：</p>\n<pre class="lang-java" data-nodeid="6791"><code data-language="java"><span class="hljs-keyword">const</span> [text, setText] = useState(<span class="hljs-string">"初始文本"</span>);\n</code></pre>\n<p data-nodeid="6792">“set + 具体变量名”这种命名形式，可以帮助我们快速地将 API 和它对应的状态建立逻辑联系。</p>\n<p data-nodeid="6793">当我们在函数组件中调用 React.useState 的时候，实际上是给这个组件关联了一个状态——注意，是“一个状态”而不是“一批状态”。这一点是相对于类组件中的 state 来说的。在类组件中，我们定义的 state 通常是一个这样的对象，如下所示：</p>\n<pre class="lang-java" data-nodeid="6794"><code data-language="java"><span class="hljs-keyword">this</span>.state {\n  text: <span class="hljs-string">"初始文本"</span>,\n  length: <span class="hljs-number">10000</span>,\n  author: [<span class="hljs-string">"xiuyan"</span>, <span class="hljs-string">"cuicui"</span>, <span class="hljs-string">"yisi"</span>]\n}\n</code></pre>\n<p data-nodeid="6795">这个对象是“包容万物”的：整个组件的状态都在 state 对象内部做收敛，当我们需要某个具体状态的时候，会通过 this.state.xxx 这样的访问对象属性的形式来读取它。</p>\n<p data-nodeid="6796">而在 useState 这个钩子的使用背景下，state 就是单独的一个状态，它可以是任何你需要的 JS 类型。像这样：</p>\n<pre class="lang-java" data-nodeid="6797"><code data-language="java"><span class="hljs-comment">// 定义为数组</span>\n<span class="hljs-keyword">const</span> [author, setAuthor] = useState([<span class="hljs-string">"xiuyan"</span>, <span class="hljs-string">"cuicui"</span>, <span class="hljs-string">"yisi"</span>]);\n \n<span class="hljs-comment">// 定义为数值</span>\n<span class="hljs-keyword">const</span> [length, setLength] = useState(<span class="hljs-number">100</span>);\n<span class="hljs-comment">// 定义为字符串</span>\n<span class="hljs-keyword">const</span> [text, setText] = useState(<span class="hljs-string">"初始文本"</span>)\n</code></pre>\n<p data-nodeid="6798">你还可以定义为布尔值、对象等，都是没问题的。<strong data-nodeid="6935">它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态</strong>，允许你存储任意类型的值。</p>\n<h4 data-nodeid="6799">useEffect()：允许函数组件执行副作用操作</h4>\n<p data-nodeid="6800">函数组件相比于类组件来说，最显著的差异就是 state 和生命周期的缺失。useState 为函数组件引入了 state，而 useEffect 则在一定程度上弥补了生命周期的缺席。</p>\n<p data-nodeid="6801">useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。</p>\n<h5 data-nodeid="6802">useEffect 和生命周期函数之间的“替换”关系</h5>\n<p data-nodeid="6803">我们可以通过下面这个例子来理解 useEffect 和生命周期函数之间的替换关系。这里我先给到你一个用 useEffect 编写的函数组件示例：</p>\n<pre class="lang-js" data-nodeid="6804"><code data-language="js"><span class="hljs-comment">// 注意 hook 在使用之前需要引入</span>\n<span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-comment">// 定义函数组件</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IncreasingTodoList</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// 创建 count 状态及其对应的状态修改函数</span>\n  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);\n  <span class="hljs-comment">// 此处的定位与 componentDidMount 和 componentDidUpdate 相似</span>\n  useEffect(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 每次 count 增加时，都增加对应的待办项</span>\n    <span class="hljs-keyword">const</span> todoList = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"todoList"</span>);\n    <span class="hljs-keyword">const</span> newItem = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>);\n    newItem.innerHTML = <span class="hljs-string">`我是第<span class="hljs-subst">${count}</span>个待办项`</span>;\n    todoList.append(newItem);\n  });\n  <span class="hljs-comment">// 编写 UI 逻辑</span>\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前共计 {count} 个todo Item<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"todoList"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点我增加一个待办项<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p data-nodeid="6805">通过上面这段代码构造出来的界面在刚刚挂载完毕时，就是如下图所示的样子：</p>\n<p data-nodeid="6806"><img src="https://s0.lgstatic.com/i/image/M00/63/B1/Ciqc1F-WvXSAQpxnAACHqrwRF3k766.png" alt="Drawing 0.png" data-nodeid="6944"></p>\n<p data-nodeid="6807">IncreasingTodoList 是一个只允许增加 item 的 ToDoList（待办事项列表）。按照 useEffect 的设定，每当我们点击“点我增加一个待办项”这个按钮，驱动 count+1 的同时，DOM 结构里也会被追加一个 li 元素。以下是连击按钮三次之后的效果图：</p>\n<p data-nodeid="6808"><img src="https://s0.lgstatic.com/i/image/M00/63/BC/CgqCHl-WvXmAFcc7AADFEkuiF7Y038.png" alt="Drawing 1.png" data-nodeid="6948"></p>\n<p data-nodeid="6809">同样的效果，按照注释里的提示，我们也可以通过编写 class 组件来实现：</p>\n<pre class="lang-js" data-nodeid="6810"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-comment">// 定义类组件</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncreasingTodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n\n  <span class="hljs-comment">// 初始化 state</span>\n  state = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }\n  <span class="hljs-comment">// 此处调用上个 demo 中 useEffect 中传入的函数</span>\n  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> {\n    <span class="hljs-built_in">this</span>.addTodoItem()\n  }\n  <span class="hljs-comment">// 此处调用上个 demo 中 useEffect 中传入的函数</span>\n  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> {\n    <span class="hljs-built_in">this</span>.addTodoItem()\n  }\n  <span class="hljs-comment">// 每次 count 增加时，都增加对应的待办项</span>\n  addTodoItem = <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> { count } = <span class="hljs-built_in">this</span>.state\n    <span class="hljs-keyword">const</span> todoList = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"todoList"</span>)\n    <span class="hljs-keyword">const</span> newItem = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>)\n    newItem.innerHTML = <span class="hljs-string">`我是第<span class="hljs-subst">${count}</span>个待办项`</span>\n    todoList.append(newItem)\n  }\n\n  <span class="hljs-comment">// 定义渲染内容</span>\n  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {\n    <span class="hljs-keyword">const</span> { count } = <span class="hljs-built_in">this</span>.state\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前共计 {count} 个todo Item<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"todoList"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>\n          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span>\n            this.setState({\n              count: this.state.count + 1,\n            })\n          }\n        &gt;\n          点我增加一个待办项\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    )\n  }\n}\n</code></pre>\n<p data-nodeid="6811">通过这样一个对比，类组件生命周期和函数组件 useEffect 之间的转换关系可以说是跃然纸上了。</p>\n<p data-nodeid="6812">在这里，我提个醒：初学 useEffect 时，我们难免习惯于借助对生命周期的理解来推导对 useEffect 的理解。但长期来看，若是执着于这个学习路径，无疑将阻碍你真正从心智模式的层面拥抱 React-Hooks。</p>\n<p data-nodeid="6813"><strong data-nodeid="6960">有时候，我们必须学会忘记旧的知识，才能够更好地拥抱新的知识</strong>。对于每一个学习 useEffect 的人来说，生命周期到 useEffect 之间的转换关系都不是最重要的，最重要的是在脑海中构建一个“组件有副作用 → 引入 useEffect”这样的条件反射——<strong data-nodeid="6961">当你真正抛却类组件带给你的刻板印象、拥抱函数式编程之后，想必你会更加认同“useEffect 是用于为函数组件引入副作用的钩子”这个定义</strong>。</p>\n<h5 data-nodeid="6814">useEffect 快速上手</h5>\n<p data-nodeid="6815">useEffect 可以接收两个参数，分别是回调函数与依赖数组，如下面代码所示：</p>\n<pre class="lang-java" data-nodeid="6816"><code data-language="java">useEffect(callBack, [])\n</code></pre>\n<p data-nodeid="6817">useEffect 用什么姿势来调用，本质上取决于你想用它来达成什么样的效果。下面我们就以效果为线索，简单介绍 useEffect 的调用规则。</p>\n<ul data-nodeid="6818">\n<li data-nodeid="6819">\n<p data-nodeid="6820">每一次渲染后都执行的副作用：传入回调函数，不传依赖数组。调用形式如下所示：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="6821"><code data-language="java">useEffect(callBack)\n</code></pre>\n<ul data-nodeid="6822">\n<li data-nodeid="6823">\n<p data-nodeid="6824">仅在挂载阶段执行一次的副作用：传入回调函数，<strong data-nodeid="6971">且这个函数的返回值不是一个函</strong>数，同时传入一个空数组。调用形式如下所示：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="6825"><code data-language="java">useEffect(()=&gt;{\n  <span class="hljs-comment">// 这里是业务逻辑 </span>\n}, [])\n</code></pre>\n<ul data-nodeid="6826">\n<li data-nodeid="6827">\n<p data-nodeid="6828">仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，<strong data-nodeid="6977">且这个函数的返回值是一个函数</strong>，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。调用形式如下所示：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="6829"><code data-language="java">useEffect(()=&gt;{\n  <span class="hljs-comment">// 这里是 A 的业务逻辑</span>\n\n  <span class="hljs-comment">// 返回一个函数记为 B</span>\n  <span class="hljs-keyword">return</span> ()=&gt;{\n  }\n}, [])\n</code></pre>\n<p data-nodeid="6830">这里需要注意，这种调用方式之所以会在卸载阶段去触发 B 函数的逻辑，是由 useEffect 的执行规则决定的：<strong data-nodeid="6987">useEffect 回调中返回的函数被称为“清除函数”</strong>，当 React 识别到清除函数时，会在卸载时执行清除函数内部的逻辑。<strong data-nodeid="6988">这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理</strong>。</p>\n<ul data-nodeid="6831">\n<li data-nodeid="6832">\n<p data-nodeid="6833">每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。如下所示：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="6834"><code data-language="java">useEffect(()=&gt;{\n  <span class="hljs-comment">// 这里是 A 的业务逻辑</span>\n\n  <span class="hljs-comment">// 返回一个函数记为 B</span>\n  <span class="hljs-keyword">return</span> ()=&gt;{\n  }\n})\n</code></pre>\n<p data-nodeid="12311" class="">上面这段代码就会使得 React 在每一次渲染都去触发 A 逻辑，并且在卸载阶段去触发 B 逻辑。</p>\n\n\n\n\n\n\n\n\n\n<p data-nodeid="6836">其实你只要记住，如果你有一段副作用逻辑需要在卸载阶段执行，那么把它写进 useEffect 回调的返回函数（上面示例中的 B 函数）里就行了。也可以认为，这个 B 函数的角色定位就类似于生命周期里 componentWillUnmount 方法里的逻辑（虽然并不推荐你再继续钻生命周期的牛角尖，哈哈）。</p>\n<ul data-nodeid="6837">\n<li data-nodeid="6838">\n<p data-nodeid="6839">根据一定的依赖条件来触发的副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述），同时传入一个非空的数组，如下所示：</p>\n</li>\n</ul>\n<pre class="lang-java" data-nodeid="6840"><code data-language="java">useEffect(()=&gt;{\n  <span class="hljs-comment">// 这是回调函数的业务逻辑 </span>\n\n  <span class="hljs-comment">// 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发</span>\n  <span class="hljs-keyword">return</span> xxx\n}, [num1, num2, num3])\n</code></pre>\n<p data-nodeid="6841">这里我给出的一个示意数组是 [num1, num2, num3]。首先需要说明，数组中的变量一般都是来源于组件本身的数据（props 或者 state）。若数组不为空，那么 React 就会在新的一次渲染后去对比前后两次的渲染，查看数组内是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了），并在有更新的前提下去触发 useEffect 中定义的副作用逻辑。</p>\n<h3 data-nodeid="6842">Why React-Hooks：Hooks 是如何帮助我们升级工作模式的</h3>\n<p data-nodeid="6843">在第 06 课时我们已经了解到，函数组件相比类组件来说，有着不少能够利好 React 组件开发的特性，而 React-Hooks 的出现正是为了强化函数组件的能力。现在，基于对 React-Hooks 编码层面的具体认知，想必你对“动机”的理解也已经上了一个台阶。这里我们就趁热打铁，针对“Why React-Hooks”这个问题，做一个加强版的总结。</p>\n<p data-nodeid="6844">相信有不少嗅觉敏锐的同学已经感觉到了——没错，这个环节就是手把手教你做“为什么需要 React-Hooks”这道面试题。以“Why xxx”开头的这种面试题，往往都没有标准答案，但会有一些关键的“点”，只要能答出关键的点，就足以证明你思考的方向是正确的，也就意味着这道题能给你加分。这里，我梳理了以下 4 条答题思路：</p>\n<ul data-nodeid="6845">\n<li data-nodeid="6846">\n<p data-nodeid="6847">告别难以理解的 Class；</p>\n</li>\n<li data-nodeid="6848">\n<p data-nodeid="6849">解决业务逻辑难以拆分的问题；</p>\n</li>\n<li data-nodeid="6850">\n<p data-nodeid="6851">使状态逻辑复用变得简单可行；</p>\n</li>\n<li data-nodeid="6852">\n<p data-nodeid="6853">函数组件从设计思想上来看，更加契合 React 的理念。</p>\n</li>\n</ul>\n<p data-nodeid="6854">关于思路 4，我在上个课时已经讲得透透的了，这里我主要是借着代码的东风，把 1、2、3 摊开来给你看一下。</p>\n<h4 data-nodeid="6855">1. 告别难以理解的 Class：把握 Class 的两大“痛点”</h4>\n<p data-nodeid="6856">坊间总有传言说 Class 是“难以理解”的，这个说法的背后<strong data-nodeid="7014">是 this 和生命周期这两个痛点</strong>。</p>\n<p data-nodeid="6857">先来说说 this，在上个课时，你已经初步感受了一把 this 有多么难以捉摸。但那毕竟是个相对特殊的场景，更为我们所熟悉的，可能还是 React 自定义组件方法中的 this。看看下面这段代码：</p>\n<pre class="lang-java" data-nodeid="6858"><code data-language="java">class Example extends Component {\n  state = {\n    name: \'修言\',\n    age: \'99\';\n  };\n  changeAge() {\n    // 这里会报错\n    this.setState({\n      age: \'100\'\n    });\n  }\n  render() {\n    return &lt;button onClick={this.changeAge}&gt;{this.state.name}的年龄是{this.state.age}&lt;/button&gt;\n  }\n}\n</code></pre>\n<p data-nodeid="6859">你先不用关心组件具体的逻辑，就看 changeAge 这个方法：它是 button 按钮的事件监听函数。当我点击 button 按钮时，希望它能够帮我修改状态，但事实是，点击发生后，程序会报错。原因很简单，changeAge 里并不能拿到组件实例的 this，至于为什么拿不到，我们将在第 15课时讲解其背后的原因，现在先不用关心。单就这个现象来说，略有一些 React 开发经验的同学应该都会非常熟悉。</p>\n<p data-nodeid="6860">为了解决 this 不符合预期的问题，各路前端也是各显神通，之前用 bind、现在推崇箭头函数。但不管什么招数，<strong data-nodeid="7022">本质上都是在用实践层面的约束来解决设计层面的问题</strong>。好在现在有了 Hooks，一切都不一样了，我们可以在函数组件里放飞自我（毕竟函数组件是不用关心 this 的）哈哈，解放啦！</p>\n<p data-nodeid="6861">至于生命周期，它带来的麻烦主要有以下两个方面：</p>\n<ul data-nodeid="6862">\n<li data-nodeid="6863">\n<p data-nodeid="6864">学习成本</p>\n</li>\n<li data-nodeid="6865">\n<p data-nodeid="6866">不合理的逻辑规划方式</p>\n</li>\n</ul>\n<p data-nodeid="6867">对于第一点，大家都学过生命周期，都懂。下面着重说说这“不合理的逻辑规划方式”是如何被 Hooks 解决掉的。</p>\n<h4 data-nodeid="6868">2. Hooks 如何实现更好的逻辑拆分</h4>\n<p data-nodeid="6869">在过去，你是怎么组织自己的业务逻辑的呢？我想多数情况下应该都是先想清楚业务的需要是什么样的，然后将对应的业务逻辑拆到不同的生命周期函数里去——没错，<strong data-nodeid="7035">逻辑曾经一度与生命周期耦合在一起</strong>。</p>\n<p data-nodeid="6870">在这样的前提下，生命周期函数常常做一些奇奇怪怪的事情：比如在 componentDidMount 里获取数据，在 componentDidUpdate 里根据数据的变化去更新 DOM 等。如果说你只用一个生命周期做一件事，那好像也还可以接受，但是往往在一个稍微成规模的 React 项目中，一个生命周期不止做一件事情。下面这段伪代码就很好地诠释了这一点：</p>\n<pre class="lang-java" data-nodeid="6871"><code data-language="java">componentDidMount() {\n  <span class="hljs-comment">// 1. 这里发起异步调用</span>\n  <span class="hljs-comment">// 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM</span>\n\n  <span class="hljs-comment">// 3. 这里设置一个订阅</span>\n\n  <span class="hljs-comment">// 4. 这里随便干点别的什么 </span>\n\n  <span class="hljs-comment">// ...</span>\n}\ncomponentWillUnMount() {\n  <span class="hljs-comment">// 在这里卸载订阅</span>\n}\ncomponentDidUpdate() {\n  <span class="hljs-comment">// 1. 在这里根据 DidMount 获取到的异步数据更新 DOM</span>\n\n  <span class="hljs-comment">// 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样）</span>\n}\n</code></pre>\n<p data-nodeid="6872">像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，<strong data-nodeid="7042">这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样</strong>。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。</p>\n<p data-nodeid="6873">而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作<strong data-nodeid="7053">按照逻辑上的关联拆分进不同的函数组件里：<strong data-nodeid="7052">我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们</strong>实现业务逻辑的聚合，避免复杂的组件和冗余的代码</strong>。</p>\n<h4 data-nodeid="6874">3. 状态复用：Hooks 将复杂的问题变简单</h4>\n<p data-nodeid="6875">过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。</p>\n<p data-nodeid="6876">Hooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。</p>\n<p data-nodeid="6877">要理解上面这两段话，需要你对组件设计模式有基本的理解和应用。如果你读下来觉得一头雾水，也不必心慌。对于组件状态复用这个问题（包括 HOC、Render Props 和自定义 Hook），现在我对你的预期是“知道有这回事就可以了”。如果你实在着急，可以先通过<a href="https://zh-hans.reactjs.org/docs/hooks-custom.html" data-nodeid="7062">文档中的相关内容</a>简单了解一下。在专栏的第三模块，我会专门把这块知识提出来，放在一个更合适的上下文里给你掰开来讲。</p>\n<h3 data-nodeid="6878">保持清醒：Hooks 并非万能</h3>\n<p data-nodeid="6879">尽管我们已经说了这么多 Hooks 的“好话”，尽管 React 团队已经用脚投票表明了对函数组件的积极态度，但我们还是要谨记这样一个基本的认知常识：事事无绝对，凡事皆有两面性。更何况 React 仅仅是推崇函数组件，并没有“拉踩”类组件，甚至还官宣了“类组件和函数组件将继续共存”这件事情。这些都在提醒我们，<strong data-nodeid="7070">在认识到 Hooks 带来的利好的同时，还需要认识到它的局限性</strong>。</p>\n<p data-nodeid="6880">关于 Hooks 的局限性，目前社区鲜少有人讨论。这里我想结合团队开发过程当中遇到的一些瓶颈，和你分享实践中的几点感受：</p>\n<ul data-nodeid="6881">\n<li data-nodeid="6882">\n<p data-nodeid="6883"><strong data-nodeid="7076">Hooks 暂时还不能完全地为函数组件补齐类组件的能力</strong>：比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。官方虽然立了“会尽早把它们加进来”的 Flag，但是说真的，这个 Flag 真的立了蛮久了……（扶额）</p>\n</li>\n<li data-nodeid="6884">\n<p data-nodeid="6885"><strong data-nodeid="7085">“轻量”几乎是函数组件的基因，这可能会使它不能够很好地消化“复杂”</strong>：我们有时会在类组件中见到一些方法非常繁多的实例，如果用函数组件来解决相同的问题，业务逻辑的拆分和组织会是一个很大的挑战。我个人的感觉是，从头到尾都在“过于复杂”和“过度拆分”之间摇摆不定，哈哈。耦合和内聚的边界，有时候真的很难把握，<strong data-nodeid="7086">函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求</strong>。</p>\n</li>\n<li data-nodeid="6886">\n<p data-nodeid="6887"><strong data-nodeid="7091">Hooks 在使用层面有着严格的规则约束</strong>：这也是我们下个课时要重点讲的内容。对于如今的 React 开发者来说，如果不能牢记并践行 Hooks 的使用原则，如果对 Hooks 的关键原理没有扎实的把握，很容易把自己的 React 项目搞成大型车祸现场。</p>\n</li>\n</ul>\n<h3 data-nodeid="6888">总结</h3>\n<p data-nodeid="6889">在本课时，我们结合编码层面的认知，辩证地探讨了 Hooks 带来的利好与局限性。现在，你对于 React-Hooks 的基本形态和前世今生都已经有了透彻的了解，也真刀真枪地感受到了 Hooks 带来的利好。学习至此，相信你已经建立了对 React-Hooks 的学习自信。</p>\n<p data-nodeid="6890" class="">接下来，我们将续上本课时结尾处的“悬念”，向 React-Hooks 的执行规则发问，同时也将进入 React-Hooks 知识链路真正的深水区。</p>',
          },
        ],
      },
      {
        sectionName: '模块二：刨根问底吃透“核心原理”',
        sectionId: 3,
        courseList: [
          {
            theme: '08 | 深入 React-Hooks 工作机制：“原则”的背后，是“原理”',
            id: 29,
            content:
              '<p data-nodeid="8633" class="">React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：</p>\n<ol data-nodeid="8634">\n<li data-nodeid="8635">\n<p data-nodeid="8636">只在 React 函数中调用 Hook；</p>\n</li>\n<li data-nodeid="8637">\n<p data-nodeid="8638">不要在循环、条件或嵌套函数中调用 Hook。</p>\n</li>\n</ol>\n<p data-nodeid="8639">原则 1 无须多言，React-Hooks 本身就是 React 组件的“钩子”，在普通函数里引入意义不大。我相信更多的人在原则 2 上栽过跟头，或者说至今仍然对它半信半疑。其实，原则 2 中强调的所有“<strong data-nodeid="8722">不要</strong>”，都是在指向同一个目的，那就是<strong data-nodeid="8723">要确保 Hooks 在每次渲染时都保持同样的执行顺序</strong>。</p>\n<p data-nodeid="8640">为什么顺序如此重要？这就要从 Hooks 的实现机制说起了。这里我就以 useState 为例，带你从现象入手，深度探索一番 React-Hooks 的工作原理。</p>\n<p data-nodeid="8641">注：本讲 Demo 基于 React 16.8.x 版本进行演示。</p>\n<h3 data-nodeid="8642">从现象看问题：若不保证 Hooks 执行顺序，会带来什么麻烦？</h3>\n<p data-nodeid="8643">先来看一个小 Demo：</p>\n<pre class="lang-javascript" data-nodeid="8644"><code data-language="javascript"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// 集中定义变量</span>\n  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;\n\n  <span class="hljs-comment">// 获取姓名状态</span>\n  [name, setName] = useState(<span class="hljs-string">"修言"</span>);\n\n  <span class="hljs-comment">// 获取年龄状态</span>\n  [age] = useState(<span class="hljs-string">"99"</span>);\n\n  <span class="hljs-comment">// 获取职业状态</span>\n  [career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);\n\n  <span class="hljs-comment">// 输出职业信息</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"career"</span>, career);\n\n  <span class="hljs-comment">// 编写 UI 逻辑</span>\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"personalInfo"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>\n        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {\n          setName("秀妍");\n        }}\n      &gt;\n        修改姓名\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;\n</code></pre>\n<p data-nodeid="8645">这个 PersonalInfoComponent 组件渲染出来的界面长这样：</p>\n<p data-nodeid="8646"><img src="https://s0.lgstatic.com/i/image/M00/89/5F/Ciqc1F_YT0uAT1kZAACw9EfbQe8557.png" alt="1.png" data-nodeid="8731"></p>\n<p data-nodeid="10684" class="te-preview-highlight">PersonalInfoComponent 用于对个人信息进行展示，这里展示的内容包括姓名、年龄、职业。出于测试效果需要，PersonalInfoComponent 还允许你点击“修改姓名”按钮修改姓名信息。点击一次后，“修言”会被修改为“秀妍”，如下图所示：</p>\n\n\n\n\n\n<p data-nodeid="8648"><img src="https://s0.lgstatic.com/i/image/M00/89/6A/CgqCHl_YT1qAUSuVAAC-xZcsk54138.png" alt="2.png" data-nodeid="8735"></p>\n<p data-nodeid="8649">到目前为止，组件的行为都是符合我们的预期的，一切看上去都是那么的和谐。但倘若我对代码做一丝小小的改变，把一部分的 useState 操作放进 if 语句里，事情就会变得大不一样。改动后的代码如下：</p>\n<pre class="lang-js" data-nodeid="8650"><code data-language="js"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-comment">// isMounted 用于记录是否已挂载（是否是首次渲染）</span>\n<span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// 定义变量的逻辑不变</span>\n  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;\n\n  <span class="hljs-comment">// 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"isMounted is"</span>, isMounted);\n  <span class="hljs-comment">// 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span>\n  <span class="hljs-keyword">if</span> (!isMounted) {\n    <span class="hljs-comment">// eslint-disable-next-line</span>\n    [name, setName] = useState(<span class="hljs-string">"修言"</span>);\n    <span class="hljs-comment">// eslint-disable-next-line</span>\n    [age] = useState(<span class="hljs-string">"99"</span>);\n\n    <span class="hljs-comment">// if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）</span>\n    isMounted = <span class="hljs-literal">true</span>;\n  }\n\n  <span class="hljs-comment">// 对职业信息的获取逻辑不变</span>\n  [career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);\n  <span class="hljs-comment">// 这里追加对 career 的输出，这也是一个 debug 性质的操作</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"career"</span>, career);\n  <span class="hljs-comment">// UI 逻辑的改动在于，name和age成了可选的展示项，若值为空，则不展示</span>\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"personalInfo"</span>&gt;</span>\n      {name ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}\n      {age ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>\n        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {\n          setName("秀妍");\n        }}\n      &gt;\n        修改姓名\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;\n</code></pre>\n<p data-nodeid="8651">修改后的组件在初始渲染的时候，界面与上个版本无异：</p>\n<p data-nodeid="8652"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJDaAC6-qAACIdJOIg3E041.png" alt="Drawing 5.png" data-nodeid="8740"></p>\n<p data-nodeid="8653">注意，你在自己电脑上模仿这段代码的时候，千万不要漏掉 if 语句里面<code data-backticks="1" data-nodeid="8742">// eslint-disable-next-line</code>这个注释——因为目前大部分的 React 项目都在内部预置了对 React-Hooks-Rule（React-Hooks 使用规则）的强校验，而示例代码中把 Hooks 放进 if 语句的操作作为一种不合规操作，会被直接识别为 Error 级别的错误，进而导致程序报错。这里我们只有将相关代码的 eslint 校验给禁用掉，才能够避免校验性质的报错，从而更直观地看到错误的效果到底是什么样的，进而理解错误的原因。</p>\n<p data-nodeid="8654">修改后的组件在初始挂载的时候，实际执行的逻辑内容和上个版本是没有区别的，都涉及对 name、age、career 三个状态的获取和渲染。理论上来说，<strong data-nodeid="8749">变化应该发生在我单击“修改姓名”之后触发的二次渲染里</strong>：二次渲染时，isMounted 已经被置为 true，if 内部的逻辑会被直接跳过。此时按照代码注释中给出的设计意图，这里我希望在二次渲染时，只获取并展示 career 这一个状态。那么事情是否会如我所愿呢？我们一起来看看单击“修改姓名”按钮后会发生什么：</p>\n<p data-nodeid="8655"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJEOAMfdIAAJ8aDhIGdA549.png" alt="Drawing 7.png" data-nodeid="8752"></p>\n<p data-nodeid="8656">组件不仅没有像预期中一样发生界面变化，甚至直接报错了。报错信息提醒我们，这是因为“<strong data-nodeid="8758">组件渲染的 Hooks 比期望中更少</strong>”。</p>\n<p data-nodeid="8657">确实，按照现有的逻辑，初始渲染调用了三次 useState，而二次渲染时只会调用一次。但仅仅因为这个，就要报错吗？</p>\n<p data-nodeid="8658">按道理来说，二次渲染的时候，只要我获取到的 career 值没有问题，那么渲染就应该是没有问题的（因为二次渲染实际只会渲染 career 这一个状态），React 就没有理由阻止我的渲染动作。啊这……难道是 career 出问题了吗？还好我们预先留了一手 Debug 逻辑，每次渲染的时候都会尝试去输出一次 isMounted 和 career 这两个变量的值。现在我们就赶紧来看看，这两个变量到底是什么情况。</p>\n<p data-nodeid="8659">首先我将界面重置回初次挂载的状态，观察控制台的输出，如下图所示：</p>\n<p data-nodeid="8660"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJHSAL8SuAAHP-0rTPKY784.png" alt="Drawing 9.png" data-nodeid="8764"></p>\n<p data-nodeid="8661">这里我把关键的 isMounted 和 career 两个变量用红色框框圈了出来：isMounted 值为 false，说明是初次渲染；career 值为“我是一个前端，爱吃小熊饼干”，这也是没有问题的。</p>\n<p data-nodeid="8662">接下来单击“修改姓名”按钮后，我们再来看一眼两个变量的内容，如下图所示：</p>\n<p data-nodeid="8663"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJRiAP2doAAKt-ZhwxQ0744.png" alt="图片11.png" data-nodeid="8769"></p>\n<p data-nodeid="8664">二次渲染时，isMounted 为 true，这个没毛病。但是 career 竟然被修改为了“秀妍”，这也太诡异了？代码里面可不是这么写的。赶紧回头确认一下按钮单击事件的回调内容，代码如下所示：</p>\n<pre class="lang-js" data-nodeid="8665"><code data-language="js"> &lt;button\n   onClick={() =&gt; {\n    setName(<span class="hljs-string">"秀妍"</span>);\n  }}\n   &gt;\n  修改姓名\n&lt;/button&gt;\n</code></pre>\n<p data-nodeid="8666">确实，代码是没错的，我们调用的是 setName，那么它修改的状态也应该是 name，而不是 career。</p>\n<p data-nodeid="8667">那为什么最后发生变化的竟然是 career 呢？年轻人，不如我们一起来看一看 Hooks 的实现机制吧！</p>\n<h3 data-nodeid="8668">从源码调用流程看原理：Hooks 的正常运作，在底层依赖于顺序链表</h3>\n<p data-nodeid="8669">这里强调“源码流程”而非“源码”，主要有两方面的考虑：</p>\n<ol data-nodeid="8670">\n<li data-nodeid="8671">\n<p data-nodeid="8672">React-Hooks 在源码层面和 Fiber 关联十分密切，我们目前仍然处于基础夯实阶段，对 Fiber 机制相关的底层实现暂时没有讨论，盲目啃源码在这个阶段来说没有意义；</p>\n</li>\n<li data-nodeid="8673">\n<p data-nodeid="8674">原理 !== 源码，阅读源码只是掌握原理的一种手段，在某些场景下，阅读源码确实能够迅速帮我们定位到问题的本质（比如 React.createElement 的源码就可以快速帮我们理解 JSX 转换出来的到底是什么东西）；而 React-Hooks 的源码链路相对来说比较长，涉及的关键函数 renderWithHooks 中“脏逻辑”也比较多，整体来说，学习成本比较高，学习效果也难以保证。</p>\n</li>\n</ol>\n<p data-nodeid="8675">综上所述，这里我不会精细地贴出每一行具体的源码，而是针对关键方法做重点分析。同时我也<strong data-nodeid="8788">不建议你在对 Fiber 底层实现没有认知的前提下去和 Hooks 源码死磕</strong>。对于搞清楚“Hooks 的执行顺序为什么必须一样”这个问题来说，重要的并不是去细抠每一行代码到底都做了什么，而是要搞清楚整个<strong data-nodeid="8789">调用链路</strong>是什么样的。如果我们能够理解 Hooks 在每个关键环节都做了哪些事情，同时也能理解这些关键环节是如何对最终的渲染结果产生影响的，那么理解 Hooks 的工作机制对于你来说就不在话下了。</p>\n<h4 data-nodeid="8676">以 useState 为例，分析 React-Hooks 的调用链路</h4>\n<p data-nodeid="8677">首先要说明的是，React-Hooks 的调用链路在首次渲染和更新阶段是不同的，这里我将两个阶段的链路各总结进了两张大图里，我们依次来看。首先是首次渲染的过程，请看下图：</p>\n<p data-nodeid="8678"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJYCAWVjCAAEtNT9pGHA170.png" alt="图片12.png" data-nodeid="8794"></p>\n<p data-nodeid="8679">在这个流程中，useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。以下我为你提取了 mountState 的源码：</p>\n<pre class="lang-java" data-nodeid="8680"><code data-language="java"><span class="hljs-comment">// 进入 mounState 逻辑</span>\n<span class="hljs-function">function <span class="hljs-title">mountState</span><span class="hljs-params">(initialState)</span> </span>{\n\n  <span class="hljs-comment">// 将新的 hook 对象追加进链表尾部</span>\n  <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();\n\n  <span class="hljs-comment">// initialState 可以是一个回调，若是回调，则取回调执行后的值</span>\n  <span class="hljs-keyword">if</span> (typeof initialState === <span class="hljs-string">\'function\'</span>) {\n    <span class="hljs-comment">// $FlowFixMe: Flow doesn\'t like mixed types</span>\n    initialState = initialState();\n  }\n\n  <span class="hljs-comment">// 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch</span>\n  <span class="hljs-keyword">const</span> queue = hook.queue = {\n    last: <span class="hljs-keyword">null</span>,\n    dispatch: <span class="hljs-keyword">null</span>,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  };\n\n  <span class="hljs-comment">// 将 initialState 作为一个“记忆值”存下来</span>\n  hook.memoizedState = hook.baseState = initialState;\n\n  <span class="hljs-comment">// dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么</span>\n  <span class="hljs-keyword">var</span> dispatch = queue.dispatch = dispatchAction.bind(<span class="hljs-keyword">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);\n  <span class="hljs-comment">// 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈</span>\n  <span class="hljs-keyword">return</span> [hook.memoizedState, dispatch];\n}\n</code></pre>\n<p data-nodeid="8681">从这段源码中我们可以看出，<strong data-nodeid="8801">mounState 的主要工作是初始化 Hooks</strong>。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式。以下是 mountWorkInProgressHook 方法的源码：</p>\n<pre class="lang-java" data-nodeid="8682"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">mountWorkInProgressHook</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 注意，单个 hook 是以对象的形式存在的</span>\n  <span class="hljs-keyword">var</span> hook = {\n    memoizedState: <span class="hljs-keyword">null</span>,\n    baseState: <span class="hljs-keyword">null</span>,\n    baseQueue: <span class="hljs-keyword">null</span>,\n    queue: <span class="hljs-keyword">null</span>,\n    next: <span class="hljs-keyword">null</span>\n  };\n  <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理</span>\n    firstWorkInProgressHook = workInProgressHook = hook;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 若链表不为空，则将 hook 追加到链表尾部</span>\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  <span class="hljs-comment">// 返回当前的 hook</span>\n  <span class="hljs-keyword">return</span> workInProgressHook;\n}\n</code></pre>\n<p data-nodeid="8683">到这里可以看出，<strong data-nodeid="8807">hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联</strong>。</p>\n<p data-nodeid="8684">接下来我们再看更新过程的大图：</p>\n<p data-nodeid="8685"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJTGANs5yAAD4e6ACv8Q643.png" alt="图片13.png" data-nodeid="8811"></p>\n<p data-nodeid="8686">根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：<strong data-nodeid="8817">按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染</strong>。</p>\n<p data-nodeid="8687">我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。</p>\n<p data-nodeid="8688">看到这里，你是不是已经大概知道怎么回事儿了？没错，<strong data-nodeid="8824">hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的</strong>。</p>\n<p data-nodeid="8689">这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。也正因为如此，在许多文章里，都会直截了当地下这样的定义：Hooks 的本质就是数组。但读完这一课时的内容你就会知道，<strong data-nodeid="8830">Hooks 的本质其实是链表</strong>。</p>\n<p data-nodeid="8690">接下来我们把这个已知的结论还原到 PersonalInfoComponent 里去，看看实际项目中，变量到底是怎么发生变化的。</p>\n<h3 data-nodeid="8691">站在底层视角，重现 PersonalInfoComponent 组件的执行过程</h3>\n<p data-nodeid="8692">我们先来复习一下修改过后的 PersonalInfoComponent 组件代码：</p>\n<pre class="lang-js" data-nodeid="8693"><code data-language="js"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-comment">// isMounted 用于记录是否已挂载（是否是首次渲染）</span>\n<span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// 定义变量的逻辑不变</span>\n  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;\n\n  <span class="hljs-comment">// 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"isMounted is"</span>, isMounted);\n  <span class="hljs-comment">// 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span>\n  <span class="hljs-keyword">if</span> (!isMounted) {\n    <span class="hljs-comment">// eslint-disable-next-line</span>\n    [name, setName] = useState(<span class="hljs-string">"修言"</span>);\n    <span class="hljs-comment">// eslint-disable-next-line</span>\n    [age] = useState(<span class="hljs-string">"99"</span>);\n\n    <span class="hljs-comment">// if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）</span>\n    isMounted = <span class="hljs-literal">true</span>;\n  }\n\n  <span class="hljs-comment">// 对职业信息的获取逻辑不变</span>\n  [career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);\n  <span class="hljs-comment">// 这里追加对 career 的输出，这也是一个 debug 性质的操作</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"career"</span>, career);\n  <span class="hljs-comment">// UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示</span>\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"personalInfo"</span>&gt;</span>\n      {name ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}\n      {age ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : null}\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>\n        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {\n          setName("秀妍");\n        }}\n      &gt;\n        修改姓名\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;\n</code></pre>\n<p data-nodeid="8694">从代码里面，我们可以提取出来的 useState 调用有三个：</p>\n<pre class="lang-java" data-nodeid="8695"><code data-language="java">[name, setName] = useState(<span class="hljs-string">"修言"</span>);\n[age] = useState(<span class="hljs-string">"99"</span>);\n[career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);\n</code></pre>\n<p data-nodeid="8696">这三个调用在首次渲染的时候都会发生，伴随而来的链表结构如图所示：</p>\n<p data-nodeid="8697"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJUWAe27kAAC_6mxli_Q918.png" alt="图片14.png" data-nodeid="8838"></p>\n<p data-nodeid="8698">当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：</p>\n<pre class="lang-java" data-nodeid="8699"><code data-language="java">useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>)\n</code></pre>\n<p data-nodeid="8700">而此时的链表情况如下图所示：</p>\n<p data-nodeid="8701"><img src="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJeCAY_aoAAF7Tt5bK8k880.png" alt="图片15.png" data-nodeid="8843"></p>\n<p data-nodeid="8702">我们再复习一遍更新（二次渲染）的时候会发生什么事情：updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它难免会认为：<strong data-nodeid="8849">喔，原来你想要的是第一个位置的 hook 啊</strong>。</p>\n<p data-nodeid="8703">然后就会有下面这样的效果：</p>\n<p data-nodeid="8704"><img src="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJe2ATIhGAAHpze3gFHg893.png" alt="图片16.png" data-nodeid="8853"></p>\n<p data-nodeid="8705">如此一来，career 就自然而然地取到了链表头节点 hook 对象中的“秀妍”这个值。</p>\n<h3 data-nodeid="8706">总结</h3>\n<p data-nodeid="8707">三个课时学完了，到这里，我们对 React-Hooks 的学习，才终于算是告一段落。</p>\n<p data-nodeid="8708">在过去的三个课时里，我们摸排了“动机”，认知了“工作模式”，最后更是结合源码、深挖了一把 React-Hooks 的底层原理。我们所做的这所有的努力，都是为了能够真正吃透 React-Hooks，不仅要确保实践中不出错，还要做到面试时有底气。</p>\n<p data-nodeid="8709" class="">接下来，我们就将进入整个专栏真正的“深水区”，逐步切入“虚拟 DOM → Diff 算法 → Fiber 架构”这个知识链路里来。在后续的学习中，我们将延续并且强化这种“刨根问底”的风格，紧贴源码、原理和面试题来向 React 最为核心的部分发起挑战。真正的战斗，才刚刚开始，大家加油~</p>',
          },
          {
            theme: '09 | 真正理解虚拟 DOM：React 选它，真的是为了性能吗？',
            id: 210,
            content:
              '<p data-nodeid="6674" class="">在过去的十年里，前端技术日新月异。从最早的纯静态页面，到 jQuery 一统江湖，再到近几年大火的 MVVM 框架——研发模式升级这件事情对于前端来说，好像成了某种常态。其实<strong data-nodeid="6788">研发模式不断演进的背后，恰恰蕴含着前端人对 “DOM 操作” 这一核心动作的持续思考和改进</strong>。而虚拟 DOM，正是先驱们在这个过程中孕育出的一颗明珠。</p>\n<p data-nodeid="6675">在 MVVM 框架这个领域分支，有一道至今仍然非常经典的面试题：“<strong data-nodeid="6794">为什么我们需要虚拟 DOM？</strong>”。</p>\n<p data-nodeid="6676">这个问题比较常见的回答思路是：“<strong data-nodeid="6800">DOM 操作是很慢的，而 JS 却可以很快</strong>，直接操作 DOM 可能会导致频繁的回流与重绘，JS 不存在这些问题。因此虚拟 DOM 比原生 DOM 更快”。</p>\n<p data-nodeid="6677">但真的是这样吗？学完本课时，你心中自会有答案。</p>\n<h3 data-nodeid="6678">快速搞定虚拟 DOM 的两个“大问题”</h3>\n<p data-nodeid="6679">温故而知新，在一切开始之前，我们先来复习一下虚拟 DOM是什么。</p>\n<p data-nodeid="6680">虚拟 DOM（Virtual DOM）本质上是<strong data-nodeid="6813">JS 和 DOM 之间的一个映射缓存</strong>，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 <strong data-nodeid="6814">JS 对象</strong>。在第 01 课时，我们探讨了 JSX 和 DOM 之间的转换关系，其中就提到了虚拟 DOM 在 React 中的形态，如下图所示：</p>\n<p data-nodeid="6681"><img src="https://s0.lgstatic.com/i/image/M00/68/F3/Ciqc1F-lMbGAZJopAAJVEWRSZj4098.png" alt="Lark20201106-192037.png" data-nodeid="6817"></p>\n<p data-nodeid="6682">就这个示例来说，你需要把握住以下两点：</p>\n<ol data-nodeid="6683">\n<li data-nodeid="6684">\n<p data-nodeid="6685">虚拟 DOM 是 JS 对象</p>\n</li>\n<li data-nodeid="6686">\n<p data-nodeid="6687">虚拟 DOM 是对真实 DOM 的描述</p>\n</li>\n</ol>\n<p data-nodeid="6688">这样就基本解决了虚拟 DOM“是什么”的问题，接下来我们看看 React 中的虚拟 DOM 大致是如何工作的。虚拟 DOM 在 React 组件的挂载阶段和更新阶段都会作为“关键人物”出镜，其参与的工作流程如下：</p>\n<ul data-nodeid="6689">\n<li data-nodeid="6690">\n<p data-nodeid="6691"><strong data-nodeid="6826">挂载阶段</strong>，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；</p>\n</li>\n<li data-nodeid="6692">\n<p data-nodeid="6693"><strong data-nodeid="6831">更新阶段</strong>，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM。</p>\n</li>\n</ul>\n<p data-nodeid="6694">OK，现在我们用最短的时间迅速搞定了“What”和“How”两个大问题。或许过程有些粗糙，但这丝毫不影响你吃透本课时的核心内容，也就是虚拟 DOM 背后的“Why”。</p>\n<p data-nodeid="6695">“为什么需要虚拟 DOM？”“虚拟 DOM 的优势何在？”“虚拟 DOM 是否伴随更好的性能？” ，要想回答好这无穷无尽的为什么，你千万<strong data-nodeid="6842">不要点对点</strong>地去看待问题本身。虚拟 DOM 相对于过往的 DOM 操作解决方案来说，是一个新生事物。要想理解一个新生事物存在、发展的合理性，我们必须<strong data-nodeid="6843">将其放在一个足够长的、合理的上下文中去讨论</strong>。</p>\n<p data-nodeid="6696">接下来我要做的事情，就是帮你把这个上下文完全地铺开。当你清楚了虚拟 DOM 在历史长河中的位置后，将能迅速地理解它到底帮助前端开发解决掉了什么问题，彼时，所有的答案都会跃然纸上。</p>\n<h3 data-nodeid="6697">历史长河中的 DOM 操作解决方案</h3>\n<p data-nodeid="6698">现在，让我们一起来回顾一下，那些没有虚拟 DOM 的苦逼日子。</p>\n<h4 data-nodeid="6699">1. 原生 JS 支配下的“人肉 DOM” 时期</h4>\n<p data-nodeid="6700">在前端这个工种的萌芽阶段，前端页面“展示”的属性远远强于其“交互”的属性，这就导致 JS 的定位只能是“辅助”：在很长一段时间里，前端工程师们会花费大量的时间去实现静态的 DOM，待一切结束后，再补充少量 JS，实现一些类似于拖拽、隐藏、幻灯片之类的“特效”。</p>\n<p data-nodeid="6701">在这个阶段，作为前端开发者来说，虽然我们一无所有，但过得很快乐——简单的业务需求决定了我们不需要去做太多或太复杂的 DOM 操作，原生 JS，足矣。</p>\n<h4 data-nodeid="6702">2.解放生产力的先导阶段：jQuery 时期</h4>\n<p data-nodeid="6703">时代的浪潮滚滚向前，人们很快就不再满足于简单到有些无聊的交互效果，开始追求更加丰富的用户体验，与之而来的就是大量 DOM 操作需求带来的前端开发工作量的激增。在这个过程中，早期前端们渐渐地明白了一个道理：原生 JS 提供的 DOM API，实在是太太太太太难用了。</p>\n<p data-nodeid="6704">为了能够实现高效的开发，jQuery 首先解决的就是“API 不好使”这个问题——它将 DOM API 封装为了相对简单和优雅的形式，同时一口气做掉了跨浏览器的兼容工作，并且提供了链式 API 调用、插件扩展等一系列能力用于进一步解放生产力。最终达到的效果正是我们喜闻乐见的“写得更少，做得更多”。</p>\n<p data-nodeid="6705">jQuery 使 DOM 操作变得简单、快速，并且始终确保其形式稳定、可用性稳定。虽然现在看来并不完美，但在当年能够一统江湖，确实当之无愧。</p>\n<h4 data-nodeid="6706">3.民智初启：早期模板引擎方案</h4>\n<p data-nodeid="6707">jQuery 帮助我们能够以更舒服的姿势操作 DOM，但它并不能从根本上解决 DOM 操作量过大情况下前端侧的压力。</p>\n<p data-nodeid="6708">它就好比是一个<strong data-nodeid="6863">手持吸尘器</strong>，虽然可以帮助我们更加方便快速地清洁某一处的灰尘，但是要想清洁多个位置的灰尘，你仍然需要拿着它四处奔走。这样虽说不必再弯腰擦地板，但还是避免不了跑断腿的结局。</p>\n<p data-nodeid="6709">既然“手持吸尘器”满足不了日益膨胀的 DOM 操作需求，那我们想要的到底是什么呢？是一个只需要接收命令，就能够自己跑来跑去、把活干得漂漂亮亮的“扫地机器人”。</p>\n<p data-nodeid="6710">而模板引擎方案，正是“扫地机器人”的雏形。</p>\n<blockquote data-nodeid="6711">\n<p data-nodeid="6712">注：由于模板引擎更倾向于点对点解决烦琐 DOM 操作的问题，它在能力和定位上既不能够、也不打算替换掉 jQuery，两者是和谐共存的。因此这里不存在“模板引擎时期”，只有“模板引擎方案”。</p>\n</blockquote>\n<p data-nodeid="6713">怎么理解模板这个概念呢？我们来看一个例子。比如说我现在手里有一套员工数据，数据内容如下：</p>\n<pre class="lang-js" data-nodeid="6714"><code data-language="js"><span class="hljs-keyword">const</span> staff = [\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">\'修言\'</span>,\n    <span class="hljs-attr">career</span>: <span class="hljs-string">\'前端\'</span>\n  },\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">\'翠翠\'</span>,\n    <span class="hljs-attr">career</span>: <span class="hljs-string">\'编辑\'</span>\n  },\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">\'花花\'</span>,\n    <span class="hljs-attr">career</span>: <span class="hljs-string">\'运营\'</span> \n  }\n]\n</code></pre>\n<p data-nodeid="6715">现在我想要在前端用表格展示这一堆数据，我就可以遵循模板的语法，把它塞进模板（template）里去。下面就是一个典型的模板语法使用示例：</p>\n<pre class="lang-js" data-nodeid="6716"><code data-language="js">&lt;table&gt;\n  {% staff.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">person</span>)</span>{ %}\n  &lt;tr&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{% student.name %}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span>\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{% student.age %}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span>\n  &lt;/tr&gt;\n  {% }); %}\n&lt;/table&gt;\n</code></pre>\n<p data-nodeid="6717">可以看出，模板语法其实就是把 JS 和 HTML 结合在一起的一种规则，而模板引擎做的事情也非常容易理解。</p>\n<p data-nodeid="6718">把 staff 这个数据源读进去，塞到预置好的 HTML 模板里，然后把两者融合在一起，吐出一段目标字符串给你。这段字符串的内容，其实就是一份标准的、可用于渲染的 HTML 代码，它将对应一个 DOM 元素。最后，将这个 DOM 元素挂载到页面中去，整个模板的渲染流程也就走完了。</p>\n<p data-nodeid="6719">这个过程可以用伪代码来表示，如下所示：</p>\n<pre class="lang-js" data-nodeid="6720"><code data-language="js"><span class="hljs-comment">// 数据和模板融合出 HTML 代码</span>\n<span class="hljs-keyword">var</span> targetDOM = template({<span class="hljs-attr">data</span>: students})\n<span class="hljs-comment">// 添加到页面中去</span>\n<span class="hljs-built_in">document</span>.body.appendChild(targetDOM)\n</code></pre>\n<p data-nodeid="6721">当然，实际的过程会比我们描述的要复杂一些。这里我补充一下模板引擎的实现思路，供感兴趣的同学参考。模板引擎一般需要做下面几件事情：</p>\n<ol data-nodeid="6722">\n<li data-nodeid="6723">\n<p data-nodeid="6724">读取 HTML 模板并解析它，分离出其中的 JS 信息；</p>\n</li>\n<li data-nodeid="6725">\n<p data-nodeid="6726">将解析出的内容拼接成字符串，动态生成 JS 代码；</p>\n</li>\n<li data-nodeid="6727">\n<p data-nodeid="6728">运行动态生成的 JS 代码，吐出“目标 HTML”；</p>\n</li>\n<li data-nodeid="6729">\n<p data-nodeid="6730">将“目标 HTML”赋值给 innerHTML，触发渲染流水线，完成真实 DOM 的渲染。</p>\n</li>\n</ol>\n<p data-nodeid="6731">使用模板引擎方案来渲染数据是非常爽的：每次数据发生变化时，我们都不用关心到底是哪里的数据变了，也不用手动去点对点完成 DOM 的修改。只<strong data-nodeid="6882">需要关注的仅仅是数据和数据变化本身</strong>，DOM 层面的改变模板引擎会帮我们做掉。</p>\n<p data-nodeid="6732">如此看来，模板引擎像极了一个只需要接收命令，就能够把活干得漂漂亮亮的“扫地机器人”！可惜的是，模板引擎出现的契机虽然是为了使用户界面与业务数据相分离，但实际的应用场景基本局限在“实现高效的字符串拼接”这一个点上，因此不能指望它去做太复杂的事情。尤其令人无法接受的是，<strong data-nodeid="6888">它在性能上的表现并不尽如人意</strong>：由于不够“智能”，它更新 DOM 的方式是将已经渲染出 DOM 整体注销后再整体重渲染，并且不存在更新缓冲这一说。在 DOM 操作频繁的场景下，模板引擎可能会直接导致页面卡死。</p>\n<blockquote data-nodeid="6733">\n<p data-nodeid="6734">注：请注意小标题中“早期”这个限定词——本课时所讨论的“模板引擎”概念，指的是虚拟 DOM 思想推而广之以前，相对原始的一类模板引擎，这类模板引擎曾经主导了一个时代。但时下来看，越来越多的模板引擎正在引入虚拟 DOM，模板引擎最终也将走向现代化。</p>\n</blockquote>\n<p data-nodeid="6735">虽然指望模板引擎实现生产力解放有些天方夜谭，但模板引擎在思想上无疑具备高度的先进性：允许程序员只关心数据而不必关心 DOM 细节的这一操作，和 React 的“数据驱动视图”思想如出一辙，实在是高！</p>\n<h3 data-nodeid="6736">那该怎么办呢？</h3>\n<p data-nodeid="6737">jQuery 救不了加班写 DOM 操作的前端，模板引擎也救不了，那该怎么办呢？</p>\n<p data-nodeid="6738">这时候有一批仁人志士，兴许是从模板引擎的设计思想上得到了启发，他们明确了要走“数据驱动视图”这条基本道路，于是便沿着这个思路往下摸索：模板引擎的数据驱动视图方案，核心问题在于对真实 DOM 的修改过于“大刀阔斧”，导致了 DOM 操作的范围过大、频率过高，进而可能会导致糟糕的性能。然后这帮人就想啊：既然操作真实 DOM 对性能损耗这么大，那我操作假的 DOM 不就行了？</p>\n<p data-nodeid="6739">沿着这个思路再往下走，就有了我们都爱的虚拟 DOM。</p>\n<blockquote data-nodeid="6740">\n<p data-nodeid="6741">注：出于严谨，还是要解释下。真实历史中的虚拟 DOM 创作过程，到底有没有向模板引擎去学习，这个暂时无从考证。但是按照前端发展的过程来看，模板引擎和虚拟 DOM 确实在思想上存在递进关系，很多场景下，面试官也可能会问及两者的关系。因此在此处，我采取了这样一种表述方式，希望能够帮助你更好地把握住问题的关键所在。</p>\n</blockquote>\n<h3 data-nodeid="6742">虚拟 DOM 是如何解决问题的</h3>\n<p data-nodeid="6743">读到这里，你可能对虚拟 DOM 已经有些感觉了。这里我来帮你总结下，同样是将用户界面与数据相分离，模板引擎是这样做的：</p>\n<p data-nodeid="6744"><img src="https://s0.lgstatic.com/i/image/M00/68/F3/Ciqc1F-lMciARJRWAABf3Qw2zLE639.png" alt="Lark20201106-192050.png" data-nodeid="6900"></p>\n<p data-nodeid="6745">而在虚拟 DOM 的加持下，事情变成了这样：</p>\n<p data-nodeid="6746"><img src="https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMdaAD-COAAB2DeSedec916.png" alt="Lark20201106-192053.png" data-nodeid="6904"></p>\n<p data-nodeid="6747">注意图中的“模板”二字加了引号，这是因为虚拟 DOM 在实现上并不总是借助模板。比如 React 就使用了 JSX，前面咱们着重讲过，JSX 本质不是模板，而是一种使用体验和模板相似的 JS 语法糖。</p>\n<p data-nodeid="6748">区别就在于多出了一层虚拟 DOM 作为缓冲层。这个缓冲层带来的利好是：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“<strong data-nodeid="6911">差量更新</strong>”。这个过程对应的虚拟 DOM 工作流如下图所示：</p>\n<p data-nodeid="6749"><img src="https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMeWADhSdAABuVFS6_bo480.png" alt="Lark20201106-192055.png" data-nodeid="6914"></p>\n<blockquote data-nodeid="6750">\n<p data-nodeid="6751">注：图中的 diff 和 patch 其实都是函数名，这些函数取材于一个<a href="https://github.com/Matt-Esch/virtual-dom" data-nodeid="6918">独立的虚拟 DOM 库</a>。之所以写明了具体流程对应的函数名，是因为我发现面试的时候，很多面试官习惯于用函数名指代过程，但不少人不清楚这个对应关系（尤其是 patch），会非常影响作答。这里提前帮你把这个坑给规避掉。</p>\n</blockquote>\n<p data-nodeid="6752">还需要说明的一点是， 虚拟 DOM 和 Redux 一样，不依附于任何具体的框架。学习虚拟 DOM，实际上可以完全不借助 React；但学习 React，就必须了解虚拟 DOM。如果你对虚拟 DOM 的具体实现过程感兴趣，可以在<a href="https://github.com/Matt-Esch/virtual-dom" data-nodeid="6923">这个 GitHub 仓库</a>里查看其源码细节。</p>\n<p data-nodeid="6753">回到主线剧情上来，差量更新可以确保虚拟 DOM 既能够提供高效的开发体验（开发者只需要关心数据），又能够保持过得去的性能（只更新发生了变化的那部分 DOM），实在是妙啊！</p>\n<h3 data-nodeid="6754">React 选用虚拟 DOM，真的是为了更好的性能吗？</h3>\n<p data-nodeid="6755">读到这里，相信你至少已经 get 到了这样一个点：在整个 DOM 操作的演化过程中，主要矛盾并不在于性能，而在于开发者写得爽不爽，在于<strong data-nodeid="6932">研发体验/研发效率</strong>。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。</p>\n<p data-nodeid="6756">虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。<strong data-nodeid="6938">虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能</strong>。</p>\n<p data-nodeid="6757">性能问题属于前端领域复杂度比较高的问题。当我们量化性能的时候，往往并不能只追求一个单一的数据，而是需要结合具体的参照物、渲染的阶段、数据的吞吐量等各种要素来作分情况的讨论。</p>\n<p data-nodeid="6758">拿前面讲过的模板渲染来举例，我们可以对比一下它和虚拟 DOM 在性能开销上的差异。两者的渲染工作流对比如下图所示：</p>\n<p data-nodeid="6759"><img src="https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMhKAbHiXAACFes1Uw30648.png" alt="Lark20201106-192058.png" data-nodeid="6943"><br>\n<img src="https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMheAZqbEAACP9ZvpCP8374.png" alt="Lark20201106-192100.png" data-nodeid="6947"></p>\n<p data-nodeid="6760">从图中可以看出，模板渲染的步骤1，和虚拟 DOM 渲染的步骤1、2都属于 JS 范畴的行为，这两者是具备可比性的，我们放在一起来看：动态生成 HTML 字符串的过程本质是对字符串的拼接，对性能的消耗是有限的；而虚拟 DOM 的构建和 diff 过程逻辑则相对复杂，它不可避免地涉及递归、遍历等耗时操作。<strong data-nodeid="6953">因此在 JS 行为这个层面，模板渲染胜出</strong>。</p>\n<p data-nodeid="6761">模板渲染的步骤3，和虚拟 DOM 的步骤3 都属于 DOM 范畴的行为，两者具备可比性，因此我们仍然可以愉快地对比下去：模板渲染是全量更新，而虚拟 DOM 是差量更新。</p>\n<p data-nodeid="6762">乍一看好像差量更新一定比全量更新高效，但你需要考虑这样一种情况：数据内容变化非常大（或者说整个发生了改变），促使差量更新计算出来的结果和全量更新极为接近（或者说完全一样）。</p>\n<p data-nodeid="6763">在这种情况下，DOM 更新的工作量基本一致，而虚拟 DOM 却伴随着开销更大的 JS 计算，此时会出现的一种现象就是模板渲染和虚拟 DOM 在整体性能上难分伯仲：若两者最终计算出的 DOM 更新内容完全一致，那么虚拟 DOM 大概率不敌模板渲染；但只要两者在最终 DOM 操作量上拉开那么一点点的差距，虚拟 DOM 就将具备战胜模板渲染的底气。<strong data-nodeid="6961">因为虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级</strong>，极少量的 DOM 操作耗费的性能足以支撑大量的 JS 计算。</p>\n<p data-nodeid="6764">当然，上面讨论的这种情况相对来说比较极端。在实际的开发中，更加高频的场景是这样的：我每次 setState 的时候只修改少量的数据，比如一个对象中的某几个属性，再比如一个数组中的某几个元素。在这样的场景下，模板渲染和虚拟 DOM 之间 DOM 操作量级的差距就完全拉开了，虚拟 DOM 将在性能上具备绝对的优势。</p>\n<blockquote data-nodeid="6765">\n<p data-nodeid="6766">注意，此处的结论是“在 XXX 场景下，虚拟 DOM 相对于 XXX 具备性能优势”，它是有严格限定条件的。有人不到黄河心不死，可能又要问“那虚拟 DOM 对比 jQuery 呢？”“那虚拟 DOM 对比原生 DOM 呢？”。<br>\n我想说的是，性能问题不能一概而论，而且咱都讲到这个份上了，就不要再钻性能这个牛角尖了。jQuery、原生 DOM 在思维模式上来说和虚拟 DOM 截然不同，强行比较意义不大。</p>\n</blockquote>\n<p data-nodeid="6767">前面又是分析又是举例地说了这么多，其实我最终希望你明白的事情只有一件：<strong data-nodeid="6971">虚拟 DOM 的价值不在性能，而在别处</strong>。因此想要从性能角度来把握虚拟 DOM 的优势，无异于南辕北辙。偏偏在面试场景下，10 个人里面有 9 个都走这条歧路，最后9个人里面自然没有一个能自圆其说，实在让人惋惜。</p>\n<h3 data-nodeid="6768">那么虚拟 DOM 的价值到底是什么呢？</h3>\n<p data-nodeid="6769">最后我想和你聊聊虚拟 DOM 的价值，这又是一个宏大的、容易说错话的命题。当我们谈及某个事物的价值时，其实就像是在称赞一个美女，不同的人自然有着不同看待美女的视角。此处我无意于给你一个天衣无缝的标准答案（这样的答案想必也不存在），而是希望能够站在“虚拟 DOM 解决了哪些关键问题”这个视角，和你分享一些业内关于虚拟 DOM 的共识。</p>\n<p data-nodeid="6770">虚拟 DOM 解决的关键问题有以下两个。</p>\n<ol data-nodeid="7674">\n<li data-nodeid="7675">\n<p data-nodeid="7676">研发体验/研发效率的问题：这一点前面已经反复强调过，DOM 操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。</p>\n</li>\n<li data-nodeid="7677">\n<p data-nodeid="7678">跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是真实 DOM，也可以是iOS 界面、安卓界面、小程序......同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和1是高度呼应的。</p>\n</li>\n</ol>\n<p data-nodeid="7679" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/69/AE/CgqCHl-otLSAT1ivAACwY9bVkZQ836.png" alt="Lark20201109-110626.png" data-nodeid="7684"></p>\n\n<p data-nodeid="7340" class="">在本课时的主线内容之外，虚拟 DOM 还有非常多的亮点值得我们去挖掘，这里我想着重拓展一下的是前面聊到的性能层面的优化。</p>\n\n\n<p data-nodeid="6777">除了差量更新以外，“<strong data-nodeid="6993">批量更新</strong>”也是虚拟 DOM 在性能方面所做的一个重要努力：<strong data-nodeid="6994">“批量更新”在</strong><a href="https://github.com/Matt-Esch/virtual-dom" data-nodeid="6988">通用虚拟 DOM 库</a><strong data-nodeid="6995">里是由 batch 函数来处理的</strong>。在差量更新速度非常快的情况下（比如极短的时间里多次操作同一个 DOM），用户实际上只能看到最后一次更新的效果。这种场景下，前面几次的更新动作虽然意义不大，但都会触发重渲染流程，带来大量不必要的高耗能操作。</p>\n<p data-nodeid="6778">这时就需要请 batch 来帮忙了，<strong data-nodeid="7001">batch 的作用是缓冲每次生成的补丁集</strong>，它会把收集到的多个补丁集暂存到队列中，再将最终的结果交给渲染函数，最终实现集中化的 DOM 批量更新。</p>\n<h3 data-nodeid="6779">总结</h3>\n<p data-nodeid="6780">本课时我们首先一起回顾了 DOM 操作解决方案的发展史，从中明确了虚拟 DOM 定位和解决的主要问题，然后对虚拟 DOM 的通用工作流进行了分析。在这个工作流中，有一个过程值得我们格外去注意，那就是“diff”。</p>\n<p data-nodeid="6781">diff 指的是对比出两棵虚拟 DOM 树之间差异的过程，不同的框架对 diff 过程有着不同的实现思路。对于 React 框架来说，有特色的、与时俱进的 diff 算法正是它最迷人的地方，也是框架的核心所在。</p>\n<p data-nodeid="6782" class="">在接下来的课时，我将从 React15 的 diff 过程切入，对经典的“栈调和”算法一探究竟。</p>',
          },
          {
            theme: '10 | React 中的“栈调和”（Stack Reconciler）过程是怎样的？',
            id: 211,
            content:
              '<p data-nodeid="1137" class="">时下 React 16 乃至 React 17 都是业界公认的“当红炸子鸡”，相比之下 React 15 似乎已经是一副黯淡无光垂垂老矣的囧相了。</p>\n<p data-nodeid="1138">在这样的时代背景下，愿意自动自发地了解 React 15 的人越来越少，这是一个令人心碎的现象。毕竟有位伟人曾经说过，“以史为镜，可以知兴替”；还有另一位伟人曾经说过，“学习知识需要建立必要且完整的上下文”——如果我们不清楚 React 15 的运作机制，就无从把握它的局限性；如果我们不能确切地把握 React 15 的局限性，就无法从根本上理解 React 16 大改版背后的设计动机。因此在追逐时代潮流之前，必须学好历史。</p>\n<p data-nodeid="1139">在本讲，我们就要迈出“学习历史”的第一步，也是最重要的一步——理解 React 15 的“栈调和”算法。</p>\n<h3 data-nodeid="1140">调和（Reconciliation）过程与 Diff 算法</h3>\n<p data-nodeid="1141" class="">迫于喜欢钻名词牛角尖的人实在太多，开篇我先来带你做一个概念辨析，显式声明一下专栏中所提及的“调和”和“Diff”两个东西的确切指向。</p>\n<p data-nodeid="1142">“调和”又译为“协调”，协调过程的官方定义，藏在 React 官网对虚拟 DOM 这一概念的解释中，原文如下：</p>\n<blockquote data-nodeid="1143">\n<p data-nodeid="1144">Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作<a href="https://zh-hans.reactjs.org/docs/reconciliation.html" data-nodeid="1225">协调</a>（调和）。</p>\n</blockquote>\n<p data-nodeid="1145">我来划一下这段话里的重点：<strong data-nodeid="1232">通过如 ReactDOM 等类库使虚拟 DOM 与“真实的” DOM 同步，这一过程叫作协调（调和）</strong>。</p>\n<p data-nodeid="1146">说人话：调和指的是将虚拟 DOM<strong data-nodeid="1242">映射</strong>到真实 DOM 的过程。因此严格来说，<strong data-nodeid="1243">调和过程并不能和 Diff 画等号</strong>。调和是“使一致”的过程，而 Diff 是“找不同”的过程，它只是“使一致”过程中的一个环节。</p>\n<p data-nodeid="1147"><strong data-nodeid="1252">React 的源码结构佐证了这一点</strong>：React 从大的板块上将源码划分为了 Core、Renderer 和 Reconciler 三部分。其中 Reconciler（调和器）的源码位于<a href="https://github.com/facebook/react/tree/15-stable/src/renderers/shared/stack/reconciler" data-nodeid="1250">src/renderers/shared/stack/reconciler</a>这个路径，调和器所做的工作是一系列的，包括组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用。</p>\n<p data-nodeid="1148">所以说<code data-backticks="1" data-nodeid="1254">调和 !== Diff</code>这个结论，是站得住脚的，如果你持有这个观点，说明你很专业，为你点赞！</p>\n<p data-nodeid="2547" class=""><strong data-nodeid="2552">但是</strong>！在如今大众的认知里，当我们讨论调和的时候，其实就是在讨论 Diff。</p>\n\n\n\n<p data-nodeid="1150">这样的认知也有其合理性，因为<strong data-nodeid="1267">Diff 确实是调和过程中最具代表性的一环</strong>：根据 Diff 实现形式的不同，调和过程被划分为了以 React 15 为代表的“栈调和”以及 React 16 以来的“Fiber 调和”。在实际的面试过程中，当面试官抛出 Reconciliation 相关问题时，也多半是为了了解候选人对 Diff 的掌握程度。因此在本讲中，“栈调和”指的就是 React 15 的 Diff 算法。</p>\n<h3 data-nodeid="1151">Diff 策略的设计思想</h3>\n<p data-nodeid="1152">在展开讲解 Diff 算法的具体逻辑之前，我们首先从整体上把握一下 Diff 的设计思想。</p>\n<p data-nodeid="1153">前面我们已经提到，Diff 算法其实就是“找不同”的过程。在计算机科学领域，要想找出两个树结构之间的不同, 传统的计算方法是通过循环递归进行树节点的一一对比, &nbsp;这个过程的算法复杂度是 O (n<sup>3</sup>) 。尽管这个算法本身已经是几代程序员持续优化的结果，但对计算能力有限的浏览器来说，O (n<sup>3</sup>) 仍然意味着一场性能灾难。</p>\n<p data-nodeid="1154">具体来说，若一张页面中有 100 个节点（这样的情况在实际开发中并不少见），100<sup>3</sup> 算下来就有十万次操作了，这还只是一次 Diff 的开销；若应用规模更大一点，维护 1000 个节点，那么操作次数将会直接攀升到 10 亿的量级。</p>\n<p data-nodeid="1155">经常做算法题的人都知道，OJ 中相对理想的时间复杂度一般是 O(1) 或 O(n)。当复杂度攀升至 O(n<sup>2</sup>) 时，我们就会本能地寻求性能优化的手段，更不必说是人神共愤的 O(n<sup>3</sup>) 了！我们看不下去，React 自然也看不下去。React 团队结合设计层面的一些推导，总结了以下两个规律， 为将 O (n<sup>3</sup>) 复杂度转换成 O (n) 复杂度确立了大前提：</p>\n<ul data-nodeid="1156">\n<li data-nodeid="1157">\n<p data-nodeid="1158">若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构；</p>\n</li>\n<li data-nodeid="1159">\n<p data-nodeid="1160">处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。</p>\n</li>\n</ul>\n<p data-nodeid="1161">除了这两个“板上钉钉”的规律之外，还有一个和实践结合比较紧密的规律，它为 React 实现高效的 Diff 提供了灵感：DOM 节点之间的跨层级操作并不多，<strong data-nodeid="1304">同层级操作是主流</strong>。</p>\n<p data-nodeid="1162">接下来我们就一起看看 React 是如何巧用这 3 个规律，打造高性能 Diff 的。</p>\n<h3 data-nodeid="1163">把握三个“要点”，图解 Diff 逻辑</h3>\n<p data-nodeid="1164">对于 Diff 逻辑的拆分与解读，社区目前已经有过许多版本，不同版本的解读姿势和角度各有不同。但说到底，真正需要你把握的要点无非下面这 3 个：</p>\n<ol data-nodeid="1165">\n<li data-nodeid="1166">\n<p data-nodeid="1167">Diff 算法性能突破的关键点在于“<strong data-nodeid="1313">分层对比</strong>”；</p>\n</li>\n<li data-nodeid="1168">\n<p data-nodeid="1169">类型一致的节点才有继续 Diff 的必要性；</p>\n</li>\n<li data-nodeid="1170">\n<p data-nodeid="1171">key 属性的设置，可以帮我们尽可能重用同一层级内的节点。</p>\n</li>\n</ol>\n<p data-nodeid="1172">这 3 个要点各自呼应着上文的 3 个规律，我们逐个来看。</p>\n<h4 data-nodeid="1173">1. 改变时间复杂度量级的决定性思路：分层对比</h4>\n<p data-nodeid="1174">结合“DOM 节点之间的跨层级操作并不多，<strong data-nodeid="1329">同层级操作是主流</strong>”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它<strong data-nodeid="1330">只针对相同层级的节点作对比</strong>，如下图所示。这样一来，只需要从上到下的一次遍历，就可以完成对整棵树的对比，这是降低复杂度量级方面的一个最重要的设计。</p>\n<blockquote data-nodeid="1175">\n<p data-nodeid="1176">需要注意的是：虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转的，<strong data-nodeid="1336">分层递归也是递归</strong>。</p>\n</blockquote>\n<p data-nodeid="1177"><img src="https://s0.lgstatic.com/i/image/M00/6C/14/Ciqc1F-qYhGAEPpKAAEByai_5tk134.png" alt="Drawing 1.png" data-nodeid="1339"></p>\n<p data-nodeid="1178">那么如果真的发生了跨层级的节点操作（比如将以 B 节点为根节点的子树从 A 节点下面移动到 C 节点下面，如下图所示）会怎样呢？很遗憾，作为“次要矛盾”，在这种情况下 React 并不能够判断出“移动”这个行为，它只能机械地认为移出子树那一层的组件消失了，对应子树需要被销毁；而移入子树的那一层新增了一个组件，需要重新为其创建一棵子树。</p>\n<p data-nodeid="1179"><strong data-nodeid="1345">销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性</strong>。</p>\n<p data-nodeid="1180"><img src="https://s0.lgstatic.com/i/image/M00/6C/20/CgqCHl-qYhqAbo1HAAGSgsK973k251.png" alt="Drawing 3.png" data-nodeid="1348"></p>\n<h4 data-nodeid="1181">2. 减少递归的“一刀切”策略：类型的一致性决定递归的必要性</h4>\n<p data-nodeid="1182">结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，我们虽不能直接反推出“不同类型的组件 DOM 结构不同”，但在大部分的情况下，这个结论都是成立的。毕竟，实际开发中遇到两个 DOM 结构完全一致、而类型不一致的组件的概率确实太低了。</p>\n<p data-nodeid="1183"><strong data-nodeid="1357">本着抓“主要矛盾”的基本原则，React 认为，只有同类型的组件，才有进一步对比的必要性</strong>；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点，如下图所示。只有确认组件类型相同后，React 才会在保留组件对应 DOM 树（或子树）的基础上，尝试向更深层次去 Diff。</p>\n<p data-nodeid="1184">这样一来，便能够从很大程度上减少 Diff 过程中冗余的递归操作。</p>\n<p data-nodeid="1185"><img src="https://s0.lgstatic.com/i/image/M00/6C/15/Ciqc1F-qYiqAbfiqAAD0Bt0pyEY472.png" alt="Drawing 5.png" data-nodeid="1361"></p>\n<h4 data-nodeid="1186">3. 重用节点的好帮手：key 属性帮 React “记住”节点</h4>\n<p data-nodeid="1187">在上文中，我们提到了“key 属性能够帮助维持节点的稳定性”，这个结论从何而来呢？首先，我们来看看 React 对 key 属性的定义：</p>\n<blockquote data-nodeid="1188">\n<p data-nodeid="1189">key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。</p>\n</blockquote>\n<p data-nodeid="1190">它试图解决的是<strong data-nodeid="1372">同一层级下节点的重用问题</strong>。在展开分析之前，我们先结合到现在为止对 Diff 过程的理解，来思考这样一种情况，如下图所示：</p>\n<p data-nodeid="1191"><img src="https://s0.lgstatic.com/i/image/M00/6C/20/CgqCHl-qYjGANI2jAAC86KpVHsE612.png" alt="Drawing 7.png" data-nodeid="1375"></p>\n<p data-nodeid="1192">图中 A 组件在保持类型和其他属性均不变的情况下，在两个子节点（B 和 D）之间插入了一个新的节点（C）。按照已知的 Diff 原则，两棵树之间的 Diff 过程应该是这样的：</p>\n<ul data-nodeid="1193">\n<li data-nodeid="1194">\n<p data-nodeid="1195">首先对比位于第 1 层的节点，发现两棵树的节点类型是一致的（都是 A），于是进一步 Diff；</p>\n</li>\n<li data-nodeid="1196">\n<p data-nodeid="1197">开始对比位于第 2 层的节点，第 1 个接受比较的是 B 这个位置，对比下来发现两棵树这个位置上的节点都是 B，没毛病，放过它；</p>\n</li>\n<li data-nodeid="1198">\n<p data-nodeid="1199">第 2 个接受比较的是 D 这个位置，对比 D 和 C，发现前后的类型不一致，<strong data-nodeid="1384">直接删掉 D 重建 C</strong>；</p>\n</li>\n<li data-nodeid="1200">\n<p data-nodeid="1201">第 3 个接受比较的是 E 这个位置，对比 E 和 D，发现前后的类型不一致，<strong data-nodeid="1390">直接删掉 E 重建 D</strong>；</p>\n</li>\n<li data-nodeid="1202">\n<p data-nodeid="1203">最后接受“比较”的是树 2 的 E 节点这个位置，这个位置在树 1 里是空的，也就是说树 2 的E 是一个新增节点，所以<strong data-nodeid="1396">新增一个 E</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="1204">你看你看，奇怪的事情发生了：C、D、E 三个节点，其实都是可以直接拿来用的。<strong data-nodeid="1406">原本新增 1 个节点就能搞定的事情，现在却又是删除又是重建地搞了半天</strong>，这也太蠢了吧？而且这个蠢操作和跨层级移动节点还不太一样，后者本来就属于低频操作，加以合理的最佳实践约束一下基本上可以完全规避掉；但图示的这种插入节点的形式，可是实打实的高频操作，你怎么躲也躲不过的。频繁增删节点必定拖垮性能，<strong data-nodeid="1407">这时候就需要请出 key 属性来帮我们重用节点了</strong>。</p>\n<p data-nodeid="1205">key 属性的形式，我们肯定都不陌生。在基于数组动态生成节点时，我们一般都会给每个节点加装一个 key 属性（下面是一段代码示例）：</p>\n<pre class="lang-js" data-nodeid="1206"><code data-language="js"><span class="hljs-keyword">const</span> todoItems = todos.map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span>\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span>&gt;</span>\n    {todo.text}\n  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n)\n</code></pre>\n<p data-nodeid="1207">如果你忘记写 key，React 虽然不至于因此报错，但控制台标红是难免的，它会给你抛出一个“请给列表元素补齐 key 属性”的 warning，这个常见的 warning 也从侧面反映出了 key 的重要性。事实上，当我们没有设定 key 值的时候，Diff 的过程就正如上文所描述的一样惨烈。但只要你按照规范加装一个合适的 key，这个 key 就会像一个记号一样，帮助 React “记住”某一个节点，从而在后续的更新中实现对这个节点的追踪。比如说刚刚那棵虚拟 DOM 树，若我们给位于第 2 层的每一个子节点一个 key 值，如下图所示：</p>\n<p data-nodeid="1208"><img src="https://s0.lgstatic.com/i/image/M00/6C/15/Ciqc1F-qYkOANYXaAAC2tCBcU4k280.png" alt="Drawing 9.png" data-nodeid="1412"></p>\n<p data-nodeid="1209">这个 key 就充当了每个节点的 ID（唯一标识），有了这个标识之后，当 C 被插入到 B 和 D 之间时，React 并不会再认为 C、D、E 这三个坑位都需要被重建——它会通过识别 ID，意识到 D 和 E 并没有发生变化（D 的 ID 仍然是 1，E 的 ID 仍然是 2），而只是被调整了顺序而已。接着，React 便能够轻松地重用它“追踪”到旧的节点，将 D 和 E 转移到新的位置，并完成对 C 的插入。这样一来，同层级下元素的操作成本便大大降低。</p>\n<blockquote data-nodeid="1210">\n<p data-nodeid="1211">注：作为一个节点的唯一标识，在使用 key 之前，请务必确认 key 的唯一和稳定。</p>\n</blockquote>\n<h3 data-nodeid="1212">总结</h3>\n<p data-nodeid="1213">行文至此，栈调和机制下 Diff 算法的核心逻辑其实已经讲完了。前面我曾经强调过，原理!==源码，这一点放在 Diff 算法这儿来看尤为应验——Diff 算法的源码调用链路很长，就 React 15 这一个大版本来说，我个人就断断续续花了好几天才真正读完；但若真的把源码中的逻辑要点作提取，你消化它们可能也就不过一杯茶的工夫。</p>\n<p data-nodeid="1214">对于 React 15 下的 Diff 过程，我个人的建议是你了解到逻辑这一层，把握住“树递归”这个特征，这就够了。专栏对调和过程的讨论，主要的发力点仍然是围绕 React 16 来展开的。若你学有余力，可以提前了解一下 React 16 对调和的实现，这将是我们整个第二模块的一个重中之重。</p>\n<p data-nodeid="1215" class="">结束了对 React 15 时代下 Diff 的探讨，你可别忘了虚拟 DOM 中还有一个叫作“batch”的东西。“batch”描述的是“批处理”机制，这个机制和 Diff 一样，在 React 中都可以由 setState 来触发。在下一讲，我们就会深入 setState 工作流，对包括“批量更新”在内的一系列问题一探究竟。</p>',
          },
          {
            theme: '11 | setState 到底是同步的，还是异步的？',
            id: 212,
            content:
              '<p data-nodeid="853" class="">setState 对于许多的 React 开发者来说，像是一个“最熟悉的陌生人”：</p>\n<ul data-nodeid="854">\n<li data-nodeid="855">\n<p data-nodeid="856">当你入门 React 的时候，接触的第一波 API 里一定有 setState——数据驱动视图，没它就没法创造变化；</p>\n</li>\n<li data-nodeid="857">\n<p data-nodeid="858">当你项目的数据流乱作一团的时候，层层排查到最后，始作俑者也往往是 setState——工作机制太复杂，文档又不说清楚，只能先“摸着石头过河”。</p>\n</li>\n</ul>\n<p data-nodeid="859">久而久之，setState 的工作机制渐渐与 React 调和算法并驾齐驱，成了 React 核心原理中区分度最高的知识模块之一。本讲我们就紧贴 React 源码和时下最高频的面试题目，帮你从根儿上理解 setState 工作流。</p>\n<h3 data-nodeid="860">从一道面试题说起</h3>\n<p data-nodeid="861">这是一道变体繁多的面试题，在 BAT 等一线大厂的面试中考察频率非常高。首先题目会给出一个这样的 App 组件，在它的内部会有如下代码所示的几个不同的 setState 操作：</p>\n<pre class="lang-js" data-nodeid="862"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">"./styles.css"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>{\n  state = {\n    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>\n  }\n  increment = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'increment setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>\n    });\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'increment setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  }\n  triple = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'triple setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>\n    });\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>\n    });\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>\n    });\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'triple setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  }\n  reduce = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'reduce setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n      <span class="hljs-keyword">this</span>.setState({\n        <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count - <span class="hljs-number">1</span>\n      });\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'reduce setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n    },<span class="hljs-number">0</span>);\n  }\n  render(){\n    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.increment}</span>&gt;</span>点我增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.triple}</span>&gt;</span>点我增加三倍<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.reduce}</span>&gt;</span>点我减少<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  }\n}\n</code></pre>\n<p data-nodeid="863">接着我把组件挂载到 DOM 上：</p>\n<pre class="lang-js" data-nodeid="864"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;\n<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./App"</span>;\n<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);\nReactDOM.render(\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,\n  rootElement\n);\n</code></pre>\n<p data-nodeid="865">此时浏览器里渲染出来的是如下图所示的三个按钮：</p>\n<p data-nodeid="866"><img src="https://s0.lgstatic.com/i/image/M00/6C/16/Ciqc1F-qYzOAEHeBAAAouh3EFik606.png" alt="Drawing 0.png" data-nodeid="955"></p>\n<p data-nodeid="867">此时有个问题，若从左到右依次点击每个按钮，控制台的输出会是什么样的？读到这里，建议你先暂停 1 分钟在脑子里跑一下代码，看看和下图实际运行出来的结果是否有出入。</p>\n<p data-nodeid="868"><img src="https://s0.lgstatic.com/i/image/M00/6D/8A/Ciqc1F-uMdqAVUoFAAIqtDlymxs173.png" alt="图片4.png" data-nodeid="959"></p>\n<p data-nodeid="869">如果你是一个熟手 React 开发，那么 increment 这个方法的输出结果想必难不倒你——正如许许多多的 React 入门教学所声称的那样，“setState 是一个异步的方法”，这意味着当我们执行完 setState 后，state 本身并不会立刻发生改变。 因此紧跟在 setState 后面输出的 state 值，仍然会维持在它的初始状态（0）。在同步代码执行完毕后的某个“神奇时刻”，state 才会“恰恰好”地增加到 1。</p>\n<p data-nodeid="870">但这个“神奇时刻”到底何时发生，所谓的“恰恰好”又如何界定呢？如果你对这个问题搞不太清楚，那么 triple 方法的输出对你来说就会有一定的迷惑性——setState 一次不好使， setState 三次也没用，state 到底是在哪个环节发生了变化呢？</p>\n<p data-nodeid="871">带着这样的困惑，你决定先抛开一切去看看 reduce 方法里是什么光景，结果更令人大跌眼镜，reduce 方法里的 setState 竟然是同步更新的！这......到底是我们初学 React 时拿到了错误的基础教程，还是电脑坏了？</p>\n<p data-nodeid="872">要想理解眼前发生的这魔幻的一切，我们还得从 setState 的工作机制里去找线索。</p>\n<h3 data-nodeid="873">异步的动机和原理——批量更新的艺术</h3>\n<p data-nodeid="874">我们首先要认知的一个问题：在 setState 调用之后，都发生了哪些事情？基于截止到现在的专栏知识储备，你可能会更倾向于站在生命周期的角度去思考这个问题，得出一个如下图所示的结论：</p>\n<p data-nodeid="875"><img src="https://s0.lgstatic.com/i/image/M00/6D/8A/Ciqc1F-uMeSAYK6FAABN0Vwnq5M814.png" alt="图片3.png" data-nodeid="968"></p>\n<p data-nodeid="876">从图上我们可以看出，一个完整的更新流程，涉及了包括 re-render（重渲染） 在内的多个步骤。re-render 本身涉及对 DOM 的操作，它会带来较大的性能开销。假如说“一次 setState 就触发一个完整的更新流程”这个结论成立，那么每一次 setState 的调用都会触发一次 re-render，我们的视图很可能没刷新几次就卡死了。这个过程如我们下面代码中的箭头流程图所示：</p>\n<pre class="lang-java" data-nodeid="877"><code data-language="java"><span class="hljs-keyword">this</span>.setState({\n  count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>    ===&gt;    shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate\n});\n<span class="hljs-keyword">this</span>.setState({\n  count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>    ===&gt;    shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate\n});\n<span class="hljs-keyword">this</span>.setState({\n  count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>    ===&gt;    shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate\n});\n</code></pre>\n<p data-nodeid="878">事实上，这正是 setState 异步的一个重要的动机——<strong data-nodeid="975">避免频繁的 re-render</strong>。</p>\n<p data-nodeid="879">在实际的 React 运行时中，setState 异步的实现方式有点类似于 Vue 的 $nextTick 和浏览器里的 Event-Loop：<strong data-nodeid="981">每来一个 setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。这个过程，叫作“批量更新”</strong>，批量更新的过程正如下面代码中的箭头流程图所示：</p>\n<pre class="lang-java" data-nodeid="880"><code data-language="java"><span class="hljs-keyword">this</span>.setState({\n  count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务]\n});\n<span class="hljs-keyword">this</span>.setState({\n  count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务，count+<span class="hljs-number">1</span>的任务]\n});\n<span class="hljs-keyword">this</span>.setState({\n  count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>    ===&gt;    入队, [count+<span class="hljs-number">1</span>的任务，count+<span class="hljs-number">1</span>的任务, count+<span class="hljs-number">1</span>的任务]\n});\n                                          ↓\n                                         合并 state，[count+<span class="hljs-number">1</span>的任务]\n                                          ↓\n                                         执行 count+<span class="hljs-number">1</span>的任务\n</code></pre>\n<p data-nodeid="881">值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。因此就算我们在 React 中写了这样一个 100 次的 setState 循环：</p>\n<pre class="lang-java" data-nodeid="882"><code data-language="java">test = () =&gt; {\n  console.log(<span class="hljs-string">\'循环100次 setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  <span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) {\n    <span class="hljs-keyword">this</span>.setState({\n      count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>\n    })\n  }\n  console.log(<span class="hljs-string">\'循环100次 setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n}\n</code></pre>\n<p data-nodeid="883">也只是会增加 state 任务入队的次数，并不会带来频繁的 re-render。当 100 次调用结束后，仅仅是 state 的任务队列内容发生了变化， state 本身并不会立刻改变：</p>\n<p data-nodeid="884"><img src="https://s0.lgstatic.com/i/image/M00/6D/8B/Ciqc1F-uMfKALHLXAAEBeCrt5lE676.png" alt="图片5.png" data-nodeid="986"></p>\n<h3 data-nodeid="885">“同步现象”背后的故事：从源码角度看 setState 工作流</h3>\n<p data-nodeid="886">读到这里，相信你对异步这回事多少有些眉目了。接下来我们就要重点理解刚刚代码里最诡异的一部分——setState 的同步现象：</p>\n<pre class="lang-java" data-nodeid="887"><code data-language="java">reduce = () =&gt; {\n  setTimeout(() =&gt; {\n    console.log(<span class="hljs-string">\'reduce setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n    <span class="hljs-keyword">this</span>.setState({\n      count: <span class="hljs-keyword">this</span>.state.count - <span class="hljs-number">1</span>\n    });\n    console.log(<span class="hljs-string">\'reduce setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  },<span class="hljs-number">0</span>);\n}\n</code></pre>\n<p data-nodeid="888">从题目上看，setState 似乎是在 setTimeout 函数的“保护”之下，才有了同步这一“特异功能”。事实也的确如此，假如我们把 setTimeout 摘掉，setState 前后的 console 表现将会与 increment 方法中无异：</p>\n<pre class="lang-java" data-nodeid="889"><code data-language="java">reduce = () =&gt; {\n  <span class="hljs-comment">// setTimeout(() =&gt; {</span>\n  console.log(<span class="hljs-string">\'reduce setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  <span class="hljs-keyword">this</span>.setState({\n    count: <span class="hljs-keyword">this</span>.state.count - <span class="hljs-number">1</span>\n  });\n  console.log(<span class="hljs-string">\'reduce setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  <span class="hljs-comment">// },0);</span>\n}\n</code></pre>\n<p data-nodeid="890">点击后的输出结果如下图所示：</p>\n<p data-nodeid="891"><img src="https://s0.lgstatic.com/i/image/M00/6D/96/CgqCHl-uMguADJiMAAEld6KAKBI013.png" alt="图片6.png" data-nodeid="993"></p>\n<p data-nodeid="892">现在问题就变得清晰多了：为什么 setTimeout 可以将 setState 的执行顺序从异步变为同步？</p>\n<p data-nodeid="893">这里我先给出一个结论：<strong data-nodeid="1000">并不是 setTimeout 改变了 setState，而是 setTimeout 帮助 setState “逃脱”了 React 对它的管控。只要是在 React 管控下的 setState，一定是异步的</strong>。</p>\n<p data-nodeid="894">接下来我们就从 React 源码里，去寻求佐证这个结论的线索。</p>\n<blockquote data-nodeid="895">\n<p data-nodeid="896">tips：时下虽然市场里的 React 16、React 17 十分火热，但就 setState 这块知识来说，React 15 仍然是最佳的学习素材。因此下文所有涉及源码的分析，都会围绕 React 15 展开。关于 React 16 之后 Fiber 机制给 setState 带来的改变，我们会有专门一讲来分析，不在本讲的讨论范围内。</p>\n</blockquote>\n<h4 data-nodeid="897">解读 setState 工作流</h4>\n<p data-nodeid="898">我们阅读任何框架的源码，都应该带着问题、带着目的去读。React 中对于功能的拆分是比较细致的，setState 这部分涉及了多个方法。为了方便你理解，我这里先把主流程提取为一张大图：</p>\n<p data-nodeid="899"><img src="https://s0.lgstatic.com/i/image2/M01/04/81/Cip5yF_yswuAWzDfAAEc1lISh-Q211.png" alt="3.png" data-nodeid="1007"></p>\n<p data-nodeid="900">接下来我们就沿着这个流程，逐个在源码中对号入座。首先是 setState 入口函数：</p>\n<pre class="lang-java" data-nodeid="901"><code data-language="java">ReactComponent.prototype.setState = function (partialState, callback) {\n  <span class="hljs-keyword">this</span>.updater.enqueueSetState(<span class="hljs-keyword">this</span>, partialState);\n  <span class="hljs-keyword">if</span> (callback) {\n    <span class="hljs-keyword">this</span>.updater.enqueueCallback(<span class="hljs-keyword">this</span>, callback, <span class="hljs-string">\'setState\'</span>);\n  }\n};\n</code></pre>\n<p data-nodeid="902">入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。这里我们以对象形式的入参为例，可以看到它直接调用了 this.updater.enqueueSetState 这个方法：</p>\n<pre class="lang-java" data-nodeid="903"><code data-language="java">enqueueSetState: function (publicInstance, partialState) {\n  <span class="hljs-comment">// 根据 this 拿到对应的组件实例</span>\n  <span class="hljs-keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance, <span class="hljs-string">\'setState\'</span>);\n  <span class="hljs-comment">// 这个 queue 对应的就是一个组件实例的 state 数组</span>\n  <span class="hljs-keyword">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n  queue.push(partialState);\n  <span class="hljs-comment">//  enqueueUpdate 用来处理当前的组件实例</span>\n  enqueueUpdate(internalInstance);\n}\n</code></pre>\n<p data-nodeid="904">这里我总结一下，enqueueSetState 做了两件事：</p>\n<ul data-nodeid="905">\n<li data-nodeid="906">\n<p data-nodeid="907">将新的 state 放进组件的状态队列里；</p>\n</li>\n<li data-nodeid="908">\n<p data-nodeid="909">用 enqueueUpdate 来处理将要更新的实例对象。</p>\n</li>\n</ul>\n<p data-nodeid="910">继续往下走，看看 enqueueUpdate 做了什么：</p>\n<pre class="lang-java" data-nodeid="911"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">enqueueUpdate</span><span class="hljs-params">(component)</span> </span>{\n  ensureInjected();\n  <span class="hljs-comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span>\n  <span class="hljs-keyword">if</span> (!batchingStrategy.isBatchingUpdates) {\n    <span class="hljs-comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span>\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    <span class="hljs-keyword">return</span>;\n  }\n  <span class="hljs-comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span>\n  dirtyComponents.push(component);\n  <span class="hljs-keyword">if</span> (component._updateBatchNumber == <span class="hljs-keyword">null</span>) {\n    component._updateBatchNumber = updateBatchNumber + <span class="hljs-number">1</span>;\n  }\n}\n</code></pre>\n<p data-nodeid="912">这个 enqueueUpdate 非常有嚼头，它引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates属性直接决定了当下是要走更新流程，还是应该排队等待；其中的batchedUpdates 方法更是能够直接发起更新流程。由此我们可以大胆推测，<strong data-nodeid="1021">batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象</strong>。<br>\n接下来，我们就一起来研究研究这个 batchingStrategy。</p>\n<pre class="lang-java" data-nodeid="913"><code data-language="java"><span class="hljs-comment">/**\n * batchingStrategy源码\n**/</span>\n \n<span class="hljs-keyword">var</span> ReactDefaultBatchingStrategy = {\n  <span class="hljs-comment">// 全局唯一的锁标识</span>\n  isBatchingUpdates: <span class="hljs-keyword">false</span>,\n \n  <span class="hljs-comment">// 发起更新动作的方法</span>\n  batchedUpdates: function(callback, a, b, c, d, e) {\n    <span class="hljs-comment">// 缓存锁变量</span>\n    <span class="hljs-keyword">var</span> alreadyBatchingStrategy = ReactDefaultBatchingStrategy. isBatchingUpdates\n    <span class="hljs-comment">// 把锁“锁上”</span>\n    ReactDefaultBatchingStrategy. isBatchingUpdates = <span class="hljs-function"><span class="hljs-keyword">true</span>\n\n    <span class="hljs-title">if</span> <span class="hljs-params">(alreadyBatchingStrategy)</span> </span>{\n      callback(a, b, c, d, e)\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 启动事务，将 callback 放进事务里执行</span>\n      transaction.perform(callback, <span class="hljs-keyword">null</span>, a, b, c, d, e)\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="914">batchingStrategy 对象并不复杂，你可以理解为它是一个“锁管理器”。</p>\n<p data-nodeid="915">这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p>\n<p data-nodeid="916">理解了批量更新整体的管理机制，还需要注意 batchedUpdates 中，有一个引人注目的调用：</p>\n<pre class="lang-java" data-nodeid="917"><code data-language="java">transaction.perform(callback, <span class="hljs-keyword">null</span>, a, b, c, d, e)\n</code></pre>\n<p data-nodeid="918">这行代码为我们引出了一个更为硬核的概念——React 中的 Transaction（事务）机制。</p>\n<h4 data-nodeid="919">理解 React 中的 Transaction（事务） 机制</h4>\n<p data-nodeid="920">Transaction 在 React 源码中的分布可以说非常广泛。如果你在 Debug React 项目的过程中，发现函数调用栈中出现了 initialize、perform、close、closeAll 或者 notifyAll 这样的方法名，那么很可能你当前就处于一个 Trasaction 中。</p>\n<p data-nodeid="921">Transaction 在 React 源码中表现为一个核心类，React 官方曾经这样描述它：<strong data-nodeid="1033">Transaction 是创建一个黑盒</strong>，该黑盒能够封装任何的方法。因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行），实例化 Transaction 时只需提供相关的方法即可。</p>\n<p data-nodeid="922">这段话初读有点拗口，这里我推荐你结合 React 源码中的一段针对 Transaction 的注释来理解它：</p>\n<pre class="lang-java" data-nodeid="923"><code data-language="java">* &lt;pre&gt;\n *                       wrappers (injected at creation time)\n *                                      +        +\n *                                      |        |\n *                    +-----------------|--------|--------------+\n *                    |                 v        |              |\n *                    |      +---------------+   |              |\n *                    |   +--|    wrapper1   |---|----+         |\n *                    |   |  +---------------+   v    |         |\n *                    |   |          +-------------+  |         |\n *                    |   |     +----|   wrapper2  |--------+   |\n *                    |   |     |    +-------------+  |     |   |\n *                    |   |     |                     |     |   |\n *                    |   v     v                     v     v   | wrapper\n *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\n * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\n * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | +---+ +---+   +---------+   +---+ +---+ |\n *                    |  initialize                    close    |\n *                    +-----------------------------------------+\n * &lt;/pre&gt;\n</code></pre>\n<p data-nodeid="924">说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，同时需要使用 Transaction 类暴露的 perform 方法去执行它。如上面的注释所示，在 anyMethod 执行之前，perform 会先执行所有 wrapper 的 initialize 方法，执行完后，再执行所有 wrapper 的 close 方法。这就是 React 中的事务机制。</p>\n<h4 data-nodeid="925">“同步现象”的本质</h4>\n<p data-nodeid="926">下面结合对事务机制的理解，我们继续来看在 ReactDefaultBatchingStrategy 这个对象。ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。</p>\n<pre class="lang-java" data-nodeid="927"><code data-language="java"><span class="hljs-keyword">var</span> RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function () {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="hljs-keyword">false</span>;\n  }\n};\n<span class="hljs-keyword">var</span> FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)\n};\n<span class="hljs-keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n</code></pre>\n<p data-nodeid="928">我们把这两个 wrapper 套进 Transaction 的执行机制里，不难得出一个这样的流程：</p>\n<p data-nodeid="929"><img src="https://s0.lgstatic.com/i/image/M00/6E/2E/Ciqc1F-x-tyAbioYAACikzik89A130.png" alt="图片5.png" data-nodeid="1049"></p>\n<p data-nodeid="6630" class="te-preview-highlight">到这里，相信你对 isBatchingUpdates 管控下的批量更新机制已经了然于胸。但是 setState 为何会表现同步这个问题，似乎还是没有从当前展示出来的源码里得到根本上的回答。这是因为 batchedUpdates 这个方法，不仅仅会在 setState 之后才被调用。若我们在 React 源码中全局搜索 batchedUpdates，会发现调用它的地方很多，但与更新流有关的只有这两个地方：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre class="lang-java" data-nodeid="931"><code data-language="java"><span class="hljs-comment">// ReactMount.js</span>\n_renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) {\n  <span class="hljs-comment">// 实例化组件</span>\n  <span class="hljs-keyword">var</span> componentInstance = instantiateReactComponent(nextElement);\n  <span class="hljs-comment">// 初始渲染直接调用 batchedUpdates 进行同步渲染</span>\n  ReactUpdates.batchedUpdates(\n    batchedMountComponentIntoNode,\n    componentInstance,\n    container,\n    shouldReuseMarkup,\n    context\n  );\n  ...\n}\n</code></pre>\n<p data-nodeid="932">这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次 batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用 setState。因此，我们需要通过开启 batch 来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始渲染流程中所有的 setState 都是生效的。</p>\n<p data-nodeid="933">下面代码是 React 事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。</p>\n<pre class="lang-java" data-nodeid="934"><code data-language="java"><span class="hljs-comment">// ReactEventListener.js</span>\ndispatchEvent: function (topLevelType, nativeEvent) {\n  ...\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 处理事件</span>\n    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n  } <span class="hljs-keyword">finally</span> {\n    TopLevelCallbackBookKeeping.release(bookKeeping);\n  }\n}\n</code></pre>\n<p data-nodeid="935">话说到这里，一切都变得明朗了起来：isBatchingUpdates 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 悄悄修改为了 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。</p>\n<p data-nodeid="936">以开头示例中的 increment 方法为例，整个过程像是这样：</p>\n<pre class="lang-java" data-nodeid="937"><code data-language="java">increment = () =&gt; {\n  <span class="hljs-comment">// 进来先锁上</span>\n  isBatchingUpdates = <span class="hljs-keyword">true</span>\n  console.log(<span class="hljs-string">\'increment setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  <span class="hljs-keyword">this</span>.setState({\n    count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>\n  });\n  console.log(<span class="hljs-string">\'increment setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  <span class="hljs-comment">// 执行完函数再放开</span>\n  isBatchingUpdates = <span class="hljs-keyword">false</span>\n}\n</code></pre>\n<p data-nodeid="938">很明显，在 isBatchingUpdates 的约束下，setState 只能是异步的。而当 setTimeout 从中作祟时，事情就会发生一点点变化：</p>\n<pre class="lang-java" data-nodeid="939"><code data-language="java">reduce = () =&gt; {\n  <span class="hljs-comment">// 进来先锁上</span>\n  isBatchingUpdates = <span class="hljs-function"><span class="hljs-keyword">true</span>\n  <span class="hljs-title">setTimeout</span><span class="hljs-params">(()</span> </span>=&gt; {\n    console.log(<span class="hljs-string">\'reduce setState前的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n    <span class="hljs-keyword">this</span>.setState({\n      count: <span class="hljs-keyword">this</span>.state.count - <span class="hljs-number">1</span>\n    });\n    console.log(<span class="hljs-string">\'reduce setState后的count\'</span>, <span class="hljs-keyword">this</span>.state.count)\n  },<span class="hljs-number">0</span>);\n  <span class="hljs-comment">// 执行完函数再放开</span>\n  isBatchingUpdates = <span class="hljs-keyword">false</span>\n}\n</code></pre>\n<p data-nodeid="940">会发现，咱们开头锁上的那个 isBatchingUpdates，对 setTimeout 内部的执行逻辑完全没有约束力。因为 isBatchingUpdates 是在同步代码中变化的，而 setTimeout 的逻辑是异步执行的。当 this.setState 调用真正发生的时候，isBatchingUpdates 早已经被重置为了 false，这就使得当前场景下的 setState 具备了立刻发起同步更新的能力。所以咱们前面说的没错——<strong data-nodeid="1061">setState 并不是具备同步这种特性，只是在特定的情境下，它会从 React 的异步管控中“逃脱”掉</strong>。</p>\n<h3 data-nodeid="941">总结</h3>\n<p data-nodeid="942">道理很简单，原理却很复杂。最后，我们再一次面对面回答一下标题提出的问题，对整个 setState 工作流做一个总结。</p>\n<p data-nodeid="943">setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同：在 React 钩子函数及合成事件中，它表现为异步；而在 setTimeout、setInterval 等函数中，包括在 DOM 原生事件中，它都表现为同步。这种差异，本质上是由 React 事务机制和批量更新机制的工作方式来决定的。</p>\n<p data-nodeid="944" class="">行文至此，相信你已经对 setState 有了知根知底的理解。我们整篇文章的讨论，目前都建立在 React 15 的基础上。React 16 以来，整个 React 核心算法被重写，setState 也不可避免地被“Fiber化”。那么到底什么是“Fiber”，它到底怎样改变着包括 setState 在内的 React 的各个核心技术模块，这就是我们下面两讲要重点讨论的问题了。</p>',
          },
          {
            theme: '12 | 如何理解 Fiber 架构的迭代动机与设计思想？',
            id: 213,
            content:
              '<p data-nodeid="2166" class="">在理解 Fiber 架构之前，我们先来看看 React &nbsp;团队在“<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html#gatsby-focus-wrapper" data-nodeid="2248">React 哲学</a>”中对 React 的定位：</p>\n<blockquote data-nodeid="2167">\n<p data-nodeid="2168">我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p>\n</blockquote>\n<p data-nodeid="2169">这段话里有 4 个字值得我们细细品味，那就是“<strong data-nodeid="2260">快速响应</strong>”，这 4 个字可以说是 React 团队在用户体验方面最为要紧的一个追求。关于这点，在 React 15 时代已经可见一斑：正是出于对“快速响应”的执着，React 才会想方设法把原本 O(n<sup>3</sup>) 的 Diff 时间复杂度优化到了前无古人的 O(n)。</p>\n<p data-nodeid="2170">然而，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 Stack Reconciler 也渐渐在体验方面显出疲态。为了更进一步贯彻“快速响应”的原则，React 团队“壮士断腕”，在 16.x 版本中将其最为核心的 Diff 算法整个重写，使其以“Fiber Reconciler”的全新面貌示人。</p>\n<p data-nodeid="2171">那么 Stack Reconciler 到底有着怎样根深蒂固的局限性，使得 React 不得不从架构层面做出改变？而 Fiber 架构又是何方神圣，基于它来实现的调和过程又有什么不同呢？本讲我们就围绕这两个大问题展开讨论。</p>\n<h3 data-nodeid="2172">前置知识：单线程的 JavaScript 与多线程的浏览器</h3>\n<p data-nodeid="2173">大家在入门前端的时候，想必都听说过这样一个结论：JavaScript 是单线程的，浏览器是多线程的。</p>\n<p data-nodeid="2174">对于多线程的浏览器来说，它除了要处理 JavaScript 线程以外，还需要处理包括事件系统、定时器/延时器、网络请求等各种各样的任务线程，这其中，自然也包括负责处理 DOM 的<strong data-nodeid="2274">UI 渲染</strong>线程。而 <strong data-nodeid="2275">JavaScript 线程是可以操作 DOM 的</strong>。</p>\n<p data-nodeid="2175">这意味着什么呢？试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。这就决定了<strong data-nodeid="2285">JavaScript 线程和渲染线程必须是互斥的</strong>：这两个线程不能够穿插执行，必须串行。<strong data-nodeid="2286">当其中一个线程执行时，另一个线程只能挂起等待</strong>。</p>\n<p data-nodeid="2176">具有相似特征的还有事件线程，浏览器的 Event-Loop 机制决定了事件任务是由一个异步队列来维持的。当事件被触发时，对应的任务不会立刻被执行，而是由事件线程把它添加到任务队列的末尾，<strong data-nodeid="2292">等待 JavaScript</strong> 的同步代码执行完毕后，在空闲的时间里执行出队。</p>\n<p data-nodeid="2177">在这样的机制下，若 JavaScript 线程长时间地占用了主线程，那么<strong data-nodeid="2302">渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”</strong>。一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，<strong data-nodeid="2303">事件线程也在等待 JavaScript，这就导致你触发的事件也将是难以被响应的</strong>。</p>\n<p data-nodeid="2178">试想一下界面不更新、交互无反应的这种感觉，是不是非常令人抓狂？这其实正是 Stack Reconciler 后期所面临的困局。</p>\n<h3 data-nodeid="2179">为什么会产生“卡顿”这样的困局？</h3>\n<p data-nodeid="2180">Stack Reconciler 所带来的一个无解的问题，正是<strong data-nodeid="2319">JavaScript 对主线程的超时占用问题</strong>。为什么会出现这个问题？这就对应上了我们“<strong data-nodeid="2320">第 10 讲</strong>”中所强调的一个关键知识点——<strong data-nodeid="2321">Stack Reconciler 是一个同步的递归过程</strong>。</p>\n<p data-nodeid="2181">同步的递归过程，意味着不撞南墙不回头，意味着一旦更新开始，就像吃了炫迈一样，根本停不下来。这里我用一个案例来帮你复习一下这个过程，请先看下面这张图：</p>\n<p data-nodeid="2182"><img src="https://s0.lgstatic.com/i/image/M00/6E/D8/CgqCHl-zlcmATw-hAAD1942js64663.png" alt="Drawing 1.png" data-nodeid="2325"></p>\n<p data-nodeid="2183">在 React 15 及之前的版本中，虚拟 DOM 树的数据结构载体是计算机科学中的“树”，其 Diff 算法的遍历思路，也是沿袭了传统计算机科学中“对比两棵树”的算法，在此基础上优化得来。因此从本质上来说，栈调和机制下的 Diff 算法，其实是<strong data-nodeid="2331">树的深度优先遍历的过程</strong>。而树的深度优先遍历，总是和递归脱不了关系。</p>\n<p data-nodeid="2441" class="te-preview-highlight">拿这棵树来举例，若 A 组件发生了更新，那么栈调和的工作过程是这样的：对比第 1 层的两个 A，确认节点可复用，继续 Diff 其子组件。当 Diff 到 B 的时候，对比前后的两个 B 节点，发现可复用，于是继续 Diff 其子节点 D、E。待 B 树最深层的 Diff 完成、逐层回溯后，再进入 C 节点的 Diff 逻辑......调和器会重复“父组件调用子组件”的过程，直到最深的一层节点更新完毕，才慢慢向上返回。</p>\n\n<p data-nodeid="2185"><strong data-nodeid="2346">这个过程的致命性在于它是同步的，不可以被打断</strong>。当处理结构相对复杂、体量相对庞大的虚拟 DOM 树时，<strong data-nodeid="2347">Stack Reconciler 需要的调和时间会很长，这就意味着 JavaScript 线程将长时间地霸占主线程，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题</strong>。</p>\n<h3 data-nodeid="2186">设计思想：Fiber 是如何解决问题的</h3>\n<p data-nodeid="2187">什么是 Fiber？从字面上来理解，Fiber 这个单词翻译过来是“丝、纤维”的意思，是比线还要细的东西。在计算机科学里，我们有进程、线程之分，而 <strong data-nodeid="2358">Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”</strong>。纤程的出现，<strong data-nodeid="2359">意在对渲染过程实现更加精细的控制</strong>。</p>\n<p data-nodeid="2188">Fiber 是一个多义词。从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写；从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM”；从工作流的角度来看，Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。</p>\n<p data-nodeid="2189">本讲我们将站在架构角度来理解 Fiber。</p>\n<p data-nodeid="2190">Fiber 架构的应用目的，按照 React 官方的说法，是实现“<strong data-nodeid="2371">增量渲染</strong>”。所谓“增量渲染”，通俗来说就是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里面。不过严格来说，增量渲染其实也只是一种手段，<strong data-nodeid="2372">实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验</strong>。</p>\n<h4 data-nodeid="2191">Fiber 架构核心：“可中断”“可恢复”与“优先级”</h4>\n<p data-nodeid="2192">在 React 16 之前，React 的渲染和更新阶段依赖的是如下图所示的两层架构：</p>\n<p data-nodeid="2193"><img src="https://s0.lgstatic.com/i/image/M00/6E/D8/CgqCHl-zleqAJoRjAAA9BnH9jdQ473.png" alt="Drawing 2.png" data-nodeid="2377"></p>\n<p data-nodeid="2194">正如上文所分析的那样，Reconciler 这一层负责对比出新老虚拟 DOM 之间的变化，Renderer 这一层负责将变化的部分应用到视图上，从 Reconciler 到 Renderer 这个过程是严格同步的。</p>\n<p data-nodeid="2195">而在 React 16 中，为了实现“可中断”和“优先级”，两层架构变成了如下图所示的三层架构：</p>\n<p data-nodeid="2196"><img src="https://s0.lgstatic.com/i/image/M00/6E/D8/CgqCHl-zlfaALmyYAABbITniefc225.png" alt="Drawing 3.png" data-nodeid="2382"></p>\n<p data-nodeid="2197">多出来的这层架构，叫作“Scheduler（调度器）”，调度器的作用是调度更新的优先级。</p>\n<p data-nodeid="2198">在这套架构模式下，更新的处理工作流变成了这样：首先，<strong data-nodeid="2397">每个更新任务都会被赋予一个优先级</strong>。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被<strong data-nodeid="2398">中断</strong>，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 <strong data-nodeid="2399">A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”</strong>。</p>\n<p data-nodeid="2199">以上，便是架构层面对“可中断”“可恢复”与“优先级”三个核心概念的处理。</p>\n<h4 data-nodeid="2200">Fiber 架构对生命周期的影响</h4>\n<p data-nodeid="2201">在基础篇我们曾经探讨过，React 16 的生命周期分为这样三个阶段，如下图所示：</p>\n<p data-nodeid="2202"><img src="https://s0.lgstatic.com/i/image/M00/6E/CC/Ciqc1F-zlgGAVlMRAAMB6-4eyN4900.png" alt="Drawing 5.png" data-nodeid="2405"></p>\n<ol data-nodeid="2203">\n<li data-nodeid="2204">\n<p data-nodeid="2205">render 阶段：纯净且没有副作用，可能会被 React 暂停、终止或重新启动。</p>\n</li>\n<li data-nodeid="2206">\n<p data-nodeid="2207">pre-commit 阶段：可以读取 DOM。</p>\n</li>\n<li data-nodeid="2208">\n<p data-nodeid="2209">commit 阶段：可以使用 DOM，运行副作用，安排更新。</p>\n</li>\n</ol>\n<p data-nodeid="2210">其中 pre-commit 和 commit 从大阶段上来看都属于 commit 阶段。</p>\n<p data-nodeid="2211">在 render 阶段，React 主要是在内存中做计算，明确 DOM 树的更新点；而 commit 阶段，则负责把 render 阶段生成的更新真正地执行掉。这两个阶段做的事情，非常适合和本讲刚刚讲过的 React 架构分层结合起来理解。</p>\n<p data-nodeid="2212">首先我们来看 React 15 中从 render 到 commit 的过程：</p>\n<p data-nodeid="2213"><img src="https://s0.lgstatic.com/i/image/M00/6E/CC/Ciqc1F-zlgqAYLTjAACBi-NvpYI353.png" alt="Drawing 6.png" data-nodeid="2414"></p>\n<p data-nodeid="2214">而在 React 16 中，render 到 commit 的过程变成了这样，如下图所示：</p>\n<p data-nodeid="2215"><img src="https://s0.lgstatic.com/i/image/M00/6E/CC/Ciqc1F-zlhKAMu6ZAACYDSGoCUY002.png" alt="Drawing 7.png" data-nodeid="2418"></p>\n<p data-nodeid="2216">可以看出，新老两种架构对 React 生命周期的影响主要在 render 这个阶段，这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的。</p>\n<p data-nodeid="2217">在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知。但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：</p>\n<ul data-nodeid="2218">\n<li data-nodeid="2219">\n<p data-nodeid="2220">componentWillMount</p>\n</li>\n<li data-nodeid="2221">\n<p data-nodeid="2222">componentWillUpdate</p>\n</li>\n<li data-nodeid="2223">\n<p data-nodeid="2224">shouldComponentUpdate</p>\n</li>\n<li data-nodeid="2225">\n<p data-nodeid="2226">componentWillReceiveProps</p>\n</li>\n</ul>\n<p data-nodeid="2227">其中 shouldComponentUpdate 的作用是通过返回 true 或者 false，来帮助我们判断更新的必要性，一般在这个函数中不会进行副作用操作，因此风险不大。</p>\n<p data-nodeid="2228">而 “componentWill” 开头的三个生命周期，则常年被开发者以各种各样的姿势滥用，是副作用的“重灾区”。关于这点，我在第 03 讲“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=510#/detail/pc?id=4852" data-nodeid="2429">为什么 React 16 要更改组件的生命周期？（下）</a> ”中已经有过非常细致的讲解，此处不再赘述。你在这里需要做的，是把 React 架构分层的变化与生命周期的变化建立联系，从而对两者的设计动机都形成更加深刻的理解。</p>\n<h3 data-nodeid="2229">总结</h3>\n<p data-nodeid="2230" class="">通过本讲的学习，你已经知道了 React 16 中 Fiber 架构的架构分层和宏观视角下的工作流。但这一切，都还只是我们学习 Fiber Reconciler 的一个起点。Fiber Reconciler 目前对于你来说仍然是一个黑盒，关于它，还有太多的谜题需要我们一一去探索，这些谜题包括但不限于：</p>\n<ul data-nodeid="2231">\n<li data-nodeid="2232">\n<p data-nodeid="2233">React 16 在所有情况下都是异步渲染的吗？</p>\n</li>\n<li data-nodeid="2234">\n<p data-nodeid="2235">Fiber 架构中的“可中断”“可恢复”到底是如何实现的？</p>\n</li>\n<li data-nodeid="2236">\n<p data-nodeid="2237">Fiber 树和传统虚拟 DOM 树有何不同？</p>\n</li>\n<li data-nodeid="2238">\n<p data-nodeid="2239">优先级调度又是如何实现的？</p>\n</li>\n<li data-nodeid="2240">\n<p data-nodeid="2241">......</p>\n</li>\n</ul>\n<p data-nodeid="2242">所有这些问题的答案，我们都需要从 Fiber 架构下的 React 源码中去寻找。</p>\n<p data-nodeid="2243">下一讲我们就将以 ReactDOM.render 串联起的渲染链路作为引子，切入对 Fiber 相关源码的探讨。</p>\n<p data-nodeid="2244" class="">ReactDOM.render 之后到底发生了什么？this.setState 之后又发生了什么？我想，当你对这两个问题形成概念之后，上面罗列出的所有小问题都将迎刃而解。</p>',
          },
          {
            theme: '13 | ReactDOM.render 是如何串联渲染链路的？（上）',
            id: 214,
            content:
              '<p data-nodeid="1277" class="">由于 ReactDOM.render 的内容比较多，所以这里拆分了上中下三讲来讲解。</p>\n<p data-nodeid="1278">在上一讲，我们站在宏观角度对 Fiber 的架构分层和迭代动机有了充分的把握。从本讲开始，我们将以首次渲染为切入点，拆解 Fiber 架构下 ReactDOM.render 所触发的渲染链路，结合源码理解整个链路中所涉及的初始化、render 和 commit 等过程。</p>\n<h3 data-nodeid="1279">ReactDOM.render 调用栈的逻辑分层</h3>\n<p data-nodeid="1280">开篇先给到你一个简单的 React AppDemo：</p>\n<pre class="lang-java" data-nodeid="1281"><code data-language="java">import React from "react";\nimport ReactDOM from "react-dom";\n\nfunction App() {\n    return (\n      &lt;div className="App"&gt;\n        &lt;div className="container"&gt;\n          &lt;h1&gt;我是标题&lt;/h1&gt;\n          &lt;p&gt;我是第一段话&lt;/p&gt;\n          &lt;p&gt;我是第二段话&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n}\n\nconst rootElement = document.getElementById("root");\nReactDOM.render(&lt;App /&gt;, rootElement);\n</code></pre>\n<p data-nodeid="1282">Demo 启动后，渲染出的界面如下图所示：</p>\n<p data-nodeid="1283"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmEOAGbJ5AAAxGM0SPWA261.png" alt="Drawing 0.png" data-nodeid="1379"></p>\n<p data-nodeid="1284">现在请你打开 Chrome 的 Performance 面板，点击下图红色圈圈所圈住的这个“记录”按钮：</p>\n<p data-nodeid="1285"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmEuALVycAAEENjoXJ6E407.png" alt="Drawing 1.png" data-nodeid="1383"></p>\n<p data-nodeid="1286">然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图：</p>\n<p data-nodeid="1287"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmFKAFeHBAAQn6ZuFPrI619.png" alt="Drawing 2.png" data-nodeid="1387"></p>\n<p data-nodeid="1288">放大该图，定位“src/index.js”这个文件路径，我们就可以找到 ReactDOM.render 方法对应的调用栈，如下图所示：</p>\n<p data-nodeid="1289"><img src="https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmFmAXkYlAAI2ONTKc9s081.png" alt="Drawing 3.png" data-nodeid="1391"></p>\n<p data-nodeid="1290">从图中你可以看到，ReactDOM.render 方法对应的调用栈非常深，中间涉及的函数量也比较大。如果这张图使你心里发虚，请先不要急于撤退——分析调用栈只是我们理解渲染链路的一个手段，我们的目的是借此提取关键逻辑，而非理解调用栈中的每一个方法。就这张图来说，你首先需要把握的，就是整个调用链路中所包含的三个阶段：</p>\n<p data-nodeid="1291"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmGKAFb5NAAItD2ouVoc061.png" alt="Drawing 4.png" data-nodeid="1395"></p>\n<p data-nodeid="1292">图中 scheduleUpdateOnFiber 方法的作用是调度更新，在由 ReactDOM.render 发起的首屏渲染这个场景下，它触发的就是 performSyncWorkOnRoot。performSyncWorkOnRoot 开启的正是我们反复强调的 <strong data-nodeid="1405">render 阶段</strong>；而 commitRoot 方法开启的则是真实 DOM 的渲染过程（<strong data-nodeid="1406">commit 阶段</strong>）。因此以scheduleUpdateOnFiber 和 commitRoot 两个方法为界，我们可以大致把 ReactDOM.render 的调用栈划分为三个阶段：</p>\n<ol data-nodeid="1293">\n<li data-nodeid="1294">\n<p data-nodeid="1295">初始化阶段</p>\n</li>\n<li data-nodeid="1296">\n<p data-nodeid="1297">render 阶段</p>\n</li>\n<li data-nodeid="1298">\n<p data-nodeid="1299">commit 阶段</p>\n</li>\n</ol>\n<p data-nodeid="1300">接下来，我们就一起来看看这三个阶段分别做了哪些事情。</p>\n<blockquote data-nodeid="1301">\n<p data-nodeid="1302">注：渲染链路串讲已被拆分为 3 个课时，本课时讲解的是初始化阶段。</p>\n</blockquote>\n<h3 data-nodeid="1303">拆解 ReactDOM.render 调用栈——初始化阶段</h3>\n<p data-nodeid="1304">首先我们提取出初始化过程中涉及的调用栈大图：</p>\n<p data-nodeid="1305"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmGqAU-42AABcbqaOzFc800.png" alt="Drawing 5.png" data-nodeid="1416"></p>\n<p data-nodeid="1306">图中的方法虽然看上去又多又杂，但做的事情清清爽爽，那就是<strong data-nodeid="1422">完成 Fiber 树中基本实体的创建</strong>。</p>\n<p data-nodeid="1307">什么是基本实体？基本实体有哪些？问题的答案藏在源码里，这里我为你提取了源码中的关键逻辑，首先是 legacyRenderSubtreeIntoContainer 方法。在 ReactDOM.render 函数体中，以下面代码所示的姿势调用了它：</p>\n<pre class="lang-java" data-nodeid="1308"><code data-language="java"><span class="hljs-keyword">return</span> legacyRenderSubtreeIntoContainer(<span class="hljs-keyword">null</span>, element, container, <span class="hljs-keyword">false</span>, callback);\n</code></pre>\n<p data-nodeid="1309">而 legacyRenderSubtreeIntoContainer 的关键逻辑如下（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="1310"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">legacyRenderSubtreeIntoContainer</span><span class="hljs-params">(parentComponent, children, container, forceHydrate, callback)</span> </span>{\n  <span class="hljs-comment">// container 对应的是我们传入的真实 DOM 对象</span>\n  <span class="hljs-keyword">var</span> root = container._reactRootContainer;\n  <span class="hljs-comment">// 初始化 fiberRoot 对象</span>\n  <span class="hljs-keyword">var</span> fiberRoot;\n  <span class="hljs-comment">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span>\n  <span class="hljs-keyword">if</span> (!root) {\n    <span class="hljs-comment">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span>\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    <span class="hljs-comment">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span>\n    fiberRoot = root._internalRoot;\n\n    <span class="hljs-comment">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span>\n    <span class="hljs-keyword">if</span> (typeof callback === <span class="hljs-string">\'function\'</span>) {\n      <span class="hljs-keyword">var</span> originalCallback = callback;\n      callback = function () {\n        <span class="hljs-keyword">var</span> instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    } <span class="hljs-comment">// Initial mount should not be batched.</span>\n    <span class="hljs-comment">// 进入 unbatchedUpdates 方法</span>\n    unbatchedUpdates(function () {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span>\n    fiberRoot = root._internalRoot;\n    <span class="hljs-keyword">if</span> (typeof callback === <span class="hljs-string">\'function\'</span>) {\n      <span class="hljs-keyword">var</span> _originalCallback = callback;\n      callback = function () {\n        <span class="hljs-keyword">var</span> instance = getPublicRootInstance(fiberRoot);\n        _originalCallback.call(instance);\n      };\n    } <span class="hljs-comment">// Update</span>\n\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  <span class="hljs-keyword">return</span> getPublicRootInstance(fiberRoot);\n}\n</code></pre>\n<p data-nodeid="1311">这里我为你总结一下首次渲染过程中 legacyRenderSubtreeIntoContainer 方法的主要逻辑链路：</p>\n<p data-nodeid="1312"><img src="https://s0.lgstatic.com/i/image/M00/70/03/CgqCHl-3mfWABLi5AADUzMV7iHA320.png" alt="Lark20201120-182606.png" data-nodeid="1428"></p>\n<p data-nodeid="1313">在这个流程中，你需要关注到 fiberRoot 这个对象。fiberRoot 到底是什么呢？这里我将运行时的 root 和 fiberRoot 为你截取出来，其中 root 对象的结构如下图所示：</p>\n<p data-nodeid="1314"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmH6AKzPPAADcEbfK6K4199.png" alt="Drawing 6.png" data-nodeid="1432"></p>\n<p data-nodeid="1315">可以看出，root 对象（container._reactRootContainer）上有一个 _internalRoot 属性，这个 _internalRoot 也就是 fiberRoot。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容：</p>\n<p data-nodeid="1316"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmISANlmfAADLqX8jue0154.png" alt="Drawing 7.png" data-nodeid="1442"></p>\n<p data-nodeid="1317">或许你会对 current 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“current 对象是一个 FiberNode 实例”这一点，<strong data-nodeid="1452">而 FiberNode，正是 Fiber 节点对应的对象类型</strong>。current 对象是一个 Fiber 节点，不仅如此，它还是<strong data-nodeid="1453">当前 Fiber 树的头部节点</strong>。</p>\n<p data-nodeid="1318">考虑到 current 属性对应的 FiberNode 节点，在调用栈中实际是由 createHostRootFiber 方法创建的，React 源码中也有多处以 rootFiber 代指 current 对象，因此下文中我们将以 rootFiber 指代 current 对象。</p>\n<p data-nodeid="1319">读到这里，你脑海中应该不难形成一个这样的指向关系：</p>\n<p data-nodeid="1320"><img src="https://s0.lgstatic.com/i/image/M00/6F/F8/Ciqc1F-3mh-AZrlvAABgy8S1u44402.png" alt="Lark20201120-182610.png" data-nodeid="1458"></p>\n<p data-nodeid="1321">其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而 rootFiber 则作为虚拟 DOM 的根节点存在。<strong data-nodeid="1464">这两个节点，将是后续整棵 Fiber 树构建的起点</strong>。</p>\n<p data-nodeid="1322">接下来，fiberRoot 将和 ReactDOM.render 方法的其他入参一起，被传入 updateContainer 方法，从而形成一个回调。这个回调，正是接下来要调用的 unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates 做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：</p>\n<pre class="lang-java" data-nodeid="1323"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">unbatchedUpdates</span><span class="hljs-params">(fn, a)</span> </span>{\n  <span class="hljs-comment">// 这里是对上下文的处理，不必纠结</span>\n  <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;\n  executionContext &amp;= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span>\n    <span class="hljs-keyword">return</span> fn(a);\n  } <span class="hljs-keyword">finally</span> {\n    <span class="hljs-comment">// finally 逻辑里是对回调队列的处理，此处不用太关注</span>\n    executionContext = prevExecutionContext;\n    <span class="hljs-keyword">if</span> (executionContext === NoContext) {\n      <span class="hljs-comment">// Flush the immediate callbacks that were scheduled during this batch</span>\n      resetRenderTimer();\n      flushSyncCallbackQueue();\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="1324">在 unbatchedUpdates 函数体里，当下你只需要 Get 到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn 是什么呢？<strong data-nodeid="1471">fn 是一个针对 updateContainer 的调用</strong>：</p>\n<pre class="lang-java" data-nodeid="1325"><code data-language="java">unbatchedUpdates(function () {\n  updateContainer(children, fiberRoot, parentComponent, callback);\n});\n</code></pre>\n<p data-nodeid="1326">接下来我们很有必要去看看 updateContainer 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：</p>\n<pre class="lang-java" data-nodeid="1327"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">updateContainer</span><span class="hljs-params">(element, container, parentComponent, callback)</span> </span>{\n  ......\n\n  <span class="hljs-comment">// 这是一个 event 相关的入参，此处不必关注</span>\n  <span class="hljs-keyword">var</span> eventTime = requestEventTime();\n\n  ......\n\n  <span class="hljs-comment">// 这是一个比较关键的入参，lane 表示优先级</span>\n  <span class="hljs-keyword">var</span> lane = requestUpdateLane(current$<span class="hljs-number">1</span>);\n  <span class="hljs-comment">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span>\n  <span class="hljs-keyword">var</span> update = createUpdate(eventTime, lane); \n\n  <span class="hljs-comment">// update 的 payload 对应的是一个 React 元素</span>\n  update.payload = {\n    element: element\n  };\n\n  <span class="hljs-comment">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span>\n  callback = callback === undefined ? <span class="hljs-keyword">null</span> : callback;\n  <span class="hljs-keyword">if</span> (callback !== <span class="hljs-keyword">null</span>) {\n    {\n      <span class="hljs-keyword">if</span> (typeof callback !== <span class="hljs-string">\'function\'</span>) {\n        error(<span class="hljs-string">\'render(...): Expected the last optional `callback` argument to be a \'</span> + <span class="hljs-string">\'function. Instead received: %s.\'</span>, callback);\n      }\n    }\n    update.callback = callback;\n  }\n\n  <span class="hljs-comment">// 将 update 入队</span>\n  enqueueUpdate(current$<span class="hljs-number">1</span>, update);\n  <span class="hljs-comment">// 调度 fiberRoot </span>\n  scheduleUpdateOnFiber(current$<span class="hljs-number">1</span>, lane, eventTime);\n  <span class="hljs-comment">// 返回当前节点（fiberRoot）的优先级</span>\n  <span class="hljs-keyword">return</span> lane;\n}\n</code></pre>\n<p data-nodeid="1328">updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p>\n<ol data-nodeid="1329">\n<li data-nodeid="1330">\n<p data-nodeid="1331">请求当前 Fiber 节点的 lane（优先级）；</p>\n</li>\n<li data-nodeid="1332">\n<p data-nodeid="1333">结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</p>\n</li>\n<li data-nodeid="1334">\n<p data-nodeid="1335">调度当前节点（rootFiber）。</p>\n</li>\n</ol>\n<p data-nodeid="1336">函数体中的 scheduleWork 其实就是 scheduleUpdateOnFiber，scheduleUpdateOnFiber 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是<strong data-nodeid="1482">在 ReactDOM.render 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的</strong>。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：</p>\n<p data-nodeid="1337"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmJGATpFIAAPP-sFYf70749.png" alt="Drawing 8.png" data-nodeid="1485"></p>\n<p data-nodeid="1338">performSyncWorkOnRoot直译过来就是“执行根节点的同步任务”，<strong data-nodeid="1491">这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程</strong>。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。</p>\n<p data-nodeid="1339">前面我们曾经提到过，performSyncWorkOnRoot 是 render 阶段的起点，render 阶段的任务就是完成 Fiber 树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render 阶段应该是一个可打断的异步过程（下一讲我们就将针对 render 过程作详细的逻辑拆解）。</p>\n<p data-nodeid="1340">而现在，我相信你心里更多的疑惑在于：<strong data-nodeid="1498">都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢</strong>？</p>\n<h3 data-nodeid="1341">同步的 ReactDOM.render，异步的 ReactDOM.createRoot</h3>\n<p data-nodeid="1342">其实在 React 16，包括近期发布的 React 17 小版本中，React 都有以下 3 种启动方式：</p>\n<p data-nodeid="1343"><strong data-nodeid="1516">legacy 模式</strong>：<br>\n<code data-backticks="1" data-nodeid="1506">ReactDOM.render(&lt;App /&gt;, rootNode)</code>。这是当前 React App 使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。<br>\n<strong data-nodeid="1517">blocking 模式</strong>：<br>\n<code data-backticks="1" data-nodeid="1514">ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code>。目前正在实验中，作为迁移到 concurrent 模式的第一个步骤。</p>\n<p data-nodeid="1344"><strong data-nodeid="1525">concurrent 模式</strong>：<br>\n<code data-backticks="1" data-nodeid="1523">ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式，这个模式开启了所有的新功能。</p>\n<p data-nodeid="1345">在这 3 种模式中，<strong data-nodeid="1535">我们常用的 ReactDOM.render 对应的是 legacy 模式，它实际触发的仍然是同步的渲染链路</strong>。blocking 模式可以理解为 legacy 和 concurrent 之间的一个过渡形态，之所以会有这个模式，是因为 React 官方希望能够提供<a href="https://zh-hans.reactjs.org/docs/faq-versioning.html#commitment-to-stability" data-nodeid="1533">渐进的迁移策略</a>，帮助我们更加顺滑地过渡到 Concurrent 模式。blocking 在实际应用中是比较低频的一个模式，了解即可。</p>\n<p data-nodeid="1346">按照官方的说法，“<strong data-nodeid="1541">长远来看，模式的数量会收敛，不用考虑不同的模式</strong>，但就目前而言，模式是一项重要的迁移策略，让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移”。由此可以看出，Concurrent 模式确实是 React 的终极目标，也是其创作团队使用 Fiber 架构重写核心算法的动机所在。</p>\n<h3 data-nodeid="1347">拓展：关于异步模式下的首次渲染链路</h3>\n<p data-nodeid="1348">当下，如果想要开启异步渲染，我们需要调用 <code data-backticks="1" data-nodeid="1544">ReactDOM.createRoot</code>方法来启动应用，那<code data-backticks="1" data-nodeid="1546">ReactDOM.createRoot</code>开启的渲染链路与 ReactDOM.render 有何不同呢？</p>\n<p data-nodeid="1349">这里我修改一下调用方式，给你展示一下调用栈。由于本讲的源码取材于 React 17.0.0 版本，在这个版本中，createRoot 仍然是一个 unstable 的方法。因此实际调用的 API 应该是“unstable_createRoot”：</p>\n<pre class="lang-java" data-nodeid="1350"><code data-language="java">ReactDOM.unstable_createRoot(rootElement).render(&lt;App /&gt;);\n</code></pre>\n<p data-nodeid="1351">Concurrent 模式开启后，首次渲染的调用栈变成了如下图所示的样子：</p>\n<p data-nodeid="1352"><img src="https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmJyAbYZNAAFI67qKm98019.png" alt="Drawing 9.png" data-nodeid="1554"></p>\n<p data-nodeid="1353">乍一看，好像和 ReactDOM.render 差别很大，其实不然。图中 createRoot 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示：</p>\n<p data-nodeid="1354"><img src="https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmKKAF0ODAADhhdYWzo0441.png" alt="Drawing 10.png" data-nodeid="1558"></p>\n<p data-nodeid="1355">我们拉近一点来看，如下图所示：</p>\n<p data-nodeid="1356"><img src="https://s0.lgstatic.com/i/image/M00/70/75/CgqCHl-7GiaAUY_zAAxz8mfEvT0309.png" alt="图片1.png" data-nodeid="1562"><br>\n你会发现这地方也调用了一个 render。再顺着这个调用往下看，发现有大量的熟悉面孔：updateContainer、requestUpdateLane、createUpdate、scheduleUpdateOnFiber......这些函数在 ReactDOM.render 的调用栈中也出现过。</p>\n<p data-nodeid="1357">其实，当前你看到的这个 render 调用链路，和 ReactDOM.render 的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber 的这个判断里：</p>\n<p data-nodeid="1358"><img src="https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmMKAJFKYAAMfoIVWxeM650.png" alt="image.png" data-nodeid="1568"></p>\n<p data-nodeid="1359">在异步渲染模式下，由于请求到的 lane 不再是 SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot 这个调用，而是会转而执行 else 中调度相关的逻辑。</p>\n<p data-nodeid="1360">这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 requestUpdateLane 函数为例，下面是它局部的代码：</p>\n<pre class="lang-java" data-nodeid="1361"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">requestUpdateLane</span><span class="hljs-params">(fiber)</span> </span>{\n  <span class="hljs-comment">// 获取 mode 属性</span>\n  <span class="hljs-keyword">var</span> mode = fiber.mode;\n  <span class="hljs-comment">// 结合 mode 属性判断当前的</span>\n  <span class="hljs-keyword">if</span> ((mode &amp; BlockingMode) === NoMode) {\n    <span class="hljs-keyword">return</span> SyncLane;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) {\n    <span class="hljs-keyword">return</span> getCurrentPriorityLevel() === ImmediatePriority$<span class="hljs-number">1</span> ? SyncLane : SyncBatchedLane;\n  }\n  ......\n  <span class="hljs-keyword">return</span> lane;\n}\n</code></pre>\n<p data-nodeid="1362">上面代码中需要注意 fiber节点上的 mode 属性：<strong data-nodeid="1576">React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式</strong>。</p>\n<p data-nodeid="1363">因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。</p>\n<p data-nodeid="1364">关于异步挂载/更新的实现细节，我们将在后续的第 16 讲“Fiber 架构实现原理与编码形态”中详细探讨。</p>\n<h3 data-nodeid="1365">Fiber 架构一定是异步渲染吗？</h3>\n<p data-nodeid="1366">之前我曾经被读者朋友问到过这样的问题：<strong data-nodeid="1585">React 16 如果没有开启 Concurrent 模式，那它还能叫 Fiber 架构吗</strong>？</p>\n<p data-nodeid="1367">这个问题很有意思，从动机上来看，Fiber 架构的设计确实主要是为了 Concurrent 而存在。但经过了本讲紧贴源码的讲解，相信你也能够看出，在 React 16，包括已发布的 React 17 版本中，不管是否是 Concurrent，整个数据结构层面的设计、包括贯穿整个渲染链路的处理逻辑，已经完全用 Fiber 重构了一遍。站在这个角度来看，Fiber 架构在 React 中并不能够和异步渲染画严格的等号，它是一种<strong data-nodeid="1591">同时兼容了同步渲染与异步渲染的设计</strong>。</p>\n<h3 data-nodeid="1368">总结</h3>\n<p data-nodeid="1369">从本讲开始，我们以 ReactDOM.render 所触发的首次渲染为切入点，试图串联 React Fiber 架构下完整的工作链路，本讲为整个源码链路分析的前半部分。</p>\n<p data-nodeid="1370">正所谓“磨刀不误砍柴工”。虽然当前的进度条只推到了初始化这个位置，但在这部分的分析过程中，相信你已经对Fiber 树的初始形态、Fiber 根节点的创建过程建立了感性的认知，同时把握住了 ReactDOM.render 同步渲染的过程特征，理解了 React 当下共存的3种渲染方式。在此基础上，我们再去理解 render 过程，就会轻松得多。</p>\n<p data-nodeid="1371" class="te-preview-highlight">整个初始化的工作过程都是在为后续的 render 阶段做准备。现在，我们的 Fiber Tree 还处在只有根节点的起始状态。接下来，我们就要进入到最最关键的 render 阶段里去，一起去看看这棵树是怎么一点点丰满起来的，加油！</p>',
          },
          {
            theme: '14 | ReactDOM.render 是如何串联渲染链路的？（中）',
            id: 215,
            content:
              '<p data-nodeid="2389" class="">上一讲我们对 ReactDOM.render 的调用链路、包括其对应的初始化阶段的工作内容都有了学习和掌握。这一讲我们在此基础上，学习后续的 render 阶段和 commit 阶段。这其中，render 阶段可以认为是整个渲染链路中最为核心的一环，因为我们反复强调“找不同”的过程，恰恰就是在这个阶段发生的。</p>\n<p data-nodeid="2390">render 阶段做的事情有很多，这一讲我们将以 beginWork 为线索，着重探讨 Fiber 树的构建过程。</p>\n<h3 data-nodeid="2391">拆解 ReactDOM.render 调用栈——render 阶段</h3>\n<p data-nodeid="2392">首先，我们复习一下 render 阶段在整个渲染链路中的定位，如下图所示。</p>\n<p data-nodeid="2393"><img src="https://s0.lgstatic.com/i/image/M00/71/0B/CgqCHl-8xCmAcvVyAADtTCzN0RM929.png" alt="Drawing 0.png" data-nodeid="2561"></p>\n<p data-nodeid="2394">图中，performSyncWorkOnRoot 标志着 render 阶段的开始，finishSyncRender 标志着 render 阶段的结束。这中间包含了大量的 beginWork、completeWork 调用栈，正是 render 的工作内容。</p>\n<blockquote data-nodeid="2395">\n<p data-nodeid="2396">beginWork、completeWork 这两个方法需要注意，它们串联起的是一个“模拟递归”的过程。</p>\n</blockquote>\n<p data-nodeid="2397">在第 10 讲“栈调和”中强调过，React 15 下的调和过程<strong data-nodeid="2577">是一个递归的过程</strong>。而 Fiber 架构下的调和过程，虽然并不是依赖递归来实现的，<strong data-nodeid="2578">但在 ReactDOM.render 触发的同步模式下，它仍然是一个深度优先搜索的过程</strong>。在这个过程中，<strong data-nodeid="2579">beginWork 将创建新的 Fiber 节点，而 completeWork 则负责将 Fiber 节点映射为 DOM 节点</strong>。</p>\n<p data-nodeid="2398">那么问题就来了：截止到上一讲，我们的 Fiber 树都还长这个样子：</p>\n<p data-nodeid="2399"><img src="https://s0.lgstatic.com/i/image/M00/71/0A/CgqCHl-8w7qAc91bAABOxKDmLgA173.png" alt="Drawing 1.png" data-nodeid="2583"></p>\n<p data-nodeid="2400">就这么个样子，你遍历它，能遍历出来什么？到底怎么个遍历法？接下来我们就深入到源码里去一探究竟！</p>\n<h3 data-nodeid="2401">workInProgress 节点的创建</h3>\n<p data-nodeid="2402">上一讲曾经提到，performSyncWorkOnRoot &nbsp;是 render 阶段的起点，而这个函数最关键的地方在于它调用了 renderRootSync。下面我们放大 Performance 调用栈，来看看 renderRootSync 被调用后，紧接着发生了什么：</p>\n<p data-nodeid="2403"><img src="https://s0.lgstatic.com/i/image/M00/70/FF/Ciqc1F-8xByAOzCeAAAoruuugdE734.png" alt="Drawing 2.png" data-nodeid="2589"></p>\n<p data-nodeid="2404">紧随其后的是 prepareFreshStack，这里不卖关子，prepareFreshStack 的作用是重置一个新的堆栈环境，其中最需要我们关注的步骤，就是对<strong data-nodeid="2595">createWorkInProgress</strong> 的调用。以下我对 createWorkInProgress 的主要逻辑进行了提取（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="2405"><code data-language="java"><span class="hljs-comment">// 这里入参中的 current 传入的是现有树结构中的 rootFiber 对象</span>\n<span class="hljs-function">function <span class="hljs-title">createWorkInProgress</span><span class="hljs-params">(current, pendingProps)</span> </span>{\n  <span class="hljs-keyword">var</span> workInProgress = current.alternate;\n  <span class="hljs-comment">// ReactDOM.render 触发的首屏渲染将进入这个逻辑</span>\n  <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 这是需要你关注的第一个点，workInProgress 是 createFiber 方法的返回值</span>\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n    <span class="hljs-comment">// 这是需要你关注的第二个点，workInProgress 的 alternate 将指向 current</span>\n    workInProgress.alternate = current;\n    <span class="hljs-comment">// 这是需要你关注的第三个点，current 的 alternate 将反过来指向 workInProgress</span>\n    current.alternate = workInProgress;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// else 的逻辑此处先不用关注</span>\n  }\n\n  <span class="hljs-comment">// 以下省略大量 workInProgress 对象的属性处理逻辑</span>\n  <span class="hljs-comment">// 返回 workInProgress 节点</span>\n  <span class="hljs-keyword">return</span> workInProgress;\n}\n</code></pre>\n<p data-nodeid="2406">首先要声明的是，该函数中的 current 入参指的是现有树结构中的 rootFiber 对象，如下图所示：</p>\n<p data-nodeid="2407"><img src="https://s0.lgstatic.com/i/image/M00/70/FF/Ciqc1F-8xDeAR3RMAAClHPw_BEk265.png" alt="Drawing 3.png" data-nodeid="2599"></p>\n<p data-nodeid="2408">源码太长（其实经过处理已经不长了）不看版的重点如下：</p>\n<ul data-nodeid="2409">\n<li data-nodeid="2410">\n<p data-nodeid="2411">createWorkInProgress 将<strong data-nodeid="2610">调用 createFiber</strong>，workInProgress<strong data-nodeid="2611">是 createFiber 方法的返回值</strong>；</p>\n</li>\n<li data-nodeid="2412">\n<p data-nodeid="2413">workInProgress 的 <strong data-nodeid="2617">alternate 将指向 current</strong>；</p>\n</li>\n<li data-nodeid="2414">\n<p data-nodeid="2415"><strong data-nodeid="2622">current 的 alternate 将反过来指向 workInProgress</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="2416">理解了这三点，你就会自然而然地想知道 workInProgress 的本体到底是什么样的，也就是<strong data-nodeid="2628">createFiber 到底会返回什么</strong>。下面我们就看看 createFiber 的逻辑：</p>\n<pre class="lang-java" data-nodeid="2417"><code data-language="java"><span class="hljs-keyword">var</span> createFiber = function (tag, pendingProps, key, mode) {\n\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FiberNode(tag, pendingProps, key, mode);\n};\n</code></pre>\n<p data-nodeid="2418"><strong data-nodeid="2637">代码出奇的简单，但信息却给得很到位 —— createFiber 将创建一个 FiberNode 实例</strong>，而 FiberNode，上一讲已经讲过，它正是 Fiber 节点的类型。<strong data-nodeid="2638">因此 workInProgress 就是一个 Fiber 节点</strong>。不仅如此，细心的你可能还会发现 workInProgress 的创建入参其实来源于 current，如下面代码所示：</p>\n<pre class="lang-java" data-nodeid="2419"><code data-language="java"> workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n</code></pre>\n<p data-nodeid="2420"><strong data-nodeid="2643">实锤了，workInProgress 节点其实就是 current 节点（即 rootFiber）的副本</strong>。</p>\n<p data-nodeid="2421">再结合 &nbsp;current 指向 rootFiber 对象（同样是 FiberNode 实例），以及 current 和 workInProgress 通过 alternate 互相连接这些信息，我们可以分析出这波操作执行完之后，整棵树的结构应该如下图所示：</p>\n<p data-nodeid="2422"><img src="https://s0.lgstatic.com/i/image/M00/71/49/CgqCHl-91EqAJlftAAB6KmeoTMw529.png" alt="1.png" data-nodeid="2647"></p>\n<p data-nodeid="2423">完成了这个任务之后，就会进入 workLoopSync 的逻辑。这个 workLoopSync 函数也是个“人狠话不多”的主，它的逻辑同样是简洁明了的，如下所示（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="2424"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">workLoopSync</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 若 workInProgress 不为空</span>\n  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 针对它执行 performUnitOfWork 方法</span>\n    performUnitOfWork(workInProgress);\n  }\n}\n</code></pre>\n<p data-nodeid="2425">workLoopSync 做的事情就是<strong data-nodeid="2654">通过 while 循环反复判断 workInProgress 是否为空，并在不为空的情况下针对它执行 performUnitOfWork 函数</strong>。</p>\n<p data-nodeid="2426">而 performUnitOfWork 函数将<strong data-nodeid="2664">触发对 beginWork 的调用，进而实现对新 Fiber 节点的创建</strong>。若 beginWork 所创建的 Fiber 节点不为空，则 performUniOfWork 会用这个新的 Fiber 节点来更新 workInProgress 的值，<strong data-nodeid="2665">为下一次循环做准备</strong>。</p>\n<p data-nodeid="2427"><strong data-nodeid="2670">通过循环调用 performUnitOfWork 来触发 beginWork，新的 Fiber 节点就会被不断地创建</strong>。当 workInProgress 终于为空时，说明没有新的节点可以创建了，也就意味着已经完成对整棵 Fiber 树的构建。</p>\n<p data-nodeid="2428">在这个过程中，<strong data-nodeid="2680">每一个被创建出来的新 Fiber 节点，都会一个一个挂载为最初那个 workInProgress 节点（如下图高亮处）的后代节点</strong>。而上述过程中构建出的这棵 Fiber 树，也正是大名鼎鼎的 <strong data-nodeid="2681">workInProgress 树</strong>。</p>\n<p data-nodeid="2429"><img src="https://s0.lgstatic.com/i/image/M00/71/49/CgqCHl-91HeADxF2AACYnkvx4lM165.png" alt="2.png" data-nodeid="2684"></p>\n<p data-nodeid="2430">相应地，图中 current 指针所指向的根节点所在的那棵树，我们叫它“<strong data-nodeid="2690">current 树</strong>”。</p>\n<p data-nodeid="2431">这时候，相信一些同学心里已经开始犯嘀咕了：一棵 current 树，一棵 workInProgress 树，这名堂也太多了吧！况且这两棵 Fiber 树至少在现在看来，是完全没区别的（毕竟都还只有一个根节点，哈哈）。React 这样设计的目的何在？或者换个问法——到底是什么样的事情一棵树做不到，非得搞两棵“一样”的树出来？</p>\n<p data-nodeid="2432">如果你想知道答案，就请好好把握住接下来的两讲内容吧！在一步一步理解 Fiber 树的构建和更新过程之后，我将带你去认识“两棵 Fiber 树”这一现象背后的动机。</p>\n<p data-nodeid="2433">接下来我们就深入到 beginWork 和 completeWork 的逻辑里去，一起看看 Fiber 树的构建过程及最终形态。</p>\n<h3 data-nodeid="2434">beginWork 开启 Fiber 节点创建过程</h3>\n<p data-nodeid="2435">有一说一，beginWork 的源码实在是长到不科学。这里我们本着抓主要矛盾的原则，针对与树构建过程强相关的动作进行逻辑提取，代码如下（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="2436"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">beginWork</span><span class="hljs-params">(current, workInProgress, renderLanes)</span> </span>{\n  ......\n\n  <span class="hljs-comment">//  current 节点不为空的情况下，会加一道辨识，看看是否有更新逻辑要处理</span>\n  <span class="hljs-keyword">if</span> (current !== <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 获取新旧 props</span>\n    <span class="hljs-keyword">var</span> oldProps = current.memoizedProps;\n    <span class="hljs-keyword">var</span> newProps = workInProgress.pendingProps;\n\n    <span class="hljs-comment">// 若 props 更新或者上下文改变，则认为需要"接受更新"</span>\n    <span class="hljs-keyword">if</span> (oldProps !== newProps || hasContextChanged() || (\n     workInProgress.type !== current.type )) {\n      <span class="hljs-comment">// 打个更新标</span>\n      didReceiveUpdate = <span class="hljs-keyword">true</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xxx) {\n      <span class="hljs-comment">// 不需要更新的情况 A</span>\n      <span class="hljs-keyword">return</span> A\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">if</span> (需要更新的情况 B) {\n        didReceiveUpdate = <span class="hljs-keyword">true</span>;\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 不需要更新的其他情况，这里我们的首次渲染就将执行到这一行的逻辑</span>\n        didReceiveUpdate = <span class="hljs-keyword">false</span>;\n      }\n    }\n  } <span class="hljs-keyword">else</span> {\n    didReceiveUpdate = <span class="hljs-keyword">false</span>;\n  } \n  ......\n  <span class="hljs-comment">// 这坨 switch 是 beginWork 中的核心逻辑，原有的代码量相当大</span>\n  <span class="hljs-keyword">switch</span> (workInProgress.tag) {\n    ......\n    <span class="hljs-comment">// 这里省略掉大量形如"case: xxx"的逻辑</span>\n    <span class="hljs-comment">// 根节点将进入这个逻辑</span>\n    <span class="hljs-keyword">case</span> HostRoot:\n      <span class="hljs-keyword">return</span> updateHostRoot(current, workInProgress, renderLanes)\n    <span class="hljs-comment">// dom 标签对应的节点将进入这个逻辑</span>\n    <span class="hljs-keyword">case</span> HostComponent:\n      <span class="hljs-keyword">return</span> updateHostComponent(current, workInProgress, renderLanes)\n\n    <span class="hljs-comment">// 文本节点将进入这个逻辑</span>\n    <span class="hljs-keyword">case</span> HostText:\n      <span class="hljs-keyword">return</span> updateHostText(current, workInProgress)\n    ...... \n    <span class="hljs-comment">// 这里省略掉大量形如"case: xxx"的逻辑</span>\n  }\n  <span class="hljs-comment">// 这里是错误兜底，处理 switch 匹配不上的情况</span>\n  {\n    {\n      <span class="hljs-keyword">throw</span> Error(\n        <span class="hljs-string">"Unknown unit of work tag ("</span> +\n          workInProgress.tag +\n          <span class="hljs-string">"). This error is likely caused by a bug in React. Please file an issue."</span>\n      )\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="2437">beginWork 源码太长不看版的重点总结：</p>\n<ol data-nodeid="2438">\n<li data-nodeid="2439">\n<p data-nodeid="2440">beginWork 的入参是<strong data-nodeid="2702">一对用 alternate 连接起来的 workInProgress 和 current 节点</strong>；</p>\n</li>\n<li data-nodeid="2441" class="">\n<p data-nodeid="2442" class=""><strong data-nodeid="2711">beginWork 的核心逻辑是根据 fiber 节点（workInProgress</strong>）<strong data-nodeid="2712">的 tag 属性的不同，调用不同的节点创建函数</strong>。</p>\n</li>\n</ol>\n<p data-nodeid="6574" class="">当前的 current 节点是 rootFiber，而 workInProgress 则是 current 的副本，它们的 tag 都是 3，如下图所示：</p>\n\n\n\n\n<p data-nodeid="2444"><img src="https://s0.lgstatic.com/i/image/M00/71/0B/CgqCHl-8xHmAV2FMAABmLqBlHD0379.png" alt="Drawing 6.png" data-nodeid="2716"></p>\n<p data-nodeid="2445">而 3 正是 HostRoot 所对应的值，因此第一个 beginWork 将进入 updateHostRoot 的逻辑。</p>\n<p data-nodeid="2446">这里你先不必急于关注 updateHostRoot 的逻辑细节。事实上，在整段 switch 逻辑里，包含的形如“update+类型名”这样的函数是非常多的。在专栏示例的 Demo 中，就涉及了对 updateHostRoot、updateHostComponent 等的调用，十来种 updateXXX，我们不可能一个一个去扣每一个函数的逻辑。</p>\n<p data-nodeid="2447">幸运的是，这些函数之间不仅命名形式一致，工作内容也相似。就 render 链路来说，它们共同的特性，就是都会<strong data-nodeid="2724">通过调用 reconcileChildren 方法，生成当前节点的子节点</strong>。</p>\n<p data-nodeid="2448">reconcileChildren 的源码如下：</p>\n<pre class="lang-java" data-nodeid="2449"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">reconcileChildren</span><span class="hljs-params">(current, workInProgress, nextChildren, renderLanes)</span> </span>{\n  <span class="hljs-comment">// 判断 current 是否为 null</span>\n  <span class="hljs-keyword">if</span> (current === <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 若 current 为 null，则进入 mountChildFibers 的逻辑</span>\n    workInProgress.child = mountChildFibers(workInProgress, <span class="hljs-keyword">null</span>, nextChildren, renderLanes);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 若 current 不为 null，则进入 reconcileChildFibers 的逻辑</span>\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n</code></pre>\n<p data-nodeid="2450">从源码来看，reconcileChildren 也只是做逻辑的分发，具体的工作还要到 <strong data-nodeid="2735">mountChildFibers</strong> 和 <strong data-nodeid="2736">reconcileChildFibers</strong> 里去看。</p>\n<h3 data-nodeid="2451">ChildReconciler，处理 Fiber 节点的幕后“操盘手”</h3>\n<p data-nodeid="2452">那么这两个函数又是何方神圣呢？在源码中，我们可以觅得这样两个赋值语句：</p>\n<pre class="lang-java" data-nodeid="2453"><code data-language="java"><span class="hljs-keyword">var</span> reconcileChildFibers = ChildReconciler(<span class="hljs-keyword">true</span>);\n<span class="hljs-keyword">var</span> mountChildFibers = ChildReconciler(<span class="hljs-keyword">false</span>);\n</code></pre>\n<p data-nodeid="2454">原来 reconcileChildFibers 和 mountChildFibers 不仅名字相似，出处也一致。<strong data-nodeid="2744">它们都是 ChildReconciler 这个函数的返回值，仅仅存在入参上的区别</strong>。而 ChildReconciler，则是一个实打实的“庞然大物”，其内部的逻辑量堪比 N 个 beginWork。这里我将关键要素提取如下（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="2455"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">ChildReconciler</span><span class="hljs-params">(shouldTrackSideEffects)</span> </span>{\n  <span class="hljs-comment">// 删除节点的逻辑</span>\n  <span class="hljs-function">function <span class="hljs-title">deleteChild</span><span class="hljs-params">(returnFiber, childToDelete)</span> </span>{\n    <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {\n      <span class="hljs-comment">// Noop.</span>\n      <span class="hljs-keyword">return</span>;\n    } \n    <span class="hljs-comment">// 以下执行删除逻辑</span>\n  }\n \n  ......\n\n\n  <span class="hljs-comment">// 单个节点的插入逻辑</span>\n  <span class="hljs-function">function <span class="hljs-title">placeSingleChild</span><span class="hljs-params">(newFiber)</span> </span>{\n    <span class="hljs-keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="hljs-keyword">null</span>) {\n      newFiber.flags = Placement;\n    }\n    <span class="hljs-keyword">return</span> newFiber;\n  }\n\n  <span class="hljs-comment">// 插入节点的逻辑</span>\n  <span class="hljs-function">function <span class="hljs-title">placeChild</span><span class="hljs-params">(newFiber, lastPlacedIndex, newIndex)</span> </span>{\n    newFiber.index = newIndex;\n    <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {\n      <span class="hljs-comment">// Noop.</span>\n      <span class="hljs-keyword">return</span> lastPlacedIndex;\n    }\n    <span class="hljs-comment">// 以下执行插入逻辑</span>\n  }\n  ......\n  <span class="hljs-comment">// 此处省略一系列 updateXXX 的函数，它们用于处理 Fiber 节点的更新</span>\n\n  <span class="hljs-comment">// 处理不止一个子节点的情况</span>\n  <span class="hljs-function">function <span class="hljs-title">reconcileChildrenArray</span><span class="hljs-params">(returnFiber, currentFirstChild, newChildren, lanes)</span> </span>{\n    ......\n  }\n  <span class="hljs-comment">// 此处省略一堆 reconcileXXXXX 形式的函数，它们负责处理具体的 reconcile 逻辑</span>\n  <span class="hljs-function">function <span class="hljs-title">reconcileChildFibers</span><span class="hljs-params">(returnFiber, currentFirstChild, newChild, lanes)</span> </span>{\n    <span class="hljs-comment">// 这是一个逻辑分发器，它读取入参后，会经过一系列的条件判断，调用上方所定义的负责具体节点操作的函数</span>\n  }\n\n  <span class="hljs-comment">// 将总的 reconcileChildFibers 函数返回</span>\n  <span class="hljs-keyword">return</span> reconcileChildFibers;\n}\n</code></pre>\n<p data-nodeid="2456">由于原本的代码量着实巨大，感兴趣的同学可以点开<a href="https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactChildFiber.old.js#L253" data-nodeid="2748">这个文件</a>查看细节，此处我仅针对与主流程强相关的逻辑为你总结以下要点：</p>\n<ol data-nodeid="2457">\n<li data-nodeid="2458">\n<p data-nodeid="2459">关键的入参 shouldTrackSideEffects，意为“是否需要追踪副作用”，<strong data-nodeid="2755">因此 reconcileChildFibers 和 mountChildFibers 的不同，在于对副作用的处理不同</strong>；</p>\n</li>\n<li data-nodeid="2460">\n<p data-nodeid="2461">ChildReconciler 中定义了大量如 placeXXX、deleteXXX、updateXXX、reconcileXXX 等这样的函数，这些函数覆盖了对 Fiber 节点的创建、增加、删除、修改等动作，将直接或间接地被 reconcileChildFibers 所调用；</p>\n</li>\n<li data-nodeid="2462">\n<p data-nodeid="2463">ChildReconciler 的返回值是一个名为 reconcileChildFibers 的函数，这个函数是一个逻辑分发器，<strong data-nodeid="2762">它将根据入参的不同，执行不同的 Fiber 节点操作，最终返回不同的目标 Fiber 节点</strong>。</p>\n</li>\n</ol>\n<p data-nodeid="2464">对于第 1 点，这里展开说说。对副作用的处理不同，到底是哪里不同？以 placeSingleChild 为例，以下是 placeSingleChild 的源码：</p>\n<pre class="lang-java" data-nodeid="2465"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">placeSingleChild</span><span class="hljs-params">(newFiber)</span> </span>{\n  <span class="hljs-keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="hljs-keyword">null</span>) {\n    newFiber.flags = Placement;\n  }\n  <span class="hljs-keyword">return</span> newFiber;\n}\n</code></pre>\n<p data-nodeid="2466">可以看出，一旦判断 shouldTrackSideEffects 为 false，那么下面所有的逻辑都不执行了，直接返回。那如果执行下去会发生什么呢？简而言之就是给 Fiber 节点打上一个叫“flags”的标记，像这样：</p>\n<pre class="lang-java" data-nodeid="2467"><code data-language="java">newFiber.flags = Placement;\n</code></pre>\n<p data-nodeid="2468">这个名为 flags 的标记有何作用呢？</p>\n<h4 data-nodeid="2469">小科普：flags 是什么</h4>\n<p data-nodeid="2470">由于这里我引用的是 <a href="https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactChildFiber.old.js#L253" data-nodeid="2770">v17.0.0 版本的源码</a>，属性名已经变更为 flags，但在更早一些的版本中，这个属性名叫“effectTag”。在时下的社区讨论中，effectTag 这个命名更常见，也更语义化，因此下文我将以 “effectTag”代指“flags”。</p>\n<p data-nodeid="2471">Placement 这个 effectTag 的意义，是在渲染器执行时，也就是真实 DOM 渲染时，告诉渲染器：<strong data-nodeid="2789">我这里需要新增 DOM 节点</strong>。 effectTag 记录的是<strong data-nodeid="2790">副作用的类型</strong>，而<strong data-nodeid="2791">所谓“副作用”</strong>，React 给出的定义是“<strong data-nodeid="2792">数据获取、订阅或者修改 DOM</strong>”等动作。在这里，Placement 对应的显然是 DOM 相关的副作用操作。</p>\n<p data-nodeid="2472">像 Placement 这样的副作用标识，还有很多，它们均以二进制常量的形式存在，下图我为你截取了局部（你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js" data-nodeid="2796">这个文件</a>里查看 effectTag 的类型）：</p>\n<p data-nodeid="2473"><img src="https://s0.lgstatic.com/i/image/M00/71/0B/CgqCHl-8xIyAZ3VoAADupBJcrgo966.png" alt="Drawing 7.png" data-nodeid="2800"></p>\n<p data-nodeid="2474">回到我们的调用链路里来，由于 current 是 rootFiber，它不为 null，因此它将走入的是下图所高亮的这行逻辑。也就是说在 mountChildFibers 和 reconcileChildFibers 之间，它选择的是 <strong data-nodeid="2806">reconcileChildFibers</strong>：</p>\n<p data-nodeid="2475"><img src="https://s0.lgstatic.com/i/image/M00/71/07/Ciqc1F-80U-AfncYAAEt69YE2-g951.png" alt="Drawing 8.png" data-nodeid="2809"></p>\n<p data-nodeid="2476">结合前面的分析可知，reconcileChildFibers 是<code data-backticks="1" data-nodeid="2811">ChildReconciler(true)</code>的返回值。入参为 true，意味着其内部逻辑是允许追踪副作用的，因此“打 effectTag”这个动作将会生效。</p>\n<p data-nodeid="2477">接下来进入 reconcileChildFibers 的逻辑，在 reconcileChildFibers 这个逻辑分发器中，会把 rootFiber 子节点的创建工作分发给 reconcileXXX 函数家族的一员——reconcileSingleElement 来处理，具体的调用形式如下图高亮处所示：</p>\n<p data-nodeid="2478"><img src="https://s0.lgstatic.com/i/image/M00/71/07/Ciqc1F-80VaABnJCAACe4hcSiBM598.png" alt="Drawing 9.png" data-nodeid="2816"></p>\n<p data-nodeid="2479">reconcileSingleElement 将基于 rootFiber 子节点的 ReactElement 对象信息，创建其对应的 FiberNode。这个过程中涉及的函数调用如下图高亮处所示：</p>\n<p data-nodeid="2480"><img src="https://s0.lgstatic.com/i/image/M00/71/12/CgqCHl-80VyAC2P6AAJfHF2gzfs579.png" alt="Drawing 10.png" data-nodeid="2820"></p>\n<p data-nodeid="2481">这里需要说明的一点是：<strong data-nodeid="2830">rootFiber 作为 Fiber 树的根节点</strong>，它并没有一个确切的 ReactElement 与之映射。结合 JSX 结构来看，<strong data-nodeid="2831">我们可以将其理解为是 JSX 中根组件的父节点</strong>。课时所给出的 Demo 中，组件编码如下：</p>\n<pre class="lang-java" data-nodeid="2482"><code data-language="java">import React from "react";\nimport ReactDOM from "react-dom";\nfunction App() {\n    return (\n      &lt;div className="App"&gt;\n        &lt;div className="container"&gt;\n          &lt;h1&gt;我是标题&lt;/h1&gt;\n          &lt;p&gt;我是第一段话&lt;/p&gt;\n          &lt;p&gt;我是第二段话&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n}\nconst rootElement = document.getElementById("root");\nReactDOM.render(&lt;App /&gt;, rootElement);\n</code></pre>\n<p data-nodeid="2483">可以看出，根组件是一个类型为 App 的函数组件，因此 <strong data-nodeid="2837">rootFiber 就是 App 的父节点</strong>。</p>\n<p data-nodeid="2484">结合这个分析来看，图中的 _created4 是根据 rootFiber 的第一个子节点对应的 ReactElement 来创建的 Fiber 节点，那么它就是 <strong data-nodeid="2847">App 所对应的 Fiber 节点</strong>。现在我为你打印出运行时的 _created4 值，会发现确实如此：</p>\n<p data-nodeid="2485"><img src="https://s0.lgstatic.com/i/image/M00/71/12/CgqCHl-80WaAXLPeAAD-OcP7y4o323.png" alt="Drawing 11.png" data-nodeid="2850"></p>\n<p data-nodeid="2486">App 所对应的 Fiber 节点，将被 placeSingleChild 打上“Placement”（新增）的副作用标记，而后作为 reconcileChildFibers 函数的返回值，返回给下图中的 workInProgress.child：</p>\n<p data-nodeid="2487"><img src="https://s0.lgstatic.com/i/image/M00/71/12/CgqCHl-80WyARnfDAAGNRsiaht8973.png" alt="Drawing 12.png" data-nodeid="2854"></p>\n<p data-nodeid="2488">reconcileChildren 函数上下文里的 workInProgress 就是 rootFiber 节点。那么此时，我们就将新创建的 App Fiber 节点和 rootFiber 关联了起来，整个 Fiber 树如下图所示：</p>\n<p data-nodeid="2489"><img src="https://s0.lgstatic.com/i/image/M00/71/3E/Ciqc1F-91MmARvQRAADFJC1K20o629.png" alt="3.png" data-nodeid="2858"></p>\n<h3 data-nodeid="2490">Fiber 节点的创建过程梳理</h3>\n<p data-nodeid="2491">分析完 App FiberNode 的创建过程，我们先不必急于继续往下走这个渲染链路。因为其实最关键的东西已经讲完了，剩余节点的创建只不过是对 performUnitOfWork、 beginWork 和 ChildReconciler 等相关逻辑的重复。</p>\n<p data-nodeid="2492">刚刚这一通分析所涉及的调用栈很长，相信不少人如果是初读的话，过程中肯定不可避免地要反复回看，确认自己现在到底在调用栈的哪一环。这里为了方便你把握逻辑脉络，我将本讲讲解的 beginWork 所触发的调用流程总结进一张大图：</p>\n<p data-nodeid="2493"><img src="https://s0.lgstatic.com/i/image/M00/71/47/Ciqc1F-97fSAYLUIAAGBjhvNylg581.png" alt="7.png" data-nodeid="2864"></p>\n<h3 data-nodeid="2494">Fiber 树的构建过程</h3>\n<p data-nodeid="2495">理解了 Fiber 节点的创建过程，就不难理解 Fiber 树的构建过程了。</p>\n<p data-nodeid="2496">前面我们已经锲而不舍地研究了各路关键函数的源码逻辑，此时相信你已经能够将函数名与函数的工作内容做到对号入座。这里我们不必再纠结与源码的实现细节，可以直接从工作流程的角度来看后续节点的创建。</p>\n<h4 data-nodeid="2497">循环创建新的 Fiber 节点</h4>\n<p data-nodeid="2498">研究节点创建的工作流，我们的切入点是<code data-backticks="1" data-nodeid="2870">workLoopSync</code>这个函数。</p>\n<p data-nodeid="2499">为什么选它？这里来复习一遍<code data-backticks="1" data-nodeid="2873">workLoopSync</code>会做什么：</p>\n<pre class="lang-java" data-nodeid="2500"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">workLoopSync</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 若 workInProgress 不为空</span>\n  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 针对它执行 performUnitOfWork 方法</span>\n    performUnitOfWork(workInProgress);\n  }\n}\n</code></pre>\n<p data-nodeid="2501"><strong data-nodeid="2883">它会循环地调用 performUnitOfWork</strong>，而 performUnitOfWork，开篇我们已经点到过它，其主要工作是“通过调用 beginWork，来实现新 Fiber 节点的创建”；它还有一个次要工作，<strong data-nodeid="2884">就是把新创建的这个 Fiber 节点的值更新到 workInProgress 变量里去</strong>。源码中的相关逻辑提取如下：</p>\n<pre class="lang-java" data-nodeid="2502"><code data-language="java"><span class="hljs-comment">// 新建 Fiber 节点</span>\nnext = beginWork$<span class="hljs-number">1</span>(current, unitOfWork, subtreeRenderLanes);\n<span class="hljs-comment">// 将新的 Fiber 节点赋值给 workInProgress</span>\n<span class="hljs-keyword">if</span> (next === <span class="hljs-keyword">null</span>) {\n  <span class="hljs-comment">// If this doesn\'t spawn new work, complete the current work.</span>\n  completeUnitOfWork(unitOfWork);\n} <span class="hljs-keyword">else</span> {\n  workInProgress = next;\n}\n</code></pre>\n<p data-nodeid="2503">如此便能够确保每次 performUnitOfWork 执行完毕后，当前的 <strong data-nodeid="2890">workInProgress 都存储着下一个需要被处理的节点，从而为下一次的 workLoopSync 循环做好准备</strong>。</p>\n<p data-nodeid="2504">现在我在 workLoopSync 内部打个断点，尝试输出每一次获取到的 workInProgress 的值，workInProgress 值的变化过程如下图所示：</p>\n<p data-nodeid="2505"><img src="https://s0.lgstatic.com/i/image/M00/71/12/CgqCHl-80ZuAA1HAAAEBle-yZFM332.png" alt="Drawing 15.png" data-nodeid="2894"></p>\n<p data-nodeid="2506">共有 7 个节点，若你点击展开查看每个节点的内容，就会发现这 7 个节点其实分别是：</p>\n<ul data-nodeid="2507">\n<li data-nodeid="2508">\n<p data-nodeid="2509">rootFiber（当前 Fiber 树的根节点）</p>\n</li>\n<li data-nodeid="2510">\n<p data-nodeid="2511">App FiberNode（App 函数组件对应的节点）</p>\n</li>\n<li data-nodeid="2512">\n<p data-nodeid="2513">class 为 App 的 DOM 元素对应的节点，其内容如下图所示</p>\n</li>\n</ul>\n<p data-nodeid="2514"><img src="https://s0.lgstatic.com/i/image/M00/71/12/CgqCHl-80aSAF7MKAAEHjyZ0Xwk039.png" alt="Drawing 16.png" data-nodeid="2901"></p>\n<ul data-nodeid="2515">\n<li data-nodeid="2516">\n<p data-nodeid="2517">class 为 container 的 DOM 元素对应的节点，其内容如下图所示</p>\n</li>\n</ul>\n<p data-nodeid="2518"><img src="https://s0.lgstatic.com/i/image/M00/71/07/Ciqc1F-80aqAJId4AACkvKHjlTM377.png" alt="Drawing 17.png" data-nodeid="2905"></p>\n<ul data-nodeid="2519">\n<li data-nodeid="2520">\n<p data-nodeid="2521">h1 标签对应的节点</p>\n</li>\n<li data-nodeid="2522">\n<p data-nodeid="2523">第 1 个 p 标签对应的 FiberNode，内容为“我是第一段话”，如下图所示</p>\n</li>\n</ul>\n<p data-nodeid="2524"><img src="https://s0.lgstatic.com/i/image/M00/71/07/Ciqc1F-80bGAGFKTAADArDpX9j4096.png" alt="Drawing 18.png" data-nodeid="2910"></p>\n<ul data-nodeid="2525">\n<li data-nodeid="2526">\n<p data-nodeid="2527">第 2 个 p 标签对应的 FiberNode，内容为“我是第二段话”，如下图所示</p>\n</li>\n</ul>\n<p data-nodeid="2528"><img src="https://s0.lgstatic.com/i/image/M00/71/12/CgqCHl-80biASe4KAAEZMaZTIY8632.png" alt="Drawing 19.png" data-nodeid="2914"></p>\n<p data-nodeid="2529">结合这 7 个 FiberNode，再对照对照我们的 Demo：</p>\n<pre class="lang-java" data-nodeid="2530"><code data-language="java">function App() {\n    return (\n      &lt;div className="App"&gt;\n        &lt;div className="container"&gt;\n          &lt;h1&gt;我是标题&lt;/h1&gt;\n          &lt;p&gt;我是第一段话&lt;/p&gt;\n          &lt;p&gt;我是第二段话&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n}\n</code></pre>\n<p data-nodeid="2531"><strong data-nodeid="2920">你会发现组件自上而下，每一个非文本类型的 ReactElement 都有了它对应的 Fiber 节点</strong>。</p>\n<blockquote data-nodeid="2532">\n<p data-nodeid="2533">注：React 并不会为所有的文本类型 ReactElement 创建对应的 FiberNode，这是一种优化策略。是否需要创建 FiberNode，在源码中是通过<a href="https://github.com/facebook/react/blob/765e89b908206fe62feb10240604db224f38de7d/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1068" data-nodeid="2924">isDirectTextChild</a>这个变量来区分的。</p>\n</blockquote>\n<p data-nodeid="2534">这样一来，我们构建的这棵树里，就多出了不少 FiberNode，如下图所示：</p>\n<p data-nodeid="2535"><img src="https://s0.lgstatic.com/i/image/M00/71/49/CgqCHl-91PKANLSRAACt8c-uYAk378.png" alt="4.png" data-nodeid="2929"></p>\n<p data-nodeid="2536">Fiber 节点有是有了，但这些 Fiber 节点之间又是如何相互连接的呢？</p>\n<h4 data-nodeid="2537">Fiber 节点间是如何连接的呢</h4>\n<p data-nodeid="2538"><strong data-nodeid="2940">不同的 Fiber 节点之间，将通过 child、return、sibling 这 3 个属性建立关系</strong>，<strong data-nodeid="2941">其中 child、return 记录的是父子节点关系，而 sibling 记录的则是兄弟节点关系</strong>。</p>\n<p data-nodeid="2539">这里我以 h1 这个元素对应的 Fiber 节点为例，给你展示下它是如何与其他节点相连接的。展开这个 Fiber 节点，对它的 child、 return、sibling 3 个属性作截取，如下图所示：</p>\n<p data-nodeid="2540">child 属性为 null，说明 h1 节点没有子 Fiber 节点：</p>\n<p data-nodeid="2541"><img src="https://s0.lgstatic.com/i/image/M00/71/13/CgqCHl-80d2AV6r7AABCQ4zzis4597.png" alt="Drawing 21.png" data-nodeid="2946"></p>\n<p data-nodeid="2542">return 属性局部截图：</p>\n<p data-nodeid="2543"><img src="https://s0.lgstatic.com/i/image/M00/71/07/Ciqc1F-80eOAMhlKAACxayioeh4810.png" alt="Drawing 22.png" data-nodeid="2950"></p>\n<p data-nodeid="2544">sibling 属性局部截图：</p>\n<p data-nodeid="2545"><img src="https://s0.lgstatic.com/i/image/M00/71/13/CgqCHl-80eiAJ6doAAClFZDD7jE642.png" alt="Drawing 23.png" data-nodeid="2954"></p>\n<p data-nodeid="2546">可以看到，return 属性指向的是 class 为 container 的 div 节点，而 sibling 属性指向的是第 1 个 p 节点。结合 JSX 中的嵌套关系我们不难得知 ——<strong data-nodeid="2960">FiberNode 实例中，return 指向的是当前 Fiber 节点的父节点，而 sibling 指向的是当前节点的第 1 个兄弟节点</strong>。</p>\n<p data-nodeid="2547">结合这 3 个属性所记录的节点间关系信息，我们可以轻松地将上面梳理出来的新 FiberNode 连接起来：</p>\n<p data-nodeid="2548"><img src="https://s0.lgstatic.com/i/image/M00/71/3E/Ciqc1F-91RGAAygAAAEYVWI-PXg439.png" alt="5.png" data-nodeid="2964"></p>\n<p data-nodeid="11373" class="">以上便是 workInProgress Fiber 树的最终形态了。从图中可以看出，虽然人们习惯上仍然将眼前的这个产物称为“Fiber 树”，但<strong data-nodeid="11379">它的数据结构本质其实已经从树变成了链表</strong>。</p>\n\n\n\n\n<p data-nodeid="2550" class="te-preview-highlight">注意，在分析 Fiber 树的构建过程时，我们选取了 <strong data-nodeid="2980">beginWork</strong> 作为切入点，但整个 Fiber 树的构建过程中，并不是只有 beginWork 在工作。这其中，还穿插着 <strong data-nodeid="2981">completeWork</strong> 的工作。只有将 completeWork 和 beginWork 放在一起来看，你才能够真正理解，Fiber 架构下的“深度优先遍历”到底是怎么一回事。</p>\n<h3 data-nodeid="2551">总结</h3>\n<p data-nodeid="2552">通过本讲的学习，你掌握了 beginWork 的实现原理、理清了 Fiber 节点的创建链路，最终串联起了 Fiber 树的宏观构建过程。至此，你已经揽获了 render 阶段大半的知识，这一路道阻且难，胜在收获满满。</p>\n<p data-nodeid="2553">下一讲，我们一方面将乘胜追击，继续探索 completeWork 的工作内容，将整个 render 阶段讲透；另一方面，我会带你快速地过一遍 commit 阶段的工作流，并基于此去串联由初始化、render、commit 所组成的完整渲染工作流，力求对整个 ReactDOM.render 所触发的渲染链路形成一个系统、通透的理解。</p>\n<p data-nodeid="2554" class="">此外，在本讲的开头，我还给你留下了一个悬念，也就是“为什么需要两棵 Fiber 树”的问题。这个问题的答案，也将会随着我们对 Fiber 探索的深入，逐渐浮出水面。</p>',
          },
          {
            theme: '15 | ReactDOM.render 是如何串联渲染链路的？（下）',
            id: 216,
            content:
              '<p data-nodeid="1653" class="">在上一讲我们从 beginWork 切入，摸索出了 Fiber 节点的创建链路与 Fiber 树的构建链路。本讲我们将以 completeWork 为线索，去寻觅 Fiber 树和 DOM 树之间的关联，将整个 render 阶段讲透。在此基础上，结合 commit 阶段工作流，你将会对 ReactDOM.render 所触发的渲染链路有一个完整、通透的理解。</p>\n<p data-nodeid="1654">本讲的实验 Demo 与前两讲保持一致，代码如下：</p>\n<pre class="lang-java" data-nodeid="1655"><code data-language="java">import React from "react";\nimport ReactDOM from "react-dom";\nfunction App() {\n  return (\n    &lt;div className="App"&gt;\n      &lt;div className="container"&gt;\n        &lt;h1&gt;我是标题&lt;/h1&gt;\n        &lt;p&gt;我是第一段话&lt;/p&gt;\n        &lt;p&gt;我是第二段话&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\nconst rootElement = document.getElementById("root");\nReactDOM.render(&lt;App /&gt;, rootElement);\n</code></pre>\n<h3 data-nodeid="1656">completeWork——将 Fiber 节点映射为 DOM 节点</h3>\n<h4 data-nodeid="1657">completeWork 的调用时机</h4>\n<p data-nodeid="1658">首先，我们先在调用栈中定位一下 completeWork。Demo 所对应的调用栈中，第一个 completeWork 出现在下图红框选中的位置：</p>\n<p data-nodeid="1659"><img src="https://s0.lgstatic.com/i/image/M00/72/1B/CgqCHl_AsdSAQuGuAAC09U5X0K0556.png" alt="Drawing 0.png" data-nodeid="1787"></p>\n<p data-nodeid="1660">从图上我们需要把握住的一个信息是，从 performUnitOfWork 到 completeWork，中间会经过一个这样的调用链路：</p>\n<p data-nodeid="1661"><img src="https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2PuADu50AABVUspw4O0014.png" alt="图片10.png" data-nodeid="1791"></p>\n<p data-nodeid="1662">其中 completeUnitOfWork 的工作也非常关键，但眼下我们先拿 completeWork 开刀，你可以暂时将 completeUnitOfWork 简单理解为一个用于发起 completeWork 调用的“工具人”。completeUnitOfWork 是在 performUnitOfWork 中被调用的，那么 performUnitOfWork 是如何把握其调用时机的呢？我们直接来看相关源码（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="1663"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">performUnitOfWork</span><span class="hljs-params">(unitOfWork)</span> </span>{\n  ......\n  <span class="hljs-comment">// 获取入参节点对应的 current 节点</span>\n  <span class="hljs-keyword">var</span> current = unitOfWork.alternate;\n\n  <span class="hljs-keyword">var</span> next;\n  <span class="hljs-keyword">if</span> (xxx) {\n    ...\n    <span class="hljs-comment">// 创建当前节点的子节点</span>\n    next = beginWork$<span class="hljs-number">1</span>(current, unitOfWork, subtreeRenderLanes);\n    ...\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 创建当前节点的子节点</span>\n    next = beginWork$<span class="hljs-number">1</span>(current, unitOfWork, subtreeRenderLanes);\n  }\n  ......\n  <span class="hljs-keyword">if</span> (next === <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 调用 completeUnitOfWork</span>\n    completeUnitOfWork(unitOfWork);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 将当前节点更新为新创建出的 Fiber 节点</span>\n    workInProgress = next;\n  }\n  ......\n}\n</code></pre>\n<p data-nodeid="1664">这段源码中你需要提取出的信息是：performUnitOfWork 每次会尝试调用 beginWork 来创建当前节点的子节点，若创建出的子节点为空（也就意味着当前节点不存在子 Fiber 节点），则说明当前节点是一个叶子节点。<strong data-nodeid="1798">按照深度优先遍历的原则，当遍历到叶子节点时，“递”阶段就结束了，随之而来的是“归”的过程</strong>。因此这种情况下，就会调用 completeUnitOfWork，执行当前节点对应的 completeWork 逻辑。</p>\n<p data-nodeid="1665">接下来我们在 Demo 代码的 completeWork 处打上断点，看看第一个走到 completeWork 的节点是哪个，结果如下图所示：</p>\n<p data-nodeid="1666"><img src="https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_AseOADKNDAALdERWik0M525.png" alt="Drawing 1.png" data-nodeid="1802"></p>\n<p data-nodeid="1667">显然，第一个进入 completeWork 的节点是 h1，这也符合我们上一讲所构建出来的 Fiber 树中的节点关系，如下图所示：</p>\n<p data-nodeid="1668"><img src="https://s0.lgstatic.com/i/image/M00/72/1B/CgqCHl_AsgSAJoM0AAEYVWI-PXg056.png" alt="Drawing 3.png" data-nodeid="1806"></p>\n<p data-nodeid="1669">由图可知，按照深度优先遍历的原则，h1 确实将是第一个被遍历到的叶子节点。接下来我们就以 h1 为例，一起看看 completeWork 都围绕它做了哪些事情。</p>\n<h4 data-nodeid="1670">completeWork 的工作原理</h4>\n<p data-nodeid="1671">这里仍然为你提取一下 completeWork 的源码结构和主体逻辑，代码如下（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="1672"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">completeWork</span><span class="hljs-params">(current, workInProgress, renderLanes)</span> </span>{\n  <span class="hljs-comment">// 取出 Fiber 节点的属性值，存储在 newProps 里</span>\n  <span class="hljs-keyword">var</span> newProps = workInProgress.pendingProps;\n\n  <span class="hljs-comment">// 根据 workInProgress 节点的 tag 属性的不同，决定要进入哪段逻辑</span>\n  <span class="hljs-keyword">switch</span> (workInProgress.tag) {\n    <span class="hljs-keyword">case</span> ......:\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n    <span class="hljs-keyword">case</span> ClassComponent:\n      {\n        .....\n      }\n    <span class="hljs-keyword">case</span> HostRoot:\n      {\n        ......\n      }\n    <span class="hljs-comment">// h1 节点的类型属于 HostComponent，因此这里为你讲解的是这段逻辑</span>\n    <span class="hljs-keyword">case</span> HostComponent:\n      {\n        popHostContext(workInProgress);\n        <span class="hljs-keyword">var</span> rootContainerInstance = getRootHostContainer();\n        <span class="hljs-keyword">var</span> type = workInProgress.type;\n        <span class="hljs-comment">// 判断 current 节点是否存在，因为目前是挂载阶段，因此 current 节点是不存在的</span>\n        <span class="hljs-keyword">if</span> (current !== <span class="hljs-keyword">null</span> &amp;&amp; workInProgress.stateNode != <span class="hljs-keyword">null</span>) {\n          updateHostComponent$<span class="hljs-number">1</span>(current, workInProgress, type, newProps, rootContainerInstance);\n          <span class="hljs-keyword">if</span> (current.ref !== workInProgress.ref) {\n            markRef$<span class="hljs-number">1</span>(workInProgress);\n          }\n        } <span class="hljs-keyword">else</span> {\n          <span class="hljs-comment">// 这里首先是针对异常情况进行 return 处理</span>\n          <span class="hljs-keyword">if</span> (!newProps) {\n            <span class="hljs-keyword">if</span> (!(workInProgress.stateNode !== <span class="hljs-keyword">null</span>)) {\n              {\n                <span class="hljs-keyword">throw</span> Error(<span class="hljs-string">"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."</span>);\n              }\n            } \n\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n          }\n\n          <span class="hljs-comment">// 接下来就为 DOM 节点的创建做准备了</span>\n          <span class="hljs-keyword">var</span> currentHostContext = getHostContext();\n          <span class="hljs-comment">// _wasHydrated 是一个与服务端渲染有关的值，这里不用关注</span>\n          <span class="hljs-keyword">var</span> _wasHydrated = popHydrationState(workInProgress);\n\n          <span class="hljs-comment">// 判断是否是服务端渲染</span>\n          <span class="hljs-keyword">if</span> (_wasHydrated) {\n            <span class="hljs-comment">// 这里不用关注，请你关注 else 里面的逻辑</span>\n            <span class="hljs-keyword">if</span> (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          } <span class="hljs-keyword">else</span> {\n            <span class="hljs-comment">// 这一步很关键， createInstance 的作用是创建 DOM 节点</span>\n            <span class="hljs-keyword">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            <span class="hljs-comment">// appendAllChildren 会尝试把上一步创建好的 DOM 节点挂载到 DOM 树上去</span>\n            appendAllChildren(instance, workInProgress, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);\n            <span class="hljs-comment">// stateNode 用于存储当前 Fiber 节点对应的 DOM 节点</span>\n            workInProgress.stateNode = instance; \n\n            <span class="hljs-comment">// finalizeInitialChildren 用来为 DOM 节点设置属性</span>\n            <span class="hljs-keyword">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {\n              markUpdate(workInProgress);\n            }\n          }\n          ......\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n      }\n    <span class="hljs-keyword">case</span> HostText:\n      {\n        ......\n      }\n    <span class="hljs-keyword">case</span> SuspenseComponent:\n      {\n        ......\n      }\n    <span class="hljs-keyword">case</span> HostPortal:\n      ......\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n    <span class="hljs-keyword">case</span> ContextProvider:\n      ......\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;\n    ......\n  }\n  {\n    {\n      <span class="hljs-keyword">throw</span> Error(<span class="hljs-string">"Unknown unit of work tag ("</span> + workInProgress.tag + <span class="hljs-string">"). This error is likely caused by a bug in React. Please file an issue."</span>);\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="1673">试图捋顺这段 completeWork 逻辑，你需要掌握以下几个要点。</p>\n<ol data-nodeid="1674">\n<li data-nodeid="1675">\n<p data-nodeid="1676">completeWork 的核心逻辑是一段体量巨大的 switch 语句，在这段 switch 语句中，<strong data-nodeid="1816">completeWork 将根据 workInProgress 节点的 tag 属性的不同，进入不同的 DOM 节点的创建、处理逻辑</strong>。</p>\n</li>\n<li data-nodeid="1677">\n<p data-nodeid="1678">在 Demo 示例中，h1 节点的 tag 属性对应的类型应该是 HostComponent，也就是“原生 DOM 元素类型”。</p>\n</li>\n<li data-nodeid="1679">\n<p data-nodeid="1680">completeWork 中的 current、 workInProgress 分别对应的是下图中左右两棵 Fiber 树上的节点：</p>\n</li>\n</ol>\n<p data-nodeid="1681"><img src="https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2R-AWalhAAD-42SivEU001.png" alt="图片12.png" data-nodeid="1821"></p>\n<p data-nodeid="1682">其中 workInProgress 树代表的是“当前正在 render 中的树”，而 current 树则代表“已经存在的树”。</p>\n<p data-nodeid="1683">workInProgress 节点和 current 节点之间用 alternate 属性相互连接。在组件的挂载阶段，current 树只有一个 rootFiber 节点，并没有其他内容。因此 h1 这个 workInProgress 节点对应的 current 节点是 null。</p>\n<p data-nodeid="1684">带着上面这些前提，再去结合注释读一遍上面提炼出来的源码，思路是不是就清晰多了？</p>\n<p data-nodeid="1685">捋顺思路后，我们直接来提取知识点。关于 completeWork，你需要明白以下几件事。</p>\n<p data-nodeid="1686">（1）用一句话来总结 completeWork 的工作内容：<strong data-nodeid="1831">负责处理 Fiber 节点到 DOM 节点的映射逻辑</strong>。</p>\n<p data-nodeid="1687">（2）completeWork 内部有 3 个关键动作：</p>\n<ul data-nodeid="1688">\n<li data-nodeid="1689">\n<p data-nodeid="1690"><strong data-nodeid="1837">创建</strong>DOM 节点（CreateInstance）</p>\n</li>\n<li data-nodeid="1691">\n<p data-nodeid="1692">将 DOM 节点<strong data-nodeid="1843">插入</strong>到 DOM 树中（AppendAllChildren）</p>\n</li>\n<li data-nodeid="1693">\n<p data-nodeid="1694">为 DOM 节点<strong data-nodeid="1849">设置属性</strong>（FinalizeInitialChildren）</p>\n</li>\n</ul>\n<p data-nodeid="1695">（3）<strong data-nodeid="1855">创建好的 DOM 节点会被赋值给 workInProgress 节点的 stateNode 属性</strong>。也就是说当我们想要定位一个 Fiber 对应的 DOM 节点时，访问它的 stateNode 属性就可以了。这里我们可以尝试访问运行时的 h1 节点的 stateNode 属性，结果如下图所示：</p>\n<p data-nodeid="1696"><img src="https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_Ash-AW32XAABIXg8drFo176.png" alt="Drawing 5.png" data-nodeid="1858"></p>\n<p data-nodeid="1697">（4）将 DOM 节点插入到 DOM 树的操作是通过 appendAllChildren 函数来完成的。</p>\n<p data-nodeid="1698">说是将 DOM 节点插入到 DOM 树里去，实际上是将<strong data-nodeid="1869">子 Fiber 节点所对应的 DOM 节点</strong>挂载到其<strong data-nodeid="1870">父 Fiber 节点所对应的 DOM 节点里去</strong>。比如说在本讲 Demo 所构建出的 Fiber 树中，h1 节点的父结点是 div，那么 h1 对应的 DOM 节点就理应被挂载到 div 对应的 DOM 节点里去。</p>\n<p data-nodeid="1699">那么如果执行 appendAllChildren 时，父级的 DOM 节点还不存在怎么办？</p>\n<p data-nodeid="1700">比如 h1 节点作为第一个进入 completeWork 的节点，它的父节点 div 对应的 DOM 就尚不存在。其实不存在也没关系，反正 h1 DOM 节点被创建后，会作为 h1 Fiber 节点的 stateNode 属性存在，丢不掉的。当父节点 div 进入 appendAllChildren 逻辑后，会逐个向下查找并添加自己的后代节点，这时候，h1 就会被它的父级 DOM 节点“收入囊中”啦~</p>\n<h3 data-nodeid="1701">completeUnitOfWork —— 开启收集 EffectList 的“大循环”</h3>\n<p data-nodeid="1702">completeUnitOfWork 的作用是开启一个大循环，在这个大循环中，将会重复地做下面三件事：</p>\n<ol data-nodeid="1703">\n<li data-nodeid="1704">\n<p data-nodeid="1705"><strong data-nodeid="1880">针对传入的当前节点，调用 completeWork</strong>，completeWork 的工作内容前面已经讲过，这一步应该是没有异议的；</p>\n</li>\n<li data-nodeid="1706">\n<p data-nodeid="1707">将<strong data-nodeid="1890">当前节点的副作用链</strong>（EffectList）插入到其<strong data-nodeid="1891">父节点对应的副作用链</strong>（EffectList）中；</p>\n</li>\n<li data-nodeid="1708">\n<p data-nodeid="1709">以当前节点为起点，循环遍历其兄弟节点及其父节点。当遍历到兄弟节点时，将 return 掉当前调用，触发兄弟节点对应的 performUnitOfWork 逻辑；而遍历到父节点时，则会直接进入下一轮循环，也就是重复 1、2 的逻辑。</p>\n</li>\n</ol>\n<p data-nodeid="1710">步骤 1 无须多言，接下来我将为你解读步骤 2 和步骤 3 的含义。</p>\n<h4 data-nodeid="1711">completeUnitOfWork 开启下一轮循环的原则</h4>\n<p data-nodeid="1712">在理解副作用链之前，首先要理解 completeUnitOfWork 开启下一轮循环的原则，也就是步骤 3。步骤 3 相关的源码如下所示（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="1713"><code data-language="java"><span class="hljs-keyword">do</span> {\n  ......\n  <span class="hljs-comment">// 这里省略步骤 1 和步骤 2 的逻辑 </span>\n\n  <span class="hljs-comment">// 获取当前节点的兄弟节点</span>\n  <span class="hljs-keyword">var</span> siblingFiber = completedWork.sibling;\n\n  <span class="hljs-comment">// 若兄弟节点存在</span>\n  <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 将 workInProgress 赋值为当前节点的兄弟节点</span>\n    workInProgress = siblingFiber;\n    <span class="hljs-comment">// 将正在进行的 completeUnitOfWork 逻辑 return 掉</span>\n    <span class="hljs-keyword">return</span>;\n  } \n\n  <span class="hljs-comment">// 若兄弟节点不存在，completeWork 会被赋值为 returnFiber，也就是当前节点的父节点</span>\n  completedWork = returnFiber; \n    <span class="hljs-comment">// 这一步与上一步是相辅相成的，上下文中要求 workInProgress 与 completedWork 保持一致</span>\n  workInProgress = completedWork;\n} <span class="hljs-keyword">while</span> (completedWork !== <span class="hljs-keyword">null</span>);\n</code></pre>\n<p data-nodeid="1714">步骤 3 是整个循环体的收尾工作，它会在当前节点相关的各种工作都做完之后执行。</p>\n<p data-nodeid="1715">当前节点处理完了，自然是去寻找下一个可以处理的节点。我们知道，当前的 Fiber 节点之所以会进入 completeWork，是因为“递无可递”了，才会进入“归”的逻辑，这就意味着当前 Fiber 要么没有 child 节点、要么 child 节点的 completeWork 早就执行过了。因此 child 节点不会是下次循环需要考虑的对象，下次循环只需要考虑兄弟节点（siblingFiber）和父节点（returnFiber）。</p>\n<p data-nodeid="1716">那么为什么在源码中，遇到兄弟节点会 return，遇到父节点才会进入下次循环呢？这里我以 h1 节点的节点关系为例进行说明。请看下图：</p>\n<p data-nodeid="1717"><img src="https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2UCAeC8WAAByZUWVwpM770.png" alt="图片8.png" data-nodeid="1901"></p>\n<p data-nodeid="1718">结合前面的分析和图示可知，<strong data-nodeid="1907">h1 节点是递归过程中所触及的第一个叶子节点，也是其兄弟节点中被遍历到的第一个节点</strong>；而剩下的两个 p 节点，此时都还没有被遍历到，也就是说连 beginWork 都没有执行过。</p>\n<p data-nodeid="1719"><strong data-nodeid="1912">因此对于 h1 节点的兄弟节点来说，当下的第一要务是回去从 beginWork 开始走起，直到 beginWork “递无可递”时，才能够执行 completeWork 的逻辑</strong>。beginWork 的调用是在 performUnitOfWork 里发生的，因此 completeUnitOfWork 一旦识别到当前节点的兄弟节点不为空，就会终止后续的逻辑，退回到上一层的 performUnitOfWork 里去。</p>\n<p data-nodeid="1720">接下来我们再来看 h1 的父节点 div：在向下递归到 h1 的过程中，div 必定已经被遍历过了，也就是说 div 的“递”阶段（ beginWork） 已经执行完毕，只剩下“归”阶段的工作要处理了。因此，对于父节点，completeUnitOfWork 会毫不犹豫地把它推到下一次循环里去，让它进入 completeWork 的逻辑。</p>\n<p data-nodeid="1721">值得注意的是，completeUnitOfWork 中处理兄弟节点和父节点的顺序是：先检查兄弟节点是否存在，若存在则优先处理兄弟节点；确认没有待处理的兄弟节点后，才转而处理父节点。这也就意味着，<strong data-nodeid="1919">completeWork 的执行是严格自底向上的</strong>，子节点的 completeWork 总会先于父节点执行。</p>\n<h4 data-nodeid="1722">副作用链（effectList）的设计与实现</h4>\n<p data-nodeid="1723">无论是 beginWork 还是 completeWork，它们的应用对象都是 workInProgress 树上的节点。我们说 render 阶段是一个递归的过程，“递归”的对象，正是这棵 workInProgress 树（见下图右侧高亮部分）：</p>\n<p data-nodeid="1724"><img src="https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2VCAHbHdAAEBwCIJFE4253.png" alt="图片13.png" data-nodeid="1924"></p>\n<p data-nodeid="1725">那么我们递归的目的是什么呢？或者说，render 阶段的工作目标是什么呢？</p>\n<p data-nodeid="1726"><strong data-nodeid="1930">render 阶段的工作目标是找出界面中需要处理的更新</strong>。</p>\n<p data-nodeid="1727">在实际的操作中，并不是所有的节点上都会产生需要处理的更新。比如在挂载阶段，对图中的整棵 workInProgress 递归完毕后，React 会发现实际只需要对 App 节点执行一个挂载操作就可以了；而在更新阶段，这种现象更为明显。</p>\n<p data-nodeid="1728">更新阶段与挂载阶段的主要区别在于更新阶段的 current 树不为空，比如说情况可以是下图这样子的：</p>\n<p data-nodeid="1729"><img src="https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2VyAUxeJAAIrypFDLh4388.png" alt="图片14.png" data-nodeid="1935"></p>\n<p data-nodeid="1730">假如说我的某一次操作，仅仅对 p 节点产生了影响，那么对于渲染器来说，它理应只关注 p 节点这一处的更新。这时候问题就来了：<strong data-nodeid="1941">怎样做才能让渲染器又快又好地定位到那些真正需要更新的节点呢</strong>？</p>\n<p data-nodeid="7897" class="">在 render 阶段，我们通过艰难的递归过程来明确“p 节点这里有一处更新”这件事情。按照 React 的设计思路，render 阶段结束后，“找不同”这件事情其实也就告一段落了。<strong data-nodeid="7911">commit 只负责实现更新，而不负责寻找更新</strong>，这就意味着我们必须找到一个办法能让 commit 阶段“坐享其成”，能直接拿到 render 阶段的工作成果。而这，正是<strong data-nodeid="7912">副作用链</strong>（<strong data-nodeid="7913">effectList</strong>）的价值所在。</p>\n\n\n\n\n\n\n\n\n<p data-nodeid="1732" class="te-preview-highlight"><strong data-nodeid="1958">副作用链（effectList）</strong> 可以理解为 render 阶段“工作成果”的一个集合：每个 Fiber 节点都维护着一个属于它自己的 effectList，effectList 在数据结构上以链表的形式存在，链表内的每一个元素都是一个 Fiber 节点。这些 Fiber 节点需要满足两个共性：</p>\n<ol data-nodeid="1733">\n<li data-nodeid="1734">\n<p data-nodeid="1735">都是当前 Fiber 节点的后代节点</p>\n</li>\n<li data-nodeid="1736">\n<p data-nodeid="1737">都有待处理的副作用</p>\n</li>\n</ol>\n<p data-nodeid="1738">没错，Fiber 节点的 effectList 里记录的并非它自身的更新，而是其<strong data-nodeid="1966">需要更新的后代节点</strong>。带着这个结论，我们再来品品小节开头 completeUnitOfWork 中的“步骤 2”：</p>\n<blockquote data-nodeid="1739">\n<p data-nodeid="1740">将<strong data-nodeid="1976">当前节点的副作用链</strong>（effectList）插入到其<strong data-nodeid="1977">父节点对应的副作用链</strong>（effectList）中。</p>\n</blockquote>\n<p data-nodeid="1741">咱们前面已经分析过，“<strong data-nodeid="1987">completeWork 是自底向上执行的</strong>”，也就是说，子节点的 completeWork 总是比父节点先执行。试想，若每次处理到一个节点，都将当前节点的 effectList 插入到其父节点的 effectList 中。那么当所有节点的 completeWork 都执行完毕时，我是不是就可以从“终极父节点”，也就是 rootFiber 上，拿到一个<strong data-nodeid="1988">存储了当前 Fiber 树所有 effect Fiber</strong>的“终极版”的 effectList 了？</p>\n<p data-nodeid="1742"><strong data-nodeid="1993">把所有需要更新的 Fiber 节点单独串成一串链表，方便后续有针对性地对它们进行更新，这就是所谓的“收集副作用”的过程</strong>。</p>\n<p data-nodeid="1743">这里我以挂载过程为例，带你分析一下这个过程是如何实现的。</p>\n<p data-nodeid="1744">首先我们要知道的是，这个 effectList 链表在 Fiber 节点中是通过 firstEffect 和 lastEffect 来维护的，如下图所示：</p>\n<p data-nodeid="1745"><img src="https://s0.lgstatic.com/i/image/M00/72/1C/CgqCHl_AspmALRFDAADaKY8wTqc180.png" alt="Drawing 10.png" data-nodeid="1998"></p>\n<p data-nodeid="1746">其中 firstEffect 表示 effectList 的第一个节点，而 lastEffect 则记录最后一个节点。</p>\n<p data-nodeid="1747">对于挂载过程来说，我们唯一要做的就是把 App 组件挂载到界面上去，因此 App 后代节点们的 effectList&nbsp;其实都是不存在的。effectList 只有在 App 的父节点（rootFiber）这才不为空。</p>\n<p data-nodeid="1748">那么 effectList 的创建逻辑又是怎样的呢？其实非常简单，只需要为 firstEffect 和 lastEffect 各赋值一个引用即可。以下是从 completeUnitOfWork 源码中提取出的相关逻辑（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="1749"><code data-language="java"><span class="hljs-comment">// 若副作用类型的值大于“PerformedWork”，则说明这里存在一个需要记录的副作用</span>\n<span class="hljs-keyword">if</span> (flags &gt; PerformedWork) {\n  <span class="hljs-comment">// returnFiber 是当前节点的父节点</span>\n  <span class="hljs-keyword">if</span> (returnFiber.lastEffect !== <span class="hljs-keyword">null</span>) {\n    <span class="hljs-comment">// 若父节点的 effectList 不为空，则将当前节点追加到 effectList 的末尾去</span>\n    returnFiber.lastEffect.nextEffect = completedWork;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 若父节点的 effectList 为空，则当前节点就是 effectList 的 firstEffect</span>\n    returnFiber.firstEffect = completedWork;\n  }\n\n  <span class="hljs-comment">// 将 effectList 的 lastEffect 指针后移一位</span>\n  returnFiber.lastEffect = completedWork;\n}\n</code></pre>\n<p data-nodeid="1750">代码中的 flags 咱们已经反复强调过了，它旧时的名字叫“effectTag”，是用来标识副作用类型的；而“completedWork”这个变量，在当前上下文中存储的就是“正在被执行 completeWork 相关逻辑”的节点；至于“PerformedWork”，它是一个值为 1 的常量，React 规定若 flags（又名 effectTag）的值小于等于 1，则不必提交到 commit 阶段。因此 completeUnitOfWork 只会对 flags 大于 PerformedWork 的 effect fiber 进行收集。</p>\n<p data-nodeid="1751">结合这些信息，再去读一遍源码片段，相信你的理解过程就会很流畅了。这里我以 App 节点为例，带你走一遍 effectList 的创建过程：</p>\n<ol data-nodeid="1752">\n<li data-nodeid="1753">\n<p data-nodeid="1754">App FiberNode 的 flags 属性为 3，大于 PerformedWork，因此会进入 effectList 的创建逻辑；</p>\n</li>\n<li data-nodeid="1755">\n<p data-nodeid="1756">创建 effectList 时，并不是为当前 Fiber 节点创建，而是为它的父节点创建，App 节点的父节点是 rootFiber，rootFiber 的 effectList 此时为空；</p>\n</li>\n<li data-nodeid="1757">\n<p data-nodeid="1758">rootFiber 的 firstEffect 和 lastEffect 指针都会指向 App 节点，App 节点由此成为 effectList 中的唯一一个 FiberNode，如下图所示。</p>\n</li>\n</ol>\n<p data-nodeid="1759"><img src="https://s0.lgstatic.com/i/image/M00/72/1E/Ciqc1F_A2W-AVmmRAABDdji0MoI238.png" alt="图片15.png" data-nodeid="2009"></p>\n<p data-nodeid="1760">OK，读到这里，相信你已经对 effectList 的创建过程知根知底了。</p>\n<p data-nodeid="1761">现在，即便你对部分源码细节的消化可能没有那么快，也请你不要因为这些细节去中断自己串联整个渲染链路的思路。你只需要把握住“根节点（rootFiber）上的 effectList 信息，是 commit 阶段的更新线索”这个结论，就足以将 render 阶段和 commit 阶段串联起来。</p>\n<h3 data-nodeid="1762">commit 阶段工作流简析</h3>\n<p data-nodeid="1763">在整个 ReactDOM.render 的渲染链路中，render 阶段是 Fiber 架构的核心体现，也是我们讲解的重点。对于 render 阶段，我对你的期望是“熟悉”，为了达成这个目标，我们对 render 阶段的学习还会再持续一个课时；而对于 commit 阶段，我只要求你做到“了解”。因此这里我会快速地带你过一遍 commit 阶段的重点知识，不占用你太多时间。</p>\n<p data-nodeid="1764">commit 会在 performSyncWorkOnRoot 中被调用，如下图所示：</p>\n<p data-nodeid="1765"><img src="https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_AsqiAENXWAAF6r2_37Lc521.png" alt="Drawing 12.png" data-nodeid="2017"></p>\n<p data-nodeid="1766">这里的入参 root 并不是 rootFiber，而是 fiberRoot（FiberRootNode）实例。fiberRoot 的 current 节点指向 rootFiber，因此拿到 effectList 对后续的 commit 流程来说不是什么难事。</p>\n<p data-nodeid="1767">从流程上来说，commit 共分为 3 个阶段：<strong data-nodeid="2023">before mutation、mutation、layout。</strong></p>\n<ul data-nodeid="1768">\n<li data-nodeid="1769">\n<p data-nodeid="1770">before mutation 阶段，<strong data-nodeid="2029">这个阶段 DOM 节点还没有被渲染到界面上去</strong>，过程中会触发 getSnapshotBeforeUpdate，也会处理 useEffect 钩子相关的调度逻辑。</p>\n</li>\n<li data-nodeid="1771">\n<p data-nodeid="1772">mutation，<strong data-nodeid="2035">这个阶段负责 DOM 节点的渲染</strong>。在渲染过程中，会遍历 effectList，根据 flags（effectTag）的不同，执行不同的 DOM 操作。</p>\n</li>\n<li data-nodeid="1773">\n<p data-nodeid="1774">layout，<strong data-nodeid="2045">这个阶段处理 DOM 渲染完毕之后的收尾逻辑</strong>。比如调用 componentDidMount/componentDidUpdate，调用 useLayoutEffect 钩子函数的回调等。除了这些之外，它还会<strong data-nodeid="2046">把 fiberRoot 的 current 指针指向 workInProgress Fiber 树</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="1775">关于 commit 阶段的实现细节，感兴趣的同学课下可以参阅 <a href="https://github.com/facebook/react/blob/a81c02ac150233bdb5f31380d4135397fb8f4660/packages/react-reconciler/src/ReactFiberWorkLoop.new.js" data-nodeid="2050">commit 相关源码</a>，这里不再展开讨论。对于 commit，如果你只能记住一个知识点，我希望你记住<strong data-nodeid="2056">它是一个绝对同步的过程</strong>。render 阶段可以同步也可以异步，但 commit 一定是同步的。</p>\n<h3 data-nodeid="1776" class="">总结</h3>\n<p data-nodeid="1777">这一讲我们完成了对 ReactDOM.render 调用栈的分析。表面上剖析的是首次渲染的渲染链路，实际上将包括同步模式下的挂载、更新链路（与挂载链路的调用栈非常相似）都串联了一遍。</p>\n<p data-nodeid="1778">虽然还没有正式介入更新链路、包括异步更新模式的讲解，但你此时其实已经具备了理解这些知识的基础：Concurrent 模式（异步渲染）与 Legacy 模式（同步渲染）在数据结构设计、核心 API 调用等方面都是一致的。<strong data-nodeid="2064">这也就意味着我们这三讲所讲解的知识，都是可以在后续的学习中复用的</strong>。</p>\n<p data-nodeid="1779" class="">接下来，我们就将进入更新过程的学习，揭开 Concurrent 模式及 Scheduler 的神秘面纱。同时，针对上一讲遗留下来的“为什么需要两棵树”的问题，我也会在下一讲中为你解答。</p>',
          },
          {
            theme: '16 | 剖析 Fiber 架构下 Concurrent 模式的实现原理',
            id: 217,
            content:
              '<p data-nodeid="4694" class="">你好，欢迎来到第 16 讲，关于 Fiber 架构的实现原理和编码形态，其实我们已经洋洋洒洒地分析了 3 讲了。</p>\n<p data-nodeid="4695">在过去的 3 讲里，通过对整个 ReactDOM.render 所触发的渲染链路进行了分析和串联，我们已经把 Fiber 架构在实现层面的大部分要点都过了一遍。刚讲过的这部分知识，一方面相对来说复杂度比较高，需要一些耐心反复地理解和消化；另一方面，本讲接下来要讲解的内容，也和它存在着较强的依赖关系，因此对这些前置知识的把握就显得尤为重要。</p>\n<p data-nodeid="4696">下面我说几个函数，帮你检验一下自己的学习效果：</p>\n<ol data-nodeid="4697">\n<li data-nodeid="4698">\n<p data-nodeid="4699">performSyncWorkOnRoot</p>\n</li>\n<li data-nodeid="4700">\n<p data-nodeid="4701">workLoopSync</p>\n</li>\n<li data-nodeid="4702">\n<p data-nodeid="4703">performUnitOfWork</p>\n</li>\n<li data-nodeid="4704">\n<p data-nodeid="4705">beginWork</p>\n</li>\n<li data-nodeid="4706">\n<p data-nodeid="4707">completeWork</p>\n</li>\n<li data-nodeid="4708">\n<p data-nodeid="4709">completeUnitOfWork</p>\n</li>\n<li data-nodeid="4710">\n<p data-nodeid="4711">reconcileChildFibers</p>\n</li>\n</ol>\n<p data-nodeid="4712">如果你对这些函数的执行时机和工作内容仍然感到不那么熟悉，那么不妨回到前 3 个课时里，结合案例和源码，重新捋顺一遍自己的思路，再回来续上你的知识链路。在接下来的讲解中，若对以上方法及其相关逻辑有所涉及，我将不再重复赘述。</p>\n<p data-nodeid="4713">本讲我将带你去认识 Fiber 架构最迷人的那一面——Concurrent 模式（异步渲染）下的“<strong data-nodeid="4879">时间切片</strong>”和“<strong data-nodeid="4880">优先级</strong>”实现。</p>\n<p data-nodeid="4714">在切入正题之前，我首先会回答上一讲遗留下来的“两棵树”问题。“两棵树”之间的合作模式足以将挂载过程和更新过程联系起来，对于本讲来说，是一个不错的学习切入点。</p>\n<h3 data-nodeid="4715">current 树 与 workInProgress 树：“双缓冲”模式在 Fiber 架构下的实现</h3>\n<h4 data-nodeid="4716">什么是“双缓冲”模式</h4>\n<p data-nodeid="77176" class="">“双缓冲”模式其实是一种在游戏领域由来已久的经典设计模式。为了帮助你快速理解它，这里我先举一个生活中的例子：假如你去看一场总时长只有 1 个小时的话剧，这场话剧中场不休息，需要不间断地演出。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="81094" class="">按照剧情的需求，半个小时处需要一次转场。所谓转场，就是说话剧舞台的灯光、布景、氛围等全部要切换到另一种风格里去。在不中断演出的情况下，想要实现转场，怎么办呢？场务工作做得再快，也要十几二十分钟，这对一场时长 1 小时的话剧来说，实在太漫长了。观众也无法接受这样的剧情“卡顿”体验。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="4719">有一种解法，那就是<strong data-nodeid="4891">准备两个舞台</strong>来做这场戏，当第一个舞台处于使用中时，第二个舞台的布局已经完成。这样当第一个舞台的表演结束时，只需要把第一个舞台的灯光灭掉，第二个舞台的灯光亮起，就可以做到剧情的无缝衔接了。</p>\n<p data-nodeid="83706" class="te-preview-highlight">事实上，在真实的话剧中，我们也确实常常看到这样的画面——演员从舞台的左侧走到了右侧，灯光一切换，就从卧室（左侧舞台）走到了公园（右侧舞台）；又从公园（右侧舞台）走到了办公室（左侧舞台）。左侧舞台的布景从卧室变成了办公室，这个过程正是在演员利用右侧舞台表演时完成的。</p>\n\n\n<p data-nodeid="4721">在这个过程中，我们可以认为，<strong data-nodeid="4898">左侧舞台和右侧舞台分别是两套缓冲数据，而呈现在观众眼前的连贯画面，就是不同的缓冲数据交替被读取后的结果</strong>。</p>\n<p data-nodeid="4722">在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉效果上的抖动甚至卡顿。而在 React 中，双缓冲模式的主要利好，则是<strong data-nodeid="4904">能够帮我们较大限度地实现 Fiber 节点的复用</strong>，从而减少性能方面的开销。</p>\n<h4 data-nodeid="4723">current 树与 workInProgress 树之间是如何“相互利用”的</h4>\n<p data-nodeid="4724">在 React 中，current 树与 workInProgress 树，两棵树可以对标“双缓冲”模式下的两套缓冲数据：当 current 树呈现在用户眼前时，所有的更新都会由 workInProgress 树来承接。workInProgress 树将会在用户看不到的地方（内存里）悄悄地完成所有改变，直到“灯光”打到它身上，也就是 current 指针指向它的时候，此时就意味着 commit 阶段已经执行完毕，workInProgress 树变成了那棵呈现在界面上的 current 树。</p>\n<p data-nodeid="4725">接下来我将用一个 Demo，带你切身感受一把 workInProgress 树和 current 树“相互利用”的过程。代码如下：</p>\n<pre class="lang-js" data-nodeid="4726"><code data-language="js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> [state, setState] = useState(<span class="hljs-number">0</span>)\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> { setState(state + 1) }} className="container"&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> <span class="hljs-attr">128</span>, <span class="hljs-attr">textAlign:</span> \'<span class="hljs-attr">center</span>\' }}&gt;</span>\n          {state}\n        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;\n</code></pre>\n<p data-nodeid="4727">这个组件挂载后呈现出的界面很简单，就是一个数字 0，如下图所示：</p>\n<p data-nodeid="4728"><img src="https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GIlaAHn_FAAAchawzt4s009.png" alt="Drawing 1.png" data-nodeid="4911"></p>\n<p data-nodeid="4729">每点击数字 0 一下，它的值就会 +1，这就是我们的更新动作。</p>\n<h5 data-nodeid="4730">挂载后的 Fiber &nbsp;树</h5>\n<p data-nodeid="4731">关于 Fiber 树的构建过程，前面已经详细讲解过，这里不再重复。下面我直接为你展示挂载时的 render 阶段结束后，commit 执行前，两棵 Fiber 树的形态，如下图所示：</p>\n<p data-nodeid="4732"><img src="https://s0.lgstatic.com/i/image/M00/73/AD/Ciqc1F_GK5KAPsNRAADXbk-KIQg893.png" alt="图片14.png" data-nodeid="4917"></p>\n<p data-nodeid="4733">待 commit 阶段完成后，右侧的 workInProgress 树对应的 DOM 树就被真正渲染到了页面上，此时 current 指针会指向 workInProgress 树：</p>\n<p data-nodeid="4734"><img src="https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GImqABNjLAACxddF2jhY942.png" alt="Drawing 5.png" data-nodeid="4921"></p>\n<p data-nodeid="4735">由于挂载是一个从无到有的过程，在这个过程中我们是在不断地创建新节点，因此还谈不上什么“节点复用”。节点复用要到更新过程中去看。</p>\n<h5 data-nodeid="4736">第一次更新</h5>\n<p data-nodeid="4737">现在我点击数字 0，触发一次更新。这次更新中，下图高亮的 rootFiber 节点就会被复用：</p>\n<p data-nodeid="4738"><img src="https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GInGAAhaiAADrvJFiOdA159.png" alt="Drawing 7.png" data-nodeid="4927"></p>\n<p data-nodeid="4739">这段复用的逻辑在 beginWork 调用链路中的 createWorkInProgress 方法里。这里我为你截取了 createWorkInProgress 方法里面一段非常关键的逻辑，请看下图：</p>\n<p data-nodeid="4740"><img src="https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GIneAPBZcAAKQF1HrIv0329.png" alt="Drawing 8.png" data-nodeid="4931"></p>\n<p data-nodeid="4741">在 createWorkInProgress 方法中，会先取当前节点的 alternate 属性，将其记为 workInProgress 节点。对于 rootFiber 节点来说，它的 alternate 属性，其实就是上一棵 current 树的 rootFiber，如下图高亮部分所示：</p>\n<p data-nodeid="4742"><img src="https://s0.lgstatic.com/i/image/M00/73/A0/Ciqc1F_GIn2AK_7QAADrvJFiOdA218.png" alt="Drawing 10.png" data-nodeid="4935"></p>\n<p data-nodeid="4743"><strong data-nodeid="4940">当检查到上一棵 current 树的 rootFiber 存在时，React 会直接复用这个节点，让它作为下一棵 workInProgress 的节点存在下去</strong>，也就是说会走进 createWorkInProgress 的 else 逻辑里去。如果它和目标的 workInProgress 节点之间存在差异，直接在该节点上修改属性、使其与目标节点一致即可，而不必再创建新的 Fiber 节点。</p>\n<p data-nodeid="4744">至于剩下的 App、div、p 等节点，由于没有对应的 alternate 节点存在，因此它们的 createWorkInProgress 调用会走进下图高亮处的逻辑中：</p>\n<p data-nodeid="4745"><img src="https://s0.lgstatic.com/i/image/M00/73/A0/Ciqc1F_GIoSAIIE5AAJG_0ANgrg415.png" alt="Drawing 11.png" data-nodeid="4944"></p>\n<p data-nodeid="4746">在这段逻辑里，将调用 createFiber 来新建一个 FiberNode。</p>\n<p data-nodeid="4747">第一次更新结束后，我们会得到一棵新的 workInProgress Fiber 树，current 指针最后将会指向这棵新的 workInProgress Fiber 树，如下图所示：</p>\n<p data-nodeid="4748"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIouAVjKDAAEwJVqKwHY353.png" alt="Drawing 13.png" data-nodeid="4949"></p>\n<h5 data-nodeid="4749">第二次更新</h5>\n<p data-nodeid="4750">接下来我们再次点击数字 1，触发 state 的第二次更新。</p>\n<p data-nodeid="4751">在这次更新中，current 树中的每一个 alternate 属性都不为空（如上图所示）。因此每次通过 beginWork 触发 createWorkInProgress 调用时，都会一致地走入 else 里面的逻辑，也就是直接复用现成的节点。</p>\n<p data-nodeid="4752">以上便是 current 树和 work 树相互“打配合”，实现节点复用的过程。</p>\n<h3 data-nodeid="4753">更新链路要素拆解</h3>\n<p data-nodeid="4754">在上一讲，我们已经学习了挂载阶段的渲染链路。同步模式下的更新链路与挂载链路的 render 阶段基本是一致的，都是通过 performSyncWorkOnRoot 来触发包括 beginWork、completeWork 在内的深度优先搜索过程。这里我为你展示一个更新过程的调用栈，请看下图：</p>\n<p data-nodeid="4755"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIpSAfb9qAACwnR8L9Po005.png" alt="Drawing 14.png" data-nodeid="4958"></p>\n<p data-nodeid="4756">你会发现还是熟悉的配方，还是原来的味道。<strong data-nodeid="4968">其实，挂载可以理解为一种特殊的更新，ReactDOM.render 和 setState 一样，也是一种触发更新的姿势</strong>。在 React 中，ReactDOM.render、setState、useState 等方法都是可以触发更新的，这些方法发起的调用链路很相似，是因为它们最后“殊途同归”，<strong data-nodeid="4969">都会通过创建 update 对象来进入同一套更新工作流</strong>。</p>\n<h4 data-nodeid="4757">update 的创建</h4>\n<p data-nodeid="4758">接下来我继续以开篇的 Demo 为例，为你拆解更新链路中的要素。在点击数字后，点击相关的回调被执行，它首先触发的是 dispatchAction 这个方法，如下图所示：</p>\n<p data-nodeid="4759"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIpqAFVQWAAE4Rdg6o0g228.png" alt="Drawing 15.png" data-nodeid="4974"></p>\n<p data-nodeid="4760">请你关注图中两处标红的函数调用，你会看到 dispatchAction 方法在 performSyncWorkOnRoot 的左边。也就是说整体的更新链路应该是这样的：</p>\n<p data-nodeid="4761"><img src="https://s0.lgstatic.com/i/image/M00/73/A1/Ciqc1F_GIqKAP_3fAABp3EtlwDk160.png" alt="Drawing 16.png" data-nodeid="4978"></p>\n<p data-nodeid="4762">dispatchAction 中，会完成 update 对象的创建，如下图标红处所示：</p>\n<p data-nodeid="4763"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIqiAOf4aAAQVWAWjjt0722.png" alt="Drawing 17.png" data-nodeid="4982"></p>\n<h4 data-nodeid="4764">从 update 对象到 scheduleUpdateOnFiber</h4>\n<p data-nodeid="4765">等等，这段逻辑你是否觉得似曾相识？如果你对 ReactDOM.render 系列的第一课时还有印象的话，我希望你能回忆起 updateContainer 这个方法。在 updateContainer 中，React 曾经有过性质一模一样的行为，这里我为你截取了 updateContainer 函数中的相关逻辑：</p>\n<p data-nodeid="4766"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIrCAJiUaAACZL_H8ts8659.png" alt="Drawing 18.png" data-nodeid="4987"></p>\n<p data-nodeid="4767">图中这一段代码的逻辑是非常清晰的，以 enqueueUpdate 为界，它一共做了以下三件事。</p>\n<ol data-nodeid="4768">\n<li data-nodeid="4769">\n<p data-nodeid="4770">enqueueUpdate 之前：<strong data-nodeid="4994">创建 update</strong>。</p>\n</li>\n<li data-nodeid="4771">\n<p data-nodeid="4772">enqueueUpdate 调用：<strong data-nodeid="5004">将 update 入队</strong>。这里简单说下，每一个 Fiber 节点都会有一个属于它自己的 updateQueue，用于存储多个更新，这个 updateQueue 是以链表的形式存在的。在 render 阶段，<strong data-nodeid="5005">updateQueue 的内容会成为 render 阶段计算 Fiber 节点的新 state 的依据</strong>。</p>\n</li>\n<li data-nodeid="4773">\n<p data-nodeid="4774">scheduleUpdateOnFiber：<strong data-nodeid="5011">调度 update</strong>。如果你对之前学过的知识还有印象，会记得同步挂载链路中，这个方法后面紧跟的就是 performSyncWorkOnRoot 所触发的 render 阶段，如下图所示：</p>\n</li>\n</ol>\n<p data-nodeid="4775"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIrmAO5UJAABDaDLvIyM528.png" alt="Drawing 19.png" data-nodeid="5014"></p>\n<p data-nodeid="4776">现在我们再回过头来看 dispatchAction 的逻辑，你会发现 dispatchAction 里面同样有对这三个动作的处理。上面我对 dispatchAction 的局部截图，包含了对 update 对象的创建和入队处理。dispatchAction 的更新调度动作，在函数的末尾，如下图所示：</p>\n<p data-nodeid="4777"><img src="https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIsGADUaBAAAYE3Ps56g927.png" alt="Drawing 20.png" data-nodeid="5018"></p>\n<p data-nodeid="4778">这里有一个点需要提示一下：dispatchAction 中，<strong data-nodeid="5028">调度的是当前触发更新的节点</strong>，这一点和挂载过程需要区分开来。在挂载过程中，updateContainer 会直接调度根节点。其实，对于更新这种场景来说，<strong data-nodeid="5029">大部分的更新动作确实都不是由根节点触发的</strong>，而 render 阶段的起点则是根节点。因此在 scheduleUpdateOnFiber 中，有这样一个方法，见下图标红处：</p>\n<p data-nodeid="4779"><img src="https://s0.lgstatic.com/i/image/M00/73/A1/Ciqc1F_GIseASLuzAAVy6vkOrOA579.png" alt="Drawing 21.png" data-nodeid="5032"></p>\n<p data-nodeid="4780">markUpdateLaneFromFiberToRoot 将会从当前 Fiber 节点开始，向上遍历直至根节点，并将根节点返回。</p>\n<h4 data-nodeid="4781">scheduleUpdateOnFiber 如何区分同步还是异步？</h4>\n<p data-nodeid="4782">如果你对之前学过的同步渲染链路分析还有印象，相信你对下面这段逻辑不会陌生：</p>\n<p data-nodeid="4783"><img src="https://s0.lgstatic.com/i/image/M00/73/A1/Ciqc1F_GItCAerpyAAQXnhAd3k4018.png" alt="Drawing 22.png" data-nodeid="5038"></p>\n<p data-nodeid="4784">这是 scheduleUpdateOnFiber 中的一段逻辑。在同步的渲染链路中，lane === SyncLane 这个条件是成立的，因此会直接进入 performSyncWorkOnRoot 的逻辑，开启同步的 render 流程；而在异步渲染模式下，则将进入 else 的逻辑。</p>\n<p data-nodeid="4785">在 else 中，需要引起你注意的是 ensureRootIsScheduled 这个方法，该方法很关键，它将决定如何开启当前更新所对应的 render 阶段。在 ensureRootIsScheduled 中，有<a href="https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602" data-nodeid="5043">这样一段核心逻</a>辑（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="4786"><code data-language="java"><span class="hljs-keyword">if</span> (newCallbackPriority === SyncLanePriority) {\n    <span class="hljs-comment">// 同步更新的 render 入口</span>\n    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(<span class="hljs-keyword">null</span>, root));\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 将当前任务的 lane 优先级转换为 scheduler 可理解的优先级</span>\n    <span class="hljs-keyword">var</span> schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);\n    <span class="hljs-comment">// 异步更新的 render 入口</span>\n    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="hljs-keyword">null</span>, root));\n  }\n</code></pre>\n<p data-nodeid="4787">请你关注<strong data-nodeid="5054">performSyncWorkOnRoot 和 performConcurrentWorkOnRoot</strong> 这两个方法：<strong data-nodeid="5055">前者是同步更新模式下的 render 阶段入口；而后者是异步模式下的 render 阶段入口</strong>。</p>\n<p data-nodeid="4788">从这段逻辑中我们可以看出，React 会以当前更新任务的优先级类型为依据，决定接下来是调度 performSyncWorkOnRoot 还是 performConcurrentWorkOnRoot。这里调度任务用到的函数分别是 scheduleSyncCallback 和 scheduleCallback，<strong data-nodeid="5065">这两个函数在内部都是通过调用 unstable_scheduleCallback 方法来执行任务调度的</strong>。而 unstable_scheduleCallback 正是 Scheduler（调度器）中导出的一个核心方法，也是本讲的一个重点。</p>\n<p data-nodeid="4789">在解读 unstable_scheduleCallback 的工作原理之前，我们先来一起认识一下 Scheduler。</p>\n<h3 data-nodeid="4790">Scheduler——“时间切片”与“优先级”的幕后推手</h3>\n<p data-nodeid="4791">Scheduler 从架构上来看，是 Fiber 架构分层中的“调度层”；从实现上来看，它并非一段内嵌的逻辑，而是一个与 react-dom 同级的文件夹，如下图所示，其中收敛了所有相对通用的调度逻辑：</p>\n<p data-nodeid="4792"><img src="https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIt-AVQdjAAEHWIrq_Po945.png" alt="Drawing 23.png" data-nodeid="5073"></p>\n<p data-nodeid="4793">通过前面的学习，我们已经知道 Fiber 架构下的异步渲染（即 Concurrent 模式）的核心特征分别是“<strong data-nodeid="5083">时间切片</strong>”与“<strong data-nodeid="5084">优先级调度</strong>”。而这两点，也正是 Scheduler 的核心能力。接下来，我们就以这两个特征为线索，解锁 Scheduler 的工作原理。</p>\n<h4 data-nodeid="4794">结合 React 调用栈，理解时间切片现象</h4>\n<p data-nodeid="4795">在理解时间切片的实现原理之前，我们首先要搞清楚时间切片是一种什么样的现象。</p>\n<p data-nodeid="4796">在 ReactDOM.render 相关的课时中，我曾经强调过，同步渲染模式下的 render 阶段，是一个同步的、深度优先搜索的过程。同步的过程会带来什么样的麻烦呢？在第 12 讲中，大家已经从理论层面初步认识过这个问题。现在，我们直接通过调用栈来理解它，下面是一个渲染工作量相对比较大的 React Demo，代码如下：</p>\n<pre class="lang-js" data-nodeid="4797"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-number">0</span>)\n  <span class="hljs-keyword">const</span> renderContent = arr.map(\n    <span class="hljs-function">(<span class="hljs-params">i, index</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> <span class="hljs-attr">128</span>, <span class="hljs-attr">textAlign:</span> \'<span class="hljs-attr">center</span>\' }}&gt;</span>{`测试文本第${index}行`}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>\n  )\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>\n        {\n          renderContent\n        }\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;\n</code></pre>\n<p data-nodeid="4798">这个 App 组件会在界面上渲染出 1000 行文本，局部效果如下图所示：</p>\n<p data-nodeid="4799"><img src="https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIuyABtYCAABNHJ0zT3I546.png" alt="Drawing 24.png" data-nodeid="5091"></p>\n<p data-nodeid="4800">当我使用 ReactDOM.render 来渲染这个长列表时，它的调用栈如下图所示：</p>\n<p data-nodeid="4801"><img src="https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIvOALbOqAAOn8pi1lpw155.png" alt="Drawing 25.png" data-nodeid="5095"></p>\n<p data-nodeid="4802">在这张图中，你就不必再重复去关注 beginWork、completeWork 之流了，请把目光放在调用栈的上层，也就是图中标红的地方——一个不间断的灰色“Task”长条，对浏览器来说就意味着是一个<strong data-nodeid="5101">不可中断</strong>的任务。</p>\n<p data-nodeid="4803">在我的浏览器上，这个 Task 的执行时长在 130ms 以上（将鼠标悬浮在 Task 长条上就可以查看执行时长）。而<strong data-nodeid="5115">浏览器的刷新频率为 60Hz，也就是说每 16.6ms 就会刷新一次</strong>。在这 16.6ms 里，除了 JS 线程外，渲染线程也是有工作要处理的，<strong data-nodeid="5116">但超长的 Task 显然会挤占渲染线程的工作时间</strong>，引起“掉帧”，进而带来卡顿的风险，这也正是第 12 讲中所提到的“<strong data-nodeid="5117">JS 对主线程的超时占用</strong>”问题。</p>\n<p data-nodeid="4804">若将 ReactDOM.render 调用改为 createRoot 调用（即开启 Concurrent 模式），调用栈就会变成下面这样：</p>\n<p data-nodeid="4805"><img src="https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIvuATEYcAALRQfAuBFI173.png" alt="Drawing 26.png" data-nodeid="5121"></p>\n<p data-nodeid="4806">请继续将你的注意力放在顶层的 Task 长条上。</p>\n<p data-nodeid="4807">你会发现那一个不间断的 Task 长条（大任务），如今像是被“切”过了一样，已经变成了多个断断续续的 Task “短条”（小任务），单个短 Task 的执行时长在我的浏览器中是 5ms 左右。这些短 Task 的工作量加起来，和之前长 Task 工作量是一样的。但短 Task 之间留出的时间缝隙，却给了浏览器喘息的机会，这就是所谓的“时间切片”效果。</p>\n<h4 data-nodeid="4808">时间切片是如何实现的？</h4>\n<p data-nodeid="4809">在同步渲染中，循环创建 Fiber 节点、构建 Fiber 树的过程是由 <strong data-nodeid="5130">workLoopSync</strong> 函数来触发的。这里我们来复习一下 workLoopSync 的源码，请看下图：</p>\n<p data-nodeid="4810"><img src="https://s0.lgstatic.com/i/image/M00/73/AD/CgqCHl_GIwKAHTjDAACgXrFd5c0290.png" alt="Drawing 27.png" data-nodeid="5133"></p>\n<p data-nodeid="4811">在 workLoopSync 中，只要 workInProgress 不为空，while 循环就不会结束，它所触发的是一个同步的 performUnitOfWork 循环调用过程。</p>\n<p data-nodeid="4812">而在异步渲染模式下，这个循环是由 <strong data-nodeid="5140">workLoopConcurrent</strong> 来开启的。workLoopConcurrent 的工作内容和 workLoopSync 非常相似，仅仅在循环判断上有一处不同，请注意下图源码中标红部分：</p>\n<p data-nodeid="4813"><img src="https://s0.lgstatic.com/i/image/M00/73/AD/CgqCHl_GIwiAAsOJAADS76o4FHc058.png" alt="Drawing 28.png" data-nodeid="5143"></p>\n<p data-nodeid="4814">shouldYield 直译过来的话是“需要让出”。顾名思义，<strong data-nodeid="5149">当 shouldYield() 调用返回为 true 时，就说明当前需要对主线程进行让出了，此时 whille 循环的判断条件整体为 false，while 循环将不再继续</strong>。</p>\n<p data-nodeid="4815">那么这个 shouldYield 又是何方神圣呢？在源码中，我们可以寻得这样两行赋值语句：</p>\n<pre class="lang-java" data-nodeid="4816"><code data-language="java"><span class="hljs-keyword">var</span> Scheduler_shouldYield = Scheduler.unstable_shouldYield,\n......\n<span class="hljs-keyword">var</span> shouldYield = Scheduler_shouldYield;\n</code></pre>\n<p data-nodeid="4817">从这两行代码中我们可以看出，shouldYield 的本体其实是 <strong data-nodeid="5160">Scheduler.unstable_shouldYield</strong>，也就是 Scheduler 包中导出的 unstable_shouldYield 方法，该方法本身比较简单。其源码如下图标红处所示：</p>\n<p data-nodeid="4818"><img src="https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIxeAJas8AAEiY1Hfbsw871.png" alt="Drawing 29.png" data-nodeid="5163"></p>\n<p data-nodeid="4819">其中 unstable_now 这里实际取的就是 performance.now() 的值，即“<strong data-nodeid="5175">当前时间</strong>”。那么 deadline 又是什么呢？它可以被理解为<strong data-nodeid="5176">当前时间切片的到期时间</strong>，它的计算过程在 Scheduler 包中的 performWorkUntilDeadline 方法里可以找到，也就是下图的标红部分：</p>\n<p data-nodeid="4820"><img src="https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIx-AL94QAAHs2HJQXfA804.png" alt="Drawing 30.png" data-nodeid="5179"></p>\n<p data-nodeid="4821">在这行算式里，currentTime 是当前时间，yieldInterval 是<strong data-nodeid="5185">时间切片的长度</strong>。注意，时间切片的长度并不是一个常量，它是由 React 根据浏览器的帧率大小计算所得出来的，与浏览器的性能有关。</p>\n<p data-nodeid="4822">现在我们来总结一下时间切片的实现原理：React 会根据浏览器的帧率，计算出时间切片的大小，并结合当前时间计算出每一个切片的到期时间。在 workLoopConcurrent 中，while 循环每次执行前，会调用 shouldYield 函数来询问当前时间切片是否到期，若已到期，则结束循环、出让主线程的控制权。</p>\n<h4 data-nodeid="4823">优先级调度是如何实现的</h4>\n<p data-nodeid="4824">在“更新链路要素拆解”这一小节的末尾，我们已经知道，无论是 scheduleSyncCallback 还是 scheduleCallback，最终都是通过调用 <strong data-nodeid="5201">unstable_scheduleCallback</strong> 来发起调度的。unstable_scheduleCallback 是 Scheduler 导出的一个核心方法，它将<strong data-nodeid="5202">结合任务的优先级信息为其执行不同的调度逻辑</strong>。</p>\n<p data-nodeid="4825">接下来我们就结合源码，一起看看这个过程是如何实现的（解析在注释里）。</p>\n<pre class="lang-java" data-nodeid="4826"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">unstable_scheduleCallback</span><span class="hljs-params">(priorityLevel, callback, options)</span> </span>{\n  <span class="hljs-comment">// 获取当前时间</span>\n  <span class="hljs-keyword">var</span> currentTime = <span class="hljs-keyword">exports</span>.unstable_now();\n  <span class="hljs-comment">// 声明 startTime，startTime 是任务的预期开始时间</span>\n  <span class="hljs-keyword">var</span> startTime;\n  <span class="hljs-comment">// 以下是对 options 入参的处理</span>\n  <span class="hljs-keyword">if</span> (typeof options === <span class="hljs-string">\'object\'</span> &amp;&amp; options !== <span class="hljs-keyword">null</span>) {\n    <span class="hljs-keyword">var</span> delay = options.delay;\n\n    <span class="hljs-comment">// 若入参规定了延迟时间，则累加延迟时间</span>\n    <span class="hljs-keyword">if</span> (typeof delay === <span class="hljs-string">\'number\'</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) {\n      startTime = currentTime + delay;\n    } <span class="hljs-keyword">else</span> {\n      startTime = currentTime;\n    }\n  } <span class="hljs-keyword">else</span> {\n    startTime = currentTime;\n  }\n  <span class="hljs-comment">// timeout 是 expirationTime 的计算依据</span>\n  <span class="hljs-keyword">var</span> timeout;\n  <span class="hljs-comment">// 根据 priorityLevel，确定 timeout 的值</span>\n  <span class="hljs-keyword">switch</span> (priorityLevel) {\n    <span class="hljs-keyword">case</span> ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> NormalPriority:\n    <span class="hljs-keyword">default</span>:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      <span class="hljs-keyword">break</span>;\n  }\n  <span class="hljs-comment">// 优先级越高，timout 越小，expirationTime 越小</span>\n  <span class="hljs-keyword">var</span> expirationTime = startTime + timeout;\n\n  <span class="hljs-comment">// 创建 task 对象</span>\n  <span class="hljs-keyword">var</span> newTask = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    sortIndex: -<span class="hljs-number">1</span>\n  };\n\n  {\n    newTask.isQueued = <span class="hljs-keyword">false</span>;\n  }\n  <span class="hljs-comment">// 若当前时间小于开始时间，说明该任务可延时执行(未过期）</span>\n  <span class="hljs-keyword">if</span> (startTime &gt; currentTime) {\n    <span class="hljs-comment">// 将未过期任务推入 "timerQueue"</span>\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    <span class="hljs-comment">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span>\n    <span class="hljs-keyword">if</span> (peek(taskQueue) === <span class="hljs-keyword">null</span> &amp;&amp; newTask === peek(timerQueue)) {\n      ......\n          <span class="hljs-comment">// 那么就派发一个延时任务，这个延时任务用于检查当前任务是否过期</span>\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span>\n    newTask.sortIndex = expirationTime;\n    <span class="hljs-comment">// 过期的任务会被推入 taskQueue</span>\n    push(taskQueue, newTask);\n    ......\n\n    <span class="hljs-comment">// 执行 taskQueue 中的任务</span>\n    requestHostCallback(flushWork);\n  }\n  <span class="hljs-keyword">return</span> newTask;\n}\n</code></pre>\n<p data-nodeid="4827">从源码中我们可以看出，unstable_scheduleCallback 的主要工作是针对当前任务创建一个 task，然后结合 startTime 信息将这个 task 推入 <strong data-nodeid="5215">timerQueue</strong> 或 <strong data-nodeid="5216">taskQueue</strong>，最后根据 timerQueue 和 taskQueue 的情况，执行延时任务或即时任务。</p>\n<p data-nodeid="4828">要想理解这个过程，首先要搞清楚以下几个概念。</p>\n<ul data-nodeid="4829">\n<li data-nodeid="4830">\n<p data-nodeid="4831"><strong data-nodeid="5222">startTime</strong>：任务的开始时间。</p>\n</li>\n<li data-nodeid="4832">\n<p data-nodeid="4833"><strong data-nodeid="5227">expirationTime</strong>：这是一个和优先级相关的值，expirationTime 越小，任务的优先级就越高。</p>\n</li>\n<li data-nodeid="4834">\n<p data-nodeid="4835"><strong data-nodeid="5236">timerQueue</strong>：一个以 startTime 为排序依据的<strong data-nodeid="5237">小顶堆</strong>，它存储的是 startTime 大于当前时间（也就是待执行）的任务。</p>\n</li>\n<li data-nodeid="4836">\n<p data-nodeid="4837"><strong data-nodeid="5246">taskQueue</strong>：一个以 expirationTime 为排序依据的<strong data-nodeid="5247">小顶堆</strong>，它存储的是 startTime 小于当前时间（也就是已过期）的任务。</p>\n</li>\n</ul>\n<p data-nodeid="4838">这里的“小顶堆”概念可能会触及一部分同学的知识盲区，我简单解释下：堆是一种特殊的<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" data-nodeid="5251">完全二叉树</a>。如果对一棵完全二叉树来说，它每个结点的结点值都不大于其左右孩子的结点值，这样的完全二叉树就叫“<a href="https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%A0%86?fromtitle=%E5%B0%8F%E9%A1%B6%E5%A0%86&amp;fromid=4634212" data-nodeid="5255">小顶堆</a>”。小顶堆自身特有的插入和删除逻辑，<strong data-nodeid="5265">决定了无论我们怎么增删小顶堆的元素，其根节点一定是所有元素中值最小的一个节点</strong>。这样的性质，使得小顶堆经常被用于实现<a href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97" data-nodeid="5263">优先队列</a>。</p>\n<p data-nodeid="4839">结合小顶堆的特性，我们再来看源码中涉及 timerQueue 和 taskQueue 的操作，这段代码同时也是整个 unstable_scheduleCallback 方法中的核心逻辑：</p>\n<pre class="lang-java" data-nodeid="4840"><code data-language="java"><span class="hljs-comment">// 若当前时间小于开始时间，说明该任务可延时执行(未过期）</span>\n  <span class="hljs-keyword">if</span> (startTime &gt; currentTime) {\n    <span class="hljs-comment">// 将未过期任务推入 "timerQueue"</span>\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    <span class="hljs-comment">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span>\n    <span class="hljs-keyword">if</span> (peek(taskQueue) === <span class="hljs-keyword">null</span> &amp;&amp; newTask === peek(timerQueue)) {\n      ......\n          <span class="hljs-comment">// 那么就派发一个延时任务，这个延时任务用于将过期的 task 加入 taskQueue 队列</span>\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span>\n    newTask.sortIndex = expirationTime;\n    <span class="hljs-comment">// 过期的任务会被推入 taskQueue</span>\n    push(taskQueue, newTask);\n    ......\n\n    <span class="hljs-comment">// 执行 taskQueue 中的任务</span>\n    requestHostCallback(flushWork);\n  }\n</code></pre>\n<p data-nodeid="4841">若判断当前任务是待执行任务，那么该任务会在 sortIndex 属性被赋值为 startTime 后，被<strong data-nodeid="5274">推入 timerQueue</strong>。随后，会进入这样的一段判断逻辑：</p>\n<pre class="lang-java" data-nodeid="4842"><code data-language="java"><span class="hljs-comment">// 若 taskQueue 中没有可执行的任务，而当前任务又是 timerQueue 中的第一个任务</span>\n<span class="hljs-keyword">if</span> (peek(taskQueue) === <span class="hljs-keyword">null</span> &amp;&amp; newTask === peek(timerQueue)) {\n  ......\n    <span class="hljs-comment">// 那么就派发一个延时任务，这个延时任务用于将过期的 task 加入 taskQueue 队列</span>\n  requestHostTimeout(handleTimeout, startTime - currentTime);\n}\n</code></pre>\n<p data-nodeid="4843">要理解这段逻辑，首先需要理解 peek(xxx) 做了什么：peek() 的入参是一个小顶堆，它将取出这个小顶堆的堆顶元素。</p>\n<p data-nodeid="4844">taskQueue 里存储的是已过期的任务，peek(taskQueue) 取出的任务若为空，则说明 taskQueue 为空、当前并没有已过期任务。在没有已过期任务的情况下，会进一步判断 timerQueue，也就是未过期任务队列里的情况。</p>\n<p data-nodeid="4845">而通过前面的科普，大家已经知道了小顶堆是一个<strong data-nodeid="5290">相对有序</strong>的数据结构。timerQueue 作为一个小顶堆，它的排序依据其实正是 <strong data-nodeid="5291">sortIndex</strong> 属性的大小。这里的 sortIndex 属性取值为 startTime，<strong data-nodeid="5292">意味着小顶堆的堆顶任务一定是整个 timerQueue 堆结构里 startTime 最小的任务，也就是需要最早被执行的未过期任务</strong>。</p>\n<p data-nodeid="4846">若当前任务（newTask）就是 timerQueue 中需要最早被执行的未过期任务，那么 unstable_scheduleCallback 会通过调用 requestHostTimeout，为当前任务发起一个延时调用。</p>\n<p data-nodeid="4847">注意，这个延时调用（也就是 handleTimeout）<strong data-nodeid="5305">并不会直接调度执行当前任务</strong>——它的作用是在当前任务到期后，将其从 timerQueue 中取出，加入 taskQueue 中，然后触发对 flushWork 的调用。真正的调度执行过程是在 flushWork 中进行的。<strong data-nodeid="5306">flushWork 中将调用 workLoop，workLoop 会逐一执行 taskQueue 中的任务，直到调度过程被暂停（时间片用尽）或任务全部被清空</strong>。</p>\n<p data-nodeid="4848">以上便是针对未过期任务的处理。在这个基础上，我们不难理解 else 中，对过期任务的处理逻辑（也就是下面这段代码）：</p>\n<pre class="lang-java" data-nodeid="4849"><code data-language="java">{\n  <span class="hljs-comment">// else 里处理的是当前时间大于 startTime 的情况，说明这个任务已过期</span>\n  newTask.sortIndex = expirationTime;\n  <span class="hljs-comment">// 过期的任务会被推入 taskQueue</span>\n  push(taskQueue, newTask);\n  ......\n  <span class="hljs-comment">// 执行 taskQueue 中的任务</span>\n  requestHostCallback(flushWork);\n}\n</code></pre>\n<p data-nodeid="4850">与 timerQueue 不同的是，taskQueue 是一个以 expirationTime 为 sortIndex（排序依据）的小顶堆。对于已过期任务，React 在将其推入 taskQueue 后，会通过 requestHostCallback(flushWork) 发起一个针对 flushWork 的即时任务，而 flushWork 会执行 taskQueue 中过期的任务。</p>\n<p data-nodeid="4851">从 React 17.0.0 源码来看，当下 React 发起 Task 调度的姿势有两个：<strong data-nodeid="5322">setTimeout</strong>、<strong data-nodeid="5323">MessageChannel</strong>。在宿主环境不支持 MessageChannel 的情况下，会降级到 setTimeout。但不管是 setTimeout 还是 MessageChannel，它们发起的都是<strong data-nodeid="5324">异步任务</strong>。</p>\n<p data-nodeid="4852">因此 &nbsp;requestHostCallback 发起的“即时任务”最早也要等到<strong data-nodeid="5330">下一次事件循环</strong>才能够执行。“即时”仅仅意味它相对于“延时任务”来说，不需要等待指定的时间间隔，并不意味着同步调用。</p>\n<p data-nodeid="4853">这里为了方便大家理解，我将 unstable_scheduleCallback 方法的工作流总结进一张大图：</p>\n<p data-nodeid="4854"><img src="https://s0.lgstatic.com/i/image/M00/73/AE/CgqCHl_GIzeAHilIAAFT8rmskL8314.png" alt="Drawing 32.png" data-nodeid="5336"></p>\n<p data-nodeid="4855" class="">这张大图需要结合楼上的文字解析一起消化，如果你是跳读至此，还请回到文章中细嚼慢咽~^_^</p>\n<h3 data-nodeid="4856">总结</h3>\n<p data-nodeid="4857">这一讲我们首先认识了“双缓存”模式在 Fiber 架构下的实现，接着对更新链路的种种要素进行了拆解，理解了挂载 / 更新等动作的本质。最后，我们结合源码对 Scheduler（调度器）的核心能力，也就是“时间切片”和“优先级调度”两个方面进行了剖析，最终揭开了 Fiber 架构异步渲染的神秘面纱，理解了 Concurrent 模式背后的实现逻辑。</p>\n<p data-nodeid="4858" class="">到这里，关于 Fiber 架构的探讨，就要告一段落了。下一讲将讲解“特别的事件系统：React 事件与 DOM 事件有何不同”，到时见~</p>',
          },
          {
            theme: '17 | 特别的事件系统：React 事件与 DOM 事件有何不同？',
            id: 218,
            content:
              '<p data-nodeid="2361" class="">相信不少小伙伴在进阶 React 的过程中都会或多或少地了解到这样一件事情：<strong data-nodeid="2497">React 有着自成一派的事件系统</strong>，它和 DOM 原生事件系统不一样。但到底哪里不一样，却很少有人能够一五一十地说清楚。</p>\n<p data-nodeid="2362">开篇我们曾经说过，对于不同的知识，需要采取不同的学习策略。就 React 事件系统来说，它涉及的源码量不算小，相关逻辑也不够内聚，整体的理解成本相对较高，可能不少人都被劝退过。</p>\n<p data-nodeid="2363">幸运的是，无论是在面试场景下，还是在实际的开发中，React 事件相关的问题都更倾向于考验我们对事件工作流、事件特征等<strong data-nodeid="2504">逻辑层面问题</strong>的理解，而非对源码细节的把握。而事件工作流、事件特征等逻辑层面的“主要矛盾”，正是我们本讲探讨的重点。</p>\n<p data-nodeid="2364">不管你曾经被 React 源码劝退过多少次，我想只要能好好把握住这一讲，拿下事件系统对你来说仍将是小菜一碟。所以说大家不要怕，跟着我的思路走就完了。</p>\n<p data-nodeid="2365">作为团队前端框架方向的负责人，我曾经在自研框架的初期，从 React 事件系统相关的设计思想中受益良多。在这一讲，我将基于自己对源码的理解，为你介绍 React 事件系统的工作逻辑。</p>\n<blockquote data-nodeid="2366">\n<p data-nodeid="2367">注：本文逻辑提取自 React 16.13.x。随着 React 版本的更迭，事件系统的实现细节难免有调整，但其设计思想总是一脉相承的，你只要把握住核心逻辑即可。</p>\n</blockquote>\n<h3 data-nodeid="2368">回顾原生 DOM 下的事件流</h3>\n<p data-nodeid="2369">这些年在考察候选人的过程中，我发现了一件非常有趣的事情：一些同学提起前端框架时能够滔滔不绝，可说到 DOM 基础时却开始胡言乱语。这或许只有在当下这个前端发展阶段才会有的魔幻现实主义现象，但<strong data-nodeid="2514">要想理解好 React 事件机制，就必须对原生 DOM 事件流有扎实的掌握</strong>。因此在文章的开篇，我们先来简单复习一下 DOM 事件流是如何工作的。</p>\n<p data-nodeid="2370">在浏览器中，我们通过事件监听来实现 JS 和 HTML 之间的交互。一个页面往往会被绑定许许多多的事件，而页面接收事件的顺序，就是<strong data-nodeid="2520">事件流</strong>。</p>\n<p data-nodeid="2371">W3C 标准约定了一个事件的传播过程要经过以下 3 个阶段：</p>\n<ol data-nodeid="2372">\n<li data-nodeid="2373">\n<p data-nodeid="2374">事件捕获阶段</p>\n</li>\n<li data-nodeid="2375">\n<p data-nodeid="2376">目标阶段</p>\n</li>\n<li data-nodeid="2377">\n<p data-nodeid="2378">事件冒泡阶段</p>\n</li>\n</ol>\n<p data-nodeid="2379">理解这个过程最好的方式就是读图了，下图是一棵 DOM 树的结构简图，图中的箭头就代表着事件的“穿梭”路径。</p>\n<p data-nodeid="2380"><img src="https://s0.lgstatic.com/i/image/M00/78/7B/Ciqc1F_KCc2AH3SuAADAfZ2rEXk066.png" alt="Drawing 1.png" data-nodeid="2528"></p>\n<p data-nodeid="2381">当事件被触发时，首先经历的是一个捕获过程：事件会从最外层的元素开始“穿梭”，逐层“穿梭”到最内层元素，这个过程会持续到事件抵达它目标的元素（也就是真正触发这个事件的元素）为止；此时事件流就切换到了“目标阶段”——事件被目标元素所接收；然后事件会被“回弹”，进入到冒泡阶段——它会沿着来时的路“逆流而上”，一层一层再走回去。</p>\n<p data-nodeid="2382">这个过程很像我们小时候玩的蹦床：从高处下落，触达蹦床后再弹起、回到高处，整个过程呈一个对称的“V”字形。</p>\n<p data-nodeid="2383"><img src="https://s0.lgstatic.com/i/image/M00/78/8F/Ciqc1F_KGs2AQ6VHAABqyZCa5L0820.png" alt="图片15.png" data-nodeid="2533"></p>\n<h3 data-nodeid="2384">DOM 事件流下的性能优化思路：事件委托</h3>\n<p data-nodeid="2385">在原生 DOM 中，事件委托（也叫事件代理）是一种重要的性能优化手段。这里我通过一道面试题，来快速地帮你回忆相关的知识。</p>\n<p data-nodeid="2386">请看下面这段代码：</p>\n<pre class="lang-js" data-nodeid="2387"><code data-language="js">&lt;!DOCTYPE html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta charset="UTF-8"&gt;\n  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;\n  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;ul id="poem"&gt;\n    &lt;li&gt;床前明月光&lt;/li&gt;\n    &lt;li&gt;疑是地上霜&lt;/li&gt;\n    &lt;li&gt;举头望明月&lt;/li&gt;\n    &lt;li&gt;低头思故乡&lt;/li&gt;\n    &lt;li&gt;锄禾日当午&lt;/li&gt;\n    &lt;li&gt;汗滴禾下土&lt;/li&gt;\n    &lt;li&gt;谁知盘中餐&lt;/li&gt;\n    &lt;li&gt;粒粒皆辛苦&lt;/li&gt;\n    &lt;li&gt;背不动了&lt;/li&gt;\n    &lt;li&gt;我背不动了&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p data-nodeid="2388">问：<strong data-nodeid="2542">在这段 HTML 渲染出的界面里，我希望做到点击每一个 li 元素，都能输出它内在的文本内容。你会怎么做</strong>？</p>\n<p data-nodeid="2389">一个比较直观的思路是让每一个 li 元素都去监听一个点击动作，按照这个思路写出来的代码是这样的：</p>\n<pre class="lang-js" data-nodeid="2390"><code data-language="js">&lt;script&gt;\n  <span class="hljs-comment">// 获取 li 列表</span>\n  <span class="hljs-keyword">var</span> liList = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">\'li\'</span>)\n  <span class="hljs-comment">// 逐个安装监听函数</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; liList.length; i++) {\n    liList[i].addEventListener(<span class="hljs-string">\'click\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{\n      <span class="hljs-built_in">console</span>.log(e.target.innerHTML)\n    })\n  }\n&lt;/script&gt;\n</code></pre>\n<p data-nodeid="2391">我们当然可以像这样给 10 个 li 安装 10 次监听函数，但这样不仅累，开销也大。10 个监听函数做的还都是一模一样的事情，也不够优雅。怎么办呢？<strong data-nodeid="2549">事件冒泡</strong>！</p>\n<p data-nodeid="2392">对于这 10 个 li 来说，无论点击动作发生在哪个 li 上，点击事件最终都会被冒泡到它们共同的父亲——ul 元素上去，所以我们完全可以让 ul 来帮忙感知这个点击事件。</p>\n<p data-nodeid="2393">既然 ul 可以帮忙感知事件，那它能不能帮忙处理事件呢？答案是能，因为我们有<strong data-nodeid="2556">e.target</strong>。ul 元素可以通过事件对象中的 target 属性，拿到实际触发事件的那个元素，针对这个元素分发事件处理的逻辑，做到真正的“委托”。</p>\n<p data-nodeid="2394">按照这个思路，我们就可以丢掉 for 循环来写代码了，以下是用事件代理来实现同样效果的代码：</p>\n<pre class="lang-js" data-nodeid="2395"><code data-language="js"><span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'poem\'</span>)\nul.addEventListener(<span class="hljs-string">\'click\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{\n  <span class="hljs-built_in">console</span>.log(e.target.innerHTML)\n})\n</code></pre>\n<p data-nodeid="2396">这里再强调一下 e.target 这个属性，它指的是触发事件的具体目标，它记录着<strong data-nodeid="2563">事件的源头</strong>。所以说，不管咱们的监听函数在哪一层执行，只要我拿到这个 e.target，就相当于拿到了真正触发事件的那个元素。拿到这个元素后，我们完全可以模拟出它的行为，实现无差别的监听效果。</p>\n<p data-nodeid="2397">像这样利用事件的冒泡特性，<strong data-nodeid="2569">把多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理的行为，就是事件委托</strong>。通过事件委托，我们可以减少内存开销、简化注册步骤，大大提高开发效率。</p>\n<p data-nodeid="2398">这绝妙的事件委托，正是 React<strong data-nodeid="2575">合成事件</strong>的灵感源泉。</p>\n<h3 data-nodeid="2399">React 事件系统是如何工作的</h3>\n<p data-nodeid="2400">React 的事件系统沿袭了事件委托的思想。在 React 中，除了少数特殊的不可冒泡的事件（比如媒体类型的事件）无法被事件系统处理外，绝大部分的事件都不会被绑定在具体的元素上，而是统一被绑定在页面的 document 上。<strong data-nodeid="2582">当事件在具体的 DOM 节点上被触发后，最终都会冒泡到 document 上，document 上所绑定的统一事件处理程序会将事件分发到具体的组件实例</strong>。</p>\n<p data-nodeid="2401">在分发事件之前，React 首先会对事件进行包装，把原生 DOM 事件包装成<strong data-nodeid="2588">合成事件</strong>。</p>\n<h4 data-nodeid="2402">认识 React 合成事件</h4>\n<p data-nodeid="2403">合成事件是 React 自定义的事件对象，它符合<a href="https://www.w3.org/TR/DOM-Level-3-Events/" data-nodeid="2593">W3C</a>规范，<strong data-nodeid="2603">在底层抹平了不同浏览器的差异</strong>，<strong data-nodeid="2604">在上层面向开发者暴露统一的、稳定的、与 DOM 原生事件相同的事件接口</strong>。开发者们由此便不必再关注烦琐的兼容性问题，可以专注于业务逻辑的开发。</p>\n<p data-nodeid="4142" class=""><strong data-nodeid="4151">虽然合成事件并不是原生 DOM 事件，但它保存了原生 DOM 事件的引用</strong>。当你需要访问原生 DOM 事件对象时，可以通过合成事件对象的 <strong data-nodeid="4152">e.nativeEvent</strong> 属性获取到它，如下图所示：</p>\n\n\n<p data-nodeid="2405"><img src="https://s0.lgstatic.com/i/image/M00/78/86/CgqCHl_KCfyAEJw8AAFeUK36DtI133.png" alt="Drawing 4.png" data-nodeid="2617"></p>\n<p data-nodeid="2406">e.nativeEvent 将会输出 MouseEvent 这个原生事件，如下图所示：</p>\n<p data-nodeid="2407"><img src="https://s0.lgstatic.com/i/image/M00/78/86/CgqCHl_KCgOAZixsAACyXDjo4cs933.png" alt="Drawing 5.png" data-nodeid="2621"></p>\n<p data-nodeid="2408">到这里，大家就对 React 事件系统的基本原理，包括合成事件的基本概念有了一定的了解。接下来，我们将在此基础上结合 React 源码和调用栈，对事件系统的工作流进行深入的拆解。</p>\n<h3 data-nodeid="2409">React 事件系统工作流拆解</h3>\n<p data-nodeid="2410">既然是事件系统，那就逃不出“事件绑定”和“事件触发”这两个关键动作。首先让我们一起来看看事件的绑定是如何实现的。</p>\n<h4 data-nodeid="2411">事件的绑定</h4>\n<p data-nodeid="2412">事件的绑定是在组件的挂载过程中完成的，具体来说，<strong data-nodeid="2631">是在 completeWork 中完成的</strong>。关于 completeWork，我们已经在第 15 讲中学习过它的工作原理，这里需要你回忆起来的是 completeWork 中的以下三个动作：</p>\n<blockquote data-nodeid="5333">\n<p data-nodeid="5334" class="">completeWork 内部有三个关键动作：<strong data-nodeid="5348">创建</strong> DOM 节点（createInstance）、将 DOM 节点<strong data-nodeid="5349">插入</strong>到 DOM 树中（appendAllChildren）、为 DOM 节点<strong data-nodeid="5350">设置属性</strong>（finalizeInitialChildren）。</p>\n</blockquote>\n\n<p data-nodeid="2415">其中“为 DOM 节点**设置属性”**这个环节，会遍历 FiberNode 的 props key。当遍历到事件相关的 props 时，就会触发事件的注册链路。整个过程涉及的函数调用栈如下图所示：</p>\n<p data-nodeid="2416"><img src="https://s0.lgstatic.com/i/image/M00/78/7B/Ciqc1F_KCi-ANLdOAACnuwItpnA575.png" alt="Drawing 6.png" data-nodeid="2657"></p>\n<p data-nodeid="2417">这些函数之间是如何各司其职、打好“配合”的呢？请看下面这张工作流大图：</p>\n<p data-nodeid="2418"><img src="https://s0.lgstatic.com/i/image/M00/78/87/CgqCHl_KCjaALFKsAAHNjlT3rrw342.png" alt="Drawing 8.png" data-nodeid="2661"></p>\n<p data-nodeid="2419">从图中可以看出，<strong data-nodeid="2667">事件的注册过程是由 ensureListeningTo 函数开启的</strong>。在 ensureListeningTo 中，会尝试获取当前 DOM 结构中的根节点（这里指的是 document 对象），然后通过调用 legacyListenToEvent，将统一的事件监听函数注册到 document 上面。</p>\n<p data-nodeid="2420">在 legacyListenToEvent 中，实际上是通过调用 legacyListenToTopLevelEvent 来处理事件和 document 之间的关系的。 legacyListenToTopLevelEvent 直译过来是“监听顶层的事件”，这里的“顶层”就可以理解为事件委托的最上层，也就是 document 节点。在 legacyListenToTopLevelEvent 中，有这样一段逻辑值得我们注意，请看下图：</p>\n<p data-nodeid="2421"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KCj6ABv8CAAMpWS1ws8Q056.png" alt="Drawing 9.png" data-nodeid="2671"></p>\n<p data-nodeid="2422">listenerMap 是在 legacyListenToEvent 里创建/获取的一个数据结构，它将记录<strong data-nodeid="2677">当前 document 已经监听了哪些事件</strong>。在 legacyListenToTopLevelEvent 逻辑的起点，会首先判断 listenerMap.has(topLevelType) 这个条件是否为 true。</p>\n<p data-nodeid="2423">这里插播一个小的前置知识：topLevelType 在 legacyListenToTopLevelEvent 的函数上下文中代表<strong data-nodeid="2683">事件的类型</strong>，比如说我尝试监听的是一个点击事件，那么 topLevelType 的值就会是 click，如下图所示：</p>\n<p data-nodeid="2424"><img src="https://s0.lgstatic.com/i/image/M00/78/87/CgqCHl_KCkWACHkwAACydURG2fM056.png" alt="Drawing 10.png" data-nodeid="2686"></p>\n<p data-nodeid="2425">若事件系统识别到 listenerMap.has(topLevelType) 为 true，也就是当前这个事件 document 已经监听过了，那么就会直接跳过对这个事件的处理，否则才会进入具体的事件监听逻辑。如此一来，<strong data-nodeid="2692">即便我们在 React 项目中多次调用了对同一个事件的监听，也只会在 document 上触发一次注册</strong>。</p>\n<p data-nodeid="2426"><strong data-nodeid="2701">为什么针对同一个事件，即便可能会存在多个回调，document 也只需要注册一次监听</strong>？因为 React<strong data-nodeid="2702">最终注册到 document 上的并不是某一个 DOM 节点上对应的具体回调逻辑，而是一个统一的事件分发函数</strong>。这里我将断点打在事件监听函数的绑定动作上，请看下图：</p>\n<p data-nodeid="2427"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KCk-Afe7QAADMlUnc-KU093.png" alt="Drawing 11.png" data-nodeid="2705"></p>\n<p data-nodeid="2428">在这段逻辑中，element 就是 document 这个 DOM 元素，如下图所示，它在 legacyListenToEvent 阶段被获取后，又被层层的逻辑传递到了这个位置。</p>\n<p data-nodeid="2429"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KClaATXVLAAAhVJ6fu48519.png" alt="Drawing 12.png" data-nodeid="2709"></p>\n<p data-nodeid="2430">addEventListener 就更不用多说了，它是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" data-nodeid="2713">原生 DOM 里专门用来注册事件监听器的接口</a>。我们真正需要关注的是图中这个函数的前两个入参，首先看 eventType，它表示事件的类型，这里我监听的是一个点击事件，因此 eventType 就是 click（见下图的运行时输出结果）。</p>\n<p data-nodeid="2431"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KCl-AQUfuAAA3s44GMaI290.png" alt="Drawing 13.png" data-nodeid="2717"></p>\n<p data-nodeid="2432">重点在 listener 上，前面刚说过，最终注册到 document 上的是一个<strong data-nodeid="2723">统一的事件分发函数</strong>，这个函数到底长啥样？我们来看看，以下是运行时的 listener 输出结果：</p>\n<p data-nodeid="2433"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KCmeARunyAACxP1sCnKY948.png" alt="Drawing 14.png" data-nodeid="2726"></p>\n<p data-nodeid="2434">可以看到，<strong data-nodeid="2732">listener 本体是一个名为 dispatchDiscreteEvent 的函数</strong>。事实上，根据情况的不同，listener 可能是以下 3 个函数中的任意一个：</p>\n<ol data-nodeid="2435">\n<li data-nodeid="2436">\n<p data-nodeid="2437">dispatchDiscreteEvent</p>\n</li>\n<li data-nodeid="2438">\n<p data-nodeid="2439">dispatchUserBlockingUpdate</p>\n</li>\n<li data-nodeid="2440">\n<p data-nodeid="2441">dispatchEvent</p>\n</li>\n</ol>\n<p data-nodeid="2442">dispatchDiscreteEvent 和 dispatchUserBlockingUpdate 的不同，主要体现在对优先级的处理上，对事件分发动作倒没什么影响。无论是 dispatchDiscreteEvent 还是 dispatchUserBlockingUpdate，它们最后都是通过调用 dispatchEvent 来执行事件分发的。<strong data-nodeid="2741">因此可以认为，最后绑定到 document 上的这个统一的事件分发函数，其实就是 dispatchEvent</strong>。</p>\n<p data-nodeid="2443">那么 dispatchEvent 是如何实现事件分发的呢？</p>\n<h4 data-nodeid="2444">事件的触发</h4>\n<p data-nodeid="2445">事件触发的本质是对 dispatchEvent 函数的调用。由于 dispatchEvent 触发的调用链路较长，中间涉及的要素也过多，因此我们这里不再逐个跟踪函数的调用栈，直接来看核心工作流，请看下图：</p>\n<p data-nodeid="2446"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KCneAfMZbAAE9PxK7X3w813.png" alt="Drawing 15.png" data-nodeid="2747"></p>\n<p data-nodeid="2447">工作流中前三步我们在前面都有所提及，对你来说相对难以理解的应该是 4、5、6 这三步，这三步也是我们接下来讲解的重点。</p>\n<h4 data-nodeid="2448">事件回调的收集与执行</h4>\n<p data-nodeid="2449">我们借助一个 Demo 来理解这个过程，Demo 组件代码如下：</p>\n<pre class="lang-js" data-nodeid="2450"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">const</span> [state, setState] = useState(<span class="hljs-number">0</span>)\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(\'捕获经过 div\')} onClick={() =&gt; console.log(\'冒泡经过 div\')} className="container"&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> <span class="hljs-attr">128</span>, <span class="hljs-attr">textAlign:</span> \'<span class="hljs-attr">center</span>\' }}&gt;</span>\n          {state}\n        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">width:</span> <span class="hljs-attr">128</span> }} <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> { setState(state + 1) }}&gt;点击+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;\n</code></pre>\n<p data-nodeid="2451">这个组件对应的界面如下图所示：</p>\n<p data-nodeid="2452"><img src="https://s0.lgstatic.com/i/image/M00/78/87/CgqCHl_KCoaAHCSUAAAdOFZY7GY194.png" alt="Drawing 16.png" data-nodeid="2754"></p>\n<p data-nodeid="2453">界面中渲染出来的是一行数字文本和一个按钮，每点击一下按钮，数字文本会 +1。在 JSX 结构中，监听点击事件的除了 button 按钮外，还有 id 为 container 的 div 元素，这个 div 元素同时监听了点击事件的冒泡和捕获。</p>\n<p data-nodeid="2454">App 组件对应的 Fiber 树结构如下图所示：</p>\n<p data-nodeid="2455"><img src="https://s0.lgstatic.com/i/image/M00/78/87/CgqCHl_KCuSAdlxpAADdtt6LkCw620.png" alt="Drawing 18.png" data-nodeid="2759"></p>\n<p data-nodeid="2456">接下来我们借助这张 Fiber 树结构图来理解事件回调的收集过程。</p>\n<p data-nodeid="2457">首先我们来看收集过程对应的源码逻辑，这部分逻辑在 traverseTwoPhase 函数中，源码如下（解析在注释里）：</p>\n<pre class="lang-js" data-nodeid="2458"><code data-language="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseTwoPhase</span>(<span class="hljs-params">inst, fn, arg</span>) </span>{\n  <span class="hljs-comment">// 定义一个 path 数组</span>\n  <span class="hljs-keyword">var</span> path = [];\n\n  <span class="hljs-keyword">while</span> (inst) {\n    <span class="hljs-comment">// 将当前节点收集进 path 数组</span>\n    path.push(inst);\n    <span class="hljs-comment">// 向上收集 tag===HostComponent 的父节点</span>\n    inst = getParent(inst);\n  }\n  <span class="hljs-keyword">var</span> i;\n  <span class="hljs-comment">// 从后往前，收集 path 数组中会参与捕获过程的节点与对应回调</span>\n  <span class="hljs-keyword">for</span> (i = path.length; i-- &gt; <span class="hljs-number">0</span>;) {\n    fn(path[i], <span class="hljs-string">\'captured\'</span>, arg);\n  }\n\n  <span class="hljs-comment">// 从前往后，收集 path 数组中会参与冒泡过程的节点与对应回调</span>\n  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; path.length; i++) {\n    fn(path[i], <span class="hljs-string">\'bubbled\'</span>, arg);\n  }\n}\n</code></pre>\n<p data-nodeid="2459">traverseTwoPhase 函数做了以下三件事情。</p>\n<p data-nodeid="2460"><strong data-nodeid="2768">1. 循环收集符合条件的父节点，存进 path 数组中</strong></p>\n<p data-nodeid="2461">traverseTwoPhase<strong data-nodeid="2774">会以当前节点（触发事件的目标节点）为起点，不断向上寻找 tag===HostComponent 的父节点，并将这些节点按顺序收集进 path 数组中</strong>。其中 tag===HostComponent 这个条件是在 getParent() 函数中管控的。</p>\n<p data-nodeid="2462"><strong data-nodeid="2787">为什么一定要求 tag===HostComponent 呢</strong>？前面介绍渲染链路时，我们曾经讲过，<strong data-nodeid="2788">HostComponent 是 DOM 元素对应的 Fiber 节点类型</strong>。此处限制 tag===HostComponent，也就是说<strong data-nodeid="2789">只收集 DOM 元素对应的 Fiber 节点</strong>。之所以这样做，是因为浏览器只认识 DOM 节点，浏览器事件也只会在 DOM 节点之间传播，收集其他节点是没有意义的。</p>\n<p data-nodeid="30173" class="">将这个过程对应到 Demo 示例的 Fiber 树中来看，button 节点是事件触发的起点，在它的父节点中，符合 tag===HostComponent 这个条件的只有 div#container 和 div.App（即下图高亮处）。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<p data-nodeid="2464"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KCz6AFPppAADdoA4lHx0444.png" alt="image (5).png" data-nodeid="2793"></p>\n<p data-nodeid="2465">因此最后收集上来的 path 数组内容就是 div#container、div.App 及 button 节点自身（button 节点别忘了，它是 while 循环的起点，一开始就会被推进 path 数组），如下图所示：</p>\n<p data-nodeid="2466"><img src="https://s0.lgstatic.com/i/image/M00/78/7C/Ciqc1F_KC0SAHu4MAAC4V-Al5nU582.png" alt="Drawing 20.png" data-nodeid="2797"></p>\n<p data-nodeid="2467"><strong data-nodeid="2803">2. 模拟事件在捕获阶段的传播顺序，收集捕获阶段相关的节点实例与回调函数</strong></p>\n<p data-nodeid="2468">接下来，traverseTwoPhase 会<strong data-nodeid="2809">从后往前遍历 path 数组，模拟事件的捕获顺序，收集事件在捕获阶段对应的回调与实例</strong>。</p>\n<p data-nodeid="2469">前面咱们说 path 数组是从子节点出发，向上收集得来的。所以说<strong data-nodeid="2815">path 数组中子节点在前，祖先节点在后</strong>。</p>\n<p data-nodeid="2470">从后往前遍历 path 数组，<strong data-nodeid="2837">其实就是从父节点往下遍历子节点，直至遍历到目标节点的过程</strong>，<strong data-nodeid="2838">这个遍历顺序和事件在捕获阶段的传播顺序是一致的</strong>。在遍历的过程中，fn 函数会对每个节点的回调情况进行检查，若该节点上对应当前事件的<strong data-nodeid="2839">捕获回调</strong>不为空，那么节点实例会被收集到合成事件的 _dispatchInstances 属性（也就是 SyntheticEvent._dispatchInstances）中去，事件回调则会被收集到合成事件的 _dispatchListeners 属性（也就是 SyntheticEvent._dispatchListeners） 中去，等待后续的执行。</p>\n<p data-nodeid="2471"><strong data-nodeid="2845">3. 模拟事件在冒泡阶段的传播顺序，收集冒泡阶段相关的节点实例与回调函数</strong></p>\n<p data-nodeid="2472">捕获阶段的工作完成后，traverseTwoPhase 会<strong data-nodeid="2851">从后往前遍历 path 数组，模拟事件的冒泡顺序，收集事件在捕获阶段对应的回调与实例</strong>。</p>\n<p data-nodeid="2473">这个过程和步骤 2 基本是一样的，唯一的区别是对 path 数组的<strong data-nodeid="2869">倒序遍历变成了正序遍历</strong>。既然倒序遍历模拟的是捕获阶段的事件传播顺序，那么正序遍历自然模拟的就是<strong data-nodeid="2870">冒泡阶段</strong>的事件传播顺序。在正序遍历的过程中，同样会对每个节点的回调情况进行检查，若该节点上对应当前事件的<strong data-nodeid="2871">冒泡回调</strong>不为空，那么节点实例和事件回调同样会分别被收集到 SyntheticEvent._dispatchInstances 和 SyntheticEvent._dispatchListeners 中去。</p>\n<blockquote data-nodeid="2474">\n<p data-nodeid="2475">需要注意的是，当前事件对应的 SyntheticEvent 实例有且仅有一个，因此在模拟捕获和模拟冒泡这两个过程中，收集到的实例会被推入同一个 SyntheticEvent._dispatchInstances，收集到的事件回调也会被推入同一个 SyntheticEvent._dispatchListeners。</p>\n</blockquote>\n<p data-nodeid="33747" class="">这样一来，我们在事件回调的执行阶段，只需要按照顺序执行 SyntheticEvent._dispatchListeners 数组中的回调函数，就能够一口气模拟出整个完整的 DOM 事件流，也就是 <strong data-nodeid="33755">“捕获-目标-冒泡”这三个阶段</strong>。</p>\n\n\n\n\n\n<p data-nodeid="2477">接下来仍然是以 Demo 为例，我们来看看 button 上触发的点击事件对应的 SyntheticEvent 对象上的 _dispatchInstances 和 _dispatchListeners 各是什么内容，请看下图：</p>\n<p data-nodeid="2478"><img src="https://s0.lgstatic.com/i/image/M00/78/87/CgqCHl_KC1GAecTRAAFEgV7Sms0914.png" alt="Drawing 21.png" data-nodeid="2893"></p>\n<p data-nodeid="2479">可以看出，<strong data-nodeid="2906">_dispatchInstances 和 _dispatchListeners 两个数组中的元素是严格的一一对应关系</strong>，这确保了在回调的执行阶段，我们可以简单地通过索引来将实例与监听函数关联起来，实现事件委托的效果。同时，<strong data-nodeid="2907">两个数组中元素的排序，完美地契合了 DOM 标准中“捕获-目标-冒泡”这三个阶段的事件传播顺序</strong>，真是妙啊！</p>\n<h3 data-nodeid="2480">总结</h3>\n<p data-nodeid="2481">本讲我们在回顾原生 DOM 事件流的基础上，对 React 事件系统的工作流进行了学习。行文至此，相信你已经对 React 事件机制的实现原理有了通透的理解，此时不妨尝试问自己一个问题：既然到头来不过是基于合成事件在模拟 DOM 事件流，React 为什么不直接使用原生 DOM 提供的事件机制呢？</p>\n<p data-nodeid="2482">或者换个问法：<strong data-nodeid="2915">React 事件系统的设计动机是什么</strong>？</p>\n<p data-nodeid="2483">这里我结合个人的理解，给出两个思考的角度，希望能给你带来一些启发。</p>\n<ol data-nodeid="2484">\n<li data-nodeid="2485">\n<p data-nodeid="2486">首先一定要说的，也是 React 官方说明过的一点是：合成事件符合<a href="https://www.w3.org/TR/DOM-Level-3-Events/" data-nodeid="2920">W3C</a>规范，<strong data-nodeid="2930">在底层抹平了不同浏览器的差异</strong>，<strong data-nodeid="2931">在上层面向开发者暴露统一的、稳定的、与 DOM 原生事件相同的事件接口</strong>。开发者们由此便不必再关注烦琐的底层兼容问题，可以专注于业务逻辑的开发。</p>\n</li>\n<li data-nodeid="2487">\n<p data-nodeid="2488">此外，<strong data-nodeid="2941">自研事件系统使 React 牢牢把握住了事件处理的主动权</strong>：这一点其实和我们平时造轮子是一样的。我在牵头自研团队前端框架之前，首先问自己的问题也是“为什么需要自研？React 不好用吗？Vue 不香吗？”。<strong data-nodeid="2942">我们造轮子，很多时候并不是因为别人家的轮子不好，而是因为别人家的轮子没有办法 Match 我们的场景</strong>。拿 React 来说，举两个大家都比较熟悉的例子，比如说它想在事件系统中处理 Fiber 相关的优先级概念，或者想把多个事件揉成一个事件（比如 onChange 事件），原生 DOM 会帮它做吗？不会，因为原生讲究的就是个通用性。而 React 想要的则是“量体裁衣”，通过自研事件系统，React 能够从很大程度上干预事件的表现，使其符合自身的需求。</p>\n</li>\n</ol>\n<p data-nodeid="2489">我在社区的一些讨论中，曾经见到过“合成事件性能更好”这样的结论，该结论的推导过程往往是这样的：事件委托可以节省内存开销 → React 合成事件承袭了事件委托的思想 → 合成事件性能更好。对于这类观点，个人目前持保留意见。</p>\n<p data-nodeid="34934" class="te-preview-highlight">React 合成事件虽然承袭了事件委托的思想，但它的实现过程比传统的事件委托复杂太多。个人愚见，对 React 来说，事件委托主要的作用应该在于帮助 React <strong data-nodeid="34940">实现了对所有事件的中心化管控</strong>。至于 React 事件是否比不使用事件委托的原生 DOM 事件性能更好？没有严格的对比和大量测试数据做支撑，我们很难下结论，React 官方也从没有给出过类似的说法。严谨起见，这里不推荐大家以性能为切入点去把握合成事件的特征。</p>\n\n<p data-nodeid="2491" class="">关于 React 事件系统，就介绍到这里。从下一讲开始，我们将进入 Redux 的世界。</p>',
          },
        ],
      },
      {
        sectionName: '模块三：“周边生态”帮你拓宽技术视野',
        sectionId: 4,
        courseList: [
          {
            theme: '18 | 揭秘 Redux 设计思想与工作原理（上）',
            id: 219,
            content:
              '<p data-nodeid="1353" class="">Redux 相信大家或多或少都接触过，关于 Redux 的基础知识，第 05 讲已经有过铺垫。从本讲开始，我们将在此基础上，针对 Redux 进行更加系统和深入的学习。</p>\n<blockquote data-nodeid="1354">\n<p data-nodeid="1355">注：如果你没有接触过 Redux，点击<a href="https://www.redux.org.cn/" data-nodeid="1474">这里</a>可以快速上手。</p>\n</blockquote>\n<p data-nodeid="1356"><strong data-nodeid="1484">何谓“系统”的学习</strong>？系统的一个前提就是<strong data-nodeid="1485">建立必要的学习上下文</strong>，尝试理解事情的来龙去脉。</p>\n<p data-nodeid="1357">这些年不管是面试、还是帮读者答疑，我有一个很强烈的感受：很多人对 Redux 的基本操作很熟悉，甚至对它的运作机制也有所了解，但就是不明白为什么要用 Redux，更不清楚 Redux 到底解决了什么问题。因此在讲源码和原理之前，我们首先需要说清楚的是 Redux 的问题背景和架构思想。</p>\n<h3 data-nodeid="1358">Redux 背后的架构思想——认识 Flux 架构</h3>\n<p data-nodeid="1359">Redux 的设计在很大程度上受益于 Flux 架构，我们可以认为 Redux 是 Flux 的一种实现形式（虽然它并不严格遵循 Flux 的设定），理解 Flux 将帮助你更好地从抽象层面把握 Redux。</p>\n<p data-nodeid="1360">Flux 并不是一个具体的框架，它是一套由 Facebook 技术团队提出的应用架构，这套架构约束的是<strong data-nodeid="1494">应用处理数据的模式</strong>。在 Flux 架构中，一个应用将被拆分为以下 4 个部分。</p>\n<ul data-nodeid="1361">\n<li data-nodeid="1362">\n<p data-nodeid="1363"><strong data-nodeid="1507">View</strong>（<strong data-nodeid="1508">视图层</strong>）：用户界面。该用户界面可以是以任何形式实现出来的，React 组件是一种形式，Vue、Angular 也完全 OK。<strong data-nodeid="1509">Flux 架构与 React 之间并不存在耦合关系</strong>。</p>\n</li>\n<li data-nodeid="1364">\n<p data-nodeid="1365"><strong data-nodeid="1518">Action</strong>（<strong data-nodeid="1519">动作</strong>）：也可以理解为视图层发出的“消息”，它会触发应用状态的改变。</p>\n</li>\n<li data-nodeid="1366">\n<p data-nodeid="1367"><strong data-nodeid="1524">Dispatcher</strong>（派发器）：它负责对 action 进行分发。</p>\n</li>\n<li data-nodeid="1368">\n<p data-nodeid="1369"><strong data-nodeid="1529">Store</strong>（数据层）：它是存储应用状态的“仓库”，此外还会定义修改状态的逻辑。store 的变化最终会映射到 view 层上去。</p>\n</li>\n</ul>\n<p data-nodeid="1370">这 4 个部分之间的协作将通过下图所示的工作流规则来完成配合：</p>\n<p data-nodeid="1691" class=""><img src="https://s0.lgstatic.com/i/image/M00/7E/D2/CgqCHl_PX4iAVQDeAABqpNRcHXQ065.png" alt="图片1.png" data-nodeid="1694"></p>\n\n<p data-nodeid="1372">一个典型的 Flux 工作流是这样的：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面。</p>\n<blockquote data-nodeid="1373">\n<p data-nodeid="1374">值得注意的是，图中所有的箭头都是单向的，这也正是 Flux 架构最核心的一个特点——<strong data-nodeid="1540">单向数据流</strong>。</p>\n</blockquote>\n<p data-nodeid="1375">那么 Flux 架构的出现到底是为了解决什么问题呢？</p>\n<h3 data-nodeid="1376">Flux 架构到底解决了什么问题</h3>\n<p data-nodeid="1377">Flux 的核心特征是单向数据流，要想完全了解单向数据流的好处，我们需要先了解双向数据流带来了什么问题。</p>\n<h4 data-nodeid="1378">MVC 模式在前端场景下的局限性</h4>\n<p data-nodeid="1379">双向数据流最为典型的代表就是<strong data-nodeid="1550">前端场景下的 MVC 架构</strong>，该架构的示意图如下图所示：</p>\n<p data-nodeid="1380"><img src="https://s0.lgstatic.com/i/image/M00/7E/C5/CgqCHl_PVeKAMZaHAACLXZ2Co3Q900.png" alt="Drawing 3.png" data-nodeid="1553"></p>\n<p data-nodeid="1381">除了允许用户通过 View 层交互来触发流程以外，MVC 架构还有另外一种形式，即允许用户通过直接触发 Controller 逻辑来触发流程，这种模式下的架构关系如下图所示：</p>\n<p data-nodeid="1382"><img src="https://s0.lgstatic.com/i/image/M00/7E/BA/Ciqc1F_PVe2AaJt5AACCt5hpXUM704.png" alt="Drawing 5.png" data-nodeid="1557"></p>\n<p data-nodeid="1383">在 MVC 应用中，会涉及这 3 个部分：</p>\n<ul data-nodeid="1384">\n<li data-nodeid="1385">\n<p data-nodeid="1386">Model（模型），程序需要操作的数据或信息；</p>\n</li>\n<li data-nodeid="1387">\n<p data-nodeid="1388">View（视图），用户界面；</p>\n</li>\n<li data-nodeid="1389">\n<p data-nodeid="1390">Controller（控制器），用于连接 View 和 Model，管理 Model 与 View 之间的逻辑。</p>\n</li>\n</ul>\n<p data-nodeid="1391">原则上来说，三者的关系应该像上图一样，用户操作 View 后，由 Controller 来处理逻辑（或者直接触发 Controller 的逻辑），经过 Controller 将改变应用到 Model 中，最终再反馈到 View 上。在这个过程中，数据流应该是单向的。</p>\n<p data-nodeid="1392"><strong data-nodeid="1567">事实上，在许多服务端的 MVC 应用中，数据流确实能够保持单向。但是在前端场景下，实际的 MVC 应用要复杂不少，前端应用/框架往往出于交互的需要，允许 View 和 Model 直接通信</strong>。此时的架构关系就会变成下图这样：</p>\n<p data-nodeid="1393"><img src="https://s0.lgstatic.com/i/image/M00/7E/BA/Ciqc1F_PVfWAMialAACIyVXJabE467.png" alt="Drawing 7.png" data-nodeid="1570"></p>\n<p data-nodeid="1394">这就允许了双向数据流的存在。当业务复杂度较高时，数据流会变得非常混乱，出现类似下图这种情况：</p>\n<p data-nodeid="1395"><img src="https://s0.lgstatic.com/i/image/M00/7E/C5/CgqCHl_PVgWAcAkZAAFInClVHRM354.png" alt="Drawing 11.png" data-nodeid="1574"></p>\n<p data-nodeid="1396">图中我们的示例只有一个 Controller，但考虑到一个应用中还可能存在多个 Controller，实际的情况应该比上图还要复杂得多（尽管图示本身已经够复杂了）。</p>\n<p data-nodeid="1397">在如此复杂的依赖关系下，再小的项目变更也将伴随着不容小觑的风险——或许一个小小的改动，就会对整个项目造成“蝴蝶效应”般的巨大影响。如此混乱的修改来源，将会使得我们连 Bug 排查都无从下手，因为你很难区分出一个数据的变化到底是由哪个 Controller 或者哪个 View 引发的。</p>\n<p data-nodeid="1398">此时再回头看下 Flux 的架构模式，你应该多少能感受到其中的妙处。这里我们再来回顾一下 Flux 中的数据流模式，请看下图：</p>\n<p data-nodeid="2371" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/7E/D2/CgqCHl_PX5mAYUWaAABqpNRcHXQ626.png" alt="图片1.png" data-nodeid="2374"></p>\n\n<p data-nodeid="1400">Flux 最核心的地方在于<strong data-nodeid="1590">严格的单向数据流</strong>，在单向数据流下，<strong data-nodeid="1591">状态的变化是可预测的</strong>。如果 store 中的数据发生了变化，那么有且仅有一个原因，那就是由 Dispatcher 派发 Action 来触发的。这样一来，就从根本上避免了混乱的数据关系，使整个流程变得清晰简单。</p>\n<p data-nodeid="1401">不过这并不意味着 Flux 是完美的。事实上，Flux 对数据流的约束背后是不可忽视的成本：除了开发者的学习成本会提升外，Flux 架构还意味着项目中代码量的增加。</p>\n<p data-nodeid="1402">Flux 架构往往在复杂的项目中才会体现出它的优势和必要性。如果项目中的数据关系并不复杂，其实完全轮不到 Flux 登场，这一点对于 Redux 来说也是一样的。</p>\n<p data-nodeid="1403">现在你不妨结合 Flux 架构的特性，再去品味一遍 Redux 官方给出的这个定义：</p>\n<blockquote data-nodeid="1404">\n<p data-nodeid="1405">Redux 是 JavaScript 状态容器，它提供可预测的状态管理。</p>\n</blockquote>\n<p data-nodeid="1406">此时的你，想必更加能够体会“<strong data-nodeid="1601">可预测</strong>”这三个字背后的深意。</p>\n<h3 data-nodeid="1407">Redux 关键要素与工作流回顾</h3>\n<p data-nodeid="1408">Redux 库和 Flux 架构之间可以说是“你侬我侬”，虽然 Redux 在实现层面并没有按照 Flux 那一套来（比如 Flux 中允许多个 Store 存在，而 Redux 中只有一个 Store 等），但 Redux 在设计思想上确实和 Flux 一脉相承。</p>\n<p data-nodeid="1409">前面我们介绍的 Flux 架构的特征、解决问题的思路，包括使用场景方面的注意事项，完全可以迁移到 Redux 上来用。基于 Flux 的思想背景去理解 Redux 这个落地产物，你的学习曲线将会更加平滑一些。</p>\n<p data-nodeid="1410">接下来我们在介绍 Redux 的实现原理之前，先简单回顾一下它的关键要素与工作流。Redux 主要由 3 部分组成：Store、Reducer 和 Action。</p>\n<ul data-nodeid="1411">\n<li data-nodeid="1412">\n<p data-nodeid="1413">Store：它是一个单一的数据源，而且是只读的。</p>\n</li>\n<li data-nodeid="1414">\n<p data-nodeid="1415">Action 人如其名，是“动作”的意思，它是对变化的描述。</p>\n</li>\n<li data-nodeid="1416">\n<p data-nodeid="1417">Reducer 是一个函数，它负责<strong data-nodeid="1613">对变化进行分发和处理</strong>，最终将新的数据返回给 Store。</p>\n</li>\n</ul>\n<p data-nodeid="1418">Store、Action 和 Reducer 三者紧密配合，便形成了 Redux 独树一帜的工作流，如下图所示：</p>\n<p data-nodeid="1419"><img src="https://s0.lgstatic.com/i/image/M00/7E/C6/CgqCHl_PVh-ATfOGAAB089LdYcY341.png" alt="Drawing 13.png" data-nodeid="1617"></p>\n<p data-nodeid="1420">在 Redux 的整个工作过程中，<strong data-nodeid="1627">数据流是严格单向的</strong>。如果你想对数据进行修改，只有一种途径：<strong data-nodeid="1628">派发 Action</strong>。Action 会被 Reducer 读取，Reducer 将根据 Action 内容的不同执行不同的计算逻辑，最终生成新的 state（状态），这个新的 state 会更新到 Store 对象里，进而驱动视图层面作出对应的改变。</p>\n<p data-nodeid="1421">对于组件来说，任何组件都可以以约定的方式从 Store 读取到全局的状态，任何组件也都可以通过合理地派发 Action 来修改全局的状态。<strong data-nodeid="1634">Redux 通过提供一个统一的状态容器</strong>，使得数据能够自由而有序地在任意组件之间穿梭。</p>\n<p data-nodeid="1422">复习完 Redux 的工作流，下面我们来结合源码看看这套工作流到底是如何实现的。</p>\n<h3 data-nodeid="1423">Redux 是如何工作的</h3>\n<p data-nodeid="1424">我们先来看一下 Redux 的源码文件夹结构，如下图所示：<br>\n<img src="https://s0.lgstatic.com/i/image/M00/7E/C6/CgqCHl_PVieAeMfAAABARscWp8o305.png" alt="Drawing 14.png" data-nodeid="1641"></p>\n<p data-nodeid="1425">其中，utils 是工具方法库；index.js 作为入口文件，用于对功能模块进行收敛和导出。真正“干活”的是功能模块本身，也就是下面这几个文件：</p>\n<ul data-nodeid="1426">\n<li data-nodeid="1427">\n<p data-nodeid="1428">applyMiddleware.js</p>\n</li>\n<li data-nodeid="1429">\n<p data-nodeid="1430">bindActionCreators.js</p>\n</li>\n<li data-nodeid="1431">\n<p data-nodeid="1432">combineReducers.js</p>\n</li>\n<li data-nodeid="1433">\n<p data-nodeid="1434">compose.js</p>\n</li>\n<li data-nodeid="1435">\n<p data-nodeid="1436">createStore.js</p>\n</li>\n</ul>\n<p data-nodeid="1437">applyMiddleware 是中间件模块，它的独立性较强，我们将在第 20 讲中单独讲解。</p>\n<p data-nodeid="1438">而 bindActionCreators（用于将传入的 actionCreator 与 dispatch 方法相结合，揉成一个新的方法，感兴趣的同学可以点击<a href="https://cn.redux.js.org/docs/api/bindActionCreators.html" data-nodeid="1652">这里</a>了解它的使用场景）、combineReducers（用于将多个 &nbsp;reducer 合并起来）、compose（用于把接收到的函数从右向左进行组合）这三个方法均为工具性质的方法。</p>\n<p data-nodeid="1439">如果你对这三个工具方法感到陌生，也不用急着去搜索，因为它们均独立于 Redux 主流程之外，属于“非必须使用”的<strong data-nodeid="1663">辅助 API</strong>，不熟悉这些 API 并不影响你理解 Redux 本身。理解 Redux 实现原理，真正需要我们关注的模块其实只有一个——<strong data-nodeid="1664">createStore</strong>。</p>\n<p data-nodeid="1440"><strong data-nodeid="1669">createStore 方法是我们在使用 Redux 时最先调用的方法，它是整个流程的入口，也是 Redux 中最核心的 API</strong>。接下来我们就从 createStore 入手，顺藤摸瓜揪出 Redux 源码的主流程。</p>\n<h4 data-nodeid="1441">故事的开始：createStore</h4>\n<p data-nodeid="1442">使用 Redux 的第一步，我们就需要调用 createStore 方法。单纯从使用感上来说，这个方法做的事情似乎就是创建一个 store 对象出来，像这样：</p>\n<pre class="lang-plain" data-nodeid="1443"><code data-language="plain">// 引入 redux\nimport { createStore } from \'redux\'\n// 创建 store\nconst store = createStore(\n    reducer,\n    initial_state,\n    applyMiddleware(middleware1, middleware2, ...)\n);\n</code></pre>\n<p data-nodeid="1444">createStore 方法可以接收以下 3 个入参：</p>\n<ul data-nodeid="1445">\n<li data-nodeid="1446">\n<p data-nodeid="1447">reducer</p>\n</li>\n<li data-nodeid="1448">\n<p data-nodeid="1449">初始状态内容</p>\n</li>\n<li data-nodeid="1450">\n<p data-nodeid="1451">指定中间件</p>\n</li>\n</ul>\n<p data-nodeid="1452">从拿到入参到返回出 store 的过程中，到底都发生了什么呢？这里我为你提取了 createStore 中主体逻辑的源码（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="1453"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createStore</span><span class="hljs-params">(reducer, preloadedState, enhancer)</span> </span>{\n    <span class="hljs-comment">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span>\n    <span class="hljs-keyword">if</span> (typeof preloadedState === <span class="hljs-string">\'function\'</span> &amp;&amp; typeof enhancer === <span class="hljs-string">\'undefined\'</span>) {\n        <span class="hljs-comment">// 此时第二个参数会被认为是 enhancer（中间件）</span>\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    <span class="hljs-comment">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span>\n    <span class="hljs-keyword">if</span> (typeof enhancer !== <span class="hljs-string">\'undefined\'</span>) {\n        <span class="hljs-keyword">return</span> enhancer(createStore)(reducer, preloadedState);\n    }\n    <span class="hljs-comment">// 记录当前的 reducer，因为 replaceReducer 会修改 reducer 的内容</span>\n    let currentReducer = reducer;\n    <span class="hljs-comment">// 记录当前的 state</span>\n    let currentState = preloadedState;\n    <span class="hljs-comment">// 声明 listeners 数组，这个数组用于记录在 subscribe 中订阅的事件</span>\n    let currentListeners = [];\n    <span class="hljs-comment">// nextListeners 是 currentListeners 的快照</span>\n    let nextListeners = currentListeners;\n    <span class="hljs-comment">// 该变量用于记录当前是否正在进行 dispatch</span>\n    let isDispatching = <span class="hljs-keyword">false</span>\n\n    <span class="hljs-comment">// 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身</span>\n    <span class="hljs-function">function <span class="hljs-title">ensureCanMutateNextListeners</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">if</span> (nextListeners === currentListeners) {\n            nextListeners = currentListeners.slice();\n        }\n    }\n\n    <span class="hljs-comment">// 我们通过调用 getState 来获取当前的状态</span>\n    <span class="hljs-function">function <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>{\n        <span class="hljs-keyword">return</span> currentState;\n    }\n\n    <span class="hljs-comment">// subscribe 订阅方法，它将会定义 dispatch 最后执行的 listeners 数组的内容</span>\n    <span class="hljs-function">function <span class="hljs-title">subscribe</span><span class="hljs-params">(listener)</span> </span>{\n        <span class="hljs-comment">// 校验 listener 的类型</span>\n        <span class="hljs-keyword">if</span> (typeof listener !== <span class="hljs-string">\'function\'</span>) {\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">\'Expected the listener to be a function.\'</span>)\n        }\n        <span class="hljs-comment">// 禁止在 reducer 中调用 subscribe</span>\n        <span class="hljs-keyword">if</span> (isDispatching) {\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n            <span class="hljs-string">\'You may not call store.subscribe() while the reducer is executing. \'</span> +\n              <span class="hljs-string">\'If you would like to be notified after the store has been updated, subscribe from a \'</span> +\n              <span class="hljs-string">\'component and invoke store.getState() in the callback to access the latest state. \'</span> +\n              <span class="hljs-string">\'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\'</span>\n          )\n        }\n        <span class="hljs-comment">// 该变量用于防止调用多次 unsubscribe 函数</span>\n        let isSubscribed = <span class="hljs-keyword">true</span>;\n        <span class="hljs-comment">// 确保 nextListeners 与 currentListeners 不指向同一个引用</span>\n        ensureCanMutateNextListeners(); \n        <span class="hljs-comment">// 注册监听函数</span>\n        nextListeners.push(listener); \n\n        <span class="hljs-comment">// 返回取消订阅当前 listener 的方法</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-function">function <span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span> </span>{\n            <span class="hljs-keyword">if</span> (!isSubscribed) {\n                <span class="hljs-keyword">return</span>;\n            }\n            isSubscribed = <span class="hljs-keyword">false</span>;\n            ensureCanMutateNextListeners();\n            <span class="hljs-keyword">const</span> index = nextListeners.indexOf(listener);\n            <span class="hljs-comment">// 将当前的 listener 从 nextListeners 数组中删除 </span>\n            nextListeners.splice(index, <span class="hljs-number">1</span>);\n        };\n    }\n\n    <span class="hljs-comment">// 定义 dispatch 方法，用于派发 action </span>\n    <span class="hljs-function">function <span class="hljs-title">dispatch</span><span class="hljs-params">(action)</span> </span>{\n        <span class="hljs-comment">// 校验 action 的数据格式是否合法</span>\n        <span class="hljs-keyword">if</span> (!isPlainObject(action)) {\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n            <span class="hljs-string">\'Actions must be plain objects. \'</span> +\n              <span class="hljs-string">\'Use custom middleware for async actions.\'</span>\n          )\n        }\n\n        <span class="hljs-comment">// 约束 action 中必须有 type 属性作为 action 的唯一标识 </span>\n        <span class="hljs-keyword">if</span> (typeof action.type === <span class="hljs-string">\'undefined\'</span>) {\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n            <span class="hljs-string">\'Actions may not have an undefined "type" property. \'</span> +\n              <span class="hljs-string">\'Have you misspelled a constant?\'</span>\n          )\n        }\n\n        <span class="hljs-comment">// 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）</span>\n        <span class="hljs-keyword">if</span> (isDispatching) {\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">\'Reducers may not dispatch actions.\'</span>)\n        }\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-comment">// 执行 reducer 前，先"上锁"，标记当前已经存在 dispatch 执行流程</span>\n          isDispatching = <span class="hljs-keyword">true</span>\n          <span class="hljs-comment">// 调用 reducer，计算新的 state </span>\n          currentState = currentReducer(currentState, action)\n        } <span class="hljs-keyword">finally</span> {\n          <span class="hljs-comment">// 执行结束后，把"锁"打开，允许再次进行 dispatch </span>\n          isDispatching = <span class="hljs-keyword">false</span>\n        }\n\n        <span class="hljs-comment">// 触发订阅</span>\n        <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);\n        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {\n            <span class="hljs-keyword">const</span> listener = listeners[i];\n            listener();\n        }\n        <span class="hljs-keyword">return</span> action;\n    }\n\n    <span class="hljs-comment">// replaceReducer 可以更改当前的 reducer</span>\n    <span class="hljs-function">function <span class="hljs-title">replaceReducer</span><span class="hljs-params">(nextReducer)</span> </span>{\n        currentReducer = nextReducer;\n        dispatch({ type: ActionTypes.REPLACE });\n        <span class="hljs-keyword">return</span> store;\n    }\n\n    <span class="hljs-comment">// 初始化 state，当派发一个 type 为 ActionTypes.INIT 的 action，每个 reducer 都会返回</span>\n    <span class="hljs-comment">// 它的初始值</span>\n    dispatch({ type: ActionTypes.INIT });\n\n    <span class="hljs-comment">// observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触</span>\n    <span class="hljs-function">function <span class="hljs-title">observable</span><span class="hljs-params">()</span> </span>{\n      <span class="hljs-comment">// observable 方法的实现</span>\n    }\n\n    <span class="hljs-comment">// 将定义的方法包裹在 store 对象里返回</span>\n    <span class="hljs-keyword">return</span> {\n      dispatch,\n      subscribe,\n      getState,\n      replaceReducer,\n      [$$observable]: observable\n    }\n}\n</code></pre>\n<p data-nodeid="1454">通过阅读源码会发现，createStore 从外面看只是一个简单的创建动作，但在内部却别有洞天，涵盖了所有 Redux 主流程中核心方法的定义。</p>\n<p data-nodeid="1455">接下来我将 createStore 内部逻辑总结进一张大图中，这张图涵盖了每个核心方法的工作内容，它将帮助你快速把握 createStore 的逻辑框架。</p>\n<p data-nodeid="1456"><img src="https://s0.lgstatic.com/i/image/M00/7E/BB/Ciqc1F_PVkCAST4AAAJfMvoaI4Q803.png" alt="Drawing 15.png" data-nodeid="1681"></p>\n<p data-nodeid="1457">在 createStore 导出的方法中，与 Redux 主流程强相关的，同时也是我们平时使用中最常打交道的几个方法，分别是：</p>\n<ul data-nodeid="1458">\n<li data-nodeid="1459">\n<p data-nodeid="1460">getState</p>\n</li>\n<li data-nodeid="1461">\n<p data-nodeid="1462">subscribe</p>\n</li>\n<li data-nodeid="1463">\n<p data-nodeid="1464">dispatch</p>\n</li>\n</ul>\n<p data-nodeid="1465">其中 getState 的源码内容比较简单，我们在逐行分析的过程中已经对它有了充分的认识。而 subscribe 和 dispatch 则分别代表了 Redux 独有的“发布-订阅”模式以及主流程中最为关键的分发动作，在下一讲，我们会重点讲解。</p>\n<h3 data-nodeid="1466">总结</h3>\n<p data-nodeid="1467">在本讲，我们首先学习了 Redux 的架构思想，梳理了“单向数据流”这一核心特征的来龙去脉，真正理解了 Redux 定义中“可预测”这 3 个字背后的深意。</p>\n<p data-nodeid="1468">随后，在复习 Redux 关键要素与工作流程的基础上，我们尝试对其源码进行拆解，认识了 Redux 源码的基本构成与主要模块，并选取了 createStore 这个核心模块作为发力点，提取出了 Redux 源码中值得我们格外深入的两个方法——subscribe 和 dispatch。</p>\n<p data-nodeid="1469" class="">那么 subscribe 和 dispatch 中到底藏着什么样的玄机，值得我们继续深入学习呢？我们下一讲见分晓！</p>',
          },
          {
            theme: '19 | 揭秘 Redux 设计思想与工作原理（下）',
            id: 220,
            content:
              '<p data-nodeid="278317" class="">在上一讲，我们尝试对 Redux 源码进行拆解，认识了 Redux 源码的基本构成与主要模块，并深入了解了 createStore 这个核心模块的工作逻辑。这一讲，我们将更进一步，针对 dispatch 和 subscribe 这两个具体的方法进行分析，分别认识 Redux 工作流中最为核心的<strong data-nodeid="278409">dispatch 动作</strong>，以及 Redux 自身独特的 <strong data-nodeid="278410">“发布-订阅”模式</strong>。</p>\n<h3 data-nodeid="278318">Redux 工作流的核心：dispatch 动作</h3>\n<p data-nodeid="278319">dispatch 应该是大家在使用 Redux 的过程中最为熟悉的 API 了。结合前面对设计思想的解读，我们已经知道，在 Redux 中有这样 3 个关键要素：</p>\n<ul data-nodeid="278320">\n<li data-nodeid="278321">\n<p data-nodeid="278322">action</p>\n</li>\n<li data-nodeid="278323">\n<p data-nodeid="278324">reducer</p>\n</li>\n<li data-nodeid="278325">\n<p data-nodeid="278326">store</p>\n</li>\n</ul>\n<p data-nodeid="278327">之所以说 dispatch 是 Redux 工作流的核心，是因为<strong data-nodeid="278421">dispatch 这个动作刚好能把 action、reducer 和 store 这三位“主角”给串联起来</strong>。dispatch 的内部逻辑，足以反映了这三者之间“打配合”的过程。</p>\n<p data-nodeid="278328">这里我把 dispatch 的逻辑从 createStore 中给“揪出来”，请看相关源码：</p>\n<pre class="lang-java" data-nodeid="278329"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">dispatch</span><span class="hljs-params">(action)</span> </span>{\n  <span class="hljs-comment">// 校验 action 的数据格式是否合法</span>\n  <span class="hljs-keyword">if</span> (!isPlainObject(action)) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n      <span class="hljs-string">\'Actions must be plain objects. \'</span> +\n      <span class="hljs-string">\'Use custom middleware for async actions.\'</span>\n    )\n  }\n  <span class="hljs-comment">// 约束 action 中必须有 type 属性作为 action 的唯一标识 </span>\n  <span class="hljs-keyword">if</span> (typeof action.type === <span class="hljs-string">\'undefined\'</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n      <span class="hljs-string">\'Actions may not have an undefined "type" property. \'</span> +\n      <span class="hljs-string">\'Have you misspelled a constant?\'</span>\n    )\n  }\n  <span class="hljs-comment">// 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）</span>\n  <span class="hljs-keyword">if</span> (isDispatching) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">\'Reducers may not dispatch actions.\'</span>)\n  }\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 执行 reducer 前，先"上锁"，标记当前已经存在 dispatch 执行流程</span>\n    isDispatching = <span class="hljs-keyword">true</span>\n    <span class="hljs-comment">// 调用 reducer，计算新的 state</span>\n    currentState = currentReducer(currentState, action)\n  } <span class="hljs-keyword">finally</span> {\n    <span class="hljs-comment">// 执行结束后，把"锁"打开，允许再次进行 dispatch</span>\n    isDispatching = <span class="hljs-keyword">false</span>\n  }\n  <span class="hljs-comment">// 触发订阅</span>\n  <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);\n  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {\n    <span class="hljs-keyword">const</span> listener = listeners[i];\n    listener();\n  }\n  <span class="hljs-keyword">return</span> action;\n}\n</code></pre>\n<p data-nodeid="278330">这里我结合源码，帮大家将 dispatch 的工作流程提取如下：</p>\n<p data-nodeid="278331"><img src="https://s0.lgstatic.com/i/image/M00/84/07/Ciqc1F_TF96ACQdrAADNE7uQ1fw478.png" alt="图片2.png" data-nodeid="278426"></p>\n<p data-nodeid="278332">在这段工作流中，有两个点值得我们细细回味。</p>\n<h4 data-nodeid="278333">1. 通过“上锁”避免“套娃式”的 dispatch</h4>\n<p data-nodeid="278334">dispatch 工作流中最关键的就是执行 reducer 这一步，它对应的是下面这段代码：</p>\n<pre class="lang-java" data-nodeid="278335"><code data-language="java"><span class="hljs-keyword">try</span> {\n  <span class="hljs-comment">// 执行 reducer 前，先“上锁”，标记当前已经存在 dispatch 执行流程</span>\n  isDispatching = <span class="hljs-keyword">true</span>\n  <span class="hljs-comment">// 调用 reducer，计算新的 state </span>\n  currentState = currentReducer(currentState, action)\n} <span class="hljs-keyword">finally</span> {\n  <span class="hljs-comment">// 执行结束后，把"锁"打开，允许再次进行 dispatch </span>\n  isDispatching = <span class="hljs-keyword">false</span>\n}\n</code></pre>\n<p data-nodeid="278336"><a href="https://www.redux.org.cn/docs/basics/Reducers.html" data-nodeid="278434">reducer</a> 的本质是 store 的更新规则，它指定了应用状态的变化如何响应 action 并发送到 store。这段代码中调用 reducer，传入 currentState 和 action，对应的正是第 05 讲中“编码角度看 Redux 工作流”图示中的 action → reducer → store 这个过程，如下图标红处所示：</p>\n<p data-nodeid="278337"><img src="https://s0.lgstatic.com/i/image/M00/84/13/CgqCHl_TF-uADepHAADt1xuXiTM684.png" alt="图片3.png" data-nodeid="278438"></p>\n<p data-nodeid="278338">在调用 reducer 之前，Redux 首先会将 isDispatching 变量置为 true，待 reducer 执行完毕后，再将 isDispatching 变量置为 false。这个操作你应该不陌生，因为在第 11 讲中，setState 的“批处理”也是用类似的“上锁”方式来实现的。</p>\n<p data-nodeid="278339">这里之所以要用 isDispatching 将 dispatch 的过程锁起来，目的是规避“套娃式”的 dispatch。更准确地说，是为了避免开发者在 reducer 中手动调用 dispatch。</p>\n<p data-nodeid="278340">“禁止套娃”用意何在？首先，从设计的角度来看，<strong data-nodeid="278446">作为一个“计算 state 专用函数”，Redux 在设计 reducer 时就强调了它必须是“纯净”的</strong>，它不应该执行除了计算之外的任何“脏操作”，dispatch 调用显然是一个“脏操作”；其次，从执行的角度来看，若真的在 reducer 中调用 dispatch，那么 dispatch 又会反过来调用 reducer，reducer 又会再次调用 dispatch......这样反复相互调用下去，就会进入死循环，属于非常严重的误操作。</p>\n<p data-nodeid="278341">因此，在 dispatch 的前置校验逻辑中，一旦识别出 isDispatching 为 true，就会直接 throw Error（见下面代码），把死循环扼杀在摇篮里：</p>\n<pre class="lang-java" data-nodeid="278342"><code data-language="java"><span class="hljs-keyword">if</span> (isDispatching) {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">\'Reducers may not dispatch actions.\'</span>)\n}\n</code></pre>\n<h4 data-nodeid="278343">2. 触发订阅的过程</h4>\n<p data-nodeid="278344">在 reducer 执行完毕后，会进入触发订阅的过程，它对应的是下面这段代码：</p>\n<pre class="lang-java" data-nodeid="278345"><code data-language="java"><span class="hljs-comment">// 触发订阅</span>\n<span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);\n<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {\n  <span class="hljs-keyword">const</span> listener = listeners[i];\n  listener();\n}\n</code></pre>\n<p data-nodeid="278346">在阅读这段源码的过程中，相信你的疑问点主要在两个方面：</p>\n<ol data-nodeid="278347">\n<li data-nodeid="278348">\n<p data-nodeid="278349">第 05 讲我们并没有介绍 subscribe 这个 API，也没有提及 listener 相关的内容，它们到底是如何与 Redux 主流程相结合的呢？</p>\n</li>\n<li data-nodeid="278350">\n<p data-nodeid="278351">为什么会有 currentListeners 和 nextListeners 这两个 listeners 数组？这和我们平时见到的“发布-订阅”模式好像不太一样。</p>\n</li>\n</ol>\n<p data-nodeid="278352">要弄明白这两个问题，我们需要先了解 subscribe 这个 API。</p>\n<h3 data-nodeid="278353">Redux 中的“发布-订阅”模式：认识 subscribe</h3>\n<p data-nodeid="278354">dispatch 中执行的 listeners 数组从订阅中来，而执行订阅需要调用 subscribe。在实际的开发中，subscribe 并不是一个严格必要的方法，<strong data-nodeid="278462">只有在需要监听状态的变化时，我们才会调用 subscribe</strong>。</p>\n<p data-nodeid="278355">subscribe 接收一个 Function 类型的 listener 作为入参，它的返回内容恰恰就是这个 listener 对应的解绑函数。你可以通过下面这段示例代码简单把握一下 subscribe 的使用姿势：</p>\n<pre class="lang-java" data-nodeid="278356"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">handleChange</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 函数逻辑</span>\n}\n<span class="hljs-keyword">const</span> unsubscribe = store.subscribe(handleChange)\nunsubscribe()\n</code></pre>\n<p data-nodeid="278357">subscribe 在订阅时只需要传入监听函数，而不需要传入事件类型。这是因为 Redux 中已经默认了订阅的对象就是“<strong data-nodeid="278469">状态的变化（准确地说是 dispatch 函数的调用）</strong>”这个事件。</p>\n<p data-nodeid="278358">到这里，我们就可以回答上面提出的第一个关于 subscribe 的问题了：<strong data-nodeid="278483">subscribe 是如何与 Redux 主流程结合的呢</strong>？首先，我们可以<strong data-nodeid="278484">在 store 对象创建成功后</strong>，通过调用 store.subscribe 来注册监听函数，也可以通过调用 subscribe 的返回函数来解绑监听函数，监听函数是用 listeners 数组来维护的；当<strong data-nodeid="278485">dispatch action 发生时</strong>，Redux 会在 reducer 执行完毕后，将 listeners 数组中的监听函数逐个执行。这就是 subscribe 与 Redux 主流程之间的关系。</p>\n<p data-nodeid="278359">接下来我们结合源码来分析一下 subscribe 的内部逻辑，subscribe 源码提取如下：</p>\n<pre class="lang-java" data-nodeid="278360"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">subscribe</span><span class="hljs-params">(listener)</span> </span>{\n  <span class="hljs-comment">// 校验 listener 的类型</span>\n  <span class="hljs-keyword">if</span> (typeof listener !== <span class="hljs-string">\'function\'</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">\'Expected the listener to be a function.\'</span>)\n  }\n  <span class="hljs-comment">// 禁止在 reducer 中调用 subscribe</span>\n  <span class="hljs-keyword">if</span> (isDispatching) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n      <span class="hljs-string">\'You may not call store.subscribe() while the reducer is executing. \'</span> +\n      <span class="hljs-string">\'If you would like to be notified after the store has been updated, subscribe from a \'</span> +\n      <span class="hljs-string">\'component and invoke store.getState() in the callback to access the latest state. \'</span> +\n      <span class="hljs-string">\'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\'</span>\n    )\n  }\n  <span class="hljs-comment">// 该变量用于防止调用多次 unsubscribe 函数</span>\n  let isSubscribed = <span class="hljs-keyword">true</span>;\n  <span class="hljs-comment">// 确保 nextListeners 与 currentListeners 不指向同一个引用</span>\n  ensureCanMutateNextListeners(); \n  <span class="hljs-comment">// 注册监听函数</span>\n  nextListeners.push(listener); \n  <span class="hljs-comment">// 返回取消订阅当前 listener 的方法</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-function">function <span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span> </span>{\n    <span class="hljs-keyword">if</span> (!isSubscribed) {\n      <span class="hljs-keyword">return</span>;\n    }\n    isSubscribed = <span class="hljs-keyword">false</span>;\n    ensureCanMutateNextListeners();\n    <span class="hljs-keyword">const</span> index = nextListeners.indexOf(listener);\n    <span class="hljs-comment">// 将当前的 listener 从 nextListeners 数组中删除 </span>\n    nextListeners.splice(index, <span class="hljs-number">1</span>);\n  };\n}\n</code></pre>\n<p data-nodeid="278361">结合这段源码，我们可以将 subscribe 的工作流程提取如下：</p>\n<p data-nodeid="278362"><img src="https://s0.lgstatic.com/i/image/M00/84/13/CgqCHl_TGCiAfm8CAAEEFFa3ZxA563.png" alt="图片5.png" data-nodeid="278490"></p>\n<p data-nodeid="278363">这个工作流中有一个步骤让人很难不在意，那就是对 ensureCanMutateNextListeners 的调用。结合前面整体源码的分析，我们已经知道 ensureCanMutateNextListeners 的作用就是确保 nextListeners 不会和 currentListener 指向同一个引用。 那么为什么要这样做呢？这里就引出了之前提出的关于 subscribe 的第二个问题：<strong data-nodeid="278496">为什么会有 currentListeners 和 nextListeners 两个 listeners 数组</strong>？</p>\n<p data-nodeid="278364">要理解这个问题，我们首先要搞清楚 Redux 中的订阅过程和发布过程各自是如何处理 listeners 数组的。</p>\n<h4 data-nodeid="278365">1. 订阅过程中的 listeners 数组</h4>\n<p data-nodeid="278366">两个 listeners 之间的第一次“交锋”发生在 createStore 的变量初始化阶段，nextListeners 会被赋值为 currentListeners（见下面代码），这之后两者确实指向同一个引用。</p>\n<pre class="lang-java" data-nodeid="278367"><code data-language="java"> let nextListeners = currentListeners\n</code></pre>\n<p data-nodeid="278368">但在 subscribe 第一次被调用时，ensureCanMutateNextListeners 就会发现这一点，然后将 nextListeners 纠正为一个内容与 currentListeners 一致、但引用不同的新对象。对应的逻辑如下面代码所示：</p>\n<pre class="lang-java" data-nodeid="278369"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">ensureCanMutateNextListeners</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 若两个数组指向同一个引用</span>\n  <span class="hljs-keyword">if</span> (nextListeners === currentListeners) {\n    <span class="hljs-comment">// 则将 nextListeners 纠正为一个内容与 currentListeners 一致、但引用不同的新对象</span>\n    nextListeners = currentListeners.slice()\n  }\n}\n</code></pre>\n<p data-nodeid="278370">在 subscribe 的逻辑中，ensureCanMutateNextListeners 每次都会在 listener 注册前被无条件调用，用以确保两个数组引用不同。紧跟在 ensureCanMutateNextListeners 之后执行的是 listener 的注册逻辑，我们可以对应源码中看到 listener 最终会被注册到 nextListeners 数组中去：</p>\n<pre class="lang-java" data-nodeid="278371"><code data-language="java">nextListeners.push(listener);\n</code></pre>\n<p data-nodeid="278372">接下来我们来看看事件的发布过程。</p>\n<h4 data-nodeid="278373">2. 发布过程中的 listeners 数组</h4>\n<p data-nodeid="278374">触发订阅这个动作是由 dispatch 来做的，相关的源码如下：</p>\n<pre class="lang-java" data-nodeid="278375"><code data-language="java"><span class="hljs-comment">// 触发订阅</span>\n<span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);\n<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {\n  <span class="hljs-keyword">const</span> listener = listeners[i];\n  listener();\n}\n</code></pre>\n<p data-nodeid="278376">这段源码告诉我们，在触发订阅的过程中，currentListeners 会被赋值为 nextListeners，而实际被执行的 listeners 数组又会被赋值为 currentListeners。因此，<strong data-nodeid="278514">最终被执行的 listeners 数组，实际上和当前的 nextListeners 指向同一个引用</strong>。</p>\n<p data-nodeid="278377">这就有点奇妙了：<strong data-nodeid="278520">注册监听也是操作 nextListeners，触发订阅也是读取 nextListeners（实际上，细心的同学会注意到，取消监听操作的也是 nextListeners 数组）。既然如此，要 currentListeners 有何用</strong>？</p>\n<h4 data-nodeid="278378">3. currentListeners 数组用于确保监听函数执行过程的稳定性</h4>\n<p data-nodeid="278379">正因为任何变更都是在 nextListeners 上发生的，我们才需要一个不会被变更的、内容稳定的 currentListeners ，来确保监听函数在执行过程中不会出幺蛾子。</p>\n<p data-nodeid="278380">举个例子，下面这种操作在 Redux 中完全是合法的：</p>\n<pre class="lang-java" data-nodeid="278381"><code data-language="java"><span class="hljs-comment">// 定义监听函数 A</span>\n<span class="hljs-function">function <span class="hljs-title">listenerA</span><span class="hljs-params">()</span> </span>{\n}\n<span class="hljs-comment">// 订阅 A，并获取 A 的解绑函数</span>\n<span class="hljs-keyword">const</span> unSubscribeA = store.subscribe(listenerA)\n<span class="hljs-comment">// 定义监听函数 B</span>\n<span class="hljs-function">function <span class="hljs-title">listenerB</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 在 B 中解绑 A</span>\n  unSubscribeA()\n}\n<span class="hljs-comment">// 定义监听函数 C</span>\n<span class="hljs-function">function <span class="hljs-title">listenerC</span><span class="hljs-params">()</span> </span>{\n}\n<span class="hljs-comment">// 订阅 B</span>\nstore.subscribe(listenerB)\n<span class="hljs-comment">// 订阅 C</span>\nstore.subscribe(listenerC)\n</code></pre>\n<p data-nodeid="278382">在这个 Demo 执行完毕后，nextListeners 数组的内容是 A、B、C 3 个 listener：</p>\n<pre class="lang-java" data-nodeid="278383"><code data-language="java">[listenerA,  listenerB, listenerC]\n</code></pre>\n<p data-nodeid="278384">接下来若调用 dispatch，则会执行下面这段触发订阅的逻辑：</p>\n<pre class="lang-java" data-nodeid="278385"><code data-language="java"><span class="hljs-comment">// 触发订阅</span>\n<span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);\n<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {\n  <span class="hljs-keyword">const</span> listener = listeners[i];\n  listener();\n}\n</code></pre>\n<p data-nodeid="278386">当 for 循环执行到索引 i = 1 处，也就是对应的 listener 为 listenerB 时，问题就会出现：listenerB 中执行了 unSubscribeA 这个动作。而结合我们前面的分析，监听函数注册、解绑、触发这些动作实际影响的都是 nextListeners。为了强化对这一点的认知，我们来复习一下 unsubscribe 的源码：</p>\n<pre class="lang-java" data-nodeid="278387"><code data-language="java"><span class="hljs-keyword">return</span> <span class="hljs-function">function <span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-comment">// 避免多次解绑</span>\n  <span class="hljs-keyword">if</span> (!isSubscribed) {\n    <span class="hljs-keyword">return</span>;\n  }\n  isSubscribed = <span class="hljs-keyword">false</span>;\n  <span class="hljs-comment">// 熟悉的操作，调用 ensureCanMutateNextListeners 方法</span>\n  ensureCanMutateNextListeners();\n  <span class="hljs-comment">// 获取 listener 在 nextListeners 中的索引</span>\n  <span class="hljs-keyword">const</span> index = nextListeners.indexOf(listener);\n  <span class="hljs-comment">// 将当前的 listener 从 nextListeners 数组中删除 </span>\n  nextListeners.splice(index, <span class="hljs-number">1</span>);\n};\n</code></pre>\n<p data-nodeid="278388">假如说不存在 currentListeners，那么也就意味着不需要 ensureCanMutateNextListeners 这个动作。若没有 ensureCanMutateNextListeners，unsubscribeA() 执行完之后，listenerA 会同时从 listeners 数组和 nextListeners 数组中消失（因为两者指向的是同一个引用），那么 listeners 数组此时只剩下两个元素 listenerB 和 listenerC，变成这样：</p>\n<pre class="lang-java" data-nodeid="278389"><code data-language="java">[listenerB, listenerC]\n</code></pre>\n<p data-nodeid="278390">listeners 数组的长度改变了，<strong data-nodeid="278547">但 for 循环却不会感知这一点，它将无情地继续循环下去</strong>。之前执行到 i = 1 处，listener = listeners[1] ，也就是说 listener === listenerB；下一步理应执行到 i = 2 处，但此时 listeners[2] 已经是 undefined 了，原本应该出现在这个索引位上的 listenerC，此时因为数组长度的变化，被前置到了 i = 1 处！<strong data-nodeid="278548">这样一来，undefined 就会代替 listenerC 被执行，进而引发函数异常</strong>。</p>\n<p data-nodeid="278391">这可怎么办呢？答案当然是<strong data-nodeid="278554">将 nextListeners 与当前正在执行中的 listeners 剥离开来</strong>，将两者指向不同的引用。这也正是 ensureCanMutateNextListeners 所做的事情。</p>\n<p data-nodeid="278392">在示例的这种场景下，ensureCanMutateNextListeners 执行前，listeners、currentListeners 和 nextListeners 之间的关系是这样的：</p>\n<pre class="lang-java" data-nodeid="278393"><code data-language="java">listeners === currentListeners === nextListeners\n</code></pre>\n<p data-nodeid="278394">而 ensureCanMutateNextListeners 执行后，nextListeners 就会被剥离出去：</p>\n<pre class="lang-java" data-nodeid="278395"><code data-language="java">nextListeners = currentListeners.slice()\nlisteners === currentListeners !== nextListeners\n</code></pre>\n<p data-nodeid="278396">这样一来，nextListeners 上的任何改变，都无法再影响正在执行中的 listeners 了。<strong data-nodeid="278566">currentListeners 在此处的作用，就是为了记录下当前正在工作中的 listeners 数组的引用</strong>，<strong data-nodeid="278567">将它与可能发生改变的 nextListeners 区分开来，以确保监听函数在执行过程中的稳定性</strong>。</p>\n<h3 data-nodeid="278397">总结</h3>\n<p data-nodeid="278398">这两讲，我们对 Redux 的设计思想与实现原理都有了深入的学习。到这里，相信你已经对 Redux 的架构动机、工作原理包括源码的设计依据都有了扎实的掌握。</p>\n<p data-nodeid="278399" class="te-preview-highlight">在 Redux 主流程之外，还有一个不可小觑的厉害角色，那就是<strong data-nodeid="278575">Redux 中间件</strong>。在中间件的加持下，Redux 将化身为一条灵活的“变色龙”，自由地穿梭于不同的需求场景之间。在下一讲，我们就将揭开 Redux 中间件的神秘面纱。</p>',
          },
          {
            theme: '20 | 从 Redux 中间件实现原理切入，理解“面向切面编程”',
            id: 221,
            content:
              '<p data-nodeid="12356" class="">本讲我们将结合 Redux 应用实例与 applyMiddleware 源码，对 Redux 中间件的实现原理进行分析。在此基础上，我会帮助你对“面向切面”这一经典的编程思想建立初步的认识。</p>\n<h3 data-nodeid="12357">认识 Redux 中间件</h3>\n<p data-nodeid="12358">在分析中间件实现原理之前，我们先来认识一下中间件的用法。</p>\n<h4 data-nodeid="12359">中间件的引入</h4>\n<p data-nodeid="12360">在第 05 讲介绍 createStore 函数时，已经简单地提过中间件——<strong data-nodeid="12475">中间件相关的信息将作为 createStore 函数的一个 function 类型的入参被传入</strong>。这里我们简单复习一下 createStore 的调用规则，示例代码如下：</p>\n<pre class="lang-java" data-nodeid="12361"><code data-language="java"><span class="hljs-comment">// 引入 redux</span>\n<span class="hljs-keyword">import</span> { createStore, applyMiddleware } from <span class="hljs-string">\'redux\'</span>\n......\n<span class="hljs-comment">// 创建 store</span>\n<span class="hljs-keyword">const</span> store = createStore(\n    reducer,\n    initial_state,\n    applyMiddleware(middleware1, middleware2, ...)\n);\n</code></pre>\n<p data-nodeid="12362">可以看到，redux 对外暴露了 applyMiddleware 这个方法。applyMiddleware 接受任意个中间件作为入参，而它的返回值将会作为参数传入 createStore，这就是中间件的引入过程。</p>\n<h4 data-nodeid="12363">中间件的工作模式</h4>\n<p data-nodeid="12364">中间件的引入，会为 Redux 工作流带来什么样的改变呢？这里我们以 redux-thunk 为例，从经典的“异步 Action”场景切入，一起看看中间件是如何帮我们解决问题的。</p>\n<h5 data-nodeid="12365">redux-thunk——经典的异步 Action 解决方案</h5>\n<p data-nodeid="12366">在针对 Redux 源码主流程的分析中，我们不难看出这样一个规律——<strong data-nodeid="12485">Redux 源码中只有同步操作</strong>，也就是说当我们 dispatch action 时，state 会被立即更新。</p>\n<p data-nodeid="12367">那如果想要在 Redux 中引入异步数据流，该怎么办呢？<a href="https://www.redux.org.cn/docs/advanced/AsyncFlow.html" data-nodeid="12489">Redux 官方给出的建议</a>是使用中间件来增强 createStore。支持异步数据流的 Redux 中间件有很多，其中最适合用来快速上手的应该就是 <a href="https://github.com/reduxjs/redux-thunk" data-nodeid="12493">redux-thunk</a>了。</p>\n<p data-nodeid="12368">redux-thunk 的引入和普通中间件无异，可以参考以下示例：</p>\n<pre class="lang-java" data-nodeid="12369"><code data-language="java"><span class="hljs-comment">// 引入 redux-thunk</span>\n<span class="hljs-keyword">import</span> thunkMiddleware from <span class="hljs-string">\'redux-thunk\'</span>\n<span class="hljs-keyword">import</span> reducer from <span class="hljs-string">\'./reducers\'</span>\n<span class="hljs-comment">// 将中间件用 applyMiddleware 包装后传入</span>\n<span class="hljs-keyword">const</span> store = createStore(reducer, applyMiddleware(thunkMiddleware))\n</code></pre>\n<p data-nodeid="12370">这里帮大家复习一个小小的知识点，在第 18 讲我们分析 createStore 整体源码时，曾经在 createStore 逻辑的开头见过这样一段代码：</p>\n<pre class="lang-java" data-nodeid="12371"><code data-language="java"><span class="hljs-comment">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span>\n<span class="hljs-keyword">if</span> (typeof preloadedState === <span class="hljs-string">\'function\'</span> &amp;&amp; typeof enhancer === <span class="hljs-string">\'undefined\'</span>) {\n  <span class="hljs-comment">// 此时第二个参数会被认为是 enhancer（中间件）</span>\n  enhancer = preloadedState;\n  preloadedState = undefined;\n}\n</code></pre>\n<p data-nodeid="12372">这段代码告诉我们，在只传入两个参数的情况下，createStore 会去检查第二个参数是否是 function 类型，若是，则认为第二个参数是“enhancer”。这里的“enhancer”是“增强器”的意思，而 applyMiddleware 包装过的中间件，正是“增强器”的一种。这也就解释了为什么上面 redux-thunk 的调用示例中，applyMiddleware 调用明明是作为 createStore 的第二个参数被传入的，却仍然能够被识别为中间件信息。</p>\n<p data-nodeid="12373">redux-thunk 带来的改变非常好理解，<strong data-nodeid="12503">它允许我们以函数的形式派发一个 action</strong>，像这样（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="12374"><code data-language="java"><span class="hljs-comment">// axios 是一个用于发起异步请求的库</span>\n<span class="hljs-keyword">import</span> axios from <span class="hljs-string">\'axios\'</span> \n<span class="hljs-comment">// 引入 createStore 和 applyMiddleware</span>\n<span class="hljs-keyword">import</span> { createStore, applyMiddleware } from <span class="hljs-string">\'redux\'</span>;\n<span class="hljs-comment">// 引入 redux-thunk</span>\n<span class="hljs-keyword">import</span> thunk from <span class="hljs-string">\'redux-thunk\'</span>;\n<span class="hljs-comment">// 引入 reducer</span>\n<span class="hljs-keyword">import</span> reducer from <span class="hljs-string">\'./reducers\'</span>;\n<span class="hljs-comment">// 创建一个有 thunk 中间件加持的 store 对象</span>\n<span class="hljs-keyword">const</span> store = createStore(\n  reducer,\n  applyMiddleware(thunk)\n);\n<span class="hljs-comment">// 用于发起付款请求，并处理请求结果。由于涉及资金，我们希望感知请求的发送和响应的返回</span>\n<span class="hljs-comment">// 入参是付款相关的信息（包括用户账密、金额等）</span>\n<span class="hljs-comment">// 注意 payMoney 的返回值仍然是一个函数</span>\n<span class="hljs-keyword">const</span> payMoney = (payInfo) =&gt; (dispatch) =&gt; {\n  <span class="hljs-comment">// 付款前发出准备信号</span>\n  dispatch({ type: <span class="hljs-string">\'payStart\'</span> })\n  fetch().then(res =&gt; { dispatch()})\n  <span class="hljs-keyword">return</span> axios.post(<span class="hljs-string">\'/api/payMoney\'</span>, {\n    payInfo\n  })\n  .then(function (response) {\n    console.log(response);\n    <span class="hljs-comment">// 付款成功信号</span>\n    dispatch({ type: <span class="hljs-string">\'paySuccess\'</span> })\n  })\n  .<span class="hljs-keyword">catch</span>(function (error) {\n    console.log(error);\n    <span class="hljs-comment">// 付款失败信号</span>\n    dispatch({ type: <span class="hljs-string">\'payError\'</span> })\n  });\n}\n<span class="hljs-comment">// 支付信息，入参</span>\n<span class="hljs-keyword">const</span> payInfo = {\n  userName: xxx,\n  password: xxx,\n  count: xxx,\n  ......\n}\n<span class="hljs-comment">// dispatch 一个 action，注意这个 action 是一个函数</span>\nstore.dispatch(payMoney(payInfo));\n</code></pre>\n<p data-nodeid="12375">这里我尝试用 redux-thunk 模拟了一个付款请求的发起 → 响应过程。</p>\n<p data-nodeid="12660" class="">这个过程单从表面上看，和普通 Redux 调用最大的不同就是 <strong data-nodeid="12674">dispatch 的入参从 action 对象变成了一个函数</strong>。这就不由得让人对 thunk 中间件加持下的 Redux 工作流心生好奇——<strong data-nodeid="12675">action 入参必须是一个对象</strong>，这一点我们在第 19 讲分析 dispatch 源码时，可是亲眼见过 action 相关的数据格式强校验逻辑的！<strong data-nodeid="12676">而 thunk 中间件似乎巧妙地“绕开”了这层校验，这背后到底藏着什么玄机呢</strong>？</p>\n\n<p data-nodeid="12377">要想搞清楚这个问题，你除了需要理解 thunk 的执行逻辑，更重要的是要知道 Redux 中间件是如何工作的。</p>\n<h5 data-nodeid="12378">Redux 中间件是如何与 Redux 主流程相结合的？</h5>\n<p data-nodeid="12379">Redux 中间件将会在 action 被分发之后、到达 reducer 之前执行，对应到工作流中，它的执行时机如下图所示：</p>\n<p data-nodeid="12380"><img src="https://s0.lgstatic.com/i/image2/M01/01/67/Cip5yF_Yk0yAUFNqAABk6No-RiM734.png" alt="图片2.png" data-nodeid="12526"></p>\n<p data-nodeid="12381">若有多个中间件，那么 Redux 会结合它们被“安装”的先后顺序，依序调用这些中间件，这个过程如下图所示：</p>\n<p data-nodeid="12382"><img src="https://s0.lgstatic.com/i/image2/M01/01/68/CgpVE1_Yk1aAA-MbAACcWI3Jg2Q249.png" alt="图片4.png" data-nodeid="12530"></p>\n<p data-nodeid="12383">中间件的执行时机，允许它在状态真正发生变化之前，结合 action 的信息做一些它想做的事情。</p>\n<p data-nodeid="12384">那么中间件又是如何“绕过” dispatch 的校验逻辑的呢？其实，“绕过”dispatch 只是咱们主观上的一个使用感受。<strong data-nodeid="12537">dispatch 并非被“绕过”了，而是被“改写”了，改写它的不是别人，正是 applyMiddleware</strong>。关于这点，我会在本文后续的源码分析环节为你深入讲解。</p>\n<p data-nodeid="12385">读到这里，对于 Redux 中间件的工作模式，你需要牢牢把握以下两点：</p>\n<ol data-nodeid="13285">\n<li data-nodeid="13286">\n<p data-nodeid="13287">中间件的执行时机，即 action 被分发之后、reducer 触发之前；</p>\n</li>\n<li data-nodeid="13288" class="">\n<p data-nodeid="13289" class="">中间件的执行前提，即 <strong data-nodeid="13296">applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用</strong>。</p>\n</li>\n</ol>\n\n<p data-nodeid="12391">结合这两点，再来看 redux-thunk 的源码，一切就会豁然开朗了。</p>\n<h5 data-nodeid="12392">thunk 中间件到底做了什么？</h5>\n<p data-nodeid="12393">redux-thunk 的源码其实非常简洁，我第一次接触时还是在 2016 年，这么多年过去了，很多事情都变了，唯一不变的是 redux-thunk，它仍然那么好懂。既然这么好懂，我们不如直接来读读看，请看 redux-thunk 的源码：</p>\n<pre class="lang-java" data-nodeid="12394"><code data-language="java"><span class="hljs-comment">// createThunkMiddleware 用于创建 thunk</span>\n<span class="hljs-function">function <span class="hljs-title">createThunkMiddleware</span><span class="hljs-params">(extraArgument)</span> </span>{\n  <span class="hljs-comment">// 返回值是一个 thunk，它是一个函数</span>\n  <span class="hljs-keyword">return</span> ({ dispatch, getState }) =&gt; (next) =&gt; (action) =&gt; {\n    <span class="hljs-comment">// thunk 若感知到 action 是一个函数，就会执行 action</span>\n    <span class="hljs-keyword">if</span> (typeof action === <span class="hljs-string">\'function\'</span>) {\n      <span class="hljs-keyword">return</span> action(dispatch, getState, extraArgument);\n    }\n    <span class="hljs-comment">// 若 action 不是一个函数，则不处理，直接放过</span>\n    <span class="hljs-keyword">return</span> next(action);\n  };\n}\n<span class="hljs-keyword">const</span> thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\nexport <span class="hljs-keyword">default</span> thunk;\n</code></pre>\n<p data-nodeid="12395">redux-thunk 主要做的事情，就是在拦截到 action 以后，会去检查它是否是一个函数。<strong data-nodeid="12554">若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next</strong>，告诉 Redux “我这边的工作做完了”，工作流就可以继续往下走了。</p>\n<p data-nodeid="12396">到这里，你已经在使用层面对 Redux 中间件有了足够的认知。接下来，我们就要进入源码的世界啦。</p>\n<h3 data-nodeid="12397">Redux 中间件机制是如何实现的</h3>\n<p data-nodeid="12398">Redux 中间件是通过调用 applyMiddleware 来引入的，因此我们先看看 applyMiddleware 的源码（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="12399"><code data-language="java"><span class="hljs-comment">// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组</span>\n<span class="hljs-function">export <span class="hljs-keyword">default</span> function <span class="hljs-title">applyMiddleware</span><span class="hljs-params">(...middlewares)</span> </span>{\n  <span class="hljs-comment">// 它返回的是一个接收 createStore 为入参的函数</span>\n  <span class="hljs-keyword">return</span> createStore =&gt; (...args) =&gt; {\n    <span class="hljs-comment">// 首先调用 createStore，创建一个 store</span>\n    <span class="hljs-keyword">const</span> store = createStore(...args)\n    let dispatch = () =&gt; {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(\n        `Dispatching <span class="hljs-keyword">while</span> constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to <span class="hljs-keyword">this</span> dispatch.`\n      )\n    }\n\n    <span class="hljs-comment">// middlewareAPI 是中间件的入参</span>\n    <span class="hljs-keyword">const</span> middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) =&gt; dispatch(...args)\n    }\n    <span class="hljs-comment">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span>\n    <span class="hljs-keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))\n    <span class="hljs-comment">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span>\n    dispatch = compose(...chain)(store.dispatch)\n\n    <span class="hljs-comment">// 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了</span>\n    <span class="hljs-keyword">return</span> {\n      ...store,\n      dispatch\n    }\n  }\n}\n</code></pre>\n<p data-nodeid="12400">在这段源码中，我们着重需要搞清楚的是以下几个问题：</p>\n<ol data-nodeid="12401">\n<li data-nodeid="12402">\n<p data-nodeid="12403">applyMiddleware 返回了一个什么样的函数？这个函数是如何与 createStore 配合工作的？</p>\n</li>\n<li data-nodeid="12404">\n<p data-nodeid="12405">dispatch 函数是如何被改写的？</p>\n</li>\n<li data-nodeid="12406">\n<p data-nodeid="12407">compose 函数是如何组合中间件的？</p>\n</li>\n</ol>\n<h4 data-nodeid="12408">1. applyMiddleware 是如何与 createStore 配合工作的？</h4>\n<p data-nodeid="12409"><strong data-nodeid="12569">先来看看 applyMiddleware 的返回值</strong>。在源码的注释中，我已经标明，它返回的是一个接收 createStore 为入参的函数。这个函数将会作为入参传递给 createStore，那么 createStore 会如何理解它呢？这里就要带你复习一下 createStore 中，enhancer 相关的逻辑了，请看下面代码：</p>\n<pre class="lang-java" data-nodeid="12410"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createStore</span><span class="hljs-params">(reducer, preloadedState, enhancer)</span> </span>{\n    <span class="hljs-comment">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span>\n    <span class="hljs-keyword">if</span> (typeof preloadedState === <span class="hljs-string">\'function\'</span> &amp;&amp; typeof enhancer === <span class="hljs-string">\'undefined\'</span>) {\n        <span class="hljs-comment">// 此时第二个参数会被认为是 enhancer（中间件）</span>\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    <span class="hljs-comment">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span>\n    <span class="hljs-keyword">if</span> (typeof enhancer !== <span class="hljs-string">\'undefined\'</span>) {\n        <span class="hljs-keyword">return</span> enhancer(createStore)(reducer, preloadedState);\n    }\n    ......\n}\n</code></pre>\n<p data-nodeid="12411">从这个代码片段中我们可以看出，一旦发现 enhancer 存在（对应到中间件场景下，enhancer 指的是 applyMiddleware 返回的函数），那么 createStore 内部就会直接 return 一个针对 enhancer 的调用。在这个调用中，第一层入参是 createStore，第二层入参是 reducer 和 preloadedState。</p>\n<p data-nodeid="12412">我们可以尝试将这个逻辑在 applyMiddleware 中对号入座一下。下面我从出入参角度简单提取了一下 applyMiddleware 的源码框架：</p>\n<pre class="lang-java" data-nodeid="12413"><code data-language="java"><span class="hljs-comment">// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组</span>\n<span class="hljs-function">export <span class="hljs-keyword">default</span> function <span class="hljs-title">applyMiddleware</span><span class="hljs-params">(...middlewares)</span> </span>{\n  <span class="hljs-comment">// 它返回的是一个接收 createStore 为入参的函数</span>\n  <span class="hljs-keyword">return</span> createStore =&gt; (...args) =&gt; {\n    ......\n  }\n}\n</code></pre>\n<p data-nodeid="12414">结合 createStore 中对 enhancer 的处理，我们可以知道，在 applyMiddleware return 出的这个函数中，createStore 这个入参对应的是 createStore 函数本身，而 args 入参则对应的是 reducer、preloadedState，这两个参数均为 createStore 函数的约定入参。</p>\n<p data-nodeid="12415">前面我们讲过，applyMiddleware 是 enhancer 的一种，而 enhancer 的意思是“增强器”，它增强的正是 createStore 的能力。因此调用 enhancer 时，传入 createStore 及其相关的入参信息是非常必要的。</p>\n<h4 data-nodeid="12416">2.dispatch 函数是如何被改写的？</h4>\n<p data-nodeid="12417">dispatch 函数的改写，是由下面这个代码片段完成的：</p>\n<pre class="lang-java" data-nodeid="12418"><code data-language="java"><span class="hljs-comment">// middlewareAPI 是中间件的入参</span>\n<span class="hljs-keyword">const</span> middlewareAPI = {\n  getState: store.getState,\n  dispatch: (...args) =&gt; dispatch(...args)\n}\n<span class="hljs-comment">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span>\n<span class="hljs-keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))\n<span class="hljs-comment">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span>\ndispatch = compose(...chain)(store.dispatch)\n</code></pre>\n<p data-nodeid="12419" class="">这个代码片段做了两件事：首先以 middlewareAPI 作为入参，逐个调用传入的 middleware，获取一个由“内层函数”组成的数组 chain；然后调用 compose 函数，将 chain 中的“内层函数”逐个组合起来，并调用最终组合出来的函数。</p>\n<p data-nodeid="12420">在上面这段描述中，有两个点可能对你的理解构成障碍：</p>\n<ol data-nodeid="12421">\n<li data-nodeid="12422">\n<p data-nodeid="12423">什么是“内层函数”？</p>\n</li>\n<li data-nodeid="12424">\n<p data-nodeid="12425">compose 函数到底是怎么组合函数的？它组合出来的又是个什么东西？</p>\n</li>\n</ol>\n<p data-nodeid="12426">关于第 2 点，我们需要到 compose 源码中去看，这里先按下不表，咱们来说说“内层函数”在这里的含义。</p>\n<p data-nodeid="12427">首先我们需要站在函数的视角，来观察一下 thunk 中间件的源码：</p>\n<pre class="lang-java" data-nodeid="12428"><code data-language="java"><span class="hljs-comment">// createThunkMiddleware 用于创建 thunk</span>\n<span class="hljs-function">function <span class="hljs-title">createThunkMiddleware</span><span class="hljs-params">(extraArgument)</span> </span>{\n  <span class="hljs-comment">// 返回值是一个 thunk，它是一个函数</span>\n  <span class="hljs-keyword">return</span> ({ dispatch, getState }) =&gt; (next) =&gt; (action) =&gt; {\n    <span class="hljs-comment">// thunk 若感知到 action 是一个函数，就会执行 action</span>\n    <span class="hljs-keyword">if</span> (typeof action === <span class="hljs-string">\'function\'</span>) {\n      <span class="hljs-keyword">return</span> action(dispatch, getState, extraArgument);\n    }\n    <span class="hljs-comment">// 若 action 不是一个函数，则不处理，直接放过</span>\n    <span class="hljs-keyword">return</span> next(action);\n  };\n}\n<span class="hljs-keyword">const</span> thunk = createThunkMiddleware();\n</code></pre>\n<p data-nodeid="12429">thunk 中间件是 createThunkMiddleware 的返回值，createThunkMiddleware 返回的是这样的一个函数：</p>\n<pre class="lang-java" data-nodeid="12430"><code data-language="java">({ dispatch, getState }) =&gt; (next) =&gt; (action) =&gt; {\n  <span class="hljs-comment">// thunk 若感知到 action 是一个函数，就会执行 action</span>\n  <span class="hljs-keyword">if</span> (typeof action === <span class="hljs-string">\'function\'</span>) {\n    <span class="hljs-keyword">return</span> action(dispatch, getState, extraArgument);\n  }\n  <span class="hljs-comment">// 若 action 不是一个函数，则不处理，直接放过</span>\n  <span class="hljs-keyword">return</span> next(action);\n};\n</code></pre>\n<p data-nodeid="12431">该函数的返回值仍然是一个函数，显然它是一个<strong data-nodeid="12588">高阶函数</strong>。事实上，按照约定，所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为“外层函数”，将 return 出来的函数称为“内层函数”。</p>\n<p data-nodeid="12432" class="te-preview-highlight">而 apply 中遍历 middlewares 数组，逐个调用 middleware(middlewareAPI)，无非是为了获取中间件的内层函数。</p>\n<p data-nodeid="12433">以 thunk 的源码为例，不难看出，外层函数的主要作用是获取 dispatch、getState 这两个 API，而<strong data-nodeid="12597">真正的中间件逻辑是在内层函数中包裹的</strong>。待<code data-backticks="1" data-nodeid="12595">middlewares.map(middleware =&gt; middleware(middlewareAPI))</code>执行完毕后，内层函数会被悉数提取至 chain 数组。接下来，我们直接拿 chain 数组开刀就行了。</p>\n<p data-nodeid="12434">提取出 chain 数组之后，applyMiddleware 做的第一件事就是将数组中的中间件逻辑 compose 起来。</p>\n<p data-nodeid="12435">那么 compose 函数又是如何工作的呢？</p>\n<h4 data-nodeid="12436">3. compose 源码解读：函数的合成</h4>\n<p data-nodeid="12437">函数合成（组合函数）并不是 Redux 的专利，而是函数式编程中一个通用的概念。因此在 Redux 源码中，compose 函数是作为一个独立文件存在的，它具备较强的工具属性。</p>\n<p data-nodeid="12438">我们还是先通过阅读源码，来弄清楚 compose 到底都做了什么。以下是 compose 的源码（解析在注释里）：</p>\n<pre class="lang-java" data-nodeid="12439"><code data-language="java"><span class="hljs-comment">// compose 会首先利用“...”运算符将入参收敛为数组格式</span>\n<span class="hljs-function">export <span class="hljs-keyword">default</span> function <span class="hljs-title">compose</span><span class="hljs-params">(...funcs)</span> </span>{\n  <span class="hljs-comment">// 处理数组为空的边界情况</span>\n  <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) {\n    <span class="hljs-keyword">return</span> arg =&gt; arg\n  }\n\n  <span class="hljs-comment">// 若只有一个函数，也就谈不上组合，直接返回</span>\n  <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">1</span>) {\n    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]\n  }\n  <span class="hljs-comment">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span>\n  <span class="hljs-keyword">return</span> funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))\n}\n</code></pre>\n<p data-nodeid="12440">其实整段源码中值得你细细品味的只有最后这一行代码：</p>\n<pre class="lang-java" data-nodeid="12441"><code data-language="java"><span class="hljs-comment">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span>\n<span class="hljs-keyword">return</span> funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))\n</code></pre>\n<p data-nodeid="12442">这行代码告诉我们，函数组合是通过调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" data-nodeid="12609">数组的 reduce 方法</a>来实现的。</p>\n<p data-nodeid="12443">reduce 方法是 JS 数组中一个相对基础的概念，这里我们不再展开讲解，需要复习的同学请狠狠地<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" data-nodeid="12614">点击这里</a>。</p>\n<p data-nodeid="12444">reducer 方法的特点是，会对数组中的每个元素执行我们指定的函数逻辑，并将其结果汇总为单个返回值。因此对于这样的一个 compose 调用来说：</p>\n<pre class="lang-java" data-nodeid="12445"><code data-language="java">compose(f1, f2, f3, f4)\n</code></pre>\n<p data-nodeid="12446">它会把函数组合为这种形式：</p>\n<pre class="lang-java" data-nodeid="12447"><code data-language="java">(...args) =&gt;  f1(f2(f3(f4(...args))))\n</code></pre>\n<p data-nodeid="12448">如此一来，f1、f2、f3、f4 这 4 个中间件的内层逻辑就会被组合到一个函数中去，当这个函数被调用时，f1、f2、f3、f4 &nbsp;将会按照顺序被依次调用。这就是“函数组合”在此处的含义。</p>\n<h3 data-nodeid="12449">加餐：中间件与面向切面编程</h3>\n<p data-nodeid="12450">中间件这个概念并非 Redux 的专利，它在软件领域由来已久，大家所熟知的 Koa、Express 这些 Node 框架中也都不乏对中间件的应用。那么为什么中间件可以流行？为什么我们的应用需要中间件呢？这里，我就以 Redux 中间件机制为例，简单和你聊聊中间件背后的“面向切面”编程思想。</p>\n<p data-nodeid="12451">AOP（面向切面）这个概念可能很多同学都不太了解，大家相对熟悉的应该是 OOP（面向对象）。而 AOP 的存在，恰恰是为了解决 OOP 的局限性，我们可以将 AOP 看作是对 OOP 的一种补充。</p>\n<p data-nodeid="12452">在 OOP 模式下，当我们想要拓展一个类的逻辑时，最常见的思路就是继承：class A 继承 class B，class B 继承 class C......这样一层一层将逻辑向下传递。</p>\n<p data-nodeid="12453">当我们想要为某几个类追加一段共同的逻辑时，可以通过修改它们共同的父类来实现，这无疑会使得公共类越来越臃肿，可我们也确实没有什么更好的办法——总不能任这些公共逻辑散落在不同的业务逻辑里吧？那将会引发更加严重的代码冗余及耦合问题。</p>\n<p data-nodeid="12454">怎么办呢？“面向切面”来救场！</p>\n<p data-nodeid="12455">既然是面向“切面”，那么首先我们要搞清楚什么是“切面”。切面是一个相对于执行流程来说的概念，以 Redux 为例，它的工作流自上而下应该是这样的，如下图所示：</p>\n<p data-nodeid="12456"><img src="https://s0.lgstatic.com/i/image2/M01/01/49/CgpVE1_YZC-AKwdJAACTdBArWEQ782.png" alt="Drawing 5.png" data-nodeid="12628"></p>\n<p data-nodeid="12457">此时考虑这样一个需求：要求在每个 Action 被派发之后，打出一个 console.log 记录“action 被派发了”这个动作，也就是我们常说的“日志追溯”。这个需求的<strong data-nodeid="12638">通用性很强、业务属性很弱</strong>，因此不适合与任何的业务逻辑耦合在一起。那我们就可以以 <strong data-nodeid="12639">“切面”这种形式，把它与业务逻辑剥离开来</strong>：扩展功能在工作流中的执行节点，可以视为一个单独“切点”；我们把扩展功能的逻辑放到这个“切点”上来，形成的就是一个可以拦截前序逻辑的“切面”，如下图所示：</p>\n<p data-nodeid="12458"><img src="https://s0.lgstatic.com/i/image2/M01/01/49/CgpVE1_YZEGAPHOaAACpc9ZgOG0409.png" alt="Drawing 7.png" data-nodeid="12642"></p>\n<p data-nodeid="12459">“切面”与业务逻辑是分离的，因此 AOP 是一种典型的 <strong data-nodeid="12648">“非侵入式”的逻辑扩充思路</strong>。</p>\n<p data-nodeid="12460">在日常开发中，像“日志追溯”“异步工作流处理”“性能打点”这类和业务逻辑关系不大的功能，我们都可以考虑把它们抽到“切面”中去做。</p>\n<p data-nodeid="12461">面向切面编程带来的利好是非常明显的。从 Redux 中间件机制中，不难看出，面向切面思想在很大程度上提升了我们组织逻辑的灵活度与干净度，帮助我们规避掉了逻辑冗余、逻辑耦合这类问题。通过将“切面”与业务逻辑剥离，开发者能够专注于业务逻辑的开发，并通过“<strong data-nodeid="12655">即插即用</strong>”的方式自由地组织自己想要的扩展功能。</p>\n<h3 data-nodeid="12462">总结</h3>\n<p data-nodeid="12463">在这一讲，我们首先以 redux-thunk 中间件为例，从“异步工作流”场景切入，认识了 Redux 中间件的工作模式。随后，结合 applyMiddleware 源码，对 Redux 中间件的整个执行机制进行了细致深入的分析，并在文末引入了对“面向切面”这一编程思想的介绍。</p>\n<p data-nodeid="12464">行文至此，整个由 Redux 所牵出的核心知识体系也已经一览无余地呈现在你面前，相信你对 &nbsp;Redux 的理解又上了一个台阶。</p>\n<p data-nodeid="12465" class="">专栏的下一讲，我将以 React 的另一个“好帮手” React-Router 为切入点，为你讲解前端路由相关的知识，不见不散。</p>',
          },
          {
            theme: '21 | 从 React-Router 切入，系统学习前端路由解决方案',
            id: 222,
            content:
              '<p data-nodeid="1189" class="">React-Router 是 React 场景下的路由解决方案，本讲我们将学习 React-Router 的实现机制，并基于此提取和探讨通用的前端路由解决方案。</p>\n<blockquote data-nodeid="1190">\n<p data-nodeid="1191">注：没有使用过 React-Router 的同学，可以点击<a href="https://reactrouter.com/web/guides/quick-start" data-nodeid="1306">这里</a>完成快速上手。</p>\n</blockquote>\n<h3 data-nodeid="1192">认识 React-Router</h3>\n<p data-nodeid="1193">本着尽快进入主题的原则，这里我用一个尽可能简单的 Demo 作为引子，帮助你快速地把握 React-Router 的核心功能。请看下面代码（解析在注释里）：</p>\n<pre class="lang-js" data-nodeid="1194"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-comment">// 引入 React-Router 中的相关组件</span>\n<span class="hljs-keyword">import</span> { BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;\n<span class="hljs-comment">// 导出目标组件</span>\n<span class="hljs-keyword">const</span> BasicExample = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (\n  <span class="hljs-comment">// 组件最外层用 Router 包裹</span>\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n          // 具体的标签用 Link 包裹\n          <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n          // 具体的标签用 Link 包裹\n          <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n          // 具体的标签用 Link 包裹\n          <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/dashboard"</span>&gt;</span>Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>\n\n      // Route 是用于声明路由映射到应用程序的组件层\n      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Home}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/about"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{About}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/dashboard"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Dashboard}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>\n);\n<span class="hljs-comment">// Home 组件的定义</span>\n<span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n<span class="hljs-comment">// About 组件的定义</span>\n<span class="hljs-keyword">const</span> About = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n<span class="hljs-comment">// Dashboard 的定义</span>\n<span class="hljs-keyword">const</span> Dashboard = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> BasicExample;\n</code></pre>\n<p data-nodeid="1195">这个 Demo 渲染出的页面效果如下图所示：</p>\n<p data-nodeid="1196"><img src="https://s0.lgstatic.com/i/image/M00/8B/20/CgqCHl_bOA2AfagHAAAwif17aiI096.png" alt="Drawing 0.png" data-nodeid="1313"></p>\n<p data-nodeid="1197">当我点击不同的链接时，ul 元素内部就会展示不同的组件内容。比如当我点击“About”链接时，就会展示 About 组件的内容，效果如下图所示：</p>\n<p data-nodeid="1198"><img src="https://s0.lgstatic.com/i/image2/M01/02/F3/CgpVE1_bOBOAQTs_AAAuMzu6RbY087.png" alt="Drawing 1.png" data-nodeid="1317"></p>\n<p data-nodeid="1199">注意，点击 About 后，界面中发生变化的地方有两处（见下图标红处），除了 ul 元素的内容改变了之外，路由信息也改变了。</p>\n<p data-nodeid="1200"><img src="https://s0.lgstatic.com/i/image2/M01/02/F2/Cip5yF_bOBmAfCOxAAA2a1pswj4899.png" alt="Drawing 2.png" data-nodeid="1321"></p>\n<p data-nodeid="1201">在 React-Router 中，各种细碎的功能点有不少，但作为 React 框架的前端路由解决方案，它最基本也是最核心的能力，其实正是你刚刚所见到的这一幕——<strong data-nodeid="1327">路由的跳转</strong>。这也是我们接下来讨论的重点。</p>\n<p data-nodeid="1202">接下来我们就结合 React-Router 的源码，一起来看看“跳转”这个动作是如何实现的。</p>\n<h3 data-nodeid="1203">React-Router 是如何实现路由跳转的？</h3>\n<p data-nodeid="1204">首先需要回顾下 Demo 中的第一行代码：</p>\n<pre class="lang-java" data-nodeid="1205"><code data-language="java"><span class="hljs-keyword">import</span> { BrowserRouter as Router, Route, Link } from <span class="hljs-string">"react-router-dom"</span>;\n</code></pre>\n<p data-nodeid="1206">这行代码告诉我们，为了实现一个简单的路由跳转效果，一共从 React-Router 中引入了以下 3 个组件：</p>\n<ul data-nodeid="1207">\n<li data-nodeid="1208">\n<p data-nodeid="1209">BrowserRouter</p>\n</li>\n<li data-nodeid="1210">\n<p data-nodeid="1211">Route</p>\n</li>\n<li data-nodeid="1212">\n<p data-nodeid="1213">Link</p>\n</li>\n</ul>\n<p data-nodeid="1214">这 3 个组件也就代表了 React-Router 中的 3 个核心角色：</p>\n<ul data-nodeid="1215">\n<li data-nodeid="1216">\n<p data-nodeid="1217"><strong data-nodeid="1340">路由器</strong>，比如 BrowserRouter 和 HashRouter</p>\n</li>\n<li data-nodeid="1218">\n<p data-nodeid="1219"><strong data-nodeid="1345">路由</strong>，比如 Route 和 Switch</p>\n</li>\n<li data-nodeid="1220">\n<p data-nodeid="1221"><strong data-nodeid="1350">导航</strong>，比如 Link、NavLink、Redirect</p>\n</li>\n</ul>\n<p data-nodeid="1222">路由（以 Route 为代表）负责定义路径与组件之间的映射关系，而导航（以 Link 为代表）负责触发路径的改变，路由器（包括 BrowserRouter 和 HashRouter）则会根据 Route 定义出来的映射关系，为新的路径匹配它对应的逻辑。</p>\n<p data-nodeid="1223">以上便是 3 个角色“打配合”的过程。这其中，最需要你注意的是路由器这个角色，React Router 曾在说明文档中官宣它是“React Router 应用程序的核心”。因此学习 React Router，最要紧的是搞明白路由器的工作机制。</p>\n<h4 data-nodeid="1224">路由器：BrowserRouter 和 HashRouter</h4>\n<p data-nodeid="1225"><strong data-nodeid="1358">路由器负责感知路由的变化并作出反应，它是整个路由系统中最为重要的一环</strong>。React-Router 支持我们使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则，这里我们把两种规则都讲一下。</p>\n<p data-nodeid="1226">HashRouter、BrowserRouter，这俩人名字这么像，该不会底层逻辑区别也不大吧？别说，还真是如此。我们首先来瞟一眼 HashRouter 的源码：</p>\n<p data-nodeid="1227"><img src="https://s0.lgstatic.com/i/image2/M01/02/F2/Cip5yF_bOCSAErIlAAEU7gTEf-c538.png" alt="Drawing 3.png" data-nodeid="1362"></p>\n<p data-nodeid="1228">再瞟一眼 BrowserRouter 的源码：</p>\n<p data-nodeid="1229"><img src="https://s0.lgstatic.com/i/image/M00/8B/15/Ciqc1F_bOCyAFB9oAADQnB3x2AY718.png" alt="Drawing 4.png" data-nodeid="1366"></p>\n<p data-nodeid="1230">我们会发现这两个文件惊人的相似，而最关键的区别我也已经在图中分别标出，即它们调用的 history 实例化方法不同：HashRouter 调用了 <a href="https://github.com/ReactTraining/history/blob/v4.7.2/modules/createHashHistory.js" data-nodeid="1370">createHashHistory</a>，BrowserRouter 调用了 <a href="https://github.com/ReactTraining/history/blob/v4.7.2/modules/createBrowserHistory.js" data-nodeid="1374">createBrowserHistory</a>。</p>\n<p data-nodeid="1231">这两个 history 的实例化方法均来源于 <a href="https://github.com/ReactTraining/history" data-nodeid="1379">history</a> 这个独立的代码库，关于它的实现细节，你倒不必纠结。对于 <a href="https://github.com/ReactTraining/history/blob/v4.7.2/modules/createHashHistory.js" data-nodeid="1383">createHashHistory</a> 和 <a href="https://github.com/ReactTraining/history/blob/v4.7.2/modules/createBrowserHistory.js" data-nodeid="1387">createBrowserHistory</a> 这两个 API，我们最要紧的是掌握它们各自的特征。</p>\n<ul data-nodeid="2070">\n<li data-nodeid="2071">\n<p data-nodeid="2072"><code data-backticks="1" data-nodeid="2074">createBrowserHistory</code>：它将在浏览器中使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" data-nodeid="2078">HTML5 history API</a> 来处理 URL（见下图标红处的说明），它能够处理形如这样的 URL，example.com/some/path。由此可得，<strong data-nodeid="2083">BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的。</strong></p>\n</li>\n</ul>\n<p data-nodeid="2073" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/78/Cip5yF_cKqmATWf8AAN3hb7gX3k493.png" alt="图片1.png" data-nodeid="2086"></p>\n\n\n<ul data-nodeid="1236">\n<li data-nodeid="1237">\n<p data-nodeid="1238" class="te-preview-highlight"><code data-backticks="1" data-nodeid="1402">createHashHistory</code>：它是使用 hash tag (#) 处理 URL 的方法，能够处理形如这样的 URL，example.com/#/some/path。我们可以看到<a href="https://github.com/ReactTraining/history/blob/v4.7.2/modules/createHashHistory.js" data-nodeid="1406">它的源码中</a>对各种方法的定义基本都围绕 hash 展开（如下图所示），由此可得，<strong data-nodeid="1412">HashRouter 是通过 URL 的 hash 属性来控制路由跳转的</strong>。</p>\n</li>\n</ul>\n<p data-nodeid="1239"><img src="https://s0.lgstatic.com/i/image/M00/8B/15/Ciqc1F_bOFaAWDI8AAD_FnBQsTc850.png" alt="Drawing 6.png" data-nodeid="1415"></p>\n<blockquote data-nodeid="1240">\n<p data-nodeid="1241">注：关于 hash 和 history 这两种模式，我们在下文中还会持续探讨。</p>\n</blockquote>\n<p data-nodeid="1242">现在，见识了表面现象，了解了背后机制。我们不妨回到故事的原点，再多问自己一个问题：为什么我们需要 React-Router？</p>\n<p data-nodeid="1243">或者把这个问题稍微拔高一点：<strong data-nodeid="1423">为什么我们需要前端路由</strong>？</p>\n<p data-nodeid="1244">这一切的一切，都要从很久以前说起。</p>\n<h3 data-nodeid="1245">理解前端路由——是什么？解决什么问题？</h3>\n<h4 data-nodeid="1246">背景——问题的产生</h4>\n<p data-nodeid="1247">在前端技术早期，一个 URL 对应一个页面，如果你要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——毕竟用户只有在刷新页面的情况下，才可以重新去请求数据。</p>\n<p data-nodeid="1248">后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了<strong data-nodeid="1433">SPA（单页面应用</strong>）。</p>\n<p data-nodeid="1249">SPA 极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p>\n<ul data-nodeid="1250">\n<li data-nodeid="1251">\n<p data-nodeid="1252">SPA 其实并不知道当前的页面“进展到了哪一步”，可能你在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，你必须重复之前的操作才可以重新对内容进行定位——SPA 并不会“记住”你的操作；</p>\n</li>\n<li data-nodeid="1253">\n<p data-nodeid="1254">由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息。</p>\n</li>\n</ul>\n<p data-nodeid="1255">为了解决这个问题，前端路由出现了。</p>\n<h4 data-nodeid="1256">前端路由——SPA“定位”解决方案</h4>\n<p data-nodeid="1257">前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p>\n<p data-nodeid="1258">那么如何实现这个目的呢？首先我们要解决以下两个问题。</p>\n<ul data-nodeid="1259">\n<li data-nodeid="1260">\n<p data-nodeid="1261">当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</p>\n</li>\n<li data-nodeid="1262">\n<p data-nodeid="1263">单页面应用对服务端来说，就是一个 URL、一套资源，那么如何做到用“不同的 URL”来映射不同的视图内容呢？</p>\n</li>\n</ul>\n<p data-nodeid="1264">从这两个问题来看，服务端已经救不了 SPA 这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，我们可以提供以下这样的解决思路。</p>\n<ul data-nodeid="1265">\n<li data-nodeid="1266">\n<p data-nodeid="1267"><strong data-nodeid="1448">拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容</strong>，把刷新这个动作完全放到前端逻辑里消化掉；</p>\n</li>\n<li data-nodeid="1268">\n<p data-nodeid="1269"><strong data-nodeid="1453">感知 URL 的变化</strong>。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理，这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端能感知到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</p>\n</li>\n</ul>\n<h3 data-nodeid="1270">实践思路——hash 与 history</h3>\n<p data-nodeid="1271">接下来重点就来了，现在前端界对前端路由有哪些实现思路？这里需要掌握的两个实践就是 hash 与 history。</p>\n<h4 data-nodeid="1272">hash 模式</h4>\n<p data-nodeid="1273">hash 模式是指通过改变 URL 后面以“#”分隔的字符串（这货其实就是 URL 上的哈希值），从而让页面感知到路由变化的一种实现方式。举个例子，比如这样的一个 URL：</p>\n<pre class="lang-java" data-nodeid="1274"><code data-language="java">https:<span class="hljs-comment">//www.imooc.com/</span>\n</code></pre>\n<p data-nodeid="1275">我就可以通过增加和改变哈希值，来让这个 URL 变得有那么一点点不一样：</p>\n<pre class="lang-java" data-nodeid="1276"><code data-language="java"><span class="hljs-comment">// 主页</span>\nhttps:<span class="hljs-comment">//www.imooc.com/#index</span>\n<span class="hljs-comment">// 活动页</span>\nhttps:<span class="hljs-comment">//www.imooc.com/#activePage</span>\n</code></pre>\n<p data-nodeid="1277">这个“不一样”是前端完全可感知的——JS 可以帮我们捕获到哈希值的内容。在 hash 模式下，我们实现路由的思路可以概括如下：</p>\n<p data-nodeid="1278">（1）hash 的改变：我们可以通过 location 暴露出来的属性，直接去修改当前 URL 的 hash 值：</p>\n<pre class="lang-java" data-nodeid="1279"><code data-language="java">window.location.hash = <span class="hljs-string">\'index\'</span>;\n</code></pre>\n<p data-nodeid="1280">（2）hash 的感知：通过监听 “hashchange”事件，可以用 JS 来捕捉 hash 值的变化，进而决定我们页面内容是否需要更新：</p>\n<pre class="lang-java" data-nodeid="1281"><code data-language="java"><span class="hljs-comment">// 监听hash变化，点击浏览器的前进后退会触发</span>\nwindow.addEventListener(<span class="hljs-string">\'hashchange\'</span>, function(event){ \n    <span class="hljs-comment">// 根据 hash 的变化更新内容</span>\n},<span class="hljs-keyword">false</span>)\n</code></pre>\n<h4 data-nodeid="1282">history 模式</h4>\n<p data-nodeid="1283">大家知道，在我们浏览器的左上角，往往有这样的操作点：</p>\n<p data-nodeid="1284"><img src="https://s0.lgstatic.com/i/image/M00/8B/20/CgqCHl_bOGeAQW2AAACAaTKsTyM327.png" alt="Drawing 7.png" data-nodeid="1466"></p>\n<p data-nodeid="1285">通过点击前进后退箭头，就可以实现页面间的跳转。这样的行为，其实是可以通过 API 来实现的。</p>\n<p data-nodeid="1286">浏览器的 history API 赋予了我们这样的能力，在 HTML 4 时，就可以通过下面的接口来操作浏览历史、实现跳转动作：</p>\n<pre class="lang-java" data-nodeid="1287"><code data-language="java">window.history.forward()  <span class="hljs-comment">// 前进到下一页</span>\n</code></pre>\n<pre class="lang-java" data-nodeid="1288"><code data-language="java">window.history.back() <span class="hljs-comment">// 后退到上一页</span>\n</code></pre>\n<pre class="lang-java" data-nodeid="1289"><code data-language="java">window.history.go(<span class="hljs-number">2</span>) <span class="hljs-comment">// 前进两页</span>\n</code></pre>\n<pre class="lang-java" data-nodeid="1290"><code data-language="java">window.history.go(-<span class="hljs-number">2</span>) <span class="hljs-comment">// 后退两页</span>\n</code></pre>\n<p data-nodeid="1291">很有趣吧？遗憾的是，在这个阶段，我们能做的只是“切换”，而不能“改变”。好在从 HTML 5 开始，浏览器支持了 pushState 和 replaceState 两个 API，允许我们对浏览历史进行修改和新增：</p>\n<pre class="lang-java" data-nodeid="1292"><code data-language="java">history.pushState(data[,title][,url]); <span class="hljs-comment">// 向浏览历史中追加一条记录</span>\n</code></pre>\n<pre class="lang-java" data-nodeid="1293"><code data-language="java">history.replaceState(data[,title][,url]); <span class="hljs-comment">// 修改（替换）当前页在浏览历史中的信息</span>\n</code></pre>\n<p data-nodeid="1294">这样一来，修改动作就齐活了。</p>\n<p data-nodeid="1295">有修改，就要有对修改的感知能力。在 history 模式下，我们可以通过监听 popstate 事件来达到我们的目的：</p>\n<pre class="lang-java" data-nodeid="1296"><code data-language="java">window.addEventListener(<span class="hljs-string">\'popstate\'</span>, function(e) {\n  console.log(e)\n});\n</code></pre>\n<p data-nodeid="1297">每当浏览历史发生变化，popstate 事件都会被触发。</p>\n<p data-nodeid="1298"><strong data-nodeid="1481">注</strong>：go、forward 和 back 等方法的调用确实会触发 popstate，但是<strong data-nodeid="1482">pushState 和 replaceState 不会</strong>。不过这一点问题不大，我们可以通过自定义事件和全局事件总线来手动触发事件。</p>\n<h3 data-nodeid="1299">总结</h3>\n<p data-nodeid="1300">本讲我们以 React-Router 为切入点，结合源码剖析了 React-Router 中“跳转”这一动作的实现原理，由此牵出了针对“前端路由方案”这个知识点相对系统的探讨。行文至此，React 周边生态所涉及的重难点知识，相信已经深深地烙印在了你的脑海里。</p>\n<p data-nodeid="1301" class="">下一讲开始，我们将围绕“React 设计模式与最佳实践”以及“React 性能优化”两条主线展开学习。彼时，站在“生产实践”这个全新的视角去认识 React 后，相信各位对它的理解定会更上一层楼。大家加油！</p>',
          },
        ],
      },
      {
        sectionName: '模块四：“生产实践”通用法则',
        sectionId: 5,
        courseList: [
          {
            theme: '22 | 思路拓展：如何打造高性能的 React 应用？',
            id: 223,
            content:
              '<p data-nodeid="56901">React 应用也是前端应用，如果之前你知道一些前端项目普适的性能优化手段，比如资源加载过程中的优化、减少重绘与回流、服务端渲染、启用 CDN 等，那么这些手段对于 React 来说也是同样奏效的。</p>\n<p data-nodeid="56902">不过对于 React 项目来说，它有一个区别于传统前端项目的重要特点，就是<strong data-nodeid="57014">以 React 组件的形式来组织逻辑</strong>：组件允许我们将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。因此，除了前面所提到的普适的前端性能优化手段之外，React 还有一些充满了自身特色的性能优化思路，这些思路基本都围绕“组件性能优化”这个中心思想展开。本讲我将带你认识其中最关键的 3 个思路：</p>\n<ol data-nodeid="56903">\n<li data-nodeid="56904">\n<p data-nodeid="56905"><strong data-nodeid="57018">使用 shouldComponentUpdate 规避冗余的更新逻辑</strong></p>\n</li>\n<li data-nodeid="56906">\n<p data-nodeid="56907"><strong data-nodeid="57022">PureComponent + Immutable.js</strong></p>\n</li>\n<li data-nodeid="56908">\n<p data-nodeid="56909"><strong data-nodeid="57026">React.memo 与 useMemo</strong></p>\n</li>\n</ol>\n<blockquote data-nodeid="56910">\n<p data-nodeid="56911">注：<strong data-nodeid="57032">这 3 个思路同时也是 React 面试中“性能优化”这一环的核心所在</strong>。大家在回答类似题目的时候，不管其他的细枝末节的优化策略能不能想起来，以上三点一定要尽量答全。</p>\n</blockquote>\n<h3 data-nodeid="56912">朴素思路：善用 shouldComponentUpdate</h3>\n<p data-nodeid="56913">shouldComponentUpdate 是 React 类组件的一个生命周期。关于 shouldComponentUpdate 是什么，我们已经在第 02 讲有过介绍，这里先简单复习一下。</p>\n<p data-nodeid="56914">shouldComponentUpdate 的调用形式如下：</p>\n<pre class="lang-js" data-nodeid="60415"><code data-language="js">shouldComponentUpdate(nextProps, nextState)\n</code></pre>\n\n<p data-nodeid="56916">render 方法由于伴随着对虚拟 DOM 的构建和对比，过程可以说相当耗时。而在 React 当中，很多时候我们会不经意间就频繁地调用了 render。为了避免不必要的 render 操作带来的性能开销，React 提供了 shouldComponentUpdate 这个口子。<strong data-nodeid="57041">React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行 re-render（重渲染）</strong>。</p>\n<p data-nodeid="58253" class="">shouldComponentUpdate 的默认值为 true，也就是说 <strong data-nodeid="58259">“无条件 re-render”</strong>。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，来实现“有条件的 re-render”。</p>\n\n<p data-nodeid="56918">接下来我们通过一个 Demo，来感受一下 shouldComponentUpdate 到底是如何解决问题的。在这个 Demo 中会涉及 3 个组件：子组件 ChildA、ChildB 及父组件 App 组件。</p>\n<p data-nodeid="56919">首先我们来看两个子组件的代码，这里为了尽量简化与数据变更无关的逻辑，ChildA 和 ChildB 都只负责从父组件处读取数据并渲染，它们的编码分别如下所示。</p>\n<p data-nodeid="56920">ChildA.js：</p>\n<pre class="lang-js" data-nodeid="58798"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  render() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ChildA 的render方法执行了"</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"childA"</span>&gt;</span>\n        子组件A的内容：\n        {this.props.text}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n\n<p data-nodeid="56922">ChildB.js：</p>\n<pre class="lang-js" data-nodeid="59337"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  render() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ChildB 的render方法执行了"</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"childB"</span>&gt;</span>\n        子组件B的内容：\n        {this.props.text}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n\n<p data-nodeid="56924">在共同的父组件 App.js 中，会将 ChildA 和 ChildB 组合起来，并分别向其中注入数据：</p>\n<pre class="lang-js" data-nodeid="59876"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">import</span> ChildA <span class="hljs-keyword">from</span> <span class="hljs-string">\'./ChildA\'</span>\n<span class="hljs-keyword">import</span> ChildB <span class="hljs-keyword">from</span> <span class="hljs-string">\'./ChildB\'</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  state = {\n    <span class="hljs-attr">textA</span>: <span class="hljs-string">\'我是A的文本\'</span>,\n    <span class="hljs-attr">textB</span>: <span class="hljs-string">\'我是B的文本\'</span>\n  }\n  changeA = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">textA</span>: <span class="hljs-string">\'A的文本被修改了\'</span>\n    })\n  }\n  changeB = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">textB</span>: <span class="hljs-string">\'B的文本被修改了\'</span>\n    })\n  }\n  render() {\n    <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeA}</span>&gt;</span>点击修改A处的文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeB}</span>&gt;</span>点击修改B处的文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{this.state.textA}/</span>&gt;</span>\n          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{this.state.textB}/</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n  }\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;\n</code></pre>\n\n<p data-nodeid="56926">App 组件最终渲染到界面上的效果如下图所示，两个子组件在图中分别被不同颜色的标注圈出：</p>\n<p data-nodeid="60954" class=""><img src="https://s0.lgstatic.com/i/image/M00/8B/D3/CgqCHl_ga3-ADPKZAACHTPJhWNw299.png" alt="Drawing 0.png" data-nodeid="60957"></p>\n\n<p data-nodeid="56928">通过点击左右两个按钮，我们可以分别对 ChildA 和 ChildB 中的文案进行修改。</p>\n<p data-nodeid="56929">由于初次渲染时，两个组件的 render 函数都必然会被触发，因此控制台在挂载完成后的输出内容如下图所示：</p>\n<p data-nodeid="61496" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/AA/CgpVE1_ga4qAdOlsAAAzU_bU8eQ279.png" alt="Drawing 1.png" data-nodeid="61499"></p>\n\n<p data-nodeid="56931">接下来我点击左侧的按钮，尝试对 A 处的文本进行修改。我们可以看到界面上只有 A 处的渲染效果发生了改变，如下图箭头处所示：</p>\n<p data-nodeid="62038" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/A9/Cip5yF_ga5KALnO1AABLrDrgDGM452.png" alt="Drawing 2.png" data-nodeid="62041"></p>\n\n<p data-nodeid="56933">但是如果我们打开控制台，会发现输出的内容如下图所示：</p>\n<p data-nodeid="62580" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/A9/Cip5yF_ga5qABE7ZAABs-adr_7k107.png" alt="Drawing 3.png" data-nodeid="62583"></p>\n\n<p data-nodeid="56935">这样的输出结果告诉我们，在刚刚的点击动作后，不仅 ChildA 的 re-render 被触发了，ChildB 的 re-render 也被触发了。</p>\n<p data-nodeid="56936">在 React 中，<strong data-nodeid="57075">只要父组件发生了更新，那么所有的子组件都会被无条件更新</strong>。这就导致了 ChildB 的 props 尽管没有发生任何变化，它本身也没有任何需要被更新的点，却还是会走一遍更新流程。</p>\n<blockquote data-nodeid="56937">\n<p data-nodeid="56938">注：同样的情况也适用于组件自身的更新：当组件自身调用了 setState 后，那么不管 setState 前后的状态内容是否真正发生了变化，它都会去走一遍更新流程。</p>\n</blockquote>\n<p data-nodeid="56939">而在刚刚这个更新流程中，shouldComponentUpdate 函数没有被手动定义，因此它将返回“true”这个默认值。“true”则意味着对更新流程不作任何制止，也即所谓的“无条件 re-render”。在这种情况下，我们就可以考虑使用 shouldComponentUpdate 来对更新过程进行管控，避免没有意义的 re-render 发生。</p>\n<p data-nodeid="56940">现在我们就可以为 ChildB 加装这样一段 shouldComponentUpdate 逻辑：</p>\n<pre class="lang-js" data-nodeid="63122"><code data-language="js">shouldComponentUpdate(nextProps, nextState) {\n  <span class="hljs-comment">// 判断 text 属性在父组件更新前后有没有发生变化，若没有发生变化，则返回 false</span>\n  <span class="hljs-keyword">if</span>(nextProps.text === <span class="hljs-keyword">this</span>.props.text) {\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n  }\n  <span class="hljs-comment">// 只有在 text 属性值确实发生变化时，才允许更新进行下去</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n}\n</code></pre>\n\n<p data-nodeid="56942">在这段逻辑中，我们对 ChildB 中的可变数据，也就是 this.props.text 这个属性进行了判断。</p>\n<p data-nodeid="56943">这样，当父组件 App 组件发生更新、进而试图触发 ChildB 的更新流程时，shouldComponentUpdate 就会充当一个“守门员”的角色：它会检查新下发的 props.text 是否和之前的值一致，如果一致，那么就没有更新的必要，直接返回“false”将整个 ChildB 的更新生命周期中断掉即可。只有当 props.text 确实发生变化时，它才会“准许” re-render 的发生。</p>\n<p data-nodeid="56944">在 shouldComponentUpdate 的加持下，当我们再次点击左侧按钮，试图修改 ChildA 的渲染内容时，控制台的输出就会变成下图这样：</p>\n<p data-nodeid="63661" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/AA/CgpVE1_ga6yAVvq5AABmBay34YA804.png" alt="Drawing 4.png" data-nodeid="63664"></p>\n\n<p data-nodeid="56946">我们看到，控制台中现在只有 ChildA 的 re-render 提示。ChildB “稳如泰山”，成功躲开了一次多余的渲染。</p>\n<p data-nodeid="56947">使用 shouldComponentUpdate 来调停不必要的更新，避免无意义的 re-render 发生，这是 React 组件中最基本的性能优化手段，也是最重要的手段。许多看似高级的玩法，都是基于 shouldComponentUpdate 衍生出来的。我们接下来要讲的 PureComponent，就是这类玩法中的典型。</p>\n<h3 data-nodeid="56948">进阶玩法：PureComponent &nbsp;+ Immutable.js</h3>\n<h4 data-nodeid="56949">PureComponent：提前帮你安排好更新判定逻辑</h4>\n<p data-nodeid="56950">shouldComponentUpdate 虽然一定程度上帮我们解决了性能方面的问题，但每次避免 re-render，都要手动实现一次 shouldComponentUpdate，未免太累了。作为一个不喜欢重复劳动的前端开发者来说，在写了不计其数个 shouldComponentUpdate 逻辑之后，难免会怀疑人生，进而发出由衷的感叹——“这玩意儿要是能内置到组件里该多好啊！”。</p>\n<p data-nodeid="65835" class="">哪里有需求，哪里就有产品。React 15.3 很明显听到了开发者的声音，它新增了一个叫 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" data-nodeid="65839">PureComponent</a> 的类，恰到好处地解决了“程序员写 shouldComponentUpdate 写出腱鞘炎”这个问题。</p>\n\n\n\n\n<p data-nodeid="56952">PureComponent 与 Component 的区别点，就在于它内置了对 shouldComponentUpdate 的实现：PureComponent 将会在 shouldComponentUpdate 中对组件更新前后的 props 和 state 进行<strong data-nodeid="57100">浅比较</strong>，并根据浅比较的结果，决定是否需要继续更新流程。</p>\n<p data-nodeid="56953">“浅比较”将针对值类型数据对比其值是否相等，而针对数组、对象等引用类型的数据则对比其引用是否相等。</p>\n<p data-nodeid="56954">在我们开篇的 Demo 中，若把 ChildB 的父类从 Component 替换为 PureComponent（修改后的代码如下所示），那么无须手动编写 shouldComponentUpdate，也可以达到同样避免 re-render 的目的。</p>\n<pre class="lang-js" data-nodeid="66379"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span> </span>{\n  render() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ChildB 的render方法执行了"</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"childB"</span>&gt;</span>\n        子组件B的内容：\n        {this.props.text}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n\n<p data-nodeid="56956">此时再去修改 ChildA 中的文本，我们会发现 ChildB 同样不受影响。点击左侧按钮后，控制台对应的输出内容如下图高亮处所示：</p>\n<p data-nodeid="66918" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/A9/Cip5yF_ga8qADhf9AACUfTqE0ag890.png" alt="Drawing 5.png" data-nodeid="66921"></p>\n\n<p data-nodeid="56958">在值类型数据这种场景下，PureComponent 可以说是战无不胜。但是如果数据类型为引用类型，那么这种基于浅比较的判断逻辑就会带来这样两个风险：</p>\n<ol data-nodeid="56959">\n<li data-nodeid="56960">\n<p data-nodeid="56961">若数据内容没变，但是引用变了，那么浅比较仍然会认为“数据发生了变化”，进而触发一次不必要的更新，导致过度渲染；</p>\n</li>\n<li data-nodeid="56962">\n<p data-nodeid="56963">若数据内容变了，但是引用没变，那么浅比较则会认为“数据没有发生变化”，进而阻断一次更新，导致不渲染。</p>\n</li>\n</ol>\n<p data-nodeid="56964">怎么办呢？Immutable.js 来帮忙！</p>\n<h4 data-nodeid="56965">Immutable：“不可变值”让“变化”无处遁形</h4>\n<p data-nodeid="56966">PureComponent 浅比较带来的问题，本质上是对“变化”的判断不够精准导致的。那有没有一种办法，能够让引用的变化和内容的变化之间，建立一种必然的联系呢？</p>\n<p data-nodeid="56967">这就是 Immutable.js 所做的事情。</p>\n<p data-nodeid="56968">Immutable 直译过来是“不可变的”，顾名思义，Immutable.js 是对“不可变值”这一思想的贯彻实践。它在 2014 年被 Facebook 团队推出，Facebook 给它的定位是“实现持久性数据结构的库”。<strong data-nodeid="57119">所谓“持久性数据”，指的是这个数据只要被创建出来了，就不能被更改。我们对当前数据的任何修改动作，都会导致一个新的对象的返回</strong>。这就将数据内容的变化和数据的引用严格地关联了起来，使得“变化”无处遁形。</p>\n<p data-nodeid="56969">这里我用一个简单的例子，来演示一下 Immutable.js 的效果。请看下面代码：</p>\n<pre class="lang-java" data-nodeid="56970"><code data-language="java"><span class="hljs-comment">// 引入 immutable 库里的 Map 对象，它用于创建对象</span>\n<span class="hljs-keyword">import</span> { Map } from <span class="hljs-string">\'immutable\'</span>\n<span class="hljs-comment">// 初始化一个对象 baseMap</span>\n<span class="hljs-keyword">const</span> baseMap = Map({\n  name: <span class="hljs-string">\'修言\'</span>,\n  career: <span class="hljs-string">\'前端\'</span>,\n  age: <span class="hljs-number">99</span>\n})\n<span class="hljs-comment">// 使用 immutable 暴露的 Api 来修改 baseMap 的内容</span>\n<span class="hljs-keyword">const</span> changedMap = baseMap.set({\n  age: <span class="hljs-number">100</span>\n})\n<span class="hljs-comment">// 我们会发现修改 baseMap 后将会返回一个新的对象，这个对象的引用和 baseMap 是不同的</span>\nconsole.log(<span class="hljs-string">\'baseMap === changedMap\'</span>, baseMap === changedMap)\n</code></pre>\n<p data-nodeid="56971">由此可见，PureComonent 和 Immutable.js 真是一对好基友！在实际的开发中，我们也确实经常左手 PureComonent，右手 Immutable.js，研发质量大大地提升呀！</p>\n<blockquote data-nodeid="56972">\n<p data-nodeid="56973">值得注意的是，由于 Immutable.js 存在一定的学习成本，并不是所有场景下都可以作为最优解被团队采纳。因此，一些团队也会基于 PureComonent 和 Immutable.js 去打造将两者结合的公共类，通过改写 setState 来提升研发体验，这也是不错的思路。</p>\n</blockquote>\n<h3 data-nodeid="56974">函数组件的性能优化：React.memo 和 useMemo</h3>\n<p data-nodeid="56975">以上咱们讨论的都是类组件的优化思路。那么在函数组件中，有没有什么通用的手段可以阻止“过度 re-render”的发生呢？接下来我们就一起认识一下“函数版”的 shouldComponentUpdate/Purecomponent —— React.memo。</p>\n<h4 data-nodeid="56976">React.memo：“函数版”shouldComponentUpdate/PureComponent</h4>\n<p data-nodeid="56977">React.memo 是 React 导出的一个顶层函数，它本质上是一个高阶组件，负责对函数组件进行包装。基本的调用姿势如下面代码所示：</p>\n<pre class="lang-java" data-nodeid="56978"><code data-language="java"><span class="hljs-keyword">import</span> React from <span class="hljs-string">"react"</span>;\n<span class="hljs-comment">// 定义一个函数组件</span>\n<span class="hljs-function">function <span class="hljs-title">FunctionDemo</span><span class="hljs-params">(props)</span> </span>{\n  <span class="hljs-keyword">return</span> xxx\n}\n<span class="hljs-comment">// areEqual 函数是 memo 的第二个入参，我们之前放在 shouldComponentUpdate 里面的逻辑就可以转移至此处</span>\n<span class="hljs-function">function <span class="hljs-title">areEqual</span><span class="hljs-params">(prevProps, nextProps)</span> </span>{\n  <span class="hljs-comment">/*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */</span>\n}\n<span class="hljs-comment">// 使用 React.memo 来包装函数组件</span>\nexport <span class="hljs-keyword">default</span> React.memo(FunctionDemo, areEqual);\n</code></pre>\n<p data-nodeid="56979"><strong data-nodeid="57131">React.memo 会帮我们“记住”函数组件的渲染结果，在组件前后两次 props 对比结果一致的情况下，它会直接复用最近一次渲染的结果</strong>。如果我们的组件在相同的 props 下会渲染相同的结果，那么使用 React.memo 来包装它将是个不错的选择。</p>\n<p data-nodeid="56980">从示例中我们可以看出，React.memo 接收两个参数，第一个参数是我们需要渲染的目标组件，第二个参数 areEqual 则用来承接 props 的对比逻辑。<strong data-nodeid="57137">之前我们在 shouldComponentUpdate 里面做的事情，现在就可以放在 areEqual 里来做</strong>。</p>\n<p data-nodeid="56981">比如开篇 Demo 中的 ChildB 组件，就完全可以用 Function Component + React.memo 来改造。改造后的 ChildB 代码如下：</p>\n<pre class="lang-js" data-nodeid="67460"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-comment">// 将 ChildB 改写为 function 组件</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildB</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ChildB 的render 逻辑执行了"</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"childB"</span>&gt;</span>\n      子组件B的内容：\n      {props.text}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n<span class="hljs-comment">// areEqual 用于对比 props 的变化</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEqual</span>(<span class="hljs-params">prevProps, nextProps</span>) </span>{\n  <span class="hljs-keyword">if</span>(prevProps.text === nextProps.text) {\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n}\n<span class="hljs-comment">// 使用 React.memo 来包装 ChildB</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(ChildB, areEqual);\n</code></pre>\n\n<p data-nodeid="56983">改造后的组件在效果上就等价于 shouldComponentUpdate 加持后的类组件 ChildB。</p>\n<p data-nodeid="56984"><strong data-nodeid="57144">这里的 areEqual 函数是一个可选参数，当我们不传入 areEqual 时，React.memo 也可以工作，此时它的作用就类似于 PureComponent——React.memo 会自动为你的组件执行 props 的浅比较逻辑</strong>。</p>\n<p data-nodeid="56985">和 shouldComponentUpdate 不同的是，React.memo 只负责对比 props，而不会去感知组件内部状态（state）的变化。</p>\n<h4 data-nodeid="56986">useMemo：更加“精细”的 memo</h4>\n<p data-nodeid="56987">通过上面的分析我们知道，React.memo 可以实现类似于 shouldComponentUpdate 或者 PureComponent 的效果，对组件级别的 re-render 进行管控。但是有时候，我们希望复用的并不是整个组件，而是组件中的某一个或几个部分。这种更加“精细化”的管控，就需要 useMemo 来帮忙了。</p>\n<p data-nodeid="56988"><strong data-nodeid="57152">简而言之，React.memo 控制是否需要重渲染一个组件，而 useMemo 控制的则是是否需要重复执行某一段逻辑</strong>。</p>\n<p data-nodeid="56989">useMemo 的使用方式如下面代码所示：</p>\n<pre class="lang-java" data-nodeid="56990"><code data-language="java"><span class="hljs-keyword">const</span> memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n</code></pre>\n<p data-nodeid="56991">我们可以把目标逻辑作为第一个参数传入，把逻辑的依赖项数组作为第二个参数传入。这样只有当依赖项数组中的某个依赖发生变化时，useMemo 才会重新执行第一个入参中的目标逻辑。</p>\n<p data-nodeid="56992" class="">这里我仍然以开篇的示例为例，现在我尝试向 ChildB 中传入两个属性：text 和 count，它们分别是一段文本和一个数字。当我点击右边的按钮时，只有 count 数字会发生变化。改造后的 App 组件代码如下：</p>\n<pre class="lang-js" data-nodeid="67999"><code data-language="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n  state = {\n    <span class="hljs-attr">textA</span>: <span class="hljs-string">\'我是A的文本\'</span>,\n    <span class="hljs-attr">stateB</span>: {\n      <span class="hljs-attr">text</span>: <span class="hljs-string">\'我是B的文本\'</span>,\n      <span class="hljs-attr">count</span>: <span class="hljs-number">10</span>\n    }\n  }\n  changeA = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">textA</span>: <span class="hljs-string">\'A的文本被修改了\'</span>\n    })\n  }\n  changeB = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">this</span>.setState({\n      <span class="hljs-attr">stateB</span>: {\n        ...this.state.stateB,\n        <span class="hljs-attr">count</span>: <span class="hljs-number">100</span>\n      }\n    })\n  }\n  render() {\n    <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeA}</span>&gt;</span>点击修改A处的文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.changeB}</span>&gt;</span>点击修改B处的文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{this.state.textA}/</span>&gt;</span>\n          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> {<span class="hljs-attr">...this.state.stateB</span>}/&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n  }\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;\n</code></pre>\n\n<p data-nodeid="56994">在 ChildB 中，使用 useMemo 来加持 text 和 count 各自的渲染逻辑。改造后的 ChildB 代码如下所示：</p>\n<pre class="lang-js" data-nodeid="68538"><code data-language="js"><span class="hljs-keyword">import</span> React,{ useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildB</span>(<span class="hljs-params">{text, count}</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"ChildB 的render 逻辑执行了"</span>);\n  <span class="hljs-comment">// text 文本的渲染逻辑</span>\n  <span class="hljs-keyword">const</span> renderText = <span class="hljs-function">(<span class="hljs-params">text</span>)=&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'renderText 执行了\'</span>)\n    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>\n    子组件B的文本内容：\n      {text}\n  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>\n  }\n  <span class="hljs-comment">// count 数字的渲染逻辑</span>\n  <span class="hljs-keyword">const</span> renderCount = <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'renderCount 执行了\'</span>)\n    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>\n      子组件B的数字内容：\n        {count}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>\n  }\n  \n  <span class="hljs-comment">// 使用 useMemo 加持两段渲染逻辑</span>\n  <span class="hljs-keyword">const</span> textContent = useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>renderText(text),[text])\n  <span class="hljs-keyword">const</span> countContent = useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>renderCount(count),[count])\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"childB"</span>&gt;</span>\n      {textContent}\n      {countContent}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n\n<p data-nodeid="56996">渲染 App 组件，我们可以看到初次渲染时，renderText 和 renderCount 都执行了，控制台输出如下图所示：</p>\n<p data-nodeid="69077" class=""><img src="https://s0.lgstatic.com/i/image/M00/8B/D3/CgqCHl_ga_SAeZvVAACbMQxPKsc444.png" alt="Drawing 6.png" data-nodeid="69080"></p>\n\n<p data-nodeid="56998">点击右边按钮，对 count 进行修改，修改后的界面会发生如下的变化：</p>\n<p data-nodeid="69619" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image2/M01/03/AA/CgpVE1_ga_yAZ5u-AADTkxhPMO8352.png" alt="Drawing 7.png" data-nodeid="69622"></p>\n\n<p data-nodeid="57000">可以看出，由于 count 发生了变化，因此 useMemo 针对 renderCount 的逻辑进行了重计算。而 text 没有发生变化，因此 renderText 的逻辑压根没有执行。</p>\n<p data-nodeid="57001">使用 useMemo，我们可以对函数组件的执行逻辑进行更加细粒度的管控（尤其是定向规避掉一些高开销的计算），同时也弥补了 React.memo 无法感知函数内部状态的遗憾，这对我们整体的性能提升是大有裨益的。</p>\n<h3 data-nodeid="57002">总结</h3>\n<p data-nodeid="57003">本讲，我们学习了 React 组件性能优化中最重要的 3 个思路。</p>\n<p data-nodeid="57004">这 3 个思路不仅可以作为大家日常实战的知识储备，更能够帮助你在面试场景下做到言之有物。事实上，在“React 性能优化”这个问题下，许多候选人的回答犹如隔靴搔痒，总在一些无关紧要的细节上使劲儿。若你能把握好本讲的内容，择其中一个或多个方向深入探究，相信你已经超越了大部分的同行。</p>\n<p data-nodeid="57005">下一讲，我们将学习 React 组件的设计模式，为打造“高质量应用”做知识储备。</p>',
          },
          {
            theme: '23 | 跟 React 学设计模式：掌握编程“套路”，打造高质量应用',
            id: 224,
            content:
              '<p data-nodeid="4737">这一讲我们将针对 React 中的设计模式进行探讨。</p>\n\n\n\n<p data-nodeid="3799">与性能优化的视角相似，当我们谈论 React 设计模式时，实际上是在谈论“React 组件的设计模式”。在 React 设计模式中，最重要、也是最为大家所津津乐道的几个模式分别是：</p>\n<ul data-nodeid="3800">\n<li data-nodeid="3801">\n<p data-nodeid="3802"><strong data-nodeid="3923">高阶组件（HOC）</strong></p>\n</li>\n<li data-nodeid="3803">\n<p data-nodeid="3804"><strong data-nodeid="3927">Render Props</strong></p>\n</li>\n<li data-nodeid="3805">\n<p data-nodeid="3806"><strong data-nodeid="3931">剥离有状态组件与无状态组件</strong></p>\n</li>\n</ul>\n<p data-nodeid="3807">除此之外，每个团队或许都会有自己的一套在实践中摸索出的设计模式方法论。这些形态各异的 React 设计模式虽然实现思路有所不同，但本质上基本都是为了实现这样一个终极目标——以尽可能优雅的姿态，<strong data-nodeid="3937">实现组件逻辑的复用</strong>。</p>\n<p data-nodeid="3808">而我们今天即将探讨的这 3 种模式，也无出其右。</p>\n<p data-nodeid="3809">在本讲，我们首先要做的第一件事情，就是把每一种设计模式到底是什么、怎么用给弄清楚。在这个过程中，你会对“单一职责”和“开放封闭”这两个非常重要的设计原则有所认知。</p>\n<p data-nodeid="3810">在此基础上，你还需要去思考这样一个问题：设计模式是否是万能的？如果不是，那么对框架来说，还有没有更加深刻、彻底的解法呢？</p>\n<p data-nodeid="3811">没错，最终的话题还是要回到 Hooks 上来，哈哈。接下来我们就先迈出第一步，一起认识/重温一下高阶组件这个概念。</p>\n<h3 data-nodeid="3812">高阶组件（HOC）：最经典的组件逻辑复用方式</h3>\n<h4 data-nodeid="3813">什么是高阶组件</h4>\n<blockquote data-nodeid="3814">\n<p data-nodeid="3815">高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。——React 官方</p>\n</blockquote>\n<p data-nodeid="3816">高阶组件（Higher Order Components）在概念上沿袭了高阶函数（Higher-Order Function）。在第 20 讲，我们已经和高阶函数打过交道，这里我们再复习一下高阶函数的概念：<strong data-nodeid="3950">接收函数作为输入，或者输出另一个函数的一类函数，就是高阶函数</strong>。</p>\n<p data-nodeid="3817">相应的，高阶组件指的就是<strong data-nodeid="3960">参数为组件，返回值为新组件的函数</strong>。没错，<strong data-nodeid="3961">高阶组件本质上是一个函数</strong>。下面是一个简单的高阶组件示例：</p>\n<pre class="lang-js" data-nodeid="6577"><code data-language="js"><span class="hljs-keyword">const</span> withProps = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> targetComponent = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"wrapper-container"</span>&gt;</span>\n            <span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n    <span class="hljs-keyword">return</span> targetComponent;\n};\n</code></pre>\n\n\n\n<p data-nodeid="3819">在这段代码中，withProps 就是一个高阶组件。</p>\n<h4 data-nodeid="3820">高阶组件是如何实现逻辑复用的？</h4>\n<p data-nodeid="3821">现在我们考虑这样一种情况：我有一个名为 checkUserAccess 的方法，这个方法专门用来校验用户的身份是否合法，若不合法，那么一部分组件就要根据这个不合法的身份调整自身的展示逻辑（比如查看个人信息界面需要提示“请校验身份”等）。</p>\n<p data-nodeid="3822">假如说页面中的 A、B、C、D、E 五个组件都需要甄别用户身份是否合法，那么这五个组件在理论上都需要先请求一遍 checkUserAccess 这个接口。但一个一个对组件进行修改未免太麻烦了，我们期望对“获取 checkUserAccess 接口信息，并通知到对应组件”这层逻辑进行复用，这时候就可以请出高阶组件来帮忙了。</p>\n<p data-nodeid="3823">我们可以像下面代码这样在高阶组件中定义这层通用的逻辑：</p>\n<pre class="lang-dart" data-nodeid="9642"><code data-language="dart">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑\nimport checkUserAccess from \'./utils\n// 用高阶组件包裹目标组件\nconst withCheckAccess = (WrappedComponent) =&gt; {\n    // 这部分是通用的逻辑：判断用户身份是否合法\n    const isAccessible = checkUserAccess()  \n    // 将 isAccessible（是否合法） 这个信息传递给目标组件\n    const targetComponent = (props) =&gt; (\n        &lt;div className="wrapper-container"&gt;\n            &lt;WrappedComponent {...props} isAccessible={isAccessible} /&gt;\n        &lt;/div&gt;\n    );\n    return targetComponent;\n};\n</code></pre>\n\n\n\n\n\n<p data-nodeid="3825">这样当我们需要为某个组件复用这层请求逻辑的时候，只需要直接用 withCheckAccess 包裹这个组件就可以了。以 A 组件为例，假设 A 组件的原始版本为 AComponent，那么包裹它的形式就是下面代码这样：</p>\n<pre class="lang-java" data-nodeid="3826"><code data-language="java"><span class="hljs-keyword">const</span> EnhancedAComponent = withCheckAccess(Acomponent);\n</code></pre>\n<p data-nodeid="3827">通过简单地对高阶组件 withCheckAccess 进行引入，EnhancedAComponent 轻松具备了校验用户合法性的能力。这样一来，即便再多出 5 个组件想要引入 checkUserAccess，我们也不会怂——毕竟包裹五个组件和重写五段逻辑的工作量是没法相提并论的，哈哈。</p>\n<p data-nodeid="3828">高阶组件不仅能够帮助我们简化逻辑的引入过程，还可以帮助我们规避掉逻辑变更带来的烦琐的修改步骤：假如这段 checkUserAccess 的逻辑是散落在 A、B、C、D、E 这五个组件之中的，那么一旦 checkUserAccess 的判定规则需要修改，我们就得需要去修改五段代码；但现在，checkUserAccess 被抽离进了一个独立的高阶组件里，我们在高阶组件中的一次修改，将在所有被它处理过的组件中生效。</p>\n<p data-nodeid="3829">由此可以看出，高阶组件可以帮助我们<strong data-nodeid="3975">从根本上减少重复的编写和修改工作</strong>，这不仅是高阶组件这一种模式的利好，更是“逻辑复用”这件事情的意义所在。</p>\n<h3 data-nodeid="3830">Render Props：逻辑复用的另一种思路</h3>\n<blockquote data-nodeid="3831">\n<p data-nodeid="3832" class="">术语<a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" data-nodeid="3980">“render prop”</a>是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术。——React 官方</p>\n</blockquote>\n<h4 data-nodeid="3833">什么是 render props？</h4>\n<p data-nodeid="3834">render props 是 React 中复用组件逻辑的另一种思路，它在实现上和高阶组件有异曲同工之妙——两者都是把通用的逻辑提取到某一处。区别主要在于使用层面，<strong data-nodeid="3988">高阶组件的使用姿势是用“函数”包裹“组件”，而 render props 恰恰相反，它强调的是用“组件”包裹“函数”</strong>。</p>\n<p data-nodeid="3835">一个简单的 render props 可以是这样的，见下面代码：</p>\n<pre class="lang-js" data-nodeid="10255"><code data-language="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>  \n<span class="hljs-keyword">const</span> RenderChildren = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span>(\n     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>\n        {props.children(props)}\n     <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>\n  );\n};\n</code></pre>\n\n<p data-nodeid="3837">RenderChildren 将渲染它所有的子组件。从这段代码里，你需要把握住两个要点：</p>\n<ol data-nodeid="3838">\n<li data-nodeid="3839">\n<p data-nodeid="3840">render props 的载体应该是一个<strong data-nodeid="3996">React 组件</strong>，这一点是与高阶组件不同的（高阶组件本质是函数）；</p>\n</li>\n<li data-nodeid="3841">\n<p data-nodeid="3842">render props 组件正常工作的前提是它的<strong data-nodeid="4002">子组件需要以函数形式存在</strong>。</p>\n</li>\n</ol>\n<p data-nodeid="3843">第 1 点相对明显一点，你可能会对第 2 点感到迷惑。没关系，我们直接来看 RenderChildren 的使用方式，请看下面代码：</p>\n<pre class="lang-java" data-nodeid="3844"><code data-language="java">&lt;RenderChildren&gt;         \n  {() =&gt; &lt;p&gt;我是 RenderChildren 的子组件&lt;/p&gt;}       \n&lt;/RenderChildren&gt;\n</code></pre>\n<p data-nodeid="3845">RenderChildren 本身是一个 React 组件，它可以包裹其他的 React 组件。一般来说，我们习惯于看到的包裹形式是“标签包裹着标签”，也就是下面代码演示的这种效果：</p>\n<pre class="lang-java" data-nodeid="3846"><code data-language="java">&lt;RenderChildren&gt;         \n  &lt;p&gt;我是 RenderChildren 的子组件&lt;/p&gt;     \n&lt;/RenderChildren&gt;\n</code></pre>\n<p data-nodeid="3847">但在 render props 这种模式下，它要求被 render props 组件标签包裹的一定是个函数，也就是所谓的“函数作为子组件传入”。这样一来，render props 组件就可以通过调用这个函数，传递 props，从而实现和目标组件的通信了。</p>\n<h4 data-nodeid="3848">render props 是如何实现逻辑复用的？</h4>\n<p data-nodeid="3849">这里我仍然以 checkUserAccess 这个场景举例。使用 render props 复用 checkUserAccess 这段逻辑，我们可以这样做，请看下面代码：</p>\n<pre class="lang-java" data-nodeid="3850"><code data-language="java">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑\nimport checkUserAccess from \'./utils\n// 定义 render props 组件\nconst CheckAccess = (props) =&gt; {\n    // 这部分是通用的逻辑：判断用户身份是否合法\n    const isAccessible = checkUserAccess()  \n    // 将 isAccessible（是否合法） 这个信息传递给目标组件\n    return &lt;React.Fragment&gt;\n        {props.children({ ...props, isAccessible })}\n      &lt;/React.Fragment&gt;\n};\n</code></pre>\n<p data-nodeid="3851">接下来 CheckAccess 子组件就可以这样获取 isAccessible 的值，见下面代码：</p>\n<pre class="lang-java" data-nodeid="3852"><code data-language="java">&lt;CheckAccess&gt;\n  {\n    (props) =&gt; {\n      const { isAccessible } = props;\n      return &lt;ChildComponent {...props} isAccessible={isAccessible} /&gt;\n    }\n  }\n&lt;/CheckAccess&gt;\n</code></pre>\n<p data-nodeid="3853">到这里，“函数作为子组件传入”这种情况，我们已经了解了它的来龙去脉。但其实，对于 &nbsp;render props 这种模式来说，<strong data-nodeid="4014">函数并不一定要作为子组件传入，它也可以以任意属性名传入，只要 render props 组件可以感知到它就行</strong>。</p>\n<p data-nodeid="3854">举个例子，我可以允许函数通过一个名为 checkTaget 的属性传入 render props 组件，那么 CheckAccess 组件只需要改写一下它接收函数的形式即可，见下面代码：</p>\n<pre class="lang-js" data-nodeid="10868"><code data-language="js">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑\nimport checkUserAccess from \'./utils\n// 定义 render props 组件\nconst CheckAccess = (props) =&gt; {\n    // 这部分是通用的逻辑：判断用户身份是否合法\n    const isAccessible = checkUserAccess()  \n    // 将 isAccessible（是否合法） 这个信息传递给目标组件\n    return &lt;React.Fragment&gt;\n        {props.checkTaget({ ...props, isAccessible })}\n      &lt;/React.Fragment&gt;\n};\n</code></pre>\n\n<p data-nodeid="3856">在使用 CheckAccess 组件的时候，我们将函数放在 checkTaget 中传入组件即可，见下面代码：</p>\n<pre class="lang-js" data-nodeid="11481"><code data-language="js">&lt;CheckAccess\n    checkTaget={(props) =&gt; {\n      <span class="hljs-keyword">const</span> { isAccessible } = props;\n      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> {<span class="hljs-attr">...props</span>} <span class="hljs-attr">isAccessible</span>=<span class="hljs-string">{isAccessible}</span> /&gt;</span></span>\n    }}\n  /&gt;\n</code></pre>\n\n<p data-nodeid="3858">像这样使用 render props，也是完全可以的。</p>\n<h4 data-nodeid="3859">理解 render props 的灵活之处</h4>\n<p data-nodeid="3860">读到这里，你不免会产生这样的困惑：高阶组件和 render props 都能复用逻辑，那我到底用哪个好呢？</p>\n<p data-nodeid="3861">这里我先给出结论：render props 将是你更好的选择，因为它<strong data-nodeid="4025">更灵活</strong>。这“更灵活”从何说起呢？</p>\n<p data-nodeid="3862">render props 和高阶组件一个非常重要的区别，在于对数据的处理上：在高阶组件中，目标组件对于数据的获取没有主动权，<strong data-nodeid="4035">数据的分发逻辑全部收敛在高阶组件的内部</strong>；而在 render props 中，除了父组件可以对数据进行分发处理之外，<strong data-nodeid="4036">子组件也可以选择性地对数据进行接收</strong>。</p>\n<p data-nodeid="3863">这样说你可能会觉得有点抽象，我举个例子：假如说我们现在多出一个 F 组件，它同样需要 checkUserAccess 这段逻辑。但是这个 F 组件是一个老组件，它识别不了 props.isAccessible，只认识 props.isValidated。带着这个需求，我们先来看看高阶组件怎么解决问题。原有的高阶组件逻辑是下面这样的：</p>\n<pre class="lang-java" data-nodeid="3864"><code data-language="java">// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑\nimport checkUserAccess from \'./utils\n// 用高阶组件包裹目标组件\nconst withCheckAccess = (WrappedComponent) =&gt; {\n    // 这部分是通用的逻辑：判断用户身份是否合法\n    const isAccessible = checkUserAccess()  \n    // 将 isAccessible（是否合法） 这个信息传递给目标组件\n    const targetComponent = (props) =&gt; (\n        &lt;div className="wrapper-container"&gt;\n            &lt;WrappedComponent {...props} isAccessible={isAccessible} /&gt;\n        &lt;/div&gt;\n    );\n    return targetComponent;\n};\n</code></pre>\n<p data-nodeid="3865">它会不由分说地给所有组件安装上 isAccessible 这个变量。要想让它适配 F 组件的逻辑，最直接的一个思路就是在 withCheckAccess 中增加一个组件类型的判断，一旦判断出当前入参是 F 组件，就专门将 isAccessible 改名为 isValidated。</p>\n<p data-nodeid="3866">这样做虽然能够暂时解决问题，但这并不是一个灵活的解法：假如需要改属性名的组件越来越多，那么 withCheckAccess 内部将不可避免变得越来越臃肿，长此以往将难以维护。</p>\n<p data-nodeid="3867">事实上，在软件设计模式中，有一个非常重要的原则，叫“<strong data-nodeid="4049">开放封闭原则</strong>”。一个好的模式，应该尽可能做到<strong data-nodeid="4050">对拓展开放，对修改封闭</strong>。</p>\n<p data-nodeid="3868">当我们发现 withCheckAccess 的内部逻辑需要频繁地跟随需求的变化而变化时，此时就应该提高警惕了，因为这已经违反了“对修改封闭”这一原则。</p>\n<p data-nodeid="3869"><strong data-nodeid="4056">处理同样的需求，render props 就能够在保全“开放封闭”原则的基础上，帮我们达到目的</strong>。</p>\n<p data-nodeid="3870">前面说过，在 render props 中，除了父组件可以对数据进行分发处理之外，<strong data-nodeid="4062">子组件也可以选择性地对数据进行接收</strong>。这就意味着我们可以在新增的 F 组件相关的逻辑中把数据适配这件事情给做掉（如下面代码所示），而不会影响老的 CheckAccess 组件中的逻辑。</p>\n<pre class="lang-java" data-nodeid="3871"><code data-language="java">&lt;CheckAccess&gt;\n  {\n    (props) =&gt; {\n      const { isAccessible } = props;\n      return &lt;ChildComponent {...props} isValidated={isAccessible} /&gt;\n    }\n  }\n&lt;/CheckAccess&gt;\n</code></pre>\n<p data-nodeid="3872">这样一来，不管你新来的组件有多少个，需要变更的属性名有多少个，影响面都会被牢牢地控制在“新增逻辑”这个范畴里。契合了“开放封闭”原则的 render props 模式显然比高阶组件灵活多了。</p>\n<h3 data-nodeid="3873">有状态组件与无状态组件：“单一职责”原则在组件设计模式中的实践</h3>\n<h4 data-nodeid="3874">什么是“单一职责”原则？</h4>\n<p data-nodeid="3875">单一职责原则又叫“单一功能原则”，它指的是一个类或者模块应该有且只有一个改变的原因。通俗来讲，就是说咱们的组件功能要尽可能地聚合，不要试图让一个组件做太多的事情。</p>\n<h4 data-nodeid="3876">什么是有状态组件？什么是无状态组件？</h4>\n<p data-nodeid="3877">无状态组件这个概念我们在第 06 讲中已经介绍过了，这里简单复习一下：</p>\n<blockquote data-nodeid="3878">\n<p data-nodeid="3879">函数组件顾名思义，就是以函数的形态存在的 React 组件。早期并没有 React-Hooks 的加持，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。</p>\n</blockquote>\n<p data-nodeid="3880">如下面代码所示，就是一个典型的无状态组件：</p>\n<pre class="lang-java" data-nodeid="3881"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">DemoFunction</span><span class="hljs-params">(props)</span> </span>{\n  <span class="hljs-keyword">const</span> { text } = <span class="hljs-function">props\n  <span class="hljs-title">return</span> <span class="hljs-params">(\n    &lt;div className=<span class="hljs-string">"demoFunction"</span>&gt;\n      &lt;p&gt;{`function 组件所接收到的来自外界的文本内容是：[${text}]`}&lt;/p&gt;\n    &lt;/div&gt;\n  )</span></span>;\n}\n</code></pre>\n<p data-nodeid="3882">无状态组件不一定是函数组件，不维护内部状态的类组件也可以被认为是无状态组件。<br>\n相比之下，能够在组件内部维护状态、管理数据的组件，就是“有状态组件”。</p>\n<h4 data-nodeid="3883">为何需要剥离有状态组件和无状态组件？</h4>\n<p data-nodeid="3884">有状态组件和无状态组件有很多别名，有的书籍里也会管它们叫“容器组件”和“展示组件”，甚至“聪明组件”和“傻瓜组件”。不管叫啥，核心目的就一个——把数据处理和界面渲染这两个工作剥离开来。</p>\n<p data-nodeid="3885">为什么要这样做？别忘了，React 的核心特征是“数据驱动视图”，我们经常用下图的公式来表达它的工作模式：</p>\n<p data-nodeid="12094" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/8C/12/Ciqc1F_lfZ6AJTqZAAA2ThydXNs337.png" alt="Lark20201225-133324.png" data-nodeid="12097"></p>\n\n<p data-nodeid="3887">因此对一个 React 组件来说，它做的事情说到底无外乎是这两件：</p>\n<ol data-nodeid="3888">\n<li data-nodeid="3889">\n<p data-nodeid="3890">处理数据（包括数据的获取、格式化、分发等）</p>\n</li>\n<li data-nodeid="3891">\n<p data-nodeid="3892">渲染界面</p>\n</li>\n</ol>\n<p data-nodeid="3893">我们当然也可以在一个组件里面做完这两件事情，但这样不够优雅。</p>\n<p data-nodeid="3894">按照“单一职责”的原则，我们应该将数据处理的逻辑和界面渲染的逻辑剥离到不同的组件中去，这样功能模块的组合将会更加灵活，也会更加有利于逻辑的复用。此外，单一职责还能够帮助我们尽可能地控制变更范围，降低代码的维护成本：当数据相关的逻辑发生变化时，我们只需要去修改有状态组件就可以了，无状态组件将完全不受影响。</p>\n<h3 data-nodeid="3895">Why Hooks：设计模式解决不了所有的问题</h3>\n<p data-nodeid="3896">设计模式虽好，但它并非万能。</p>\n<p data-nodeid="3897">就 React 来说，无论是高阶组件，还是 render props，两者的出现都是为了弥补类组件在“逻辑复用”这个层面的不灵活性。它们各自都有着自己的不足，这些不足包括但不限于以下几点：</p>\n<ol data-nodeid="3898">\n<li data-nodeid="3899">\n<p data-nodeid="3900">嵌套地狱问题，当嵌套层级过多后，数据源的追溯会变得十分困难</p>\n</li>\n<li data-nodeid="3901">\n<p data-nodeid="3902">较高的学习成本</p>\n</li>\n<li data-nodeid="3903">\n<p data-nodeid="3904">props 属性命名冲突问题</p>\n</li>\n<li data-nodeid="3905">\n<p data-nodeid="3906">......</p>\n</li>\n</ol>\n<p data-nodeid="3907">总体来看，“HOC/render props+类组件”这种研发模式，还是不够到位。当设计模式解决不了问题时，我们本能地需要从编程模式上寻找答案。于是便有了如今大家在 React 中所看到的 “函数式编程”对“面向对象”的补充（并且大有替代之势），有了今天我们所看到的“一切皆可 Hooks”的大趋势。</p>\n<p data-nodeid="3908"><strong data-nodeid="4103">现在，当我们想要去复用一段逻辑时，第一反应肯定不是“高阶函数”或者“render props”，而应该是“</strong><a href="https://zh-hans.reactjs.org/docs/hooks-custom.html#gatsby-focus-wrapper" data-nodeid="4098">自定义 Hook</a><strong data-nodeid="4104">”</strong>。Hooks 能够很好地规避掉旧时类组件中各种设计模式带来的弊端，比如说它不存在嵌套地狱，允许属性重命名、允许我们在任何需要它的地方引入并访问目标状态等。由此可以看出，一个好的编程模式可以帮我们节约掉大量“打补丁”式地学习各种组件设计模式的时间。框架设计越合理，开发者的工作就越轻松。</p>\n<h3 data-nodeid="3909">总结</h3>\n<p data-nodeid="3910">本讲，我们围绕“React 组件设计模式”这一专题进行学习。在认识高阶组件、render props 两种经典设计模式的同时，也对“单一职责”“开放封闭”这两个重要的软件设计原则形成了初步的认识。</p>\n<p data-nodeid="3911">软件领域没有银弹，就算有，也不可能是设计模式。通过本讲的学习，相信你在认识设计模式的利好之余，也认识到了它的局限性。在此基础上，相信你会对 React-Hooks 及其背后的“函数式编程”思想建立更加强烈的正面认识。</p>\n<p data-nodeid="3912">行文至此，整个 React 专栏的知识讲解部分就结束了。相信不少同学在学习完毕之后，都会对 React 的运行机制，甚至前端框架这个领域产生强烈的兴趣。在下一讲，我将分享自己对框架的一些理解，也会借机和你聊聊前不久刚刚推出的 React 17，我们不见不散呀！</p>',
          },
        ],
      },
      {
        sectionName: '结束语',
        sectionId: 6,
        courseList: [
          {
            theme: '结束语 | 聊聊 React 17，谈谈学习前端框架的心法',
            id: 225,
            content:
              '<p data-nodeid="3071" class="">经过 23 个课时的学习，从基础到原理再到生产实践，相信此时此刻的你已经对 React 建立起了一个系统且深入的认知。前不久，React 17 版本正式面世，但 React 17 到底意味着什么，或许有不少同学还是一头雾水。因此，在专栏的最后一讲，我们先一起聊聊面向未来的 React——React 17 版本带来的改变。</p>\n<p data-nodeid="3072">聊完面向未来的 React，还要和你聊聊面向未来的学习——授人以鱼不如授人以渔，面对前端框架的更迭，技术的日新月异，我们应该如何确保自己能够保持住对新事物的敏锐度和理解能力呢？在本文的最后，我将对前端框架的学习方法论做一个提取，希望能帮助你建立良好的学习习惯。</p>\n<h3 data-nodeid="3073">React 17 带来了哪些改变</h3>\n<p data-nodeid="3074">我们先来看看 React 官方是如何介绍 React 17 的：</p>\n<blockquote data-nodeid="3075">\n<p data-nodeid="3076">React v17 的发布非比寻常，因为它没有增加任何面向开发者的新特性。但是，<strong data-nodeid="3173">这个版本会使得 React 自身的升级变得更加容易</strong>。<br>\n值得特别说明的是，React v17 作为后续版本的“基石”，它让不同版本的 React 相互嵌套变得更加容易。<br>\n—— React 官方</p>\n</blockquote>\n<p data-nodeid="3077">React 17 中没有新特性，这是由它的定位决定的。React 17 的定位是<strong data-nodeid="3183">后续 18、19 等更新版本的“基石”</strong>，它是一个“承上启下”的版本，用官方的说法来说，“<strong data-nodeid="3184">React v17 开启了 React 渐进式升级的新篇章”</strong>。</p>\n<p data-nodeid="3078">所谓“渐进式升级”，是相对于“一次性升级”来说的。日后我们需要将项目从 React 17 迁移至 18、19 等更新版本时，不需要一口气把整个应用升级到新版本，而是可以部分升级，比如说我们完全可以在 React 18 中安全地引入 React 17 版本的某个组件。而在 React 17 之前，这样做将会伴随着不可用的风险，彼时我们但凡要升级 React 版本，就必须一次性将整个应用迁移至目标版本。</p>\n<p data-nodeid="3079">“渐进式升级”意味着更大的选择余地，它将在未来为大量的 React 老版本项目留出喘息的空间，确保开发者们不必为了兼容多版本而徒增烦恼。</p>\n<p data-nodeid="3080">没有新特性，不代表没有变化，更不代表没有东西可以学了。事实上，React 17 中仍然有不少值得我们关注的用户侧改变，个人认为最重要的是以下三点：</p>\n<ul data-nodeid="3081">\n<li data-nodeid="3082">\n<p data-nodeid="3083">新的 JSX 转换逻辑</p>\n</li>\n<li data-nodeid="3084">\n<p data-nodeid="3085">事件系统重构</p>\n</li>\n<li data-nodeid="3086">\n<p data-nodeid="3087">Lane 模型的引入</p>\n</li>\n</ul>\n<p data-nodeid="3088">除此之外，React 17 中还有一些细节层面的变化，比如调整了 useEffect 钩子中清理副作用的时机，强化了组件返回 undefined 的错误校验等，这些也很有趣，大家课下可以多摸索摸索。</p>\n<h4 data-nodeid="3089">重构 JSX 转换逻辑</h4>\n<p data-nodeid="3090">在过去，如果我们在 React 项目中写入下面这样的代码：</p>\n<pre class="lang-java" data-nodeid="3091"><code data-language="java">function MyComponent() {\n  return &lt;p&gt;这是我的组件&lt;/p&gt;\n}\n</code></pre>\n<p data-nodeid="3092">React 是会报错的，原因是 React 中对 JSX 代码的转换依赖的是 React.createElement 这个函数。因此但凡我们在代码中包含了 JSX，那么就必须在文件中引入 React，像下面这样：</p>\n<pre class="lang-java" data-nodeid="3093"><code data-language="java">import React from \'react\';\nfunction MyComponent() {\n  return &lt;p&gt;这是我的组件&lt;/p&gt;\n}\n</code></pre>\n<p data-nodeid="3094"><strong data-nodeid="3199">而 React 17 则允许我们在不引入 React 的情况下直接使用 JSX</strong>。这是因为在 React 17 中，编译器会自动帮我们引入 JSX 的解析器，也就是说像下面这样一段逻辑：</p>\n<pre class="lang-java" data-nodeid="3095"><code data-language="java">function MyComponent() {\n  return &lt;p&gt;这是我的组件&lt;/p&gt;\n}\n</code></pre>\n<p data-nodeid="3096">会被编译器转换成这个样子：</p>\n<pre class="lang-java" data-nodeid="3097"><code data-language="java"><span class="hljs-keyword">import</span> {jsx as _jsx} from <span class="hljs-string">\'react/jsx-runtime\'</span>;\n<span class="hljs-function">function <span class="hljs-title">MyComponent</span><span class="hljs-params">()</span> </span>{\n  <span class="hljs-keyword">return</span> _jsx(<span class="hljs-string">\'p\'</span>, { children: <span class="hljs-string">\'这是我的组件\'</span> });\n}\n</code></pre>\n<p data-nodeid="3098">react/jsx-runtime 中的 JSX 解析器将取代 React.createElement 完成 JSX 的编译工作，这个过程对开发者而言是自动化、无感知的。因此，新的 JSX 转换逻辑带来的最显著的改变就是<strong data-nodeid="3206">降低了开发者的学习成本</strong>。</p>\n<p data-nodeid="3099">为什么说降低了学习成本呢？仔细回忆一下，当你入门 React 时，是不是很容易因为漏掉对 React 的引入从而引发 JSX 相关的问题？当这些问题发生的时候，作为新手难免会懵逼。直到你有一天成了进阶选手，理解了 JSX 和 React.createElement 之间的关系，你才恍然大悟，从此便永远地记住了“有 JSX 就必须有 React 引入”这条真理，于是你每次用 JSX 的时候都要手动 import 一下 React，虽极为不便，但也没有什么办法。</p>\n<p data-nodeid="3100">但如果你学习的是 React 17，那么从一开始你就不会感知到 React 需要和 JSX 一同引入这件事情，后续更不必去纠结背后的许多个为什么，因为 React 17 已经为你打点好了一切。</p>\n<p data-nodeid="3101">新的 JSX 转换逻辑告诉了我们一个道理——框架，并不是越复杂越难学才越牛。好的框架，甚至说好的“轮子”，追求的一定都是简单和稳定。</p>\n<p data-nodeid="3102">react/jsx-runtime 中的 JSX 解析器看上去似乎在调用姿势上和 React.createElement 区别不大，那么它是否只是 React.createElement 换了个马甲呢？当然不是，它在内部实现了 React.createElement 无法做到的<a href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation" data-nodeid="3213">性能优化和简化</a>。在一定情况下，它可能会略微改善编译输出内容的大小。</p>\n<h4 data-nodeid="3103">事件系统重构</h4>\n<p data-nodeid="3104">事件系统在 React 17 中的重构要从以下两个方面来看：</p>\n<ul data-nodeid="3105">\n<li data-nodeid="3106">\n<p data-nodeid="3107"><strong data-nodeid="3220">卸掉历史包袱</strong></p>\n</li>\n<li data-nodeid="3108">\n<p data-nodeid="3109"><strong data-nodeid="3224">拥抱新的潮流</strong></p>\n</li>\n</ul>\n<p data-nodeid="3110"><strong data-nodeid="3230">1. 卸掉历史包袱：放弃利用 document 来做事件的中心化管控</strong></p>\n<p data-nodeid="3111">在本专栏的第 17 讲，相信你已经对 React 16.13.x 版本中的事件系统实现原理有了深入的了解。当时我们反复强调过，React 会<strong data-nodeid="3236">通过将所有事件冒泡到 document 来实现对事件的中心化管控</strong>。</p>\n<p data-nodeid="3112">这样的做法虽然看上去已经足够巧妙，但仍然有它不聪明的地方——document 是整个文档树的根节点，操作 document 带来的影响范围实在是太大了，这将会使事情变得更加不可控。相关的 Bug 中最出名的莫过于下图这个 GitHub issue 了：</p>\n<p data-nodeid="3113"><img src="https://s0.lgstatic.com/i/image/M00/8C/49/Ciqc1F_qxmOACrCCAAQ4SHpdu30570.png" alt="Drawing 0.png" data-nodeid="3240"></p>\n<p data-nodeid="3114">提问者说他试图在 input 这个元素的 React 事件函数中阻止冒泡，但事实并没有如他所愿——每次点击 input 的时候，事件还是会被冒泡到 document 上去。对此，他得到的回复是这样的：</p>\n<p data-nodeid="3115"><img src="https://s0.lgstatic.com/i/image/M00/8C/49/Ciqc1F_qxmmAbX_mAAJbigHC7d0803.png" alt="Drawing 1.png" data-nodeid="3244"></p>\n<p data-nodeid="3116">原因和大家想的一样：由于 React 依赖将 DOM 事件冒泡到 document 上来实现对所有事件的中心化管控。图中源代码中，作者在 handleClick 这个 React 事件函数中阻止了冒泡，这只能够保证该事件对应的合成事件在 React 事件体系下的冒泡被阻止了（也就是说 React 不会为这个合成事件模拟冒泡效果，关于“模拟冒泡”这个概念，第 17 讲中有源码级的原理分析，趁机拐回去复习一下吧^_^），并不能够阻止原生 DOM 事件的冒泡。因此我们安装在 document 上的事件监听器一定会被触发。</p>\n<p data-nodeid="3117">且不说 document 中心化管控这个设定给开发者带来了多大的限制，单看设计理念，就多少能够预感到其中的风险：document 是一个全局的概念，而组件只是全局的一个部分。由 React 组件引入的 React 事件系统，理论上看和组件绑在一起是最合适的，不应该将影响范围扩大到全局。</p>\n<p data-nodeid="3118">在 React 17 中，React 团队终于正面解决了这个问题：事件的中心化管控不会再全部依赖 document，管控相关的逻辑被转移到了每个 React 组件自己的容器 DOM 节点中。比如说我们在 ID 为 root 的 DOM 节点下挂载了一个 React 组件，像下面代码这样：</p>\n<pre class="lang-java" data-nodeid="3119"><code data-language="java"><span class="hljs-keyword">const</span> rootElement = document.getElementById(<span class="hljs-string">"root"</span>);\nReactDOM.render(&lt;App /&gt;, rootElement);\n</code></pre>\n<p data-nodeid="3120">那么事件管控相关的逻辑就会被安装到 root 节点上去。这样一来， React 组件就能够自己玩自己的，再也无法对全局的事件流构成威胁了。</p>\n<p data-nodeid="3121"><strong data-nodeid="3256">2. 拥抱新的潮流：放弃事件池</strong></p>\n<p data-nodeid="3122">在 React 17 之前，合成事件对象会被放进一个叫作“事件池”的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了，React 官方给出的这个例子就很能说明问题，请看下面这个代码：</p>\n<pre class="lang-java" data-nodeid="3123"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">handleChange</span><span class="hljs-params">(e)</span> </span>{\n  <span class="hljs-comment">// This won\'t work because the event object gets reused.</span>\n  setTimeout(() =&gt; {\n    console.log(e.target.value); <span class="hljs-comment">// Too late!</span>\n  }, <span class="hljs-number">100</span>);\n}\n</code></pre>\n<p data-nodeid="3124">异步执行的 setTimeout 回调会在 handleChange 这个事件处理函数执行完毕后执行，因此它拿不到想要的那个事件对象 e。</p>\n<p data-nodeid="3125">屏幕前面因为拿不到心仪的事件对象而写出过 Bug 的同学，请在心里默默地扣个 1——我相信如果文章有弹幕，此时一定能看到满屏的 1。事件池的这个设计，虽然利好了性能，却整懵了用户。很多人只有在写过无数 Bug 之后，才会后知后觉地发现，要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 e.persist() 函数，像下面这样：</p>\n<pre class="lang-java" data-nodeid="3126"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">handleChange</span><span class="hljs-params">(e)</span> </span>{\n  <span class="hljs-comment">// Prevents React from resetting its properties:</span>\n  e.persist();\n  setTimeout(() =&gt; {\n    console.log(e.target.value); <span class="hljs-comment">// Works</span>\n  }, <span class="hljs-number">100</span>);\n}\n</code></pre>\n<p data-nodeid="3127">在旧版本中，React 这样做在很大程度上是希望能能够对部分性能一般的老浏览器进行向下兼容。</p>\n<p data-nodeid="3128">但随着时代的发展，如今市面上的浏览器虽不能说是性能绝佳，但基本上也不会因为事件池里的对象多几个少几个就给你表演内存泄漏。因此，React 17 拥抱了新时代的潮流，重新在研发体验和向下兼容性能之间做了选择，这一次，它选择了前者——<strong data-nodeid="3266">放弃事件池，为每一个合成事件创建新的对象</strong>。</p>\n<p data-nodeid="3129">因此在 React 17 中，我们不需要 e.persist()，也可以随时随地访问我们想要的事件对象。</p>\n<h4 data-nodeid="3130">Lane 模型的引入</h4>\n<p data-nodeid="3131">如果你曾经尝试持续较长一段时间地关注并阅读 React 源码，会发现 React 16 中几乎每一个小版本的更新，都要动一动 Fiber Reconciler 相关的逻辑。这一点曾经让我感到很头痛，一度陷入“学不完了”的惆怅中。虽然变更仅仅发生在编码层面，并不至于影响核心思想，但这仍然会对源码学习者造成不小的压力。</p>\n<p data-nodeid="3132">为了避免你陷入类似的困境，本专栏涉及 Fiber 源码的几讲（第 13 ~ 16 讲），其中源码全部引用自 React 17——直接学最新的，是当下最保险的方式，这意味着我们捕获到的是 React 团队截至目前的“最佳思路”。</p>\n<p data-nodeid="3133">而在第 13 ~ 16 讲的分析中，我们其实就已经在源码的各个角落见过“Lane”这个概念，也分析过一些和 Lane 相关的一些函数。初学 React 源码的同学由此可能会很自然地认为：优先级就应该是用 Lane 来处理的。但事实上，React 16 中处理优先级采用的是 expirationTime 模型。</p>\n<p data-nodeid="3134">expirationTime 模型使用 expirationTime（一个时间长度） 来描述任务的优先级；而 Lane 模型则使用二进制数来表示任务的优先级：</p>\n<blockquote data-nodeid="3135">\n<p data-nodeid="3136">lane 模型通过将不同优先级赋值给一个位，通过 31 位的位运算来操作优先级。</p>\n</blockquote>\n<p data-nodeid="3137">Lane 模型提供了一个新的优先级排序的思路，相对于 expirationTime 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件。</p>\n<h3 data-nodeid="3138">如何深入了解一个前端框架</h3>\n<p data-nodeid="3139">作为团队自研前端框架方向的负责人，我在实际工作中需要调研和深扒的框架类型可能会比大家想象的多得多。那么面对一个陌生的前端框架，我们应该怎样做才能够高效且平稳地完成从“小工”到“专家”的蜕变呢？</p>\n<p data-nodeid="3140">这个问题其实是没有标准答案的，它和每个人的学习习惯、学习效率甚至元认知能力都有关系。但我想总有一些具体到行为上的规律是可以复用的。今天我想和你分享的，就是一部分我在团队的新人包括实习生同学身上验证过的、可执行度较高的学习经验，希望能够对你日后的生涯道路有所帮助。</p>\n<h4 data-nodeid="3141">不要小看官方文档</h4>\n<p data-nodeid="3142">在实际的读者调研中，我发现很多同学对 React 官方文档不够重视。大家习惯于在入门阶段借助文档完成“快速上手”，却忽视了文档所能够提供给我们的一些更有价值的信息——比如框架的设计思想、源码分层及一些对特殊功能点的介绍。</p>\n<p data-nodeid="3143">在专栏的更新过程中，我会在引用官方文档的地方标注出处，这促使了一部分同学去阅读一部分的文档内容，这是一件好事情。React 文档在前端框架文档中属于相当优秀的范本，如果你懂得利用文档，会发现它不只是一个 API 手册或是入门教程，而是一套成体系的官方教学。</p>\n<p data-nodeid="3144">如果专栏中的一些文档的摘要引用使你受用，不妨尝试去阅读一下完整的原文。在日常的源码阅读包括生产实践中，如果遇到了 React 相关的问题，请不要急于去阅读参差不齐的社区文章——先问问 React 文档试试看吧，或许你能收获的会比你想象中要多。</p>\n<h4 data-nodeid="3145">调用栈就是你的学习地图</h4>\n<p data-nodeid="3146">若你的学习层次已经超越了阅读官方文档这个阶段，接下来可能会想要了解框架到底是如何运行的。此时你已经掌握了框架的设计理念和基本特性，也有了一些简单项目的实践经验，但或许还并不具备从头挑战源码的知识储备和心理准备。这时，在阅读源码之前，框架的函数调用栈将会给你指明许多方向性的问题。</p>\n<p data-nodeid="3147">比如当你想要了解 Hooks，那么就可以尝试去观察不同 Hooks 调用所触发的函数调用栈，从中找出出镜率最高的那些函数，它们大概率暗示着 Hooks 源码的主流程。事件系统、render 过程之类的也是同理。观察调用栈，寻找共性，然后点对点去阅读关键函数的源码，这将大大降低我们阅读源码的难度。</p>\n<h4 data-nodeid="3148">如何阅读源码</h4>\n<p data-nodeid="3149">当你理解了一部分核心功能的源码逻辑之后，难免会对整个框架的运行机制产生好奇。这时候直接从入口文件出发去阅读所有的源码，仍然是一个不太明智的选择。</p>\n<p data-nodeid="3150">在整体阅读源码之前，我们最好去复习一下框架官方对框架架构设计、源码分层相关的介绍——这些信息未必会全部暴露在文档里，但借助搜索引擎，我们总能找到一些线索——比如框架作者/官方团队的博文，其内容的权威度基本和文档持平。</p>\n<p data-nodeid="3151">在理解了整个框架项目的架构分层之后，我们阅读源码的姿势就可以多样化一些了：可以尝试分层阅读，一次搞清楚一个大问题，最后再把整个思路按照架构分层的逻辑组合起来；也可以继续借助调用栈，通过观察一个完整的执行流程（比如 React 的首屏渲染过程）中所涉及的函数，自行将每个层次的逻辑对号入座，然后再向下拆分，我个人采用的就是这种办法。</p>\n<h3 data-nodeid="3152">总结</h3>\n<p data-nodeid="3153">行文至此，我们对 React 世界的探索就要告一段落了。</p>\n<p data-nodeid="3154">通过对本专栏的学习，希望大家最终收获不仅仅是对 React 框架的通透理解，更有一套健康的、可持续的前端学习的方法论。</p>\n<p data-nodeid="3155">经过几年的角逐和沉淀，主流前端框架的稳定性逐渐在强化，三大框架都向着 Web Components 的标准演化，一切并非倾向于无序，而是变得越来越确定、越来越可预测。因此大家大可不必迷信舆论中对“学不完了”这种焦虑的渲染，更不必去盲目追逐新的花样。在当下的这种趋势下，很多时候若你能深入地吃透一个优秀的框架，就能够迅速地积累许多可以复用的理解经验，这将为你学习其他的新知识创造极大的加速度。</p>\n<p data-nodeid="3156">所以说，不要急，慢慢来，或许会比较快。</p>\n<p data-nodeid="3157">主流框架趋于稳定，而前端世界却仍在野蛮生长。近年来，Serverless、低代码、智能化、跨平台等新的概念层出不穷，每一个都足以将前端推入一个崭新的时代。面对层出不穷的技术热点，我们除了要保持冷静的头脑，还需要保持飞快的脚步，这一切的一切，都需要你主动去构建并持续地迭代属于自己的、行之有效的学习习惯。如果本专栏在这个方面能够帮到你，将是我最大的幸事。</p>\n<p data-nodeid="3158">最后，我邀请你为本专栏课程进行结课评价，因为你的每一个观点都是我和拉勾教育最关注的点。<a href="https://wj.qq.com/s2/7788862/db64/" data-nodeid="3302">点击链接，既可参与课程评价</a>。编辑会随机抽 5 位同学送精美礼品喔。</p>\n<p data-nodeid="3159" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image2/M01/04/37/Cip5yF_rHZ-AXqYdAAQ04psP83A706.png" alt="图片1.png" data-nodeid="3306"></p>',
          },
        ],
      },
    ],
  },
};
